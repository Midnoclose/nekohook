/*
#############################################################################################
# Killing Floor 2 (1.8787) SDK
# Generated with TheFeckless UE3 SDK Generator v1.4_Beta-Rev.51
#
=========================================================================================
# # File: KFGame_classes.h #
=========================================================================================
# # Credits: uNrEaL, Tamimego, SystemFiles, R00T88, _silencer, the1domo, K@N@VEL
# Thanks: HOOAH07, lowHertz
# Forums: www.uc-forum.com, www.gamedeception.net
#############################################################################################
*/

#ifdef _MSC_VER
#pragma pack(push, 0x4)
#endif

/*
#
=========================================================================================
# # Constants #
=========================================================================================
#
*/

#define CONST_AIAirControl 0.35
#define CONST_MAX_GET_RBBONE_CHECKS 3
#define CONST_MAX_ADDED_HITFX 7
#define CONST_bUseAsyncRaycastsForSkipAhead 0
#define CONST_MATCH_EVENT_MAX_EVENTID 0x0000FFFF
#define CONST_MATCH_EVENT_HEAL_RECEIVED 5
#define CONST_MATCH_EVENT_HEAL_GIVEN 4
#define CONST_MATCH_EVENT_DAMAGE_TAKEN 3
#define CONST_MATCH_EVENT_DAMAGE_DEALT 2
#define CONST_MATCH_EVENT_DOSH_EARNED 1
#define CONST_MATCH_EVENT_HEADSHOT 0
#define CONST_INCAP_THRESHOLD 100.f
#define CONST_DISRUPT_THRESHOLD 25.f
#define CONST_LATENT_MOVETO 501
#define CONST_SLOW_SPEED_MOD 0.8f
#define CONST_KFID_QuickWeaponSelect 100
#define CONST_KFID_CurrentLayoutIndex 101
#define CONST_KFID_ForceFeedbackEnabled 103
#define CONST_KFID_SavedPerkIndex 105
#define CONST_KFID_AllowBloodSplatterDecals 106
#define CONST_KFID_GoreLevel 107
#define CONST_KFID_StoredCharIndex 111
#define CONST_KFID_MasterVolumeMultiplier 112
#define CONST_KFID_DialogVolumeMultiplier 113
#define CONST_KFID_MusicVolumeMultiplier 114
#define CONST_KFID_SFXVolumeMultiplier 115
#define CONST_KFID_GammaMultiplier 117
#define CONST_KFID_MusicVocalsEnabled 118
#define CONST_KFID_MinimalChatter 119
#define CONST_KFID_ShowCrossHair 121
#define CONST_KFID_FOVOptionsPercentageValue 122
#define CONST_KFID_ShowKillTicker 123
#define CONST_KFID_FriendlyHudScale 125
#define CONST_KFID_FavoriteWeapons 127
#define CONST_KFID_GearLoadouts 128
#define CONST_KFID_SetGamma 129
#define CONST_KFID_RequiresPushToTalk 130
#define CONST_KFID_InvertController 131
#define CONST_KFID_AutoTargetEnabled 132
#define CONST_KFID_GamepadSensitivityScale 133
#define CONST_KFID_ZoomedSensitivityScale 134
#define CONST_KFID_GamepadZoomedSensitivityScale 135
#define CONST_KFID_EnableMouseSmoothing 136
#define CONST_KFID_MouseSensitivity 138
#define CONST_KFID_TargetAdhesionEnabled 139
#define CONST_KFID_TargetFrictionEnabled 140
#define CONST_KFID_InvertMouse 142
#define CONST_KFID_DEPRECATED 143
#define CONST_KFID_SavedSoloModeIndex 144
#define CONST_KFID_SavedSoloMapString 145
#define CONST_KFID_SavedSoloDifficultyIndex 146
#define CONST_KFID_SavedSoloLengthIndex 147
#define CONST_KFID_SavedModeIndex 148
#define CONST_KFID_SavedMapString 149
#define CONST_KFID_SavedDifficultyIndex 150
#define CONST_KFID_SavedLengthIndex 151
#define CONST_KFID_SavedPrivacyIndex 152
#define CONST_KFID_SavedServerTypeIndex 153
#define CONST_KFID_SavedInProgressIndex 154
#define CONST_KFID_ControllerSoundEnabled 155
#define CONST_KFID_MatchmakingRegion 156
#define CONST_KFID_UseAltAimOnDuals 157
#define CONST_KFID_HideBossHealthBar 158
#define CONST_KFID_AntiMotionSickness 159
#define CONST_KFID_ShowWelderInInventory 160
#define CONST_KFID_AutoTurnOff 161
#define CONST_KFID_ReduceHightPitchSounds 162
#define CONST_KFID_ShowConsoleCrossHair 163
#define CONST_KFID_VOIPVolumeMultiplier 164
#define CONST_KFID_WeaponSkinAssociations 165
#define CONST_KFID_SavedEmoteId 166
#define CONST_KFID_DisableAutoUpgrade 167
#define CONST_KFID_SafeFrameScale 168
#define CONST_FXG_MAX 15
#define CONST_NUM_FAVE_WEAPS 8
#define CONST_MAX_AIM_CORRECTION_SIZE 35.f
#define CONST_MapObjectiveIndex 4
#define CONST_STATID_ACHIEVE_TragicKingdomCollectibles 4038
#define CONST_STATID_ACHIEVE_NukedCollectibles 4037
#define CONST_STATID_ACHIEVE_DescentCollectibles 4036
#define CONST_STATID_ACHIEVE_ZedLandingCollectibles 4035
#define CONST_STATID_ACHIEVE_HostileGroundsCollectibles 4032
#define CONST_STATID_ACHIEVE_InfernalRealmCollectibles 4031
#define CONST_STATID_ACHIEVE_ContainmentStationCollectibles 4030
#define CONST_STATID_ACHIEVE_BlackForestCollectibles 4029
#define CONST_STATID_ACHIEVE_FarmhouseCollectibles 4028
#define CONST_STATID_ACHIEVE_ParisCollectibles 4027
#define CONST_STATID_ACHIEVE_ManorCollectibles 4026
#define CONST_STATID_ACHIEVE_PrisonCollectibles 4025
#define CONST_STATID_ACHIEVE_OutpostCollectibles 4024
#define CONST_STATID_ACHIEVE_EvacsCollectibles 4023
#define CONST_STATID_ACHIEVE_BioticsCollectibles 4022
#define CONST_STATID_ACHIEVE_CollectCatacolmbs 4021
#define CONST_STATID_ACHIEVE_QuickOnTheTrigger 4033
#define CONST_STATID_ACHIEVE_HealTeam 4020
#define CONST_STATID_ACHIEVE_Benefactor 4019
#define CONST_STATID_ACHIEVE_SirenKill 4018
#define CONST_STATID_ACHIEVE_ShrikeKill 4014
#define CONST_STATID_ACHIEVE_FleshPoundKill 4013
#define CONST_STATID_ACHIEVE_DieVolter 4012
#define CONST_STATID_ACHIEVE_HoldOut 4011
#define CONST_STATID_ACHIEVE_VSHumanWins 4010
#define CONST_STATID_ACHIEVE_VSZedWins 4009
#define CONST_STATID_ACHIEVE_HellWins 4017
#define CONST_STATID_ACHIEVE_SuicidalWins 4016
#define CONST_STATID_ACHIEVE_HardWins 4015
#define CONST_STATID_ACHIEVE_MrPerky25 4005
#define CONST_STATID_ACHIEVE_MrPerky20 4004
#define CONST_STATID_ACHIEVE_MrPerky15 4003
#define CONST_STATID_ACHIEVE_MrPerky10 4002
#define CONST_STATID_ACHIEVE_MrPerky5 4001
#define CONST_STATID_DingoAchievementStart 4000
#define CONST_STATID_MatchWins 3000
#define CONST_STATID_PersonalBest_Dosh 2007
#define CONST_STATID_PersonalBest_LargeZedKill 2006
#define CONST_STATID_PersonalBest_Assists 2005
#define CONST_STATID_PersonalBest_Kills 2004
#define CONST_STATID_PersonalBest_Healing 2003
#define CONST_STATID_PersonalBest_HeadShots 2002
#define CONST_STATID_PersonalBest_PistolKills 2001
#define CONST_STATID_PersonalBest_KnifeKills 2000
#define CONST_STATID_AnalyticsPlaceholder 800
#define CONST_STATID_AchievementPlaceholder 500
#define CONST_STATID_WeeklyEventProgress 301
#define CONST_STATID_SpecialEventProgress 300
#define CONST_STATID_FleshpoundKills 203
#define CONST_STATID_CrawlerKills 202
#define CONST_STATID_StalkerKills 201
#define CONST_STATID_Kills 200
#define CONST_STATID_SWAT_Build 91
#define CONST_STATID_SWAT_Progress 90
#define CONST_STATID_Guns_Build 81
#define CONST_STATID_Guns_Progress 80
#define CONST_STATID_Surv_Build 71
#define CONST_STATID_Surv_Progress 70
#define CONST_STATID_Demo_Build 61
#define CONST_STATID_Demo_Progress 60
#define CONST_STATID_Shrp_Build 51
#define CONST_STATID_Shrp_Progress 50
#define CONST_STATID_Medic_HealPoints 42
#define CONST_STATID_Medic_Build 41
#define CONST_STATID_Medic_Progress 40
#define CONST_STATID_Fire_Build 31
#define CONST_STATID_Fire_Progress 30
#define CONST_STATID_Sup_WeldPoints 22
#define CONST_STATID_Sup_Build 21
#define CONST_STATID_Sup_Progress 20
#define CONST_STATID_Bsrk_Build 11
#define CONST_STATID_Bsrk_Progress 10
#define CONST_STATID_Cmdo_Build 2
#define CONST_STATID_Cmdo_Progress 1
#define CONST_STATID_None 0
#define CONST_VIEWID_KFGameStats 1
#define CONST_KFMAX_Perks 10
#define CONST_SkeletalMesh_Width 256
#define CONST_KActorOffset 25
#define CONST_HIT_DIRECTION_FLAG 0x80
#define CONST_DoorWidth 200
#define CONST_HumanPushDistance 40
#define CONST_SlidingPushForce 750
#define CONST_VerticalPushForce 100
#define CONST_BashHingedAnim_F 'DoorBash_A'
#define CONST_BashHingedAnim_B 'DoorBash_B'
#define CONST_BashSlidingAnim_F 'DoorBashSliding_A'
#define CONST_BashSlidingAnim_B 'DoorBashSliding_B'
#define CONST_MAX_WAYPOINTS 24
#define CONST_OverMaxPlayers_MaxLerpedPlayers 128.f
#define CONST_OverMaxPlayers_MaxHealthMod 20.f
#define CONST_TeamDeathPenaltyPerc 0.05f
#define CONST_GBE_Inventory 'Inventory'
#define CONST_GBE_TraderOpen 'TraderOpen'
#define CONST_GBE_WaveStart 'WaveStart'
#define CONST_GBE_Buy 'Buy'
#define CONST_GBE_Sell 'Sell'
#define CONST_GBE_Pickup 'Pickup'
#define CONST_GBE_Respawn 'Respawn'
#define CONST_GBE_Kills 'Kills'
#define CONST_GBE_Deaths 'Deaths'
#define CONST_NUM_CONTROLLER_BINDINGS 20
#define CONST_NUM_LAYOUTS 4
#define CONST_NUM_OVERRIDDEN_BUTTONS 12
#define CONST_GAMEEVENT_ZED_DIED 1010
#define CONST_GAMEEVENT_ZED_SPAWNED 1011
#define CONST_GAMEEVENT_SPAWNVOLUME_RATING 2002
#define CONST_GAMEEVENT_SPAWNVOLUME_PLAYERS 2003
#define CONST_GAMEEVENT_SPAWNVOLUME_BESTRATING 2004
#define CONST_GAMEEVENT_AI_MOVEFAILURE 2100
#define CONST_GAMEEVENT_AI_BUMP 2101
#define CONST_GAMEEVENT_AI_JUMPSPOT 2102
#define CONST_GAMEEVENT_AI_HITWALL 2103
#define CONST_GAMEEVENT_AI_JUMPOVERWALL 2104
#define CONST_GAMEEVENT_AI_WAITFORDOOR 2105
#define CONST_GAMEEVENT_AI_FINISHEDWAITFORDOOR 2106
#define CONST_GAMEEVENT_AI_FAILEDADJUSTFROMWALL 2107
#define CONST_GAMEEVENT_AI_CHARGEATTACK 2108
#define CONST_GAMEEVENT_AI_CHANGEDENEMY 2109
#define CONST_GAMEEVENT_AI_GETNEXTMOVEGOALFAILURE 2110
#define CONST_GAMEEVENT_AI_REDIRECTEDPATH 2111
#define CONST_GAMEEVENT_AI_BLOCKEDPATH 2112
#define CONST_GAMEEVENT_AI_PATHOBSTRUCTION_FAIL 2113
#define CONST_GAMEEVENT_AI_PATHOBSTRUCTION_REPATH 2114
#define CONST_GAMEEVENT_AI_MOVE_TIMEOUT 2115
#define CONST_GAMEEVENT_AI_INVALIDATE_ANCHOR 2116
#define CONST_GAMEEVENT_AI_ANCHOR_FALLBACK_FAILED 2117
#define CONST_GAMEEVENT_AI_FAILED_ANCHOR 2118
#define CONST_GAMEEVENT_AI_BASED_ON_PAWN 2119
#define CONST_GAMEEVENT_AI_HEADLESS_WANDER 2120
#define CONST_GAMEEVENT_AI_DESTROYED_DOOR 2121
#define CONST_GAMEEVENT_AI_PATHGOALEVAL_ABORT 2122
#define CONST_GAMEEVENT_AI_PATH_FAILURE 2123
#define CONST_MAX_SECTIONS 5
#define CONST_TraderPing_LeftSide -1.0f
#define CONST_TraderPing_RightSide 1.0f
#define CONST_PingMinRenderDistSq 100000.f
#define CONST_MAX_WEAPON_GROUPS 4
#define CONST_SKILLFLAG 0x1
#define CONST_SKILLFLAG01 0x2
#define CONST_SKILLFLAG02 0x4
#define CONST_SKILLFLAG03 0x8
#define CONST_SKILLFLAG04 0x10
#define CONST_SKILLFLAG05 0x20
#define CONST_SKILLFLAG06 0x40
#define CONST_SKILLFLAG07 0x80
#define CONST_SKILLFLAG08 0x100
#define CONST_SKILLFLAG09 0x200
#define CONST_SKILL_NONE 0
#define CONST_Skill 1
#define CONST_Skill01 2
#define CONST_RANK_1_LEVEL 5
#define CONST_RANK_2_LEVEL 10
#define CONST_RANK_3_LEVEL 15
#define CONST_RANK_4_LEVEL 20
#define CONST_RANK_5_LEVEL 25
#define CONST_UNLOCK_INTERVAL 5
#define CONST_WeaponStatMax_Damage 820.f
#define CONST_WeaponStatMax_FireRate 800.f
#define CONST_WeaponStatMax_Penetration 4.f
#define CONST_WeaponStatMax_Range 100.f
#define CONST_WeaponStatMax_Block 1.f
#define CONST_WeaponStatMax_Parry 10.f
#define CONST_WeaponStatMax_HealAmount 50.f
#define CONST_WeaponStatMax_HealRechargeSpeed 10.f
#define CONST_WeldingPointsRequired 510
#define CONST_HealingPointsRequired 10
#define CONST_MaxPerkLevel 25
#define CONST_MaxPrestigeLevel 10
#define CONST_SpecialEventObjectiveCountMax 8
#define CONST_KFACHID_ParisNormal 0
#define CONST_KFACHID_ParisHard 1
#define CONST_KFACHID_ParisSuicidal 2
#define CONST_KFACHID_ParisHellOnEarth 3
#define CONST_KFACHID_OutpostNormal 4
#define CONST_KFACHID_OutpostHard 5
#define CONST_KFACHID_OutpostSuicidal 6
#define CONST_KFACHID_OutpostHellOnEarth 7
#define CONST_KFACHID_BioticsNormal 8
#define CONST_KFACHID_BioticsHard 9
#define CONST_KFACHID_BioticsSuicidal 10
#define CONST_KFACHID_BioticsHellOnEarth 11
#define CONST_KFACHID_ManorNormal 12
#define CONST_KFACHID_ManorHard 13
#define CONST_KFACHID_ManorSuicidal 14
#define CONST_KFACHID_ManorHellOnEarth 15
#define CONST_KFACHID_ParisCollectibles 16
#define CONST_KFACHID_OutpostCollectibles 17
#define CONST_KFACHID_BioticsCollectibles 18
#define CONST_KFACHID_ManorCollectibles 19
#define CONST_KFACHID_EvacNormal 20
#define CONST_KFACHID_EvacHard 21
#define CONST_KFACHID_EvacSuicidal 22
#define CONST_KFACHID_EvacHellOnEarth 23
#define CONST_KFACHID_CatacombsNormal 24
#define CONST_KFACHID_CatacombsHard 25
#define CONST_KFACHID_CatacombsSuicidal 26
#define CONST_KFACHID_CatacombsHellOnEarth 27
#define CONST_KFACHID_EvacsCollectibles 28
#define CONST_KFACHID_CatacombsCollectibles 29
#define CONST_KFACHID_Berserker_Lvl5 30
#define CONST_KFACHID_Berserker_Lvl10 31
#define CONST_KFACHID_Berserker_Lvl15 32
#define CONST_KFACHID_Berserker_Lvl20 33
#define CONST_KFACHID_Berserker_Lvl25 34
#define CONST_KFACHID_FieldMedic_Lvl5 35
#define CONST_KFACHID_FieldMedic_Lvl10 36
#define CONST_KFACHID_FieldMedic_Lvl15 37
#define CONST_KFACHID_FieldMedic_Lvl20 38
#define CONST_KFACHID_FieldMedic_Lvl25 39
#define CONST_KFACHID_Commando_Lvl5 40
#define CONST_KFACHID_Commando_Lvl10 41
#define CONST_KFACHID_Commando_Lvl15 42
#define CONST_KFACHID_Commando_Lvl20 43
#define CONST_KFACHID_Commando_Lvl25 44
#define CONST_KFACHID_Support_Lvl5 45
#define CONST_KFACHID_Support_Lvl10 46
#define CONST_KFACHID_Support_Lvl15 47
#define CONST_KFACHID_Support_Lvl20 48
#define CONST_KFACHID_Support_Lvl25 49
#define CONST_KFACHID_Firebug_Lvl5 50
#define CONST_KFACHID_Firebug_Lvl10 51
#define CONST_KFACHID_Firebug_Lvl15 52
#define CONST_KFACHID_Firebug_Lvl20 53
#define CONST_KFACHID_Firebug_Lvl25 54
#define CONST_KFACHID_Demolitionist_Lvl5 55
#define CONST_KFACHID_Demolitionist_Lvl10 56
#define CONST_KFACHID_Demolitionist_Lvl15 57
#define CONST_KFACHID_Demolitionist_Lvl20 58
#define CONST_KFACHID_Demolitionist_Lvl25 59
#define CONST_KFACHID_Gunslinger_Lvl5 60
#define CONST_KFACHID_Gunslinger_Lvl10 61
#define CONST_KFACHID_Gunslinger_Lvl15 62
#define CONST_KFACHID_Gunslinger_Lvl20 63
#define CONST_KFACHID_Gunslinger_Lvl25 64
#define CONST_KFACHID_BerserkerNormal 65
#define CONST_KFACHID_BerserkerHard 66
#define CONST_KFACHID_BerserkerSuicidal 67
#define CONST_KFACHID_BerserkerHellOnEarth 68
#define CONST_KFACHID_FieldMedicNormal 69
#define CONST_KFACHID_FieldMedicHard 70
#define CONST_KFACHID_FieldMedicSuicidal 71
#define CONST_KFACHID_FieldMedicHellOnEarth 72
#define CONST_KFACHID_CommandoNormal 73
#define CONST_KFACHID_CommandoHard 74
#define CONST_KFACHID_CommandoSuicidal 75
#define CONST_KFACHID_CommandoHellOnEarth 76
#define CONST_KFACHID_SupportNormal 77
#define CONST_KFACHID_SupportHard 78
#define CONST_KFACHID_SupportSuicidal 79
#define CONST_KFACHID_SupportHellOnEarth 80
#define CONST_KFACHID_FirebugNormal 81
#define CONST_KFACHID_FirebugHard 82
#define CONST_KFACHID_FirebugSuicidal 83
#define CONST_KFACHID_FirebugHellOnEarth 84
#define CONST_KFACHID_DemolitionistNormal 85
#define CONST_KFACHID_DemolitionistHard 86
#define CONST_KFACHID_DemolitionistSuicidal 87
#define CONST_KFACHID_DemolitionistHellOnEarth 88
#define CONST_KFACHID_GunslingerNormal 89
#define CONST_KFACHID_GunslingerHard 90
#define CONST_KFACHID_GunslingerSuicidal 91
#define CONST_KFACHID_GunslingerHellOnEarth 92
#define CONST_KFACHID_All_Lvl25 93
#define CONST_KFACHID_BlackForestNormal 94
#define CONST_KFACHID_BlackForestHard 95
#define CONST_KFACHID_BlackForestSuicidal 96
#define CONST_KFACHID_BlackForestHellOnEarth 97
#define CONST_KFACHID_BlackForestCollectibles 98
#define CONST_KFACHID_FarmhouseNormal 99
#define CONST_KFACHID_FarmhouseHard 100
#define CONST_KFACHID_FarmhouseSuicidal 101
#define CONST_KFACHID_FarmhouseHellOnEarth 102
#define CONST_KFACHID_FarmhouseCollectibles 103
#define CONST_KFACHID_PrisonNormal 104
#define CONST_KFACHID_PrisonHard 105
#define CONST_KFACHID_PrisonSuicidal 106
#define CONST_KFACHID_PrisonHellOnEarth 107
#define CONST_KFACHID_PrisonCollectibles 108
#define CONST_KFACHID_TutorialComplete 109
#define CONST_KFACHID_Sharpshooter_Lvl5 110
#define CONST_KFACHID_Sharpshooter_Lvl10 111
#define CONST_KFACHID_Sharpshooter_Lvl15 112
#define CONST_KFACHID_Sharpshooter_Lvl20 113
#define CONST_KFACHID_Sharpshooter_Lvl25 114
#define CONST_KFACHID_SharpshooterNormal 115
#define CONST_KFACHID_SharpshooterHard 116
#define CONST_KFACHID_SharpshooterSuicidal 117
#define CONST_KFACHID_SharpshooterHellOnEarth 118
#define CONST_KFACHID_ContainmentStationNormal 119
#define CONST_KFACHID_ContainmentStationHard 120
#define CONST_KFACHID_ContainmentStationSuicidal 121
#define CONST_KFACHID_ContainmentStationHellOnEarth 122
#define CONST_KFACHID_ContainmentStationCollectibles 123
#define CONST_KFACHID_HostileGroundsNormal 124
#define CONST_KFACHID_HostileGroundsHard 125
#define CONST_KFACHID_HostileGroundsSuicidal 126
#define CONST_KFACHID_HostileGroundsHellOnEarth 127
#define CONST_KFACHID_HostileGroundsCollectibles 128
#define CONST_KFACHID_DeadSilence 129
#define CONST_KFACHID_QuickOnTheTrigger 130
#define CONST_KFACHID_ItsOnlyAFleshWound 131
#define CONST_KFACHID_HackAndSlash 132
#define CONST_KFACHID_DieVolter 133
#define CONST_KFACHID_WinHard 134
#define CONST_KFACHID_WinSuicidal 135
#define CONST_KFACHID_WinHellOnEarth 136
#define CONST_KFACHID_MrPerky5 137
#define CONST_KFACHID_MrPerky10 138
#define CONST_KFACHID_MrPerky15 139
#define CONST_KFACHID_MrPerky20 140
#define CONST_KFACHID_MrPerky25 141
#define CONST_KFACHID_Win1 142
#define CONST_KFACHID_Win10 143
#define CONST_KFACHID_Win25 144
#define CONST_KFACHID_VsZedWin 145
#define CONST_KFACHID_VsHumanWin 146
#define CONST_KFACHID_HoldOut 147
#define CONST_KFACHID_IGotYourBack 148
#define CONST_KFACHID_Benefactor 149
#define CONST_KFACHID_InfernalRealmNormal 150
#define CONST_KFACHID_InfernalRealmHard 151
#define CONST_KFACHID_InfernalRealmSuicidal 152
#define CONST_KFACHID_InfernalRealmHellOnEarth 153
#define CONST_KFACHID_InfernalRealmCollectibles 154
#define CONST_KFACHID_SWAT_Lvl5 155
#define CONST_KFACHID_SWAT_Lvl10 156
#define CONST_KFACHID_SWAT_Lvl15 157
#define CONST_KFACHID_SWAT_Lvl20 158
#define CONST_KFACHID_SWAT_Lvl25 159
#define CONST_KFACHID_SWATNormal 160
#define CONST_KFACHID_SWATHard 161
#define CONST_KFACHID_SWATSuicidal 162
#define CONST_KFACHID_SWATHellOnEarth 163
#define CONST_KFACHID_Surv_Lvl5 164
#define CONST_KFACHID_Surv_Lvl10 165
#define CONST_KFACHID_Surv_Lvl15 166
#define CONST_KFACHID_Surv_Lvl20 167
#define CONST_KFACHID_Surv_Lvl25 168
#define CONST_KFACHID_SurvNormal 169
#define CONST_KFACHID_SurvHard 170
#define CONST_KFACHID_SurvSuicidal 171
#define CONST_KFACHID_SurvHellOnEarth 172
#define CONST_KFACHID_ZedLandingNormal 173
#define CONST_KFACHID_ZedLandingHard 174
#define CONST_KFACHID_ZedLandingSuicidal 175
#define CONST_KFACHID_ZedLandingHellOnEarth 176
#define CONST_KFACHID_ZedLandingCollectibles 177
#define CONST_KFACHID_DescentNormal 178
#define CONST_KFACHID_DescentHard 179
#define CONST_KFACHID_DescentSuicidal 180
#define CONST_KFACHID_DescentHellOnEarth 181
#define CONST_KFACHID_DescentCollectibles 182
#define CONST_KFACHID_NukedNormal 183
#define CONST_KFACHID_NukedHard 184
#define CONST_KFACHID_NukedSuicidal 185
#define CONST_KFACHID_NukedHellOnEarth 186
#define CONST_KFACHID_NukedCollectibles 187
#define CONST_KFACHID_TragicKingdomNormal 188
#define CONST_KFACHID_TragicKingdomHard 189
#define CONST_KFACHID_TragicKingdomSuicidal 190
#define CONST_KFACHID_TragicKingdomHellOnEarth 191
#define CONST_KFACHID_TragicKingdomCollectibles 192
#define CONST_NUM_COSMETIC_ATTACHMENTS 3
#define CONST_MAXDEBUGWINDOWS 1
#define CONST_FLAG_SpecialMoveButtonPressed 253
#define CONST_FLAG_SpecialMoveButtonReleased 254
#define CONST_MAX_SPRAY_FX_INFOS 20
#define CONST_ACKINDEXSTART 600
#define CONST_FRIENDLYFIREINDEXSTART 700
#define CONST_GOTYOURBACKINDEXSTART 800
#define CONST_NEEDOURFLAGINDEXSTART 900
#define CONST_SNIPERINDEXINDEXSTART 1000
#define CONST_LOCATIONUPDATEINDEXSTART 1100
#define CONST_INPOSITIONINDEXSTART 1200
#define CONST_ENEMYSTATUSINDEXSTART 1300
#define CONST_KILLEDVEHICLEINDEXSTART 1400
#define CONST_ENEMYFLAGCARRIERINDEXSTART 1500
#define CONST_HOLDINGFLAGINDEXSTART 1600
#define CONST_AREASECUREINDEXSTART 1700
#define CONST_GOTOURFLAGINDEXSTART 1900
#define CONST_NODECONSTRUCTEDINDEXSTART 2000
#define CONST_DEFAULT_FIREMODE 0
#define CONST_ALTFIRE_FIREMODE 1
#define CONST_RELOAD_FIREMODE 2
#define CONST_BASH_FIREMODE 3
#define CONST_GRENADE_FIREMODE 4
#define CONST_FIREMODE_NONE 255
#define CONST_PRIMARY_AMMO 0
#define CONST_SECONDARY_AMMO 1
#define CONST_ReloadEmptyMagAnim 'Reload_Empty'
#define CONST_ReloadNonEmptyMagAnim 'Reload_Half'
#define CONST_ReloadEmptyMagEliteAnim 'Reload_Empty_Elite'
#define CONST_ReloadNonEmptyMagEliteAnim 'Reload_Half_Elite'
#define CONST_ReloadOpenAnim 'Reload_Open'
#define CONST_ReloadSingleAnim 'Reload_Insert'
#define CONST_ReloadOpenInsertAnim 'Reload_Open_Shell'
#define CONST_ReloadCloseAnim 'Reload_Close'
#define CONST_ReloadOpenEliteAnim 'Reload_Open_Elite'
#define CONST_ReloadSingleEliteAnim 'Reload_Insert_Elite'
#define CONST_ReloadOpenInsertEliteAnim 'Reload_Open_Shell_Elite'
#define CONST_ReloadCloseEliteAnim 'Reload_Close_Elite'
#define CONST_GrenadeThrowAnim 'Nade_Throw'
#define CONST_SprintStartAnim 'Sprint_In'
#define CONST_SprintLoopAnim 'Sprint_Loop'
#define CONST_SprintEndAnim 'Sprint_Out'
#define CONST_FireOneHandAnim 'Shoot_OneHand'
#define CONST_FireOneHandLastAnim 'Shoot_OneHand_Last'
#define CONST_BloodParamName 'Scalar_Blood_Contrast'
#define CONST_MinBloodParamValue 0.20f
#define CONST_MaxAimAdjust_Angle 0.1f
#define CONST_MaxAimAdjust_Cos 0.995f
#define CONST_CYLINDERSTATE_READY 0
#define CONST_CYLINDERSTATE_PENDING 1
#define CONST_CYLINDERSTATE_ROTATING 2
#define CONST_ReloadOneEmptyAnim 'Reload_Empty_Half'
#define CONST_ReloadOneEmptyEliteAnim 'Reload_Empty_Half_Elite'
#define CONST_IdleReadyAnim 'Idle_Ready'
#define CONST_HealSelfAnim 'Heal_Self'
#define CONST_HealSelfReloadAnim 'Heal_Self_Reload'
#define CONST_HealTeamAnim 'Heal_Team'
#define CONST_HealTeamReloadAnim 'Heal_Team_Reload'
#define CONST_QuickHealAnim 'Heal_Quick'
#define CONST_BLOCK_FIREMODE 1
#define CONST_HEAVY_ATK_FIREMODE 5
#define CONST_CUSTOM_FIREMODE 6
#define CONST_MeleeAttackAnim_F 'Atk_F'
#define CONST_MeleeAttackAnim_B 'Atk_B'
#define CONST_MeleeAttackAnim_L 'Atk_L'
#define CONST_MeleeAttackAnim_R 'Atk_R'
#define CONST_MeleeHeavyAttackAnim_F 'Atk_H_F'
#define CONST_MeleeHeavyAttackAnim_B 'Atk_H_B'
#define CONST_MeleeHeavyAttackAnim_L 'Atk_H_L'
#define CONST_MeleeHeavyAttackAnim_R 'Atk_H_R'
#define CONST_MeleeComboChainAnim_F 'Combo_F'
#define CONST_MeleeComboChainAnim_FL 'Combo_FL'
#define CONST_MeleeComboChainAnim_FR 'Combo_FR'
#define CONST_MeleeComboChainAnim_B 'Combo_B'
#define CONST_MeleeComboChainAnim_BL 'Combo_BL'
#define CONST_MeleeComboChainAnim_BR 'Combo_BR'
#define CONST_MeleeComboChainAnim_L 'Combo_L'
#define CONST_MeleeComboChainAnim_R 'Combo_R'
#define CONST_MeleeDrawStrikeAnim 'Atk_Draw'
#define CONST_MeleeBlockStartAnim 'Brace_in'
#define CONST_MeleeBlockLoopAnim 'Brace_loop'
#define CONST_MeleeBlockEndAnim 'Brace_out'
#define CONST_CleanBloodyAnim 'Clean_Blood'
#define CONST_CleanNonBloodyAnim 'Clean_NoBlood'
#define CONST_MeleeSustainedLoopAnim 'Atk_F_Loop'
#define CONST_MeleeSustainedStartAnim 'Atk_F_In'
#define CONST_MeleeSUstainedEndAnim 'Atk_F_Out'
#define CONST_THROW_FIREMODE 0
#define CONST_SprintInLastAnim 'Sprint_In_Last'
#define CONST_SprintLoopLastAnim 'Sprint_Loop_Last'
#define CONST_SprintOutLastAnim 'Sprint_Out_Last'
#define CONST_NadeThrowLastAnim 'Nade_Throw_Last'
#define CONST_MeleeBasic 'Melee'
#define CONST_CH_MeleeBasic 'Melee_CH'
#define CONST_MeleeAnim_F 'Atk_F'
#define CONST_MeleeAnim_B 'Atk_B'
#define CONST_MeleeAnim_L 'Atk_L'
#define CONST_MeleeAnim_R 'Atk_R'
#define CONST_CH_MeleeAnim_F 'Atk_F_CH'
#define CONST_CH_MeleeAnim_B 'Atk_B_CH'
#define CONST_CH_MeleeAnim_L 'Atk_L_CH'
#define CONST_CH_MeleeAnim_R 'Atk_R_CH'
#define CONST_MeleeHeavy_F 'Atk_H_F'
#define CONST_MeleeHeavy_B 'Atk_H_B'
#define CONST_MeleeHeavy_L 'Atk_H_L'
#define CONST_MeleeHeavy_R 'Atk_H_R'
#define CONST_CH_MeleeHeavy_F 'Atk_H_F_CH'
#define CONST_CH_MeleeHeavy_B 'Atk_H_B_CH'
#define CONST_CH_MeleeHeavy_L 'Atk_H_L_CH'
#define CONST_CH_MeleeHeavy_R 'Atk_H_R_CH'
#define CONST_MeleeLoopAnim 'Atk_F_Loop'
#define CONST_MeleeStartAnim 'Atk_F_In'
#define CONST_MeleeEndAnim 'Atk_F_Out'
#define CONST_CH_MeleeLoopAnim 'Atk_F_Loop_CH'
#define CONST_CH_MeleeStartAnim 'Atk_F_In_CH'
#define CONST_CH_MeleeEndAnim 'Atk_F_Out_CH'
#define CONST_BlockLoopAnim 'Brace_Loop'
#define CONST_BlockStartAnim 'Brace_In'
#define CONST_BlockEndAnim 'Brace_Out'
#define CONST_CH_BlockLoopAnim 'Brace_Loop_CH'
#define CONST_CH_BlockStartAnim 'Brace_In_CH'
#define CONST_CH_BlockEndAnim 'Brace_Out_CH'
#define CONST_CleanWeaponAnim 'Clean_NoBlood'
#define CONST_CH_CleanWeaponAnim 'Clean_NoBlood_CH'
#define CONST_GrenadeAnim 'Nade_Throw'
#define CONST_EquipAnim 'Equip'
#define CONST_PutAwayAnim 'PutAway'
#define CONST_CH_GrenadeAnim 'Nade_Throw_CH'
#define CONST_CH_EquipAnim 'Equip_CH'
#define CONST_CH_PutAwayAnim 'PutAway_CH'
#define CONST_ReloadEmptyAnim 'Reload_Empty'
#define CONST_ReloadHalfAnim 'Reload_Half'
#define CONST_ReloadEmptyEliteAnim 'Reload_Empty_Elite'
#define CONST_ReloadHalfEliteAnim 'Reload_Half_Elite'
#define CONST_ReloadDualsOneEmptyAnim 'Reload_Empty_Half'
#define CONST_ReloadDualsOneEmptyEliteAnim 'Reload_Empty_Half_Elite'
#define CONST_CH_ReloadEmptyAnim 'Reload_Empty_CH'
#define CONST_CH_ReloadHalfAnim 'Reload_Half_CH'
#define CONST_CH_ReloadEmptyEliteAnim 'Reload_Empty_Elite_CH'
#define CONST_CH_ReloadHalfEliteAnim 'Reload_Half_Elite_CH'
#define CONST_CH_ReloadDualsOneEmptyAnim 'Reload_Empty_Half_CH'
#define CONST_CH_ReloadDualsOneEmptyEliteAnim 'Reload_Empty_Half_Elite_CH'
#define CONST_ReloadInsertAnim 'Reload_Insert'
#define CONST_ReloadInsertEliteAnim 'Reload_Insert_Elite'
#define CONST_ReloadOpenEmptyAnim 'Reload_Open_Shell'
#define CONST_ReloadOpenEmptyEliteAnim 'Reload_Open_Shell_Elite'
#define CONST_CH_ReloadOpenAnim 'Reload_Open_CH'
#define CONST_CH_ReloadInsertAnim 'Reload_Insert_CH'
#define CONST_CH_ReloadCloseAnim 'Reload_Close_CH'
#define CONST_CH_ReloadOpenEliteAnim 'Reload_Open_Elite_CH'
#define CONST_CH_ReloadInsertEliteAnim 'Reload_Insert_Elite_CH'
#define CONST_CH_ReloadCloseEliteAnim 'Reload_Close_Elite_CH'
#define CONST_CH_ReloadOpenEmptyAnim 'Reload_Open_Shell_CH'
#define CONST_CH_ReloadOpenEmptyEliteAnim 'Reload_Open_Shell_Elite_CH'
#define CONST_HealSelfAnim01 'Healer_Self'
#define CONST_HealOtherAnim 'Healer_F'
#define CONST_CH_HealSelfAnim 'Healer_Self_CH'
#define CONST_CH_HealOtherAnim 'Healer_F_CH'
#define CONST_CH_QuickHealAnim 'Heal_Quick_CH'
#define CONST_WeldStartAnim 'Welder_Start'
#define CONST_WeldLoopAnim 'Welder_Loop'
#define CONST_WeldEndAnim 'Welder_End'
#define CONST_CH_WeldStartAnim 'Welder_Start_CH'
#define CONST_CH_WeldLoopAnim 'Welder_Loop_CH'
#define CONST_CH_WeldEndAnim 'Welder_End_CH'
#define CONST_ShootAnim 'ADD_Shoot'
#define CONST_CrouchShootAnim 'ADD_CH_Shoot'
#define CONST_IronShootAnim 'ADD_Iron_Shoot'
#define CONST_WeaponFireAnim 'Shoot'
#define CONST_WeaponAltFireAnim 'Shoot'
#define CONST_WeaponIronFireAnim 'Iron_Shoot'
#define CONST_ShootLeftAnim 'ADD_Shoot_LW'
#define CONST_ShootRightAnim 'ADD_Shoot_RW'
#define CONST_CrouchShootLeftAnim 'ADD_CH_Shoot_LW'
#define CONST_CrouchShootRightAnim 'ADD_CH_Shoot_RW'
#define CONST_IronShootLeftAnim 'ADD_Iron_Shoot_LW'
#define CONST_IronShootRightAnim 'ADD_Iron_Shoot_RW'
#define CONST_WeaponFireAnim_R 'Shoot_RW'
#define CONST_WeaponFireAnim_L 'Shoot_LW'
#define CONST_WeaponAltFireAnim_R 'Shoot_RW'
#define CONST_WeaponAltFireAnim_L 'Shoot_LW'
#define CONST_LeftWeaponSocket 'LW_Weapon'

/*
#
=========================================================================================
# # Enums #
=========================================================================================
#
*/

// Enum KFGame.KFPawn.EAnimSlotStance
/*enum EAnimSlotStance
{
        EAS_FullBody                                       = 0,
        EAS_UpperBody                                      = 1,
        EAS_LowerBody                                      = 2,
        EAS_Additive                                       = 3,
        EAS_CH_UpperBody                                   = 4,
        EAS_CH_LowerBody                                   = 5,
        EAS_Face                                           = 6,
        EAS_MAX                                            = 7
};*/

// Enum KFGame.KFPawn.EPawnOctant
/*enum EPawnOctant
{
        DIR_Forward                                        = 0,
        DIR_Backward                                       = 1,
        DIR_Left                                           = 2,
        DIR_Right                                          = 3,
        DIR_ForwardLeft                                    = 4,
        DIR_ForwardRight                                   = 5,
        DIR_BackwardLeft                                   = 6,
        DIR_BackwardRight                                  = 7,
        DIR_None                                           = 8,
        DIR_MAX                                            = 9
};*/

// Enum KFGame.KFAfflictionManager.EAfflictionType
/*enum EAfflictionType
{
        AF_EMP                                             = 0,
        AF_FirePanic                                       = 1,
        AF_MeleeHit                                        = 2,
        AF_GunHit                                          = 3,
        AF_Stumble                                         = 4,
        AF_Stun                                            = 5,
        AF_Poison                                          = 6,
        AF_Snare                                           = 7,
        AF_Knockdown                                       = 8,
        AF_Freeze                                          = 9,
        AF_Microwave                                       = 10,
        AF_Bleed                                           = 11,
        AF_Custom1                                         = 12,
        AF_Custom2                                         = 13,
        AF_Custom3                                         = 14,
        EAfflictionType_Blank                              = 15,
        EAfflictionType_MAX                                = 16
};*/

// Enum KFGame.KFAfflictionManager.EAfflictionVulnerabilityType
/*enum EAfflictionVulnerabilityType
{
        AV_Default                                         = 0,
        AV_Head                                            = 1,
        AV_Legs                                            = 2,
        AV_Arms                                            = 3,
        AV_Special                                         = 4,
        AV_MAX                                             = 5
};*/

// Enum KFGame.KFAfflictionManager.EHitZoneBodyPart
/*enum EHitZoneBodyPart
{
        BP_Torso                                           = 0,
        BP_Head                                            = 1,
        BP_LeftArm                                         = 2,
        BP_RightArm                                        = 3,
        BP_LeftLeg                                         = 4,
        BP_RightLeg                                        = 5,
        BP_Special                                         = 6,
        BP_MAX                                             = 7
};*/

// Enum KFGame.KFPawnAnimInfo.EHitReactionAnimType
/*enum EHitReactionAnimType
{
        HIT_Light                                          = 0,
        HIT_Medium                                         = 1,
        HIT_Heavy                                          = 2,
        HIT_MAX                                            = 3
};*/

// Enum KFGame.KFPawnAnimInfo.EAttackRating
/*enum EAttackRating
{
        AR_Weak                                            = 0,
        AR_Medium                                          = 1,
        AR_Strong                                          = 2,
        AR_MAX                                             = 3
};*/

// Enum KFGame.KFPawn.ESpecialMove
/*enum ESpecialMove
{
        SM_None                                            = 0,
        SM_MeleeAttack                                     = 1,
        SM_MeleeAttackDoor                                 = 2,
        SM_GrappleAttack                                   = 3,
        SM_Stumble                                         = 4,
        SM_RecoverFromRagdoll                              = 5,
        SM_Knockdown                                       = 6,
        SM_DeathAnim                                       = 7,
        SM_Stunned                                         = 8,
        SM_Frozen                                          = 9,
        SM_Emerge                                          = 10,
        SM_Jump                                            = 11,
        SM_Taunt                                           = 12,
        SM_WalkingTaunt                                    = 13,
        SM_Evade                                           = 14,
        SM_Evade_Fear                                      = 15,
        SM_Block                                           = 16,
        SM_Heal                                            = 17,
        SM_Rally                                           = 18,
        SM_SonicAttack                                     = 19,
        SM_StandAndShootAttack                             = 20,
        SM_HoseWeaponAttack                                = 21,
        SM_Suicide                                         = 22,
        SM_PlayerZedMove_LMB                               = 23,
        SM_PlayerZedMove_RMB                               = 24,
        SM_PlayerZedMove_V                                 = 25,
        SM_PlayerZedMove_MMB                               = 26,
        SM_PlayerZedMove_Q                                 = 27,
        SM_PlayerZedMove_G                                 = 28,
        SM_GrappleVictim                                   = 29,
        SM_DisabledGrappleVictim                           = 30,
        SM_HansGrappleVictim                               = 31,
        SM_SirenVortexVictim                               = 32,
        SM_Emote                                           = 33,
        SM_BossTheatrics                                   = 34,
        SM_ChangeStance                                    = 35,
        SM_Hans_ThrowGrenade                               = 36,
        SM_Hans_GrenadeHalfBarrage                         = 37,
        SM_Hans_GrenadeBarrage                             = 38,
        SM_Custom1                                         = 39,
        SM_Custom2                                         = 40,
        SM_Custom3                                         = 41,
        SM_Custom4                                         = 42,
        SM_Custom5                                         = 43,
        ESpecialMove_Blank                                 = 44,
        ESpecialMove_MAX                                   = 45
};*/

// Enum KFGame.KFWeaponAmbientEchoHandler.EEchoDirection
/*enum EEchoDirection
{
        EED_Front                                          = 0,
        EED_Right                                          = 1,
        EED_Left                                           = 2,
        EED_Rear                                           = 3,
        EED_Max                                            = 4
};*/

// Enum KFGame.KFPawn.EHitZoneIndex
/*enum EHitZoneIndex
{
        HZI_HEAD                                           = 0,
        HZI_MAX                                            = 1
};*/

// Enum KFGame.KFAiBehaviorTypes.MOVE_FAILURE_TYPE
/*enum MOVE_FAILURE_TYPE
{
        MOVE_FAILURE_TYPE_NONE                             = 0,
        MOVE_FAILURE_TYPE_NO_NAV_MESH_PATH                 = 1,
        MOVE_FAILURE_TYPE_SAME_INTERMEDIATE_POINT_TOO_MANY_TIMES = 2,
        MOVE_FAILURE_TYPE_TARGET_OFF_NAV_MESH_AND_CAN_NOT_FIND_LOCAITON_NEAR_THEM_I_CAN_MOVE_TO
= 3, MOVE_FAILURE_TYPE_LOOKING_FOR_BETTER_INTERMEDIATE_LOCATION = 4,
        MOVE_FAILURE_TYPE_MOVING_TO_BETTER_INTERMEDIATE_LOCATION = 5,
        MOVE_FAILURE_TYPE_MAX                              = 6
};*/

// Enum KFGame.KFAiBehaviorTypes.MOVEMENT_PHASE_TYPE
/*enum MOVEMENT_PHASE_TYPE
{
        MOVEMENT_PHASE_TYPE_NONE                           = 0,
        MOVEMENT_PHASE_TYPE_NAV_MESH_NORMAL_MOVE_TO        = 1,
        MOVEMENT_PHASE_TYPE_PATHNODE_NORMAL_MOVE_TO        = 2,
        MOVEMENT_PHASE_TYPE_PATHNODE_POINT_MOVE_TO         = 3,
        MOVEMENT_PHASE_TYPE_PATHNODE_DELAY_MOVE            = 4,
        MOVEMENT_PHASE_TYPE_PATHNODE_ROTATE_TO_FOCUS       = 5,
        MOVEMENT_PHASE_TYPE_PATHNODE_FAILED_MOVE           = 6,
        MOVEMENT_PHASE_TYPE_FINAL_DEST_MOVE_TOWARDS        = 7,
        MOVEMENT_PHASE_TYPE_EMT_LOS_MOVE_TOWARDS           = 8,
        MOVEMENT_PHASE_TYPE_MOVE_TOO_MESH_USING_PATH_NODES = 9,
        MOVEMENT_PHASE_TYPE_FALLBACK_FIND_NEARBY_MESH_POINT_MOVE_TO_DIRECT_NON_PATH_POS
= 10,
        MOVEMENT_PHASE_TYPE_FALLBACK_REFUSED_TO_BE_EXPLOTIED_FIND_NEARBY_MESH_POINT_MOVE_TO_DIRECT_NON_PATH_POS
= 11, MOVEMENT_PHASE_TYPE_STUCK                          = 12,
        MOVEMENT_PHASE_TYPE_MAX                            = 13
};*/

// Enum KFGame.EphemeralMatchStats.ETeamAwards
/*enum ETeamAwards
{
        ETA_MedicineMaster                                 = 0,
        ETA_ZedSlayer                                      = 1,
        ETA_Enforcer                                       = 2,
        ETA_Destroyer                                      = 3,
        ETA_GiantSlayer                                    = 4,
        ETA_MoneyBags                                      = 5,
        ETA_HeadPopper                                     = 6,
        ETA_Dominator                                      = 7,
        ETA_Carnage                                        = 8,
        ETA_Closer                                         = 9,
        ETA_ComboMaker                                     = 10,
        ETA_Grabby                                         = 11,
        ETA_ZedSupport                                     = 12,
        ETA_Zednnihilation                                 = 13,
        ETA_Max                                            = 14
};*/

// Enum KFGame.EphemeralMatchStats.EPersonalBests
/*enum EPersonalBests
{
        EPB_KnifeKills                                     = 0,
        EPB_PistolKills                                    = 1,
        EPB_HeadShots                                      = 2,
        EPB_Healing                                        = 3,
        EPB_Kills                                          = 4,
        EPB_Assists                                        = 5,
        EPB_LargeZedKill                                   = 6,
        EPB_Dosh                                           = 7,
        EPB_DoorWelding                                    = 8,
        EPB_MAX                                            = 9
};*/

// Enum KFGame.KFAffliction_Bleed.DeflateState
/*enum DeflateState
{
        EDS_None                                           = 0,
        EDS_Inflate                                        = 1,
        EDS_Deflate                                        = 2,
        EDS_MAX                                            = 3
};*/

// Enum KFGame.KFAiBehaviorTypes.EThrowImpulseType
/*enum EThrowImpulseType
{
        TIT_Impulse                                        = 0,
        TIT_Spin                                           = 1,
        TIT_MAX                                            = 2
};*/

// Enum KFGame.KFAiBehaviorTypes.PATH_FIND_STATUS
/*enum PATH_FIND_STATUS
{
        PATH_FIND_STATUS_NO_SEARCH                         = 0,
        PATH_FIND_STATUS_NO_PATH                           = 1,
        PATH_FIND_STATUS_FOUND_PATH                        = 2,
        PATH_FIND_STATUS_MAX                               = 3
};*/

// Enum KFGame.KFAiBehaviorTypes.EThrowType
/*enum EThrowType
{
        THROW_None                                         = 0,
        THROW_Scripted                                     = 1,
        THROW_Death                                        = 2,
        THROW_Explosion                                    = 3,
        THROW_RBCollision                                  = 4,
        THROW_MeleeHit                                     = 5,
        THROW_HitReaction                                  = 6,
        THROW_Lavagun                                      = 7,
        THROW_Flailgun                                     = 8,
        THROW_Flaregun                                     = 9,
        THROW_Driller                                      = 10,
        THROW_DrillerOvercharge                            = 11,
        THROW_Shotgun                                      = 12,
        THROW_ShotgunOvercharge                            = 13,
        THROW_SniperRifle                                  = 14,
        THROW_SniperRifleOvercharge                        = 15,
        THROW_Thumper                                      = 16,
        THROW_ThumperHorizontal                            = 17,
        THROW_Leash                                        = 18,
        THROW_Kick                                         = 19,
        THROW_Slide                                        = 20,
        THROW_Any                                          = 21,
        THROW_MAX                                          = 22
};*/

// Enum KFGame.KFAiBehaviorTypes.EBodyStance
/*enum EBodyStance
{
        BS_FullBody                                        = 0,
        BS_FullBody_AI                                     = 1,
        BS_UpperBody                                       = 2,
        BS_Nor_Stopped                                     = 3,
        BS_Nor_Arms                                        = 4,
        BS_Crd_Stopped                                     = 5,
        BS_Crd_Arms                                        = 6,
        BS_Std_Cov_InCover                                 = 7,
        BS_Std_LCov_InCover                                = 8,
        BS_Mid_Cov_InCover                                 = 9,
        BS_Mid_LCov_InCover                                = 10,
        BS_Std_Cov_Arms                                    = 11,
        BS_Std_LCov_Arms                                   = 12,
        BS_Mid_Cov_Arms                                    = 13,
        BS_Mid_LCov_Arms                                   = 14,
        BS_Additive_Hits                                   = 15,
        BS_MAX                                             = 16
};*/

// Enum KFGame.KFAiBehaviorTypes.EBTGoal
/*enum EBTGoal
{
        BTG_None                                           = 0,
        BTG_Hide                                           = 1,
        BTG_Guard                                          = 2,
        BTG_Banzai                                         = 3,
        BTG_Support                                        = 4,
        BTG_MAX                                            = 5
};*/

// Enum KFGame.KFSpawnVolume.ESquadType
/*enum ESquadType
{
        EST_Boss                                           = 0,
        EST_Large                                          = 1,
        EST_Medium                                         = 2,
        EST_Small                                          = 3,
        EST_Crawler                                        = 4,
        EST_MAX                                            = 5
};*/

// Enum KFGame.KFPawn_Monster.EPlayerZedGamepadMove
/*enum EPlayerZedGamepadMove
{
        ZGM_Attack_R2                                      = 0,
        ZGM_Block_R1                                       = 1,
        ZGM_Melee_Square                                   = 2,
        ZGM_Special_R3                                     = 3,
        ZGM_Explosive_Ll                                   = 4,
        ZGM_Attack_L2                                      = 5,
        ZGM_Melee_Triangle                                 = 6,
        ZGM_MAX                                            = 7
};*/

// Enum KFGame.KFPawn_ZedHansBase.EHansNadeType
/*enum EHansNadeType
{
        HNT_None                                           = 0,
        HNT_HEGrenade                                      = 1,
        HNT_NerveGas                                       = 2,
        HNT_Smoke                                          = 3,
        HNT_HEGrenadeBarrage                               = 4,
        HNT_NerveGasBarrage                                = 5,
        HNT_SmokeBarrage                                   = 6,
        HNT_MAX                                            = 7
};*/

// Enum KFGame.KFAISpawnManager.EAIType
/*enum EAIType
{
        AT_Clot                                            = 0,
        AT_SlasherClot                                     = 1,
        AT_AlphaClot                                       = 2,
        AT_Crawler                                         = 3,
        AT_GoreFast                                        = 4,
        AT_Stalker                                         = 5,
        AT_Scrake                                          = 6,
        AT_FleshPound                                      = 7,
        AT_FleshpoundMini                                  = 8,
        AT_Bloat                                           = 9,
        AT_Siren                                           = 10,
        AT_Husk                                            = 11,
        AT_BossRandom                                      = 12,
        AT_MAX                                             = 13
};*/

// Enum KFGame.KFAISpawnManager.EBossAIType
/*enum EBossAIType
{
        BAT_Hans                                           = 0,
        BAT_Patriarch                                      = 1,
        BAT_MAX                                            = 2
};*/

// Enum KFGame.KFAISteering.ESteeringFlags
/*enum ESteeringFlags
{
        STEERING_Default                                   = 0,
        STEERING_Separate                                  = 1,
        STEERING_MAX                                       = 2
};*/

// Enum KFGame.KFAnim_AimOffset.EAimInput
/*enum EAimInput
{
        AI_PawnAimOffset                                   = 0,
        AI_VehicleAimOffset                                = 1,
        AI_BasePawn                                        = 2,
        AI_CustomAimOffset                                 = 3,
        AI_MAX                                             = 4
};*/

// Enum KFGame.KFAnim_BlendByTargetingMode.ETargetingBlendChild
/*enum ETargetingBlendChild
{
        ETBC_Idle                                          = 0,
        ETBC_Aiming                                        = 1,
        ETBC_DownSights                                    = 2,
        ETBC_MAX                                           = 3
};*/

// Enum KFGame.KFAnim_PhysFalling.EJumpBlendChild
/*enum EJumpBlendChild
{
        EJBC_Walk                                          = 0,
        EJBC_Jump                                          = 1,
        EJBC_Fall                                          = 2,
        EJBC_Land                                          = 3,
        EJBC_MAX                                           = 4
};*/

// Enum KFGame.KFAnimSeq_Directional.EDirectionInterpType
/*enum EDirectionInterpType
{
        EDIT_None                                          = 0,
        EDIT_Circular                                      = 1,
        EDIT_Linear                                        = 2,
        EDIT_MAX                                           = 3
};*/

// Enum KFGame.KFGFxObject_TraderItems.EFilterTypeUI
/*enum EFilterTypeUI
{
        FT_Pistol                                          = 0,
        FT_Shotgun                                         = 1,
        FT_Rifle                                           = 2,
        FT_Projectile                                      = 3,
        FT_Flame                                           = 4,
        FT_Electric                                        = 5,
        FT_Explosive                                       = 6,
        FT_Assault                                         = 7,
        FT_Melee                                           = 8,
        FT_SMG                                             = 9,
        FT_None                                            = 10,
        FT_MAX                                             = 11
};*/

// Enum KFGame.KFGFxObject_TraderItems.TraderWeaponStat
/*enum TraderWeaponStat
{
        TWS_Damage                                         = 0,
        TWS_Range                                          = 1,
        TWS_Penetration                                    = 2,
        TWS_RateOfFire                                     = 3,
        TWS_Block                                          = 4,
        TWS_Parry                                          = 5,
        TWS_MagazineSize                                   = 6,
        TWS_AmmoCapacity                                   = 7,
        TWS_HealAmount                                     = 8,
        TWS_RechargeTime                                   = 9,
        TWS_MAX                                            = 10
};*/

// Enum KFGame.KFGFxMenu_Trader.EItemType
/*enum EItemType
{
        EIT_Weapon                                         = 0,
        EIT_Armor                                          = 1,
        EIT_NonSellable                                    = 2,
        EIT_Grenade                                        = 3,
        EIT_MAX                                            = 4
};*/

// Enum KFGame.KFSkinTypeEffects.EEffectDamageGroup
/*enum EEffectDamageGroup
{
        FXG_Ballistic                                      = 0,
        FXG_Bludgeon                                       = 1,
        FXG_Piercing                                       = 2,
        FXG_Slashing                                       = 3,
        FXG_Fire                                           = 4,
        FXG_Toxic                                          = 5,
        FXG_Healing                                        = 6,
        FXG_Sawblade                                       = 7,
        FXG_DrainLife                                      = 8,
        FXG_IncendiaryRound                                = 9,
        FXG_UnexplodedGrenade                              = 10,
        FXG_MicrowaveBlast                                 = 11,
        FXG_ShieldBash                                     = 12,
        FXG_MetalMace                                      = 13,
        FXG_Flare                                          = 14,
        FXG_MAX                                            = 15
};*/

// Enum KFGame.KFDamageType.EDamageOverTimeGroup
/*enum EDamageOverTimeGroup
{
        DOT_None                                           = 0,
        DOT_Fire                                           = 1,
        DOT_Toxic                                          = 2,
        DOT_Bleeding                                       = 3,
        DOT_MAX                                            = 4
};*/

// Enum KFGame.KFDamageType.EGoreDamageGroup
/*enum EGoreDamageGroup
{
        DGT_None                                           = 0,
        DGT_AssaultRifle                                   = 1,
        DGT_Rifle                                          = 2,
        DGT_Submachinegun                                  = 3,
        DGT_Shotgun                                        = 4,
        DGT_Handgun                                        = 5,
        DGT_Explosive                                      = 6,
        DGT_MeleeSlash                                     = 7,
        DGT_MeleeBludgeon                                  = 8,
        DGT_Fire                                           = 9,
        DGT_EMP                                            = 10,
        DGT_Obliteration                                   = 11,
        DGT_MAX                                            = 12
};*/

// Enum KFGame.KFPlayerController.KFSpectateModes
/*enum KFSpectateModes
{
        SMODE_PawnFreeCam                                  = 0,
        SMODE_PawnThirdPerson                              = 1,
        SMODE_PawnFirstPerson                              = 2,
        SMODE_Roaming                                      = 3,
        SMODE_MAX                                          = 4
};*/

// Enum KFGame.KFPlayerController.ETrackingRangeMode
/*enum ETrackingRangeMode
{
        ETR_Custom                                         = 0,
        ETR_10Meters                                       = 1,
        ETR_25Meters                                       = 2,
        ETR_50Meters                                       = 3,
        ETR_100Meters                                      = 4,
        ETR_250Meters                                      = 5,
        ETR_MAX                                            = 6
};*/

// Enum KFGame.KFPlayerController.ETrackingMode
/*enum ETrackingMode
{
        ETM_All                                            = 0,
        ETM_AllButTargeting                                = 1,
        ETM_PawnsOnly                                      = 2,
        ETM_PawnsAndTargetingOnly                          = 3,
        ETM_SpawnsOnly                                     = 4,
        ETM_FailedSpawnsOnly                               = 5,
        ETM_HumansAndSpawnsOnly                            = 6,
        ETM_PickupsOnly                                    = 7,
        ETM_MAX                                            = 8
};*/

// Enum KFGame.KFPlayerController.EGameConductorDebugMode
/*enum EGameConductorDebugMode
{
        EGCDM_OverallRankAndSkill                          = 0,
        EGCDM_Skill                                        = 1,
        EGCDM_OverallAccuracy                              = 2,
        EGCDM_LifeSpan                                     = 3,
        EGCDM_ZedSpawning                                  = 4,
        EGCDM_GameplayAdjustments                          = 5,
        EGCDM_Status                                       = 6,
        EGCDM_MAX                                          = 7
};*/

// Enum KFGame.KFPlayerController.EVoiceChannel
/*enum EVoiceChannel
{
        EVC_ALL                                            = 0,
        EVC_TEAM                                           = 1,
        EVC_MAX                                            = 2
};*/

// Enum KFGame.KFPlayerController.EAnalogMovementSpeed
/*enum EAnalogMovementSpeed
{
        AMOVESPEED                                         = 0,
        AMOVESPEED01                                       = 1,
        AMOVESPEED02                                       = 2,
        AMOVESPEED03                                       = 3,
        AMOVESPEED_MAX                                     = 4
};*/

// Enum KFGame.KFPlayerController.ETextChatChannel
/*enum ETextChatChannel
{
        ETCC_ALL                                           = 0,
        ETCC_TEAM                                          = 1,
        ETCC_MAX                                           = 2
};*/

// Enum KFGame.KFDestructibleActor.EDestructibleRepType
/*enum EDestructibleRepType
{
        RT_ServerDefault                                   = 0,
        RT_ServerOptimized                                 = 1,
        RT_ClientSide                                      = 2,
        RT_MAX                                             = 3
};*/

// Enum KFGame.KFDialogEnvironmentVolume.EDialogEnvironment
/*enum EDialogEnvironment
{
        DENV_DarkOutside                                   = 0,
        DENV_DarkInside                                    = 1,
        DENV_Raining                                       = 2,
        DENV_ColdInside                                    = 3,
        DENV_ColdOutside                                   = 4,
        DENV_HotInside                                     = 5,
        DENV_HotOutside                                    = 6,
        DENV_Foggy                                         = 7,
        DENV_Snow                                          = 8,
        DENV_Gross                                         = 9,
        DENV_Smelly                                        = 10,
        DENV_HighTech                                      = 11,
        DENV_OldSchoolHighTech                             = 12,
        DENV_Cloning                                       = 13,
        DENV_Experiments                                   = 14,
        DENV_Torture                                       = 15,
        DENV_BioMatter                                     = 16,
        DENV_Aftermath                                     = 17,
        DENV_Cave                                          = 18,
        DENV_Underground                                   = 19,
        DENV_MAX                                           = 20
};*/

// Enum KFGame.KFPawnVoiceGroupEventData.ECooldownCategory
/*enum ECooldownCategory
{
        ECC_Act                                            = 0,
        ECC_KillEnemy                                      = 1,
        ECC_DamEnemy                                       = 2,
        ECC_DamFriendly                                    = 3,
        ECC_SpotEnemy                                      = 4,
        ECC_Situ                                           = 5,
        ECC_Resp                                           = 6,
        ECC_TTime                                          = 7,
        ECC_HighZ                                          = 8,
        ECC_MAX                                            = 9
};*/

// Enum KFGame.KFDoorActor.EDoorMaterialType
/*enum EDoorMaterialType
{
        EDMT_Metal                                         = 0,
        EDMT_Wood                                          = 1,
        EDMT_MAX                                           = 2
};*/

// Enum KFGame.KFDoorActor.EDoorMechanism
/*enum EDoorMechanism
{
        EDM_Hinge                                          = 0,
        EDM_Slide                                          = 1,
        EDM_Lift                                           = 2,
        EDM_MAX                                            = 3
};*/

// Enum KFGame.KFDoorActor.EDoorFastening
/*enum EDoorFastening
{
        EDF_ArcWelding                                     = 0,
        EDF_Rivets                                         = 1,
        EDF_MAX                                            = 2
};*/

// Enum KFGame.KFLightPool.LightPoolPriority
/*enum LightPoolPriority
{
        LPP_Low                                            = 0,
        LPP_High                                           = 1,
        LPP_GameplayUsed                                   = 2,
        LPP_MAX                                            = 3
};*/

// Enum KFGame.KFGameConductor.EGameConductorStatus
/*enum EGameConductorStatus
{
        GCS_Normal                                         = 0,
        GCS_ForceLull                                      = 1,
        GCS_MAX                                            = 2
};*/

// Enum KFGame.KFGameEngine.EConnectionError
/*enum EConnectionError
{
        CE_None                                            = 0,
        CE_Generic                                         = 1,
        CE_WrongPassword                                   = 2,
        CE_NeedPassword                                    = 3,
        CE_MAX                                             = 4
};*/

// Enum KFGame.KFGameEngine.SupportedPlatform
/*enum SupportedPlatform
{
        PLATFORM_PC_DX11                                   = 0,
        PLATFORM_PC_DX10                                   = 1,
        PLATFORM_PC_MAX                                    = 2
};*/

// Enum KFGame.KFGameEngine.SeasonalEventIndex
/*enum SeasonalEventIndex
{
        SEI_None                                           = 0,
        SEI_Summer                                         = 1,
        SEI_MAX                                            = 2
};*/

// Enum KFGame.KFGameInfo.EGameLength
/*enum EGameLength
{
        GL_Short                                           = 0,
        GL_Normal                                          = 1,
        GL_Long                                            = 2,
        GL_MAX                                             = 3
};*/

// Enum KFGame.KFGameInfo.EForcedMusicType
/*enum EForcedMusicType
{
        EFM_MainMenu                                       = 0,
        EFM_Credits                                        = 1,
        EFM_Boss1                                          = 2,
        EFM_Boss2                                          = 3,
        EFM_Boss3                                          = 4,
        EFM_MAX                                            = 5
};*/

// Enum KFGame.KFGamepadLayoutManager.EGamepadLayoutType
/*enum EGamepadLayoutType
{
        LAYOUT_Default                                     = 0,
        LAYOUT_JUMPER                                      = 1,
        LAYOUT_QUICKDRAW                                   = 2,
        LAYOUT_SOUTHPAW                                    = 3,
        LAYOUT_MAX                                         = 4
};*/

// Enum KFGame.KFGameplayPoolManager.eProjectilePoolType
/*enum eProjectilePoolType
{
        PPT_C4                                             = 0,
        PPT_PukeMine                                       = 1,
        PPT_MAX                                            = 2
};*/

// Enum KFGame.KFGFxMenu_Exit.ExitOptions
/*enum ExitOptions
{
        EO_TO_Main_Menu                                    = 0,
        EO_TO_OS                                           = 1,
        EO_TO_MAX                                          = 2
};*/

// Enum KFGame.KFGFxMenu_Gear.ECustomizationOption
/*enum ECustomizationOption
{
        CO_Character                                       = 0,
        CO_Head                                            = 1,
        CO_Body                                            = 2,
        CO_Attachment                                      = 3,
        CO_MAX                                             = 4
};*/

// Enum KFGame.KFGFxMenu_Inventory.EINventory_Filter
/*enum EINventory_Filter
{
        EInv_All                                           = 0,
        EInv_WeaponSkins                                   = 1,
        EInv_Cosmetics                                     = 2,
        EInv_Consumables                                   = 3,
        EInv_Items                                         = 4,
        EInv_CraftingMats                                  = 5,
        EInv_Emotes                                        = 6,
        EInv_MAX                                           = 7
};*/

// Enum KFGame.KFGFxMenu_Store.ETitleStoreIconLocation
/*enum ETitleStoreIconLocation
{
        ETSIL_BottomLeft                                   = 0,
        ETSIL_BottomCenter                                 = 1,
        ETSIL_BottomRight                                  = 2,
        ETSIL_MAX                                          = 3
};*/

// Enum KFGame.KFGFxMenu_Trader.TabIndices
/*enum TabIndices
{
        TI_Perks                                           = 0,
        TI_Type                                            = 1,
        TI_Favorites                                       = 2,
        TI_All                                             = 3,
        TI_MAX                                             = 4
};*/

// Enum KFGame.KFGFxMenu_Trader.TraderList
/*enum TraderList
{
        TL_Shop                                            = 0,
        TL_Player                                          = 1,
        TL_MAX                                             = 2
};*/

// Enum KFGame.KFGFxMoviePlayer_Manager.EStartMenuState
/*enum EStartMenuState
{
        EMatchmaking                                       = 0,
        EServerBrowser                                     = 1,
        ESoloGame                                          = 2,
        EOverview                                          = 3,
        EServerBrowserOverview                             = 4,
        EStartMenuState_MAX                                = 5
};*/

// Enum KFGame.KFGFxMoviePlayer_Manager.EPopUpType
/*enum EPopUpType
{
        EConfirmation                                      = 0,
        EGamma                                             = 1,
        ENotification                                      = 2,
        EPopUpMax                                          = 3,
        EInputPrompt                                       = 4,
        EPopUpType_MAX                                     = 5
};*/

// Enum KFGame.KFGFxMoviePlayer_Manager.EDelayedPopupPriorityId
/*enum EDelayedPopupPriorityId
{
        EDPPID_Misc                                        = 0,
        EDPPID_SwitchTeams                                 = 1,
        EDPPID_RegionWait                                  = 2,
        EDPPID_RegionBest                                  = 3,
        EDPPID_Gamma                                       = 4,
        EDPPID_ExitToMainMenu                              = 5,
        EDPPID_JoinFailure                                 = 6,
        EDPPID_ControllerDisconnect                        = 7,
        EDPPID_MAX                                         = 8
};*/

// Enum KFGame.KFGFxMoviePlayer_Manager.EUIIndex
/*enum EUIIndex
{
        UI_Start                                           = 0,
        UI_Perks                                           = 1,
        UI_Gear                                            = 2,
        UI_Inventory                                       = 3,
        UI_Store                                           = 4,
        UI_OptionsSelection                                = 5,
        UI_Exit_Menu                                       = 6,
        UI_OptionsControls                                 = 7,
        UI_OptionsAudio                                    = 8,
        UI_OptionsGraphics                                 = 9,
        UI_OptionsGameSettings                             = 10,
        UI_Achievements                                    = 11,
        UI_Extras                                          = 12,
        UI_PostGame                                        = 13,
        UI_Trader                                          = 14,
        UI_ServerBrowserMenu                               = 15,
        UI_IIS                                             = 16,
        UI_MAX                                             = 17
};*/

// Enum KFGame.KFGFxOptionsMenu_Graphics.SupportedAspectRatio
/*enum SupportedAspectRatio
{
        KFASPECTRATIO_All                                  = 0,
        KFASPECTRATIO_Standard_4                           = 1,
        KFASPECTRATIO_Standard_5                           = 2,
        KFASPECTRATIO_Standard_3                           = 3,
        KFASPECTRATIO_Wide_16                              = 4,
        KFASPECTRATIO_Wide_1601                            = 5,
        KFASPECTRATIO_ExtraWide_2                          = 6,
        KFASPECTRATIO_ExtraWide_21                         = 7,
        KFASPECTRATIO_MultiMonitor                         = 8,
        KFASPECTRATIO_MAX                                  = 9
};*/

// Enum KFGame.KFGFxOptionsMenu_Graphics.GraphicsLevelPreset
/*enum GraphicsLevelPreset
{
        GRAPHICS_LOW                                       = 0,
        GRAPHICS_MEDIUM                                    = 1,
        GRAPHICS_HIGH                                      = 2,
        GRAPHICS_ULTRA                                     = 3,
        GRAPHICS_CUSTOM                                    = 4,
        GRAPHICS_MAX                                       = 5
};*/

// Enum KFGame.KFGFxOptionsMenu_Graphics.PerfWarning
/*enum PerfWarning
{
        PerfWarning_None                                   = 0,
        PerfWarning_Normal                                 = 1,
        PerfWarning_Severe                                 = 2,
        PerfWarning_MAX                                    = 3
};*/

// Enum KFGame.KFGFxOptionsMenu_Selection.OptionMenus
/*enum OptionMenus
{
        OM_Video                                           = 0,
        OM_Audio                                           = 1,
        OM_Controls                                        = 2,
        OM_Gameplay                                        = 3,
        OM_Credits                                         = 4,
        OM_Max                                             = 5
};*/

// Enum KFGame.KFGFxServerBrowser_Filters.EFilter_Key
/*enum EFilter_Key
{
        NO_PASSWORD                                        = 0,
        NO_MUTATORS                                        = 1,
        NOT_FULL                                           = 2,
        NOT_EMPTY                                          = 3,
        Custom                                             = 4,
        DEDICATED                                          = 5,
        IN_LOBBY                                           = 6,
        IN_PROGRESS                                        = 7,
        LIMIT_SERVER_RESULTS                               = 8,
        FILTERS_MAX                                        = 9,
        EFilter_Key_MAX                                    = 10
};*/

// Enum KFGame.KFGFxServerBrowser_ServerList.EQueryCompletionAction
/*enum EQueryCompletionAction
{
        QUERYACTION_None                                   = 0,
        QUERYACTION_Default                                = 1,
        QUERYACTION_CloseScene                             = 2,
        QUERYACTION_JoinServer                             = 3,
        QUERYACTION_RefreshAll                             = 4,
        QUERYACTION_MAX                                    = 5
};*/

// Enum KFGame.KFGFxServerBrowser_ServerList.ESearch_Tab
/*enum ESearch_Tab
{
        TAB_ALL                                            = 0,
        TAB_FAVORITES                                      = 1,
        TAB_FRIENDS                                        = 2,
        TAB_HISTORY                                        = 3,
        TAB_LAN                                            = 4,
        TAB_MAX                                            = 5
};*/

// Enum KFGame.KFGFxStartGameContainer_Options.EServerType
/*enum EServerType
{
        ES_Maps                                            = 0,
        ES_Stock                                           = 1,
        ES_Custom                                          = 2,
        ES_Unranked                                        = 3,
        ES_MAX                                             = 4
};*/

// Enum KFGame.KFGFxStartGameContainer_Options.EInProgess
/*enum EInProgess
{
        EIP_Allow_In_Progress                              = 0,
        EIP_Not_Started                                    = 1,
        EIP_Create_New                                     = 2,
        EIP_MAX                                            = 3
};*/

// Enum KFGame.KFGFxStartGameContainer_Options.EServerPrivacy
/*enum EServerPrivacy
{
        ESPr_Public                                        = 0,
        ESPr_FriendsOnly                                   = 1,
        ESPr_PasswordProtected                             = 2,
        ESPr_MAX                                           = 3
};*/

// Enum KFGame.KFGFxStoreContainer_Main.EStore_Filter
/*enum EStore_Filter
{
        EStore_All                                         = 0,
        EStore_WeaponSkins                                 = 1,
        EStore_Cosmetics                                   = 2,
        EStore_Consumables                                 = 3,
        EStore_Emotes                                      = 4,
        EStore_Market_WeaponSkins                          = 5,
        EStore_Market_Cosmetics                            = 6,
        EStore_Market_Consumables                          = 7,
        EStore_Market_Emotes                               = 8,
        EStore_Max                                         = 9
};*/

// Enum KFGame.KFGFxTraderContainer_PlayerInventory.EButtonStates
/*enum EButtonStates
{
        BS_Enabled                                         = 0,
        BS_MaxCapacity                                     = 1,
        BS_CantAfford                                      = 2,
        BS_MAX                                             = 3
};*/

// Enum KFGame.KFInventoryCatalog.EItemDisplayContainerType
/*enum EItemDisplayContainerType
{
        IDT_None                                           = 0,
        IDT_Crate                                          = 1,
        IDT_USB                                            = 2,
        IDT_MAX                                            = 3
};*/

// Enum KFGame.KFInventoryCatalog.ECrateSeries
/*enum ECrateSeries
{
        ECrate_ZedKiller                                   = 0,
        ECrate_StoriesOfWar                                = 1,
        ECrate_CyberBone                                   = 2,
        ECrate_HorzineIssue                                = 3,
        ECrate_DragonFire                                  = 4,
        ECrate_StreetPunks                                 = 5,
        ECrate_FirstEncounter                              = 6,
        ECrate_Predator                                    = 7,
        Ecrate_TacticalHorzine                             = 8,
        Ecrate_EmergencyIssue                              = 9,
        Ecrate_Swat                                        = 10,
        Ecrate_Exhibit                                     = 11,
        Ecrate_EliteMedic                                  = 12,
        Ecrate_Victorian                                   = 13,
        Ecrate_MaceShield                                  = 14,
        ECrate_HorzineSupply_S1                            = 15,
        ECrate_HorzineSupply_S2                            = 16,
        ECrate_HorzineSupply_S3                            = 17,
        ECrate_HorzineSupply_S4                            = 18,
        ECrate_HorzineSupply_S5                            = 19,
        ECrate_HorzineSupply_S6                            = 20,
        ECrate_HorzineSupply_S7                            = 21,
        ECrate_HorzineSupply_S8                            = 22,
        ECrate_HorzineSupply_S9                            = 23,
        ECrate_PSNHorzineSupply_CS1                        = 24,
        ECrate_PSNHorzineSupply_CS2                        = 25,
        ECrate_PSNHorzineSupply_WS1                        = 26,
        ECrate_PSNHorzineSupply_WS2                        = 27,
        ECrate_PSNHorzineSupply_WS3                        = 28,
        ECrate_PSNHorzineSupply_WS4                        = 29,
        ECrate_HorzineSupply_S10                           = 30,
        ECrate_HorzineSupply_S11                           = 31,
        ECrate_Emote_S1                                    = 32,
        Ecrate_TacticalHorzineMKII                         = 33,
        ECrate_HorzineSupply_S12                           = 34,
        ECrate_Deepstrike                                  = 35,
        ECrate_HorzineSupply_S13                           = 36,
        ECrate_HighVoltage                                 = 37,
        ECrate_Flare                                       = 38,
        ECrate_HorzineSupply_S14                           = 39,
        ECrate_Junkyard                                    = 40,
        ECrate_Vietnam                                     = 41,
        ECrateSeries_MAX                                   = 42
};*/

// Enum KFGame.KFKActor.EKActorNetworkType
/*enum EKActorNetworkType
{
        NT_Auto                                            = 0,
        NT_ClientSide                                      = 1,
        NT_Replicated                                      = 2,
        NT_MAX                                             = 3
};*/

// Enum KFGame.KFLocalMessage.ELocalMessageType
/*enum ELocalMessageType
{
        LMT_AdminLogin                                     = 0,
        LMT_AdminLogout                                    = 1,
        LMT_MustLoginToCheat                               = 2,
        LMT_CheatsEnabled                                  = 3,
        LMT_ServerMaintenance                              = 4,
        LMT_KickVoteStarted                                = 5,
        LMT_KickVoteFailed                                 = 6,
        LMT_KickVoteSucceeded                              = 7,
        LMT_KickVoteRejected                               = 8,
        LMT_KickVoteInProgress                             = 9,
        LMT_KickVoteDisabled                               = 10,
        LMT_KickVoteYesReceived                            = 11,
        LMT_KickVoteNoReceived                             = 12,
        LMT_KickVoteAdmin                                  = 13,
        LMT_KickVoteActiveTime                             = 14,
        LMT_KickVoteMatchNotStarted                        = 15,
        LMT_KickVoteMaxKicksReached                        = 16,
        LMT_KickVoteNotEnoughPlayers                       = 17,
        LMT_KickVoteNoSpectators                           = 18,
        LMT_MAX                                            = 19
};*/

// Enum KFGame.KFLocalMessage_Game.EGameMessageType
/*enum EGameMessageType
{
        GMT_GaveAmmoTo                                     = 0,
        GMT_GaveArmorTo                                    = 1,
        GMT_GaveAmmoAndArmorTo                             = 2,
        GMT_ReceivedAmmoFrom                               = 3,
        GMT_ReceivedArmorFrom                              = 4,
        GMT_ReceivedAmmoAndArmorFrom                       = 5,
        GMT_HealedBy                                       = 6,
        GMT_HealedPlayer                                   = 7,
        GMT_HealedSelf                                     = 8,
        GMT_Equipped                                       = 9,
        GMT_PickedupArmor                                  = 10,
        GMT_FullArmor                                      = 11,
        GMT_Ammo                                           = 12,
        GMT_PickedupWeaponAmmo                             = 13,
        GMT_AmmoIsFull                                     = 14,
        GMT_AmmoAndArmorAreFull                            = 15,
        GMT_AlreadyCarryingWeapon                          = 16,
        GMT_PickedupItem                                   = 17,
        GMT_TooMuchWeight                                  = 18,
        GMT_PendingPerkChangesSet                          = 19,
        GMT_PendingPerkChangesApplied                      = 20,
        GMT_FailedDropInventory                            = 21,
        GMT_ReceivedGrenadesFrom                           = 22,
        GMT_GaveGrenadesTo                                 = 23,
        GMT_FoundCollectible                               = 24,
        GMT_FoundAllCollectibles                           = 25,
        GMT_UserSharingContent                             = 26,
        KMT_Killed                                         = 27,
        KMT_Suicide                                        = 28,
        EGameMessageType_MAX                               = 29
};*/

// Enum KFGame.KFLocalMessage_Interaction.EInteractionMessageType
/*enum EInteractionMessageType
{
        IMT_None                                           = 0,
        IMT_AcceptObjective                                = 1,
        IMT_ReceiveAmmo                                    = 2,
        IMT_ReceiveGrenades                                = 3,
        IMT_UseTrader                                      = 4,
        IMT_UseDoor                                        = 5,
        IMT_UseDoorWelded                                  = 6,
        IMT_RepairDoor                                     = 7,
        IMT_UseMinigame                                    = 8,
        IMT_UseMinigameGenerator                           = 9,
        IMT_GamepadWeaponSelectHint                        = 10,
        IMT_HealSelfWarning                                = 11,
        IMT_ClotGrabWarning                                = 12,
        IMT_PlayerClotGrabWarning                          = 13,
        IMT_MAX                                            = 14
};*/

// Enum KFGame.KFLocalMessage_PlayerKills.EKillMessageType
/*enum EKillMessageType
{
        KMT_PlayerKillPlayer                               = 0,
        KMT_PLayerKillZed                                  = 1,
        KMT_AIKillPlayer                                   = 2,
        KMT_MAX                                            = 3
};*/

// Enum KFGame.KFLocalMessage_Priority.EGameMessageType
/*enum EGameMessageType
{
        GMT_WaveStart                                      = 0,
        GMT_WaveEnd                                        = 1,
        GMT_MatchWon                                       = 2,
        GMT_MatchLost                                      = 3,
        GMT_ObjectiveStart                                 = 4,
        GMT_ObjectiveWon                                   = 5,
        GMT_ObjectiveLost                                  = 6,
        GMT_ObjEndPlayerNeeded                             = 7,
        GMT_ObjEndTimeLimit                                = 8,
        GMT_LevelUp                                        = 9,
        GMT_TierUnlocked                                   = 10,
        GMT_Died                                           = 11,
        GMT_ZedsWin                                        = 12,
        GMT_HumansWin                                      = 13,
        GMT_AttackHumanPlayers                             = 14,
        GMT_NextRoundBegin                                 = 15,
        GMT_MAX                                            = 16
};*/

// Enum KFGame.KFLocalMessage_ServerNotification.EServerMessageType
/*enum EServerMessageType
{
        SMT_None                                           = 0,
        SMT_TeamsPendingBalance                            = 1,
        SMT_MAX                                            = 2
};*/

// Enum KFGame.KFLocalMessage_VoiceComms.EVoiceCommsType
/*enum EVoiceCommsType
{
        VCT_REQUEST_HEALING                                = 0,
        VCT_REQUEST_DOSH                                   = 1,
        VCT_REQUEST_HELP                                   = 2,
        VCT_TAUNT_ZEDS                                     = 3,
        VCT_FOLLOW_ME                                      = 4,
        VCT_GET_TO_THE_TRADER                              = 5,
        VCT_AFFIRMATIVE                                    = 6,
        VCT_NEGATIVE                                       = 7,
        VCT_EMOTE                                          = 8,
        VCT_MAX                                            = 9
};*/

// Enum KFGame.KFMapInfo.ECollectibleType
/*enum ECollectibleType
{
        ECT_DoshBling                                      = 0,
        ECT_ClotMotherBaby                                 = 1,
        ECT_MAX                                            = 2
};*/

// Enum KFGame.KFMapInfo.ESubGameType
/*enum ESubGameType
{
        ESGT_Normal                                        = 0,
        ESGT_Descent                                       = 1,
        ESGT_MAX                                           = 2
};*/

// Enum KFGame.KFMapSummary.EAssociationIdentifier
/*enum EAssociationIdentifier
{
        EAI_Custom                                         = 0,
        EAI_OfficialCustom                                 = 1,
        EAI_TripwireOfficial                               = 2,
        EAI_MAX                                            = 3
};*/

// Enum KFGame.KFMeleeHelperWeapon.EMeleeAttackType
/*enum EMeleeAttackType
{
        ATK_Normal                                         = 0,
        ATK_Combo                                          = 1,
        ATK_DrawStrike                                     = 2,
        ATK_MAX                                            = 3
};*/

// Enum KFGame.KFOnlineGameSearch.ESortType
/*enum ESortType
{
        SORTTYPE_None                                      = 0,
        SORTTYPE_Name                                      = 1,
        SORTTYPE_Mode                                      = 2,
        SORTTYPE_Difficulty                                = 3,
        SORTTYPE_Map                                       = 4,
        SORTTYPE_PlayerCount                               = 5,
        SORTTYPE_WaveCount                                 = 6,
        SORTTYPE_Ping                                      = 7,
        SORTTYPE_MAX                                       = 8
};*/

// Enum KFGame.KFOnlineGameSearch.ESortOrder
/*enum ESortOrder
{
        SORTORDER_None                                     = 0,
        SORTORDER_ACENDING                                 = 1,
        SORTORDER_DECENDING                                = 2,
        SORTORDER_MAX                                      = 3
};*/

// Enum KFGame.KFPerk_Berserker.EBerserkPerkSkills
/*enum EBerserkPerkSkills
{
        EBerserkerFortitude                                = 0,
        EBerserkerNinja                                    = 1,
        EBerserkerVampire                                  = 2,
        EBerserkerSpeed                                    = 3,
        EBerserkerResistance                               = 4,
        EBerserkerParry                                    = 5,
        EBerserkerSmash                                    = 6,
        EBerserkerFury                                     = 7,
        EBerserkerRage                                     = 8,
        EBerserkerSpartan                                  = 9,
        EBerserkPerkSkills_MAX                             = 10
};*/

// Enum KFGame.KFPerk_Commando.ECommandoSkills
/*enum ECommandoSkills
{
        ECommandoTacticalReload                            = 0,
        ECommandoLargeMags                                 = 1,
        ECommandoBackup                                    = 2,
        ECommandoImpact                                    = 3,
        ECommandoHealthIncrease                            = 4,
        ECommandoAmmoVest                                  = 5,
        ECommandoHollowPoints                              = 6,
        ECommandoEatLead                                   = 7,
        ECommandoProfessional                              = 8,
        ECommandoRapidFire                                 = 9,
        ECommandoSkills_MAX                                = 10
};*/

// Enum KFGame.KFPerk_Demolitionist.EDemoSkills
/*enum EDemoSkills
{
        EDemoDamage                                        = 0,
        EDemoTacticalReload                                = 1,
        EDemoDirectHit                                     = 2,
        EDemoAmmo                                          = 3,
        EDemoSirenResistance                               = 4,
        EDemoAoE                                           = 5,
        EDemoCriticalHit                                   = 6,
        EDemoConcussiveForce                               = 7,
        EDemoNuke                                          = 8,
        EDemoProfessional                                  = 9,
        EDemoSkills_MAX                                    = 10
};*/

// Enum KFGame.KFPerk_FieldMedic.EMedicPerkSkills
/*enum EMedicPerkSkills
{
        EMedicHealingSurge                                 = 0,
        EMedicSurvivalist                                  = 1,
        EMedicHealingSpeedBoost                            = 2,
        EMedicCombatant                                    = 3,
        EMedicHealingDamageBoost                           = 4,
        EMedicAcidicCompound                               = 5,
        EMedicHealingShield                                = 6,
        EMedicEnforcer                                     = 7,
        EMedicAirborneAgent                                = 8,
        EMedicSlug                                         = 9,
        EMedicPerkSkills_MAX                               = 10
};*/

// Enum KFGame.KFPerk_Firebug.EFirebugSkills
/*enum EFirebugSkills
{
        EFirebugBringTheHeat                               = 0,
        EFirebugHighCapFuelTank                            = 1,
        EFirebugFuse                                       = 2,
        EFirebugGroundFire                                 = 3,
        EFirebugNapalm                                     = 4,
        EFirebugZedShrapnel                                = 5,
        EFirebugSplashDamage                               = 6,
        EFirebugRange                                      = 7,
        EFirebugScorch                                     = 8,
        EFirebugInferno                                    = 9,
        EFirebugSkills_MAX                                 = 10
};*/

// Enum KFGame.KFPerk_Gunslinger.EGunslingerSkills
/*enum EGunslingerSkills
{
        EGunslingerShootnMove                              = 0,
        EGunslingerQuickSwitch                             = 1,
        EGunslingerRhythmMethod                            = 2,
        EGunslingerBoneBreaker                             = 3,
        EGunslingerPenetration                             = 4,
        EGunslingerSpeedReload                             = 5,
        EGunslingerSkullCracker                            = 6,
        EGunslingerKnockEmDown                             = 7,
        EGunslingerUberAmmo                                = 8,
        EGunslingerFanfare                                 = 9,
        EGunslingerSkills_MAX                              = 10
};*/

// Enum KFGame.KFPerk_Sharpshooter.ESharpshooterPerkSkills
/*enum ESharpshooterPerkSkills
{
        ESharpshooterStationaryAim                         = 0,
        ESharpshooterTrigger                               = 1,
        ESharpshooterCrouchAim                             = 2,
        ESharpshooterStun                                  = 3,
        ESharpshooterRhythmMethod                          = 4,
        ESharpshooterTacticalReload                        = 5,
        ESharpshooterScoped                                = 6,
        ESharpshooterAmmoPouch                             = 7,
        ESharpshooterZTKnockdown                           = 8,
        ESharpshooterZTStun                                = 9,
        ESharpshooterPerkSkills_MAX                        = 10
};*/

// Enum KFGame.KFPerk_Support.ESupportPerkSkills
/*enum ESupportPerkSkills
{
        ESupportHighCapMags                                = 0,
        ESupportTacticalReload                             = 1,
        ESupportFortitude                                  = 2,
        ESupportSalvo                                      = 3,
        ESupportAPShot                                     = 4,
        ESupportTightChoke                                 = 5,
        ESupportResupply                                   = 6,
        ESupportConcussionRounds                           = 7,
        ESupportPerforate                                  = 8,
        ESupportBarrage                                    = 9,
        ESupportPerkSkills_MAX                             = 10
};*/

// Enum KFGame.KFPerk_Survivalist.ESurvivalistPerkSkills
/*enum ESurvivalistPerkSkills
{
        ESurvivalist_TacticalReload                        = 0,
        ESurvivalist_HeavyWeaponsReload                    = 1,
        ESurvivalist_FieldMedic                            = 2,
        ESurvivalist_MeleeExpert                           = 3,
        ESurvivalist_AmmoVest                              = 4,
        ESurvivalist_BigPockets                            = 5,
        ESurvivalist_Shrapnel                              = 6,
        ESurvivalist_MakeThingsGoBoom                      = 7,
        ESurvivalist_MadMan                                = 8,
        ESurvivalist_IncapMaster                           = 9,
        ESurvivalist_MAX                                   = 10
};*/

// Enum KFGame.KFPerk_SWAT.ESWATPerkSkills
/*enum ESWATPerkSkills
{
        ESWAT_HeavyArmor                                   = 0,
        ESWAT_TacticalMovement                             = 1,
        ESWAT_Backup                                       = 2,
        ESWAT_TacticalReload                               = 3,
        ESWAT_SpecialAmmunition                            = 4,
        ESWAT_AmmoVest                                     = 5,
        ESWAT_BodyArmor                                    = 6,
        ESWAT_Cripple                                      = 7,
        ESWAT_SWATEnforcer                                 = 8,
        ESWAT_RapidAssault                                 = 9,
        ESWAT_MAX                                          = 10
};*/

// Enum KFGame.KFProjectile.FracturedMeshGlassShatterType
/*enum FracturedMeshGlassShatterType
{
        FMGS_ShatterNone                                   = 0,
        FMGS_ShatterDamaged                                = 1,
        FMGS_ShatterAll                                    = 2,
        FMGS_MAX                                           = 3
};*/

// Enum KFGame.KFSeqAct_ShowPath.eVolumeCheckType
/*enum eVolumeCheckType
{
        VCT_None                                           = 0,
        VCT_InVolume                                       = 1,
        VCT_NotInVolume                                    = 2,
        VCT_MAX                                            = 3
};*/

// Enum KFGame.KFSpawner.EEmergeAnim
/*enum EEmergeAnim
{
        EMERGE_Floor                                       = 0,
        EMERGE_Wall248UU                                   = 1,
        EMERGE_WallHigh                                    = 2,
        EMERGE_Ceiling                                     = 3,
        EMERGE_None                                        = 4,
        EMERGE_MAX                                         = 5
};*/

// Enum KFGame.KFSM_GrappleCombined.EGrappleState
/*enum EGrappleState
{
        EGS_GrabAttempt                                    = 0,
        EGS_GrabSuccess                                    = 1,
        EGS_GrabMiss                                       = 2,
        EGS_MAX                                            = 3
};*/

// Enum KFGame.KFSM_PlayerMeleeBase.EPlayerZedAtkType
/*enum EPlayerZedAtkType
{
        PZA_Default                                        = 0,
        PZA_Sprinting                                      = 1,
        PZA_SprintBackwards                                = 2,
        PZA_SprintCloaked                                  = 3,
        PZA_Cloaked                                        = 4,
        PZA_Jumping                                        = 5,
        PZA_Headless                                       = 6,
        PZA_Left                                           = 7,
        PZA_Right                                          = 8,
        PZA_Backwards                                      = 9,
        PZA_SpecialDefault                                 = 10,
        PZA_SpecialSprinting                               = 11,
        PZA_SpecialBackwards                               = 12,
        PZA_MAX                                            = 13
};*/

// Enum KFGame.KFSM_Stumble.EStubmleAnim
/*enum EStubmleAnim
{
        ESA_Body_Forward                                   = 0,
        ESA_Body_Backward                                  = 1,
        ESA_Body_Left                                      = 2,
        ESA_Body_Right                                     = 3,
        ESA_Leg_L_Forward                                  = 4,
        ESA_Leg_L_Backward                                 = 5,
        ESA_Leg_L_Left                                     = 6,
        ESA_Leg_L_Right                                    = 7,
        ESA_Leg_R_Forward                                  = 8,
        ESA_Leg_R_Backward                                 = 9,
        ESA_Leg_R_Left                                     = 10,
        ESA_Leg_R_Right                                    = 11,
        ESA_Parry                                          = 12,
        ESA_MAX                                            = 13
};*/

// Enum KFGame.KFSM_Zed_Boss_Theatrics.ETheatricType
/*enum ETheatricType
{
        THEATRIC_Entrance                                  = 0,
        THEATRIC_Victory                                   = 1,
        THEATRIC_MAX                                       = 2
};*/

// Enum KFGame.KFSM_Zed_Taunt.ETauntType
/*enum ETauntType
{
        TAUNT_Standard                                     = 0,
        TAUNT_EnemyKilled                                  = 1,
        TAUNT_Enraged                                      = 2,
        TAUNT_MAX                                          = 3
};*/

// Enum KFGame.KFUnlockManager.EPlatformRestriction
/*enum EPlatformRestriction
{
        PR_All                                             = 0,
        PR_XboxOne                                         = 1,
        PR_PC                                              = 2,
        PR_PS4                                             = 3,
        PR_Console                                         = 4,
        PR_MAX                                             = 5
};*/

// Enum KFGame.KFUnlockManager.ESharedContentUnlock
/*enum ESharedContentUnlock
{
        SCU_None                                           = 0,
        SCU_Zweihander                                     = 1,
        SCU_MAX                                            = 2
};*/

// Enum KFGame.KFWeapon.EInventoryGroup
/*enum EInventoryGroup
{
        IG_Primary                                         = 0,
        IG_Secondary                                       = 1,
        IG_Melee                                           = 2,
        IG_Equipment                                       = 3,
        IG_None                                            = 4,
        IG_MAX                                             = 5
};*/

// Enum KFGame.KFWeapon.EReloadStatus
/*enum EReloadStatus
{
        RS_None                                            = 0,
        RS_OpeningBolt                                     = 1,
        RS_Reloading                                       = 2,
        RS_ClosingBolt                                     = 3,
        RS_Complete                                        = 4,
        RS_MAX                                             = 5
};*/

// Enum KFGame.KFWeaponAttachment.EWeaponState
/*enum EWeaponState
{
        WEP_Idle                                           = 0,
        WEP_Reload                                         = 1,
        WEP_ReloadEmpty                                    = 2,
        WEP_Reload_Elite                                   = 3,
        WEP_ReloadEmpty_Elite                              = 4,
        WEP_ReloadSingle                                   = 5,
        WEP_ReloadSingleEmpty                              = 6,
        WEP_ReloadSingle_Elite                             = 7,
        WEP_ReloadSingleEmpty_Elite                        = 8,
        WEP_ReloadSecondary                                = 9,
        WEP_ReloadSecondary_Elite                          = 10,
        WEP_ReloadDualsOneEmpty                            = 11,
        WEP_ReloadDualsOneEmpty_Elite                      = 12,
        WEP_MeleeBasic                                     = 13,
        WEP_MeleeChain                                     = 14,
        WEP_MeleeSustained                                 = 15,
        WEP_Melee_L                                        = 16,
        WEP_Melee_R                                        = 17,
        WEP_Melee_F                                        = 18,
        WEP_Melee_B                                        = 19,
        WEP_MeleeHeavy_L                                   = 20,
        WEP_MeleeHeavy_R                                   = 21,
        WEP_MeleeHeavy_F                                   = 22,
        WEP_MeleeHeavy_B                                   = 23,
        WEP_MeleeBlock                                     = 24,
        WEP_Cleaning                                       = 25,
        WEP_Equipping                                      = 26,
        WEP_PutAway                                        = 27,
        WEP_Grenade                                        = 28,
        WEP_Heal                                           = 29,
        WEP_HealQuick                                      = 30,
        WEP_Weld                                           = 31,
        WEP_Custom0                                        = 32,
        WEP_Custom1                                        = 33,
        WEP_Custom2                                        = 34,
        WEP_Custom3                                        = 35,
        WEP_Custom4                                        = 36,
        WEP_Custom5                                        = 37,
        WEP_Custom6                                        = 38,
        WEP_Custom7                                        = 39,
        WEP_Custom8                                        = 40,
        WEP_Custom9                                        = 41,
        WEP_MAX                                            = 42
};*/

// Enum KFGame.KFWeaponSkinList.EWeaponSkinType
/*enum EWeaponSkinType
{
        WST_FirstPerson                                    = 0,
        WST_ThirdPerson                                    = 1,
        WST_Pickup                                         = 2,
        WST_MAX                                            = 3
};*/

/*
#
=========================================================================================
# # Classes #
=========================================================================================
#
*/

// Class KFGame.KFAnimNotify_AkEvent_IfActiveMGTarget
// 0x0000 (0x007C - 0x007C)
class UKFAnimNotify_AkEvent_IfActiveMGTarget : public UAnimNotify_AkEvent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3175];

        return pClassPointer;
    };

    void eventCanPlayAkEvent();
};

UClass* UKFAnimNotify_AkEvent_IfActiveMGTarget::pClassPointer = NULL;

// Class KFGame.KFCheatManager
// 0x0024 (0x00C4 - 0x00A0)
class UKFCheatManager : public UGameCheatManager {
   public:
    DWORD bDebugSceneEnabled : 1;     // 0x00A0 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bUsingSplatterGun : 1;      // 0x00A0 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bRequestedGlobalStats : 1;  // 0x00A0 (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    class AKFSceneCaptureDebugCam*
        DebugSceneCamera;                // 0x00A4 (0x0008) [0x0000000000000000]
    class AKFAIController* DebugKFAIC;   // 0x00AC (0x0008) [0x0000000000000000]
    class AKFPawn_Monster* DebugTarget;  // 0x00B4 (0x0008) [0x0000000000000000]
    struct FName CheatType;              // 0x00BC (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3177];

        return pClassPointer;
    };

    void DebugSetSafeFrame();
    void DebugEndGameRewards();
    void GetTitleDataValueForKey();
    void OnTitleDataRead();
    void ReadPlayfabTitleData();
    void RefreshXboxInventory();
    void DumpStoreCatalog();
    void DumpFullCatalog();
    void DumpSubscriptions();
    void DumpConsumables();
    void DumpDurables();
    void DumpApplicationProducts();
    void DumpGameProducts();
    void ShowXboxProductDetails();
    void DeleteXboxSaveData();
    void TestTutorialRewards();
    void DebugConsumeEntitlements();
    void DebugGrantItem();
    void DebugRemoveCurrency();
    void DebugAddCurrency();
    void DebugRetrieveInternalData();
    void DebugUpdateServerData();
    void DebugUpdateInternalData();
    void DumpExchangeRules();
    void DumpInventory();
    void DumpItemDefinitions();
    void UnlockContainer();
    void OnPlayfabInventoryReadComplete();
    void ReadPFUserInventory();
    void OnPlayfabStoreReadComplete();
    void ReadPFStoreData();
    void SetMatchmakingRegion();
    void OnServerStarted();
    void StartupServer();
    void OnQueryServerInfoComplete();
    void TestServerInfoQuery();
    void OnFindOnlinePlayfabGamesComplete();
    void TestPlayfabGameSearch();
    void OnLoginComplete();
    void TestLogin();
    void LoginSelf();
    void Hats();
    void ShowPostRoundMenu();
    void SpawnHumanPawnV();
    void TestGrapple();
    void DemiGod();
    void SetWeaponSkin();
    void WeaponGotoState();
    void RespawnSpectators();
    void LogServerMovementVars();
    void ToggleVisibilityView();
    void ToggleRelevancyView();
    void LogStatValue();
    void LogItemPickups();
    void LogAmmoPickups();
    void ShowKFGameVersion();
    void DBJump();
    void ClearFakeDramaEvent();
    void FakeDramaEvent();
    void ZedTimeTest();
    void TestFalloffDamage();
    void GetCurrentPerkXP();
    void ShowLevelUpPopUp();
    void TestGameSearch();
    void Chris();
    void ShowMeleeCollision();
    void LaunchChunks();
    void SetNadeRadiusDebug();
    void TurnOnAIArenaLight();
    void ConvertFOV();
    void SetLivingPlayers();
    void ToggleAIDefaultsLog();
    void DisableAtkAnimDifficultyScaling();
    void EnableAtkAnimDifficultyScaling();
    void CameraPuke();
    void HeadShotPing();
    void CameraBlood();
    void EndRound();
    void ClearCorpses();
    void ClearSplatters();
    void SplatterFire();
    void ToggleSplatterGun();
    void SetDebugSceneView();
    void SetDebugSceneViewMode();
    void PauseDebugSceneUpdate();
    void ToggleDebugSceneOrbit();
    void DestroyDebugScene();
    void FocusOff();
    void AISetFocus();
    void AILockDesiredRotation();
    void AIUnlockDesiredRotation();
    void AIClearFocus();
    void AISetFocalPoint();
    void ResetDoors();
    void ResetLevel();
    void DestroyDoors();
    void WeldDoors();
    void InitDebugScene();
    void FocusOn();
    void FocusOnZed();
    void SpawnBloatTest();
    void SpawnTest();
    void SetSpawnVolumeMinDebug();
    void SetSpawnVolumeDebug();
    void TestSpawnVolume();
    void TestPortalActive();
    void TestPortalAll();
    void TestPortalNearby();
    void GetRandomClotType();
    void SpawnZedLODs();
    void SpawnZedGroup();
    void SpawnZed();
    void KillBots();
    void SpawnHumanPawn();
    void LoadMonsterByName();
    void SetBossNum();
    void GoHumanV();
    void SpawnZedV();
    void SpawnZedVC();
    void SpawnAIZed();
    void AIShowAttackAnims();
    void SpawnDebugAI();
    void SpawnAIV();
    void SpawnAI();
    void BurnValTest();
    void EMPValTest();
    void EMPWander();
    void PlayStunned();
    void PlayKnockdown();
    void PlayTaunt();
    void PlayRandomStumble();
    void EnableLivingGore();
    void CrippleZed();
    void CrippleZeds();
    void InjureZedArm();
    void AILookAtMe();
    void AISetInUseCost();
    void BigZedMode();
    void BigHeadMode();
    void TestSpecDist();
    void DumpAICommands();
    void AIDebugLOS();
    void ShowCrawlerPath();
    void AIRage();
    void KillZeds();
    void KillOtherZeds();
    void DumpReachSpecs();
    void AIDebugEnemy();
    void AISetDebugColorA();
    void AISetDebugColorB();
    void AISetDebugColorG();
    void AISetDebugColorR();
    void AISetDebugColor();
    void AITestHansGrab();
    void AIHansGrenade();
    void AIHansTestGrenadeTrajectory();
    void AITestGrab();
    void AITestCrawlerAttack();
    void AITestCrawlers();
    void AITestCrawler();
    void AIDebugCrawler();
    void AIPathTo();
    void AIDisableMeleeEvents();
    void AIEnableMeleeEvents();
    void AIMoveToMeAsEnemy();
    void ShowPathnodes();
    void ShowBlockedPathnodes();
    void AISummonZeds();
    void HansGas();
    void HansNextPhase();
    void DebugNextPhase();
    void AIPlayTaunt();
    void AIShowLitNodes();
    void AIShowForcedSpecs();
    void AIShowFloorToWallNodes();
    void AIShowDropDowns();
    void ClearDebugLines();
    void KFDL();
    void ToggleKFDebugLines();
    void AIToggleTurnInPlace();
    void AIDebugTurnInPlace();
    void GetDebugAIController();
    void TestScreamEffect();
    void AIToggleHeadTracking();
    void AIEnableBump();
    void AIDisableBump();
    void GetYawRate();
    void AISetCanAttack();
    void AISetEnemyToMe();
    void MarkLocation();
    void GetDebugAICommand();
    void AIShowDebug();
    void AIShowNames();
    void ShowAiDebugText();
    void TAND();
    void SetNPCDebugCategory();
    void SetAllNPCDebug();
    void ToggleAllNPCDebug();
    void ShowAIInfo();
    void AIStepAside();
    void ToggleNPCDebug();
    void AIScream();
    void AIFPEnrage();
    void FlushAILogs();
    void RemoveAIFilter();
    void AddAIFilter();
    void EnterZedVictoryState();
    void AIFPRoam();
    void AIHide_Debug();
    void AIMoveForward();
    void TeleportPawnToCamera();
    void ViewZed();
    void ViewSelf();
    void DumpInfoForAI();
    void EnableDebugCamera();
    void TDC();
    void ToggleDebugCamera();
    void GetKFMPFromAim();
    void GetKFAICFromAim();
    void CheckReachSpecs();
    void ToggleShowDestructibleNavigationDebugArtifacts();
    void ToggleShowDoorNavigationDebugArtifacts();
    void ToggleShowLeapDownDebugArtifacts();
    void ToggleShowHighDetailCombatMovementDebugInfo();
    void ToggleShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState();
    void ToggleShowMovePointsDebugInfo();
    void ToggleShowVisualStuckZedDebugInfo();
    void ShowAIStuckNpcsToggle();
    void AIDebugStepAside();
    void AIDebugSteering();
    void AIWander();
    void AIFlee();
    void AIDebug();
    void HideDebugStrikeRanges();
    void ShowDebugStrikeRanges();
    void AIDebugMode();
    void PathInfo();
    void AISetSightRadius();
    void AIDebugVision();
    void AISetPeriph();
    void ShowDebugNodes();
    void GotoDebugNode();
    void DumpDebugNodes();
    void ShowReachSpecsFor();
    void ShowBlockedPaths();
    void AIHeadlessWander();
    void Puke();
    void AIDebugFloor();
    void AIShowAnchor();
    void SlasherTauntTimer();
    void SlasherTaunt();
    void DrawLineFromNPC();
    void AIHuskFlamethrower();
    void AIHelp();
    void GoToActor();
    void FPDL();
    void OpenTraderMenu();
    void OpenTraderNext();
    void OpenTrader();
    void HideTraderPath();
    void ShowTraderPath();
    void GoRecoil();
    void NoRecoil();
    void SetISMeshCompScale();
    void SetIronIdleAnims();
    void SetDebugRecoil3d();
    void ToggleWeapCanPause();
    void NoAmmo();
    void UberAmmo();
    void AllAmmo();
    void KillFlares();
    void SpawnFlare();
    void TestHitZones();
    void SpamShellEject();
    void PlayShellEject();
    void PlayMuzzleFlash();
    void ArmorMe();
    void HealMe();
    void DoTMe();
    void HurtMe();
    void DoshMe();
    void ImRich();
    void TestCheat();
    void DramaEvent();
    void RestoreWeaponCameraAnimScale();
    void SetWeaponCameraAnimScale();
    void RestoreShootCameraAnims();
    void ScaleShootCameraAnims();
    void ShowHands();
    void BackgroundBlur();
    void ShowDownloadPopup();
    void CustomDOF();
    void QuickDOF();
    void WeapFOV();
    void KillRecoil();
    void AllWeapons();
    void Surv();
    void SMG();
    void Swat();
    void Sharpshooter();
    void Rifle();
    void Firebug();
    void Flame();
    void Medic();
    void Demo();
    void ScopeFOV();
    void Scope();
    void Assault();
    void Melee();
    void Nails();
    void Berserk();
    void DummyWeapon();
    void Singles();
    void Dualies();
    void Pistols();
    void MKB();
    void Shotty();
    void GiveWeapon();
    void SetPadVolume();
    void SetMusicVolume();
    void NextTrack();
    void FlameDebugDamage3P();
    void FlameDebugFX3P();
    void FlameDebugFX();
    void FlameDebugDamage();
    void FlameSetComplex();
    void ToggleCrosshair();
    void ToggleForceCrosshair();
    void DebugShowVoteKick();
    void HideMenus();
    void GoSpread();
    void NoSpread();
    void SetPauseMonsterAnims();
    void TestWeaponAnim();
    void FreezeWeapAnimUpdate();
    void WeapForceIdle();
    void HansGunsAway();
    void HansGunsOut();
    void SpawnGunModel();
    void LogAllWaves();
    void LogCurrentWave();
    void ZedStuck();
    void ZedTeleport();
    void ToggleFrustration();
    void ToggleZedsIgnoreMe();
    void SetChar();
    void SetInflate();
    void StopBurnFX();
    void BurnFX();
    void TestNukeGrenade();
    void TestConcussiveGrenade();
    void TestGrenade();
    void FireAgain();
    void StopAutoFire();
    void AutoFire();
    void TestLocalMessage();
    void PrintOutCharacterCosmeticInfo();
    void SetCharacterAttachment();
    void MakeFakePopUp();
    void TestNumbPrompts();
    void TestSongInfoWidget();
    void SetIISText();
    void OpenIIS();
    void CloseScreenSizeMovie();
    void OpenScreenSizeMovie();
    void SetFakeDownloadProgress();
    void GetMyPawn();
    void MakeEmptyPackage();
    void FindTranslucencyInheritDominantShadowMaterials();
    void ReadGlobalStat();
    void FixupCharacterAttachmentLocalization();
    void AnalyzeCharacterAttachments();
    void ResetPerkLevels();
    void SetPerkLevel();
};

UClass* UKFCheatManager::pClassPointer = NULL;

// Class KFGame.KFDebugLines
// 0x003C (0x0280 - 0x0244)
class AKFDebugLines : public AActor {
   public:
    TArray<struct FDebugLine>
        ActiveLines;  // 0x0244 (0x0010) [0x0000000000000000]
    int MaxLines;     // 0x0254 (0x0004) [0x0000000000000000]
    TArray<struct FDebugSphere>
        ActiveSpheres;  // 0x0258 (0x0010) [0x0000000000000000]
    int MaxSpheres;     // 0x0268 (0x0004) [0x0000000000000000]
    TArray<struct FDebugText3D>
        ActiveText3D;  // 0x026C (0x0010) [0x0000000000000000]
    int MaxText3D;     // 0x027C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3179];

        return pClassPointer;
    };

    void KFDebug_ClearText();
    void KFDebug_ClearSpheres();
    void KFDebug_ClearLines();
    void GetDebugLines();
    void NewDebugSphere();
    void NewDebugLineToOwner();
    void NewDebugLineFromOwner();
    void eventDestroyed();
    void RemoveFromPostRenderList();
    void AddToPostRenderList();
    void eventPostBeginPlay();
    void ClearAll();
    void RemoveOwnedDebugText3D();
    void RemoveOwnedDebugSpheres();
    void RemoveOwnedDebugLines();
    void AddDebugText3D();
    void AddDebugSphere();
    void AddDebugLineToOwner();
    void AddDebugLineFromOwner();
    void AddDebugLine();
    void AddPawnDebugLine();
    void NativePostRenderFor();
};

UClass* AKFDebugLines::pClassPointer = NULL;

// Class KFGame.KFDestructibleActor
// 0x0134 (0x0378 - 0x0244)
class AKFDestructibleActor : public AActor {
   public:
    unsigned char ReplicationMode;  // 0x0244 (0x0001) [0x0000000000000000]
    unsigned char
        ReplicatedDamageFlags;           // 0x0245 (0x0001) [0x0000000000000000]
    unsigned char VulnerableMultiplier;  // 0x0246 (0x0001) [0x0000000000000000]
    unsigned char SubObjectLimit;        // 0x0247 (0x0001) [0x0000000000000000]
    unsigned char DamageModLimit;        // 0x0248 (0x0001) [0x0000000000000000]
    struct FReplicatedDamageModInfo
        ReplicatedDamageMods[0x10];  // 0x024C (0x0080) [0x0000000000150000] (
                                     // CPF_Travel | CPF_GlobalConfig )
    DWORD bShutDown : 1;  // 0x02CC (0x0004) [0x0000000000250000] [0x00000001] (
                          // CPF_Travel | CPF_GlobalConfig )
    DWORD bIgnoreAllDamage : 1;        // 0x02CC (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD bIgnorePlayerDamage : 1;     // 0x02CC (0x0004) [0x0000000000000000]
                                       // [0x00000004]
    DWORD bAllowBumpDamageFromAI : 1;  // 0x02CC (0x0004) [0x0000000000000000]
                                       // [0x00000008]
    DWORD bComponentsSetUp : 1;        // 0x02CC (0x0004) [0x0000000000000000]
                                       // [0x00000010]
    DWORD bInitRBPhysCalled : 1;       // 0x02CC (0x0004) [0x0000000000000000]
                                       // [0x00000020]
    DWORD bIsRadiusDamage : 1;         // 0x02CC (0x0004) [0x0000000000000000]
                                       // [0x00000040]
    DWORD bAnyDamageModApplied : 1;    // 0x02CC (0x0004) [0x0000000000000000]
                                       // [0x00000080]
    int INSTAKILL_DAMAGE;              // 0x02D0 (0x0004) [0x0000000000000000]
    TArray<class UClass*>
        InstaKillDamageType;  // 0x02D4 (0x0010) [0x0000000000000000]
    TArray<class UClass*>
        IgnoreDamageType;  // 0x02E4 (0x0010) [0x0000000000000000]
    TArray<class UClass*>
        VulnerableDamageType;    // 0x02F4 (0x0010) [0x0000000000000000]
    float LastBumpCheckTime;     // 0x0304 (0x0004) [0x0000000000000000]
    float SelfDestructAllDelay;  // 0x0308 (0x0004) [0x0000000000000000]
    class ABlockingVolume*
        BlockingVolumeToDisable;  // 0x030C (0x0008) [0x0000000000000000]
    TArray<class AActor*>
        DamageOtherActors;  // 0x0314 (0x0010) [0x0000000000000000]
    class UAkBaseSoundObject*
        AmbientSoundCue;  // 0x0324 (0x0008) [0x0000000000000000]
    class UAkComponent*
        AmbientSoundComponent;       // 0x032C (0x0008) [0x0000000000000000]
    float ClosestLocalPlayerSqDist;  // 0x0334 (0x0004) [0x0000000000000000]
    TArray<struct FDestructibleSubobject>
        SubObjects;  // 0x0338 (0x0010) [0x0000000000000000]
    TArray<struct FPointer>
        DamagedSubObjects;             // 0x0348 (0x0010) [0x0000000000000000]
    class AActor* PreviewOffsetActor;  // 0x0358 (0x0008) [0x0000000000000000]
    struct FVector
        PreviewRelativeLocation;  // 0x0360 (0x000C) [0x0000000000000000]
    struct FRotator
        PreviewRelativeRotation;  // 0x036C (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3181];

        return pClassPointer;
    };

    void ToggleAllDamage();
    void Reset();
    void MoveCollidingPawns();
    void eventUnShutDownObject();
    void eventShutDownSubObject();
    void ShutDownObject();
    void eventDelayedShutDownObject();
    void UnDestroy();
    void eventExplosion();
    void RemoveDecals();
    void ApplyDamageMod();
    void SetSubObjectStaticMesh();
    void BumpedByMonster();
    void eventTriggerDestroyedEvent();
    void eventApplySplashDamage();
    void ValidateHitComponent();
    void eventInstaKillFromStandardNPCBumpDamage();
    void eventInstaKillFromLargeNPCBumpDamage();
    void IsVulnerableTo();
    void AdjustDamage();
    void eventTakeDamage();
    void TakeRadiusDamage();
    void GetMaxHealth();
    void GetCurrentHealth();
    void HasAnyHealth();
    void DamageSubObject();
    void eventPostBeginPlay();
    void OneTimeInit();
    void SetupComponents();
    void UnPackDamageMod();
    void PackDamageMod();
    void eventReplicateDamageMod();
    void eventReplicatedEvent();
};

UClass* AKFDestructibleActor::pClassPointer = NULL;

// Class KFGame.KFDoorActor
// 0x01D8 (0x041C - 0x0244)
class AKFDoorActor : public AActor {
   public:
    struct FPointer
        VfTable_IInterface_NavigationHandle;  // 0x0244 (0x0008)
                                              // [0x0000000000000000]
    class AKFDoorTrigger* DoorTrigger;  // 0x024C (0x0008) [0x0000000000000000]
    TArray<struct FDoorMeshAttachment>
        MeshAttachments;  // 0x0254 (0x0010) [0x0000000000000000]
    class UStaticMeshComponent*
        CenterWeldComponent;  // 0x0264 (0x0008) [0x0000000000000000]
    class USkeletalMeshComponent*
        SkeletalMeshComp;  // 0x026C (0x0008) [0x0000000000000000]
    TArray<class UMaterialInstanceConstant*>
        HealthMICs;  // 0x0274 (0x0010) [0x0000000000000000]
    class UMaterialInstanceConstant*
        IntegrityMIC;             // 0x0284 (0x0008) [0x0000000000000000]
    unsigned char DoorMaterial;   // 0x028C (0x0001) [0x0000000000000000]
    unsigned char DoorMechanism;  // 0x028D (0x0001) [0x0000000000000000]
    unsigned char FastenerType;   // 0x028E (0x0001) [0x0000000000000000]
    unsigned char HitCount;       // 0x028F (0x0001) [0x0000000000150000] (
                             // CPF_Travel | CPF_GlobalConfig )
    unsigned char RepairProgress;  // 0x0290 (0x0001) [0x000000000016002A] (
                                   // CPF_Const | CPF_ExportObject | CPF_Net |
                                   // CPF_EditConst | CPF_GlobalConfig )
    float CoolDownTime;            // 0x0294 (0x0004) [0x0000000000000000]
    float OpenBlendTime;           // 0x0298 (0x0004) [0x0000000000000000]
    int HingedRotation;            // 0x029C (0x0004) [0x0000000000000000]
    int SlideTranslation;          // 0x02A0 (0x0004) [0x0000000000000000]
    int LiftTranslation;           // 0x02A4 (0x0004) [0x0000000000000000]
    DWORD bAutomaticDoor : 1;      // 0x02A8 (0x0004) [0x0000000000000000]
                                   // [0x00000001]
    DWORD bDoorMoveCompleted : 1;  // 0x02A8 (0x0004) [0x0000000000000000]
                                   // [0x00000002]
    DWORD bStartDoorOpen : 1;      // 0x02A8 (0x0004) [0x0000000000000000]
                                   // [0x00000004]
    DWORD bIsDoorOpen : 1;  // 0x02A8 (0x0004) [0x0000000000170000] [0x00000008]
                            // ( CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
    DWORD bLocalIsDoorOpen : 1;  // 0x02A8 (0x0004) [0x0000000000000000]
                                 // [0x00000010]
    DWORD
        bReverseHinge : 1;  // 0x02A8 (0x0004) [0x000000000018000A] [0x00000020]
                            // ( CPF_Const | CPF_ExportObject | CPF_Component )
    DWORD bHasBeenDirtied : 1;  // 0x02A8 (0x0004) [0x0000000000000000]
                                // [0x00000040]
    DWORD
        bStartWelded : 1;  // 0x02A8 (0x0004) [0x0000000000000000] [0x00000080]
    DWORD bShouldExplode : 1;  // 0x02A8 (0x0004) [0x0000000000190000]
                               // [0x00000100] ( CPF_Travel | CPF_Component )
    DWORD bIsDestroyed : 1;    // 0x02A8 (0x0004) [0x00000000001A0000]
                               // [0x00000200] ( CPF_EditConst | CPF_Component )
    DWORD
        bWasRepaired : 1;  // 0x02A8 (0x0004) [0x00000000001B0000] [0x00000400]
                           // ( CPF_Travel | CPF_EditConst | CPF_Component )
    DWORD
        bMonitorDoor : 1;  // 0x02A8 (0x0004) [0x0000000000000000] [0x00000800]
    float LastUsedTime;    // 0x02AC (0x0004) [0x0000000000000000]
    int MaxHealth;         // 0x02B0 (0x0004) [0x0000000000000000]
    int Health;  // 0x02B4 (0x0004) [0x00000000001C0000]              (
                 // CPF_GlobalConfig | CPF_Component )
    int MaxWeldIntegrity;  // 0x02B8 (0x0004) [0x0000000000000000]
    int WeldIntegrity;  // 0x02BC (0x0004) [0x00000000001D0000]              (
                        // CPF_Travel | CPF_GlobalConfig | CPF_Component )
    int DemoWeldRequired;  // 0x02C0 (0x0004) [0x0000000000000000]
    int DemoWeld;  // 0x02C4 (0x0004) [0x00000000001E0000]              (
                   // CPF_EditConst | CPF_GlobalConfig | CPF_Component )
    class AKFPlayerController*
        ExplosionInstigatorController;  // 0x02C8 (0x0008) [0x0000000000000000]
    float MinWeldScalar;                // 0x02D0 (0x0004) [0x0000000000000000]
    float CombatWeldModifier;           // 0x02D4 (0x0004) [0x0000000000000000]
    float CombatLength;                 // 0x02D8 (0x0004) [0x0000000000000000]
    float LastHitTime;                  // 0x02DC (0x0004) [0x0000000000000000]
    float LastWeldTime;                 // 0x02E0 (0x0004) [0x0000000000000000]
    float LastUnweldTime;               // 0x02E4 (0x0004) [0x0000000000000000]
    class AKFPawn* WelderPawn;          // 0x02E8 (0x0008) [0x0000000000000000]
    class USkelControlSingleBone*
        MovementControl;            // 0x02F0 (0x0008) [0x0000000000000000]
    class UAnimNodeSlot* BashSlot;  // 0x02F8 (0x0008) [0x0000000000000000]
    float FrameSizeOfTwoDoors;      // 0x0300 (0x0004) [0x0000000000000000]
    class UParticleSystem*
        RepairFXTemplate;              // 0x0304 (0x0008) [0x0000000000000000]
    class UAkEvent* RepairSound;       // 0x030C (0x0008) [0x0000000000000000]
    class ANavigationPoint* MyMarker;  // 0x0314 (0x0008) [0x0000000000000000]
    float BrokenDoorImpulse;           // 0x031C (0x0004) [0x0000000000000000]
    float MaxAngularVelocity;          // 0x0320 (0x0004) [0x0000000000000000]
    TArray<class AKActor*>
        BrokenDoorPhysicsActors;  // 0x0324 (0x0010) [0x0000000000000000]
    class UAkBaseSoundObject*
        OpenSound;  // 0x0334 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        OpeningAmbientSound;  // 0x033C (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        OpenedSound;  // 0x0344 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        CloseSound;  // 0x034C (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        ClosingAmbientSound;  // 0x0354 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        ClosedSound;  // 0x035C (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        DestroyedSound;  // 0x0364 (0x0008) [0x0000000000000000]
    class UAkComponent*
        AmbientSoundComponent;   // 0x036C (0x0008) [0x0000000000000000]
    struct FVector SoundOrigin;  // 0x0374 (0x000C) [0x0000000000000000]
    struct FDestroyedEffectParams
        DamageEmitter;  // 0x0380 (0x002C) [0x0000000000000000]
    TArray<struct FDestroyedEffectParams>
        DestroyedEmitters;  // 0x03AC (0x0010) [0x0000000000000000]
    TArray<class UParticleSystemComponent*>
        BrokenDoorParticleEffects;       // 0x03BC (0x0010) [0x0000000000000000]
    class UTexture2D* WelderIcon;        // 0x03CC (0x0008) [0x0000000000000000]
    struct FVector WeldUILocation;       // 0x03D4 (0x000C) [0x0000000000000000]
    struct FVector VisualDoorLocation;   // 0x03E0 (0x000C) [0x0000000000000000]
    struct FString WeldIntegrityString;  // 0x03EC (0x0010) [0x0000000000000000]
    struct FString
        RepairProgressString;        // 0x03FC (0x0010) [0x0000000000000000]
    struct FString ExplosiveString;  // 0x040C (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3183];

        return pClassPointer;
    };

    void Reset();
    void GetAIDoorDamageScale();
    void GetQueuedDoorAICounts();
    void DrawRepairHUD();
    void DrawWeldHUD();
    void eventDrawDoorHUD();
    void NotifyAIDoorOpened();
    void WeldedShut();
    void eventNotifyPathChanged();
    void BeingUnwelded();
    void BeingWelded();
    void UnderAttack();
    void GetSoundEffectFromType();
    void PlayMovingSound();
    void ResetHingedDoor();
    void SpawnBrokenDoors();
    void DestroyHingedDoor();
    void SetRBCollideWithDeadPawn();
    void UpdateIntegrityMIC();
    void UpdateHealthScalars();
    void UpdateHealthMICs();
    void ResetDoor();
    void DestroyNonPhysicsDoor();
    void PlayExplosion();
    void PlayDestroyed();
    void SpawnParticlesFromEffectParam();
    void GetBashAnimName();
    void PlayTakeHitEffects();
    void IncrementHitCount();
    void AddExplosiveWeld();
    void Timer_ResetRepairFlag();
    void RepairDoor();
    void FastenDoor();
    void AllowDamageFrom();
    void DestroyDoor();
    void eventTakeDamage();
    void TryPushPawns();
    void GetPushDirection();
    void OnCloseFinish();
    void OnOpenFinish();
    void eventNotifyDoorMoveCompleted();
    void CloseDoor();
    void OpenSwingingDoor();
    void OpenDoor();
    void eventBump();
    void UseDoor();
    void OnToggle();
    void IsCompletelyOpen();
    void InitSkelControl();
    void InitializeDoorMIC();
    void eventPostBeginPlay();
    void eventPostInitAnimTree();
    void InitBrokenAttachment();
    void eventReplicatedEvent();
};

UClass* AKFDoorActor::pClassPointer = NULL;

// Class KFGame.KFDroppedPickup
// 0x0074 (0x02D4 - 0x0260)
class AKFDroppedPickup : public ADroppedPickup {
   public:
    struct FRigidBodyState
        RBState;  // 0x0260 (0x0040) [0x0000000000170000]              (
                  // CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
    float AngErrorAccumulator;          // 0x02A0 (0x0004) [0x0000000000000000]
    DWORD bCollisionSoundsEnabled : 1;  // 0x02A4 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bEnableStaticMeshRBPhys : 1;  // 0x02A4 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bIgnoreBlockingVolumes : 1;   // 0x02A4 (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    DWORD bUseLowHealthDelay : 1;       // 0x02A4 (0x0004) [0x0000000000000000]
                                        // [0x00000008]
    DWORD bUseAuthorityRBUpdate : 1;    // 0x02A4 (0x0004) [0x0000000000180000]
                                        // [0x00000010] ( CPF_Component )
    DWORD bEmptyPickup : 1;             // 0x02A4 (0x0004) [0x0000000000190011]
                             // [0x00000020] ( CPF_Edit | CPF_OptionalParm |
                             // CPF_Travel | CPF_Component )
    class UMeshComponent* MyMeshComp;  // 0x02A8 (0x0008) [0x0000000000000000]
    class UCylinderComponent*
        MyCylinderComp;  // 0x02B0 (0x0008) [0x0000000000000000]
    int SkinItemId;      // 0x02B8 (0x0004) [0x00000000001A0011]              (
                         // CPF_Edit | CPF_OptionalParm | CPF_EditConst |
                         // CPF_Component )
    float PostAuthorityChangeLifeSpan;  // 0x02BC (0x0004) [0x0000000000000000]
    float PickupDelay;                  // 0x02C0 (0x0004) [0x0000000000000000]
    struct FLinearColor
        EmptyPickupColor;  // 0x02C4 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3185];

        return pClassPointer;
    };

    void TryFadeOut();
    void DisableAuthorityRBSim();
    void Reset();
    void IsTouchBlockedBy();
    void ValidTouch();
    void NotifyHUDofWeapon();
    void eventDestroyed();
    void GiveTo();
    void ReenableCollisionSounds();
    void PlayCollisionSound();
    void eventLanded();
    void eventRigidBodyCollision();
    void AlignCollisionCylinder();
    void eventOnSleepRBPhysics();
    void AlignMeshToCylinder();
    void GetDisplayName();
    void SetEmptyMaterial();
    void SetPickupMesh();
};

UClass* AKFDroppedPickup::pClassPointer = NULL;

// Class KFGame.KFEmoteList
// 0x0018 (0x0078 - 0x0060)
class UKFEmoteList : public UObject {
   public:
    TArray<struct FEmote> Emotes;  // 0x0060 (0x0010) [0x0000000000000000]
    int EquippedEmoteId;           // 0x0070 (0x0004) [0x0000000000000000]
    DWORD
        bDebugEmotes : 1;  // 0x0074 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3187];

        return pClassPointer;
    };

    void GetEmoteArray();
    void RefreshCachedEmoteId();
    void SaveEquippedEmote();
    void GetEquippedEmoteId();
    void IsEmoteEquipped();
    void GetEmoteFromIndex();
    void GetEmoteIndex();
    void GetUnlockedEmote();
};

UClass* UKFEmoteList::pClassPointer = NULL;

// Class KFGame.KFExportSteamItemsCommandlet
// 0x0000 (0x00B4 - 0x00B4)
class UKFExportSteamItemsCommandlet : public UCommandlet {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3189];

        return pClassPointer;
    };

    void eventMain();
};

UClass* UKFExportSteamItemsCommandlet::pClassPointer = NULL;

// Class KFGame.KFGameEngine
// 0x00C4 (0x0C14 - 0x0B50)
class UKFGameEngine : public UGameEngine {
   public:
    int LastFocusedGameStateID;          // 0x0B50 (0x0004) [0x0000000000000000]
    class UFont* KFCanvasFont;           // 0x0B54 (0x0008) [0x0000000000000000]
    float KFFontScale;                   // 0x0B5C (0x0004) [0x0000000000000000]
    DWORD bReadingPlayfabStoreData : 1;  // 0x0B60 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bMusicVocalsEnabled : 1;       // 0x0B60 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bMinimalChatter : 1;           // 0x0B60 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD bShowWelderInInv : 1;          // 0x0B60 (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    DWORD bUseAltAimOnDual : 1;          // 0x0B60 (0x0004) [0x0000000000000000]
                                         // [0x00000010]
    DWORD bAntiMotionSickness : 1;       // 0x0B60 (0x0004) [0x0000000000000000]
                                         // [0x00000020]
    DWORD bShowCrossHair : 1;            // 0x0B60 (0x0004) [0x0000000000000000]
                                         // [0x00000040]
    DWORD bShowCrossHairConsole : 1;     // 0x0B60 (0x0004) [0x0000000000000000]
                                         // [0x00000080]
    DWORD bMuteOnLossOfFocus : 1;        // 0x0B60 (0x0004) [0x0000000000000000]
                                         // [0x00000100]
    DWORD bEnableAdvDebugLines : 1;      // 0x0B60 (0x0004) [0x0000000000000000]
                                         // [0x00000200]
    int SeasonalEventId;                 // 0x0B64 (0x0004) [0x0000000000000000]
    int WeeklyEventIndex;                // 0x0B68 (0x0004) [0x0000000000000000]
    float DefaultGammaMult;              // 0x0B6C (0x0004) [0x0000000000000000]
    float MusicVolumeMultiplier;         // 0x0B70 (0x0004) [0x0000000000000000]
    float SFxVolumeMultiplier;           // 0x0B74 (0x0004) [0x0000000000000000]
    float DialogVolumeMultiplier;        // 0x0B78 (0x0004) [0x0000000000000000]
    float MasterVolumeMultiplier;        // 0x0B7C (0x0004) [0x0000000000000000]
    float PadVolumeMultiplier;           // 0x0B80 (0x0004) [0x0000000000000000]
    float VOIPVolumeMultiplier;          // 0x0B84 (0x0004) [0x0000000000000000]
    float GammaMultiplier;               // 0x0B88 (0x0004) [0x0000000000000000]
    float FOVOptionsPercentageValue;     // 0x0B8C (0x0004) [0x0000000000000000]
    TArray<struct FOnlineStatsRow>
        CachedStatRows;  // 0x0B90 (0x0010) [0x0000000000000000]
    struct FScriptDelegate
        OnHandshakeComplete;           // 0x0BA0 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x0BA4 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    unsigned char LastConnectionError;  // 0x0BB0 (0x0001) [0x0000000000000000]
    unsigned char LocalLoginStatus;     // 0x0BB1 (0x0001) [0x0000000000000000]
    struct FString
        ConsoleGameSessionGuid;  // 0x0BB4 (0x0010) [0x0000000000000000]
    class UOnlineGameSettings*
        GameSettingsForPendingInvite;  // 0x0BC4 (0x0008) [0x0000000000000000]
    struct FString ReturnToIISConnectionErrorTitle;    // 0x0BCC (0x0010)
                                                       // [0x0000000000000000]
    struct FString ReturnToIISConnectionErrorMessage;  // 0x0BDC (0x0010)
                                                       // [0x0000000000000000]
    TArray<struct FName> AILogFilter;   // 0x0BEC (0x0010) [0x0000000000000000]
    class AKFDebugLines* KFDebugLines;  // 0x0BFC (0x0008) [0x0000000000000000]
    struct FScriptDelegate
        __HandshakeCompleteCallback__Delegate;  // 0x0C04 (0x0010)
                                                // [0x0000000000000000]
    unsigned char UnknownData01[0x4];  // 0x0C08 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3191];

        return pClassPointer;
    };

    void SetCrosshairEnabled();
    void IsCrosshairEnabled();
    void GetKFFontScale();
    void GetKFCanvasFont();
    void FastTrace_PhysX();
    void KillPendingServerConnection();
    void UnlockServer();
    void IsLockedServer();
    void CancelPendingLevel();
    void eventCheckHandshakeComplete();
    void HandshakeCompleteCallback();
    void SetLastConnectionError();
    void GetConnectionErrorForMessage();
    void SetGamma();
    void IsFullScreenMoviePlaying();
    void PlayFullScreenMovie();
    void GetVoIPVolumeRange();
    void SetVoIPRecieveVolume();
    void SetWWisePADVolume();
    void SetWWiseMasterVolume();
    void SetWWiseVoiceVolume();
    void SetWWiseMusicVolume();
    void SetWWiseSFXVolume();
    void InitGamma();
    void InitAudioOptions();
    void GetWeeklyEventIndex();
    void GetSeasonalEventID();
    void ClearOnlineDelegates();
    void RegisterOnlineDelegates();
    void PerformLogout();
    void KickBackToIIS();
    void OnLoginStatusChanged();
    void OnLoginChange();
    void OnConnectionStatusChanged();
    void OnLinkStatusChange();
    void OnPlayfabInventoryReadComplete();
    void OnStoreDataRead();
    void OnReadInventoryItemsComplete();
    void OnReadAdditionalProductDetailsComplete();
    void OnReadAvailableProductsComplete();
    void OnPlayfabStoreReadComplete();
    void ReadPFStoreData();
    void IsFreeConsolePlayOver();
    void IsSoloPlayDisabled();
    void ApplyTweaks();
    void RefreshOnlineGameData();
    void RefreshEventContent();
    void InitEventContent();
    void GetPlatform();
    void GetAppID();
    void GetKFGameVersion();
    void GetGameVersion();
    void GetDebugLines();
    void GetClassCountAndSize();
    void CheckNoRandomStart();
    void CheckNoMusic();
    void CheckNoAutoStart();
    void CheckSkipGammaCheck();
    void CheckSkipLobby();
};

UClass* UKFGameEngine::pClassPointer = NULL;

// Class KFGame.KFGameInfo
// 0x026C (0x0714 - 0x04A8)
class AKFGameInfo : public AFrameworkGame {
   public:
    int POINTS_FOR_BOSS_KILL;        // 0x04A8 (0x0004) [0x0000000000000000]
    int POINTS_FOR_WAVE_COMPLETION;  // 0x04AC (0x0004) [0x0000000000000000]
    int POINTS_PENALTY_FOR_DEATH;    // 0x04B0 (0x0004) [0x0000000000000000]
    class AKFGameReplicationInfo*
        MyKFGRI;  // 0x04B4 (0x0008) [0x0000000000000000]
    class UClass*
        CustomizationPawnClass;  // 0x04BC (0x0008) [0x0000000000000000]
    float FriendlyFireScale;     // 0x04C4 (0x0004) [0x0000000000000000]
    class AKFTeamInfo_Human*
        Teams[0x2];                    // 0x04C8 (0x0010) [0x0000000000000000]
    DWORD bOnePlayerAtStart : 1;       // 0x04D8 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bStartFinalCount : 1;        // 0x04D8 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD bWaitForNetPlayers : 1;      // 0x04D8 (0x0004) [0x0000000000000000]
                                       // [0x00000004]
    DWORD bDisableKickVote : 1;        // 0x04D8 (0x0004) [0x0000000000000000]
                                       // [0x00000008]
    DWORD bDisablePublicTextChat : 1;  // 0x04D8 (0x0004) [0x0000000000000000]
                                       // [0x00000010]
    DWORD
        bDisableVOIP : 1;  // 0x04D8 (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bPartitionSpectators : 1;   // 0x04D8 (0x0004) [0x0000000000000000]
                                      // [0x00000040]
    DWORD bDisablePickups : 1;        // 0x04D8 (0x0004) [0x0000000000000000]
                                      // [0x00000080]
    DWORD bDisableMapVote : 1;        // 0x04D8 (0x0004) [0x0000000000000000]
                                      // [0x00000100]
    DWORD bEnableMapObjectives : 1;   // 0x04D8 (0x0004) [0x0000000000000000]
                                      // [0x00000200]
    DWORD bDisableTeamCollision : 1;  // 0x04D8 (0x0004) [0x0000000000000000]
                                      // [0x00000400]
    DWORD bEnableDeadToVOIP : 1;      // 0x04D8 (0x0004) [0x0000000000000000]
                                      // [0x00000800]
    DWORD bDisablePublicVOIPChannel : 1;  // 0x04D8 (0x0004)
                                          // [0x0000000000000000] [0x00001000]
    DWORD bCanPerkAlwaysChange : 1;  // 0x04D8 (0x0004) [0x0000000000000000]
                                     // [0x00002000]
    DWORD bZedTimeBlendingOut : 1;   // 0x04D8 (0x0004) [0x0000000000000000]
                                     // [0x00004000]
    DWORD bEnableGameAnalytics : 1;  // 0x04D8 (0x0004) [0x0000000000000000]
                                     // [0x00008000]
    DWORD bRecordGameStatsFile : 1;  // 0x04D8 (0x0004) [0x0000000000000000]
                                     // [0x00010000]
    DWORD bUseMapList : 1;  // 0x04D8 (0x0004) [0x0000000000000000] [0x00020000]
    DWORD bLogScoring : 1;  // 0x04D8 (0x0004) [0x0000000000000000] [0x00040000]
    DWORD bLogAIDefaults : 1;    // 0x04D8 (0x0004) [0x0000000000000000]
                                 // [0x00080000]
    DWORD bLogReservations : 1;  // 0x04D8 (0x0004) [0x0000000000000000]
                                 // [0x00100000]
    DWORD
        bLogAnalytics : 1;  // 0x04D8 (0x0004) [0x0000000000000000] [0x00200000]
    DWORD bLogAICount : 1;  // 0x04D8 (0x0004) [0x0000000000000000] [0x00400000]
    DWORD
        bIsCustomGame : 1;  // 0x04D8 (0x0004) [0x0000000000000000] [0x00800000]
    DWORD bIsUnrankedGame : 1;  // 0x04D8 (0x0004) [0x0000000000000000]
                                // [0x01000000]
    DWORD bEnableServerVersionCheck : 1;  // 0x04D8 (0x0004)
                                          // [0x0000000000000000] [0x02000000]
    DWORD
        bIsVersusGame : 1;  // 0x04D8 (0x0004) [0x0000000000000000] [0x04000000]
    DWORD bNVAlwaysDramatic : 1;      // 0x04D8 (0x0004) [0x0000000000000000]
                                      // [0x08000000]
    DWORD bNVBlockDramatic : 1;       // 0x04D8 (0x0004) [0x0000000000000000]
                                      // [0x10000000]
    DWORD bNVAlwaysHeadshot : 1;      // 0x04D8 (0x0004) [0x0000000000000000]
                                      // [0x20000000]
    DWORD bNVDebugDamage : 1;         // 0x04D8 (0x0004) [0x0000000000000000]
                                      // [0x40000000]
    DWORD bLogGroupTeamBalance : 1;   // 0x04D8 (0x0004) [0x0000000000000000]
                                      // [0x80000000]
    int HumanDeaths;                  // 0x04DC (0x0004) [0x0000000000000000]
    class UClass* KFGFxManagerClass;  // 0x04E0 (0x0008) [0x0000000000000000]
    int GameLength;                   // 0x04E8 (0x0004) [0x0000000000000000]
    int MinNetPlayers;                // 0x04EC (0x0004) [0x0000000000000000]
    int ReadyUpDelay;                 // 0x04F0 (0x0004) [0x0000000000000000]
    int GameStartDelay;               // 0x04F4 (0x0004) [0x0000000000000000]
    int EndOfGameDelay;               // 0x04F8 (0x0004) [0x0000000000000000]
    TArray<struct FsGameMode>
        GameModes;                  // 0x04FC (0x0010) [0x0000000000000000]
    float KickVotePercentage;       // 0x050C (0x0004) [0x0000000000000000]
    float TimeBetweenFailedVotes;   // 0x0510 (0x0004) [0x0000000000000000]
    float MapVotePercentage;        // 0x0514 (0x0004) [0x0000000000000000]
    float MapVoteDuration;          // 0x0518 (0x0004) [0x0000000000000000]
    struct FString ServerMOTD;      // 0x051C (0x0010) [0x0000000000000000]
    struct FColor ServerMOTDColor;  // 0x052C (0x0004) [0x0000000000000000]
    struct FString BannerLink;      // 0x0530 (0x0010) [0x0000000000000000]
    struct FString WebsiteLink;     // 0x0540 (0x0010) [0x0000000000000000]
    struct FColor WebLinkColor;     // 0x0550 (0x0004) [0x0000000000000000]
    struct FString ClanMotto;       // 0x0554 (0x0010) [0x0000000000000000]
    struct FColor ClanMottoColor;   // 0x0564 (0x0004) [0x0000000000000000]
    float ServerExpirationForKillWhenEmpty;  // 0x0568 (0x0004)
                                             // [0x0000000000000000]
    int ReconnectRespawnTime;  // 0x056C (0x0004) [0x0000000000000000]
    float XPMultiplier;        // 0x0570 (0x0004) [0x0000000000000000]
    class UKFGameDifficultyInfo*
        DifficultyInfo;                 // 0x0574 (0x0008) [0x0000000000000000]
    class UClass* DifficultyInfoClass;  // 0x057C (0x0008) [0x0000000000000000]
    class UClass*
        DifficultyInfoConsoleClass;  // 0x0584 (0x0008) [0x0000000000000000]
    TArray<class AKFTraderTrigger*>
        TraderList;  // 0x058C (0x0010) [0x0000000000000000]
    class AKFTraderTrigger*
        ScriptedTrader;  // 0x059C (0x0008) [0x0000000000000000]
    TArray<class AKFPickupFactory*>
        ItemPickups;  // 0x05A4 (0x0010) [0x0000000000000000]
    TArray<class AKFPickupFactory*>
        AmmoPickups;  // 0x05B4 (0x0010) [0x0000000000000000]
    TArray<class AKFPickupFactory*>
        AllPickupFactories;          // 0x05C4 (0x0010) [0x0000000000000000]
    unsigned char NumWeaponPickups;  // 0x05D4 (0x0001) [0x0000000000000000]
    unsigned char NumAmmoPickups;    // 0x05D5 (0x0001) [0x0000000000000000]
    unsigned char
        ForcedNumLivingPlayers;  // 0x05D6 (0x0001) [0x0000000000000000]
    TArray<float>
        DeathPenaltyModifiers;          // 0x05D8 (0x0010) [0x0000000000000000]
    TArray<float> MaxRespawnDosh;       // 0x05E8 (0x0010) [0x0000000000000000]
    int MaxGameDifficulty;              // 0x05F8 (0x0004) [0x0000000000000000]
    int MinGameDifficulty;              // 0x05FC (0x0004) [0x0000000000000000]
    TArray<float> GameLengthDoshScale;  // 0x0600 (0x0010) [0x0000000000000000]
    TArray<class UClass*>
        SpawnManagerClasses;  // 0x0610 (0x0010) [0x0000000000000000]
    class UKFGameConductor*
        GameConductor;                 // 0x0620 (0x0008) [0x0000000000000000]
    class UClass* GameConductorClass;  // 0x0628 (0x0008) [0x0000000000000000]
    class UKFAIDirector* AIDirector;   // 0x0630 (0x0008) [0x0000000000000000]
    int AIAliveCount;                  // 0x0638 (0x0004) [0x0000000000000000]
    int NumAISpawnsQueued;             // 0x063C (0x0004) [0x0000000000000000]
    int NumAlwaysRelevantZeds;         // 0x0640 (0x0004) [0x0000000000000000]
    class UKFAISpawnManager*
        SpawnManager;                   // 0x0644 (0x0008) [0x0000000000000000]
    TArray<class UClass*> AIClassList;  // 0x064C (0x0010) [0x0000000000000000]
    TArray<class UClass*>
        AIBossClassList;        // 0x065C (0x0010) [0x0000000000000000]
    float ZedTimeSlomoScale;    // 0x066C (0x0004) [0x0000000000000000]
    float ZedTimeBlendOutTime;  // 0x0670 (0x0004) [0x0000000000000000]
    float ZedTimeRemaining;     // 0x0674 (0x0004) [0x0000000000000000]
    int ZedTimeExtensionsUsed;  // 0x0678 (0x0004) [0x0000000000000000]
    float LastZedTimeEvent;     // 0x067C (0x0004) [0x0000000000000000]
    class UClass*
        GameplayEventsWriterClass;  // 0x0680 (0x0008) [0x0000000000000000]
    class UKFGameplayEventsWriter*
        GameplayEventsWriter;  // 0x0688 (0x0008) [0x0000000000000000]
    TArray<struct FGameMapCycle>
        GameMapCycles;                   // 0x0690 (0x0010) [0x0000000000000000]
    int ActiveMapCycle;                  // 0x06A0 (0x0004) [0x0000000000000000]
    int MapCycleIndex;                   // 0x06A4 (0x0004) [0x0000000000000000]
    TArray<struct FString> InValidMaps;  // 0x06A8 (0x0010) [0x0000000000000000]
    class AKFDialogManager*
        DialogManager;                 // 0x06B8 (0x0008) [0x0000000000000000]
    class UClass* DialogManagerClass;  // 0x06C0 (0x0008) [0x0000000000000000]
    class UClass*
        TraderVoiceGroupClass;  // 0x06C8 (0x0008) [0x0000000000000000]
    float ActionMusicDelay;     // 0x06D0 (0x0004) [0x0000000000000000]
    TArray<class UKFMusicTrackInfo*>
        ForcedMusicTracks;  // 0x06D4 (0x0010) [0x0000000000000000]
    TArray<struct FKFPlayerReservation>
        PlayerReservations;  // 0x06E4 (0x0010) [0x0000000000000000]
    int ReservationTimeout;  // 0x06F4 (0x0004) [0x0000000000000000]
    TArray<struct FPlayerGroupStruct>
        PlayerGroups;             // 0x06F8 (0x0010) [0x0000000000000000]
    float LastUpToDateCheckTime;  // 0x0708 (0x0004) [0x0000000000000000]
    class UKFSteamWebUpToDateCheck*
        UpToDateChecker;  // 0x070C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3193];

        return pClassPointer;
    };

    void OnAIChangeEnemy();
    void CheckNextMap();
    void UpdateCurrentMapVoteTime();
    void IsPlayerReady();
    void AnyPlayerReady();
    void MajorityPlayersReady();
    void CheckAllPlayersReady();
    void ShouldStartMatch();
    void StartMatch();
    void StripPasswordFromLastURL();
    void CheckServerUnlock();
    void LobbyCountdownComplete();
    void ResetCountDown();
    void SetCountdown();
    void LogPlayersKillCount();
    void LogPlayersDosh();
    void LogPlayersInventory();
    void AllowAnalyticsLogging();
    void AllowBalanceLogging();
    void GetAvailableReservations();
    void eventSeatPlayer();
    void eventConfirmReservation();
    void ReadReservations();
    void TimeReservations();
    void AddPlayerReservations();
    void AddPlayerMatchmakingGroup();
    void StripFromMatchmakingGroups();
    void RemoveDuplicates();
    void UniqueReservationAdd();
    void eventSendServerMaintenanceMessage();
    void eventLogin();
    void eventMakeReservations();
    void AtCapacity();
    void UniqueIdAdd();
    void ReservationPresent();
    void UniqueIdPresent();
    void FindInactivePRI();
    void AddInactivePRI();
    void UnregisterPlayer();
    void MaintenanceRestart();
    void GetCurrentMapCycleIndex();
    void GetNextMap();
    void ForceMatriarchMusicTrack();
    void ForcePatriarchMusicTrack();
    void ForceHansMusicTrack();
    void ForceCreditsMusicTrack();
    void ForceMenuMusicTrack();
    void ShouldPlayMusicAtStart();
    void ShouldPlayActionMusicTrack();
    void GetGameIntensityForMusic();
    void NotifyNavigationChanged();
    void NotifyHeadshotKill();
    void CheckZedTimeOnKill();
    void SetZedTimeDilation();
    void IsZedTimeActive();
    void TickZedTime();
    void Tick();
    void DramaticEvent();
    void AddPlayerXP();
    void DistributeMoneyAndXP();
    void GetNumHumanTeamPlayers();
    void GetNumPlayers();
    void ModifyAIDoshValueForPlayerCount();
    void GetAdjustedAIDoshValue();
    void CheckForBerserkerSmallRadiusKill();
    void NotifyIgnoredScream();
    void NotifyRally();
    void ScoreMonsterKill();
    void ScoreKill();
    void PassiveHeal();
    void ScoreDamage();
    void GetBossKillScore();
    void BossDied();
    void GetAdjustedTeamDeathPenalty();
    void GetAdjustedDeathPenalty();
    void BroadcastDeathMessage();
    void GetLastHitByDamageType();
    void Killed();
    void ReduceDamage();
    void CanSpectate();
    void ChangeTeam();
    void PickTeam();
    void CreateTeam();
    void SetTeam();
    void SetMonsterDefaults();
    void AdjustStartingGrenadeCount();
    void AllowPrimaryWeapon();
    void GetGameInfoSpawnRateMod();
    void eventPrePossessAdjustments();
    void GetBossAISpawnType();
    void GetAISpawnType();
    void GetNumAlwaysRelevantZeds();
    void GetTotalWaveCountScale();
    void IsWaveActive();
    void ModifySprintSpeed();
    void ModifyGroundSpeed();
    void SetPlayerDefaults();
    void IsInitialSpawnPointSelection();
    void CheckSpawnProximity();
    void FindCustomizationStart();
    void ShouldSpawnAtStartSpot();
    void RatePlayerStart();
    void RestartPlayer();
    void StartHumans();
    void SpawnCustomizationPawn();
    void SpawnDefaultPawnFor();
    void CustomizationPointsInitialized();
    void ActivateNextPickup();
    void DetermineNextPickup();
    void EnableNewPickup();
    void ResetPickups();
    void ResetAllPickups();
    void InitAllPickups();
    void SetupNextTrader();
    void InitTraderList();
    void AllowCheats();
    void InitGRIVariables();
    void InitGameConductor();
    void eventInitAIDirector();
    void CheckPopulation();
    void ProcessServerTravel();
    void Logout();
    void eventPostLogin();
    void GametypeChecksWaveLength();
    void GametypeChecksDifficulty();
    void eventPreLogin();
    void ReplicateWelcomeScreen();
    void InitGameplayEventWriter();
    void eventPostBeginPlay();
    void eventPreBeginPlay();
    void CheckForCustomSettings();
    void GetFloatOption();
    void CreateDifficultyInfo();
    void eventInitGame();
    void StaticSetNeedsRestart();
    void SetNeedsReload();
    void DisableServerTakeover();
    void SetNeedsRestart();
    void GetFullGameModePath();
    void GetGameModeNum();
    void GetFriendlyNameForCurrentGameMode();
    void IsGameModeSoloPlayAllowed();
    void GetLocalizeIDFromFriendlyName();
    void GetGameModeClassFromNum();
    void GetGameModeNumFromClass();
    void GetGameModeFriendlyNameFromClass();
    void GetGameModeFriendlyNameFromNum();
    void PreloadContentClasses();
    void StripPlayOnPrefix();
    void eventSetGameType();
    void IsUnrankedGame();
    void SetGameUnranked();
    void MapCycleNeedsInit();
    void IsMapAllowedInCycle();
    void GetAIDirector();
    void RefreshMonsterAliveCount();
    void ForceLivingPlayerCount();
    void GetLivingPlayerCount();
    void GetMonsterAliveCount();
};

UClass* AKFGameInfo::pClassPointer = NULL;

// Class KFGame.KFGamepadLayoutManager
// 0x0560 (0x05C0 - 0x0060)
class UKFGamepadLayoutManager : public UObject {
   public:
    struct FGamepadLayout
        GamepadLayouts[0x4];  // 0x0060 (0x04C0) [0x0000000000000000]
    struct FName
        GamepadButtonNames[0x14];  // 0x0520 (0x00A0) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3195];

        return pClassPointer;
    };

    void GetNumLayouts();
    void GetLayoutName();
    void GetGamepadButtonNames();
    void GetGamepadLayout();
};

UClass* UKFGamepadLayoutManager::pClassPointer = NULL;

// Class KFGame.KFHTTPImageDownloader
// 0x0048 (0x00A8 - 0x0060)
class UKFHTTPImageDownloader : public UObject {
   public:
    struct FPointer
        VfTable_FTickableObject;  // 0x0060 (0x0008) [0x0000000000000000]
    struct FScriptDelegate
        DownloadCompleteDelegate;      // 0x0068 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x006C (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FPointer HttpDownloader;    // 0x0078 (0x0008) [0x0000000000000000]
    class UTexture2D* TheTexture;      // 0x0080 (0x0008) [0x0000000000000000]
    struct FString ImageURL;           // 0x0088 (0x0010) [0x0000000000000000]
    struct FScriptDelegate
        __OnDownloadComplete__Delegate;  // 0x0098 (0x0010) [0x0000000000000000]
    unsigned char UnknownData01[0x4];  // 0x009C (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3197];

        return pClassPointer;
    };

    void DownloadImageFromURL();
    void OnDownloadComplete();
};

UClass* UKFHTTPImageDownloader::pClassPointer = NULL;

// Class KFGame.KFInventoryManager
// 0x0094 (0x0304 - 0x0270)
class AKFInventoryManager : public AInventoryManager {
   public:
    class AWeapon*
        PreviousEquippedWeapons[0x2];  // 0x0270 (0x0010) [0x0000000000000000]
    class AKFWeap_HealerBase*
        HealerWeapon;  // 0x0280 (0x0008) [0x0000000000160019]              (
                       // CPF_Edit | CPF_ExportObject | CPF_OptionalParm |
                       // CPF_EditConst | CPF_GlobalConfig )
    struct FString FullHealthMsg;  // 0x0288 (0x0010) [0x0000000000000000]
    unsigned char
        GrenadeCount;  // 0x0298 (0x0001) [0x0000000000170000]              (
                       // CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
    unsigned char CurrentCarryBlocks;  // 0x0299 (0x0001) [0x0000000000180000]
                                       // ( CPF_Component )
    unsigned char MaxCarryBlocks;      // 0x029A (0x0001) [0x0000000000190000] (
                                   // CPF_Travel | CPF_Component )
    unsigned char SelectedGroup;        // 0x029B (0x0001) [0x0000000000000000]
    unsigned char SelectedIndex;        // 0x029C (0x0001) [0x0000000000000000]
    DWORD bInfiniteWeight : 1;          // 0x02A0 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bSuppressPickupMessages : 1;  // 0x02A0 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bServerTraderMenuOpen : 1;    // 0x02A0 (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    DWORD bAutoswitchWeapon : 1;        // 0x02A0 (0x0004) [0x0000000000000000]
                                        // [0x00000008]
    DWORD
        bLogInventory : 1;  // 0x02A0 (0x0004) [0x0000000000000000] [0x00000010]
    class UAkEvent* AmmoPickupSound;   // 0x02A4 (0x0008) [0x0000000000000000]
    class UAkEvent* ItemPickupSound;   // 0x02AC (0x0008) [0x0000000000000000]
    class UAkEvent* ArmorPickupSound;  // 0x02B4 (0x0008) [0x0000000000000000]
    class UAkEvent*
        SwitchFireModeEvent;      // 0x02BC (0x0008) [0x0000000000000000]
    float LastCreatedWeaponTime;  // 0x02C4 (0x0004) [0x0000000000000000]
    TArray<class UGFxMoviePlayer*>
        OpticsUIMovies;  // 0x02C8 (0x0010) [0x0000000000000000]
    float
        StartedWithWeaponPriceModifier;  // 0x02D8 (0x0004) [0x0000000000000000]
    float SellPriceModifier;             // 0x02DC (0x0004) [0x0000000000000000]
    float OffPerkCostScale;  // 0x02E0 (0x0004) [0x00000000001A0000] (
                             // CPF_EditConst | CPF_Component )
    TArray<struct FTransactionItem>
        TransactionItems;            // 0x02E4 (0x0010) [0x0000000000000000]
    int SelectedGroupIndicies[0x4];  // 0x02F4 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3199];

        return pClassPointer;
    };

    void eventDiscardInventory();
    void GetIsOwned();
    void GetDisplayedBlocksRequiredFor();
    void GetAdjustedSellPriceFor();
    void GetAdjustedBuyPriceFor();
    void GetTraderItemFromWeaponLists();
    void ProcessArmorDosh();
    void ProcessGrenadeDosh();
    void ProcessAmmoDosh();
    void ProcessWeaponDosh();
    void GetWeaponFromClass();
    void GetTransactionItemIndex();
    void ServerRemoveTransactionItem();
    void RemoveTransactionItem();
    void ServerSellWeapon();
    void ServerAddTransactionItem();
    void AddTransactionItem();
    void AddCurrentCarryBlocks();
    void ServerBuyWeapon();
    void ServerBuyGrenade();
    void ServerBuyArmor();
    void eventServerAddTransactionAmmo();
    void ServerBuyAmmo();
    void BuyAmmo();
    void ServerCloseTraderMenu();
    void CombineWeaponsOnPickup();
    void GetEncumbranceSpeedMod();
    void PlayGiveInventorySound();
    void AddArmorFromPickup();
    void GiveWeaponsAmmo();
    void GiveWeaponAmmo();
    void AddAmmoFromPickup();
    void IsTransactionWeapon();
    void CheckForExcessRemoval();
    void CanCarryWeapon();
    void ServerThrowMoney();
    void ThrowMoney();
    void eventHasGrenadeAmmo();
    void ConsumeGrenades();
    void AddGrenades();
    void GiveInitialGrenadeCount();
    void QuickWeld();
    void AttemptQuickHeal();
    void SelectCurrentWeapon();
    void UpdateHUD();
    void ShowAllHUDGroups();
    void eventShowOnlyHUDGroup();
    void ClientWeaponSet();
    void IsUsingIronsightHoldKey();
    void SetCurrentWeapon();
    void ServerSetCurrentWeapon();
    void HighlightWeapon();
    void HighlightNextWeapon();
    void ShouldSkipCycleWeapon();
    void InternalNextWeapon();
    void InternalPrevWeapon();
    void GamepadNextWeapon();
    void NextWeapon();
    void PrevWeapon();
    void HighlightPrevWeapon();
    void GetNextGroupedWeapon();
    void GetBestPerkWeaponWithAmmo();
    void SwitchToLastWeapon();
    void ClassIsInInventory();
    void ItemIsInInventory();
    void ClientRemoveFromInventory();
    void ServerRemoveFromInventory();
    void RemoveFromInventory();
    void CreateInventory();
    void CreateInventoryArchetype();
    void AddInventory();
    void InitFOV();
    void RemoveOpticsUIMovie();
    void GetOpticsUIMovie();
    void GetPrimaryAmmoPercentage();
    void DumpInventory();
    void AddWeaponToGroup();
};

UClass* AKFInventoryManager::pClassPointer = NULL;

// Class KFGame.KFMapInfo
// 0x01F4 (0x0258 - 0x0064)
class UKFMapInfo : public UMapInfo {
   public:
    float WaveSpawnPeriod;  // 0x0064 (0x0004) [0x0000000000000000]
    TArray<class AKFDestructibleActor*>
        DestructibleActors;  // 0x0068 (0x0010) [0x0000000000000000]
    TArray<class UKFMusicTrackInfo*>
        ActionMusicTracks;  // 0x0078 (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        ShuffledActionMusicTrackIdxes;  // 0x0088 (0x0010) [0x0000000000000000]
    unsigned char CurrShuffledActionMusicTrackIdx;   // 0x0098 (0x0001)
                                                     // [0x0000000000000000]
    unsigned char CurrShuffledAmbientMusicTrackIdx;  // 0x0099 (0x0001)
                                                     // [0x0000000000000000]
    unsigned char CollectibleType;  // 0x009A (0x0001) [0x0000000000000000]
    unsigned char SubGameType;      // 0x009B (0x0001) [0x0000000000000000]
    TArray<class UKFMusicTrackInfo*>
        AmbientMusicTracks;  // 0x009C (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        ShuffledAmbientMusicTrackIdxes;  // 0x00AC (0x0010) [0x0000000000000000]
    int CollectiblesToFind;              // 0x00BC (0x0004) [0x0000000000000000]
    int CollectiblesFound;               // 0x00C0 (0x0004) [0x0000000000000000]
    DWORD bUsePresetObjectives : 1;      // 0x00C4 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bUseRandomObjectives : 1;      // 0x00C4 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    struct FPresetWavePairs
        PresetWaveObjectives;  // 0x00C8 (0x0180) [0x0000000000000000]
    TArray<class UKFInterface_MapObjective*>
        RandomWaveObjectives;  // 0x0248 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3201];

        return pClassPointer;
    };

    void OnCollectibleFound();
    void StaticGetRandomTrack();
    void ShuffleTracks();
    void GetRandomTrack();
    void GetNextMusicTrackByGameIntensity();
    void StaticGetNextMusicTrackStruct();
    void GetNextMusicTrackStruct();
};

UClass* UKFMapInfo::pClassPointer = NULL;

// Class KFGame.KFMapTravelData
// 0x0044 (0x00A4 - 0x0060)
class UKFMapTravelData : public UObject {
   public:
    struct FString LastGameMap;  // 0x0060 (0x0010) [0x0000000000000000]
    float LastTravelTime;        // 0x0070 (0x0004) [0x0000000000000000]
    TArray<struct FsPersistentPlayerData>
        PlayerData;               // 0x0074 (0x0010) [0x0000000000000000]
    TArray<int> TeamScores;       // 0x0084 (0x0010) [0x0000000000000000]
    int RoundCount;               // 0x0094 (0x0004) [0x0000000000000000]
    int SurvivorDeaths;           // 0x0098 (0x0004) [0x0000000000000000]
    int BossDamageDone;           // 0x009C (0x0004) [0x0000000000000000]
    int BossSurvivorDamageTaken;  // 0x00A0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3203];

        return pClassPointer;
    };

    void ClearAllMapTravelData();
    void GetBossSurvivorDamageTaken();
    void SetBossSurvivorDamageTaken();
    void GetBossDamageDone();
    void SetBossDamageDone();
    void GetSurvivorDeaths();
    void SetSurvivorDeaths();
    void GetRoundCount();
    void SetRoundCount();
    void GetTeamScore();
    void SetTeamScore();
    void ClearPlayerData();
    void GetPlayer();
    void RemovePlayer();
    void AddPlayer();
    void GetLastTravelTime();
    void SetLastTravelTime();
    void GetLastGameMap();
    void SetLastGameMap();
};

UClass* UKFMapTravelData::pClassPointer = NULL;

// Class KFGame.KFMeleeHelperBase
// 0x0060 (0x00C0 - 0x0060)
class UKFMeleeHelperBase : public UObject {
   public:
    float MaxHitRange;       // 0x0060 (0x0004) [0x0000000000000000]
    float DefaultFOVCosine;  // 0x0064 (0x0004) [0x0000000000000000]
    TArray<struct FMeleeHitboxInfo>
        HitboxChain;                  // 0x0068 (0x0010) [0x0000000000000000]
    struct FVector HitboxExtent;      // 0x0078 (0x000C) [0x0000000000000000]
    float HitboxSpacing;              // 0x0084 (0x0004) [0x0000000000000000]
    struct FName HitboxBoneName;      // 0x0088 (0x0008) [0x0000000000000000]
    unsigned char HitboxBoneAxis;     // 0x0090 (0x0001) [0x0000000000000000]
    DWORD bHitboxCollideComplex : 1;  // 0x0094 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bOnlyUseHitboxExtentAtHead : 1;  // 0x0094 (0x0004)
                                           // [0x0000000000000000] [0x00000002]
    DWORD bDoHitboxObstructionTrace : 1;   // 0x0094 (0x0004)
                                           // [0x0000000000000000] [0x00000004]
    DWORD bHitboxPawnsOnly : 1;       // 0x0094 (0x0004) [0x0000000000000000]
                                      // [0x00000008]
    DWORD bAllowMeleeToFracture : 1;  // 0x0094 (0x0004) [0x0000000000000000]
                                      // [0x00000010]
    DWORD bHasAlreadyHit : 1;         // 0x0094 (0x0004) [0x0000000000000000]
                                      // [0x00000020]
    DWORD bLogMelee : 1;  // 0x0094 (0x0004) [0x0000000000000000] [0x00000040]
    DWORD bDebugShowCollision : 1;  // 0x0094 (0x0004) [0x0000000000000000]
                                    // [0x00000080]
    TArray<class AActor*>
        ActorsCollidedWith;  // 0x0098 (0x0010) [0x0000000000000000]
    class UCameraShake*
        MeleeVictimCamShake;  // 0x00A8 (0x0008) [0x0000000000000000]
    class UCameraShake*
        MeleeImpactCamShake;  // 0x00B0 (0x0008) [0x0000000000000000]
    class UKFImpactEffectInfo*
        WorldImpactEffects;  // 0x00B8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3205];

        return pClassPointer;
    };

    void MeleeFractureMeshImpact();
    void PlayMeleeHitEffects();
    void eventInitWorldTraceForHitboxCollision();
    void eventProcessHitboxCollision();
    void HasCollidedWithHitbox();
    void SetHitboxChain();
    void CreateHitboxChain();
    void BeginHitboxCollisionDetection();
    void TickHitboxCollisionDetection();
    void TraceMeleeAttackHitZones();
    void GetMeleeHitTestLocation();
    void RateMeleeVictim();
    void FindVictimByFOV();
    void TraceNoPawns();
    void DoWeaponInstantTrace();
    void MeleeAttackDestructibles();
    void GetMeleeRange();
    void SetMeleeRange();
    void GetMeleeAimRotation();
    void GetMeleeStartTraceLocation();
};

UClass* UKFMeleeHelperBase::pClassPointer = NULL;

// Class KFGame.KFMeleeHelperAI
// 0x0048 (0x0108 - 0x00C0)
class UKFMeleeHelperAI : public UKFMeleeHelperBase {
   public:
    float BaseDamage;            // 0x00C0 (0x0004) [0x0000000000000000]
    class UClass* MyDamageType;  // 0x00C4 (0x0008) [0x0000000000000000]
    float MomentumTransfer;      // 0x00CC (0x0004) [0x0000000000000000]
    TArray<struct FSwipeHitActorData>
        SwipedActors;                  // 0x00D0 (0x0010) [0x0000000000000000]
    DWORD bTrackSwipeHits : 1;         // 0x00E0 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    float PlayerDoorDamageMultiplier;  // 0x00E4 (0x0004) [0x0000000000000000]
    float PlayerControlledFOV;         // 0x00E8 (0x0004) [0x0000000000000000]
    float MeleeImpactCamScale;         // 0x00EC (0x0004) [0x0000000000000000]
    TArray<struct FDelayedMeleeInfo>
        PendingDamage;            // 0x00F0 (0x0010) [0x0000000000000000]
    int MaxPingCompensation;      // 0x0100 (0x0004) [0x0000000000000000]
    float PingCompensationScale;  // 0x0104 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3207];

        return pClassPointer;
    };

    void eventApplyDelayedPawnDamage();
    void ResolvePawnMeleeDamage();
    void ProcessSwipeHit();
    void GetSwipeVector();
    void DoSwipeImpact();
    void CheckEnemyImpact();
    void MeleeImpactNotify();
    void PlayMeleeHitEffects();
    void DoPlayerWorldTrace();
    void DoPlayerControlledImpact();
    void DoAreaImpact();
    void ShouldDealDamageToEnemy();
    void ApplyMeleeDamage();
};

UClass* UKFMeleeHelperAI::pClassPointer = NULL;

// Class KFGame.KFMusicTrackInfo
// 0x0038 (0x0098 - 0x0060)
class UKFMusicTrackInfo : public UObject {
   public:
    class UAkEvent* StandardTrack;      // 0x0060 (0x0008) [0x0000000000000000]
    class UAkEvent* InstrumentalTrack;  // 0x0068 (0x0008) [0x0000000000000000]
    class UAkEvent* StopEvent;          // 0x0070 (0x0008) [0x0000000000000000]
    unsigned char
        MinGameIntensityLevel;  // 0x0078 (0x0001) [0x0000000000000000]
    unsigned char
        MaxGameIntensityLevel;  // 0x0079 (0x0001) [0x0000000000000000]
    DWORD bLoop : 1;  // 0x007C (0x0004) [0x0000000000000000] [0x00000001]
    struct FName TrackName;   // 0x0080 (0x0008) [0x0000000000000000]
    struct FName ArtistName;  // 0x0088 (0x0008) [0x0000000000000000]
    struct FName AlbumName;   // 0x0090 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3209];

        return pClassPointer;
    };
};

UClass* UKFMusicTrackInfo::pClassPointer = NULL;

// Class KFGame.KFOnlineGameSearch
// 0x0008 (0x0174 - 0x016C)
class UKFOnlineGameSearch : public UOnlineGameSearch {
   public:
    unsigned char SortOrder;  // 0x016C (0x0001) [0x0000000000000000]
    unsigned char SortType;   // 0x016D (0x0001) [0x0000000000000000]
    int LastResultsSize;      // 0x0170 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3211];

        return pClassPointer;
    };

    void SortIfChanged();
    void SortResults();
    void MakeFakeServerResults();
};

UClass* UKFOnlineGameSearch::pClassPointer = NULL;

// Class KFGame.KFOnlineGameSettings
// 0x0030 (0x01C8 - 0x0198)
class UKFOnlineGameSettings : public UOnlineGameSettings {
   public:
    int NumWaves;           // 0x0198 (0x0004) [0x0000000000000000]
    int CurrentWave;        // 0x019C (0x0004) [0x0000000000000000]
    DWORD bInProgress : 1;  // 0x01A0 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bMutators : 1;    // 0x01A0 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bCustom : 1;      // 0x01A0 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bAvailableForTakeover : 1;  // 0x01A0 (0x0004) [0x0000000000000000]
                                      // [0x00000008]
    int ZedCount;                     // 0x01A4 (0x0004) [0x0000000000000000]
    int MaxZedCount;                  // 0x01A8 (0x0004) [0x0000000000000000]
    struct FString MapName;           // 0x01AC (0x0010) [0x0000000000000000]
    int Difficulty;                   // 0x01BC (0x0004) [0x0000000000000000]
    int Mode;                         // 0x01C0 (0x0004) [0x0000000000000000]
    int NumSpectators;                // 0x01C4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3213];

        return pClassPointer;
    };
};

UClass* UKFOnlineGameSettings::pClassPointer = NULL;

// Class KFGame.KFOnlineGameSettingsVersus
// 0x0000 (0x01C8 - 0x01C8)
class UKFOnlineGameSettingsVersus : public UKFOnlineGameSettings {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3215];

        return pClassPointer;
    };
};

UClass* UKFOnlineGameSettingsVersus::pClassPointer = NULL;

// Class KFGame.KFOnlineStatsRead
// 0x0018 (0x00D8 - 0x00C0)
class UKFOnlineStatsRead : public UOnlineStatsRead {
   public:
    class UKFOnlineStatsWrite*
        LinkedWriteObject;               // 0x00C0 (0x0008) [0x0000000000000000]
    struct FUniqueNetId OwningUniqueID;  // 0x00C8 (0x0008) [0x0000000000000000]
    unsigned char
        UserStatsReceivedState;  // 0x00D0 (0x0001) [0x0000000000000000]
    DWORD
        bLogStatsRead : 1;  // 0x00D4 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3217];

        return pClassPointer;
    };

    void eventOnReadComplete();
    void NativeOnReadComplete();
    void OnStatsInitialized();
};

UClass* UKFOnlineStatsRead::pClassPointer = NULL;

// Class KFGame.KFOnlineStatsWrite
// 0x0170 (0x0234 - 0x00C4)
class UKFOnlineStatsWrite : public UOnlineStatsWrite {
   public:
    class AKFPlayerController* MyKFPC;  // 0x00C4 (0x0008) [0x0000000000000000]
    int Kills;                          // 0x00CC (0x0004) [0x0000000000000000]
    int StalkerKills;                   // 0x00D0 (0x0004) [0x0000000000000000]
    int CrawlerKills;                   // 0x00D4 (0x0004) [0x0000000000000000]
    int FleshPoundKills;                // 0x00D8 (0x0004) [0x0000000000000000]
    int WeldingPoints;                  // 0x00DC (0x0004) [0x0000000000000000]
    int HealingPoints;                  // 0x00E0 (0x0004) [0x0000000000000000]
    int CommandoXP;                     // 0x00E4 (0x0004) [0x0000000000000000]
    int CommandoLVL;                    // 0x00E8 (0x0004) [0x0000000000000000]
    int CommandoPSG;                    // 0x00EC (0x0004) [0x0000000000000000]
    int CommandoBuild;                  // 0x00F0 (0x0004) [0x0000000000000000]
    int BerserkerXP;                    // 0x00F4 (0x0004) [0x0000000000000000]
    int BerserkerLVL;                   // 0x00F8 (0x0004) [0x0000000000000000]
    int BerserkerPSG;                   // 0x00FC (0x0004) [0x0000000000000000]
    int BerserkerBuild;                 // 0x0100 (0x0004) [0x0000000000000000]
    int SupportXP;                      // 0x0104 (0x0004) [0x0000000000000000]
    int SupportLVL;                     // 0x0108 (0x0004) [0x0000000000000000]
    int SupportPSG;                     // 0x010C (0x0004) [0x0000000000000000]
    int SupportBuild;                   // 0x0110 (0x0004) [0x0000000000000000]
    int MedicXP;                        // 0x0114 (0x0004) [0x0000000000000000]
    int MedicLVL;                       // 0x0118 (0x0004) [0x0000000000000000]
    int MedicPSG;                       // 0x011C (0x0004) [0x0000000000000000]
    int MedicBuild;                     // 0x0120 (0x0004) [0x0000000000000000]
    int FirebugXP;                      // 0x0124 (0x0004) [0x0000000000000000]
    int FirebugLVL;                     // 0x0128 (0x0004) [0x0000000000000000]
    int FirebugPSG;                     // 0x012C (0x0004) [0x0000000000000000]
    int FirebugBuild;                   // 0x0130 (0x0004) [0x0000000000000000]
    int DemoXP;                         // 0x0134 (0x0004) [0x0000000000000000]
    int DemoLVL;                        // 0x0138 (0x0004) [0x0000000000000000]
    int DemoPSG;                        // 0x013C (0x0004) [0x0000000000000000]
    int DemoBuild;                      // 0x0140 (0x0004) [0x0000000000000000]
    int GunslingerXP;                   // 0x0144 (0x0004) [0x0000000000000000]
    int GunslingerLVL;                  // 0x0148 (0x0004) [0x0000000000000000]
    int GunslingerPSG;                  // 0x014C (0x0004) [0x0000000000000000]
    int GunslingerBuild;                // 0x0150 (0x0004) [0x0000000000000000]
    int SharpshooterXP;                 // 0x0154 (0x0004) [0x0000000000000000]
    int SharpshooterLVL;                // 0x0158 (0x0004) [0x0000000000000000]
    int SharpshooterPSG;                // 0x015C (0x0004) [0x0000000000000000]
    int SharpshooterBuild;              // 0x0160 (0x0004) [0x0000000000000000]
    int SwatXP;                         // 0x0164 (0x0004) [0x0000000000000000]
    int SwatLVL;                        // 0x0168 (0x0004) [0x0000000000000000]
    int SwatPSG;                        // 0x016C (0x0004) [0x0000000000000000]
    int SwatBuild;                      // 0x0170 (0x0004) [0x0000000000000000]
    int SurvXP;                         // 0x0174 (0x0004) [0x0000000000000000]
    int SurvLVL;                        // 0x0178 (0x0004) [0x0000000000000000]
    int SurvPSG;                        // 0x017C (0x0004) [0x0000000000000000]
    int SurvBuild;                      // 0x0180 (0x0004) [0x0000000000000000]
    int PersonalBest_KnifeKills;        // 0x0184 (0x0004) [0x0000000000000000]
    int PersonalBest_PistolKills;       // 0x0188 (0x0004) [0x0000000000000000]
    int PersonalBest_HeadShots;         // 0x018C (0x0004) [0x0000000000000000]
    int PersonalBest_Healing;           // 0x0190 (0x0004) [0x0000000000000000]
    int PersonalBest_Kills;             // 0x0194 (0x0004) [0x0000000000000000]
    int PersonalBest_Assists;           // 0x0198 (0x0004) [0x0000000000000000]
    int PersonalBest_LargeZedKil;       // 0x019C (0x0004) [0x0000000000000000]
    int PersonalBest_Dosh;              // 0x01A0 (0x0004) [0x0000000000000000]
    int SpecialEventInfo;               // 0x01A4 (0x0004) [0x0000000000000000]
    int InitialSpecialEventInfo;        // 0x01A8 (0x0004) [0x0000000000000000]
    int WeeklyEventInfo;                // 0x01AC (0x0004) [0x0000000000000000]
    int InitialWeeklyEventInfo;         // 0x01B0 (0x0004) [0x0000000000000000]
    int PerRoundWeldXP;                 // 0x01B4 (0x0004) [0x0000000000000000]
    int PerRoundHealXP;                 // 0x01B8 (0x0004) [0x0000000000000000]
    TArray<struct FAchievementDetails>
        Achievements;   // 0x01BC (0x0010) [0x0000000000000000]
    int XPTable[0x19];  // 0x01CC (0x0064) [0x0000000000000000]
    DWORD
        bFailedToRead : 1;  // 0x0230 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bReadSuccessful : 1;   // 0x0230 (0x0004) [0x0000000000000000]
                                 // [0x00000002]
    DWORD bAllowPerkCheats : 1;  // 0x0230 (0x0004) [0x0000000000000000]
                                 // [0x00000004]
    DWORD bDisabled : 1;  // 0x0230 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bLogStatsWrite : 1;  // 0x0230 (0x0004) [0x0000000000000000]
                               // [0x00000010]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3219];

        return pClassPointer;
    };

    void GetWeeklyOutbreakRewards();
    void IsWeeklyEventComplete();
    void WeeklyEventComplete();
    void UpdateWeeklyEventState();
    void CacheWeeklyEventState();
    void CanCacheWeeklyEvent();
    void IsEventObjectiveComplete();
    void UpdateSpecialEvent();
    void UpdateSpecialEventState();
    void CacheSpecialEventState();
    void CanCacheSpecialEvent();
    void CheckForRoundTeamWinAchievements();
    void UnlockTutorialAchievement();
    void CheckAllPerksLvl25();
    void CheckPerkDifficultyAchievements();
    void CheckPerkLvlAchievement();
    void CheckMapEndAchievements();
    void OnRoundEnd();
    void OnGameWon();
    void UnlockDingoAchievement();
    void OnUnlockAchievement();
    void IsAchievementUnlocked();
    void GetAchievements();
    void IsSharpshooterHeadshot();
    void IsGunslingerHeadshot();
    void AddSharpshooterHeadshot();
    void AddGunslingerHeadshot();
    void eventAddToHeadshots();
    void eventAddHealingPoints();
    void ComputeHealingXP();
    void eventDoorRepaired();
    void eventAddWeldingPoints();
    void ComputeWeldingXP();
    void IsBloatKill();
    void IsClotKill();
    void IsFleshPoundKill();
    void IsStalkerKill();
    void IsCrawlerKill();
    void AddBloatKill();
    void AddClotKill();
    void AddFleshpoundKill();
    void AddCrawlerKill();
    void eventAddSmallRadiusKill();
    void AddStalkerKill();
    void eventAddToKills();
    void SavePersonalBest();
    void GetPersonalBest();
    void eventGetPerkLVLByClass();
    void eventGetPerkPSG();
    void eventGetPerkLVLInternal();
    void eventGetPerkXP();
    void eventNotifyLevelUp();
    void eventAddXP();
    void GetPSGFromProgress();
    void GetLVLFromProgress();
    void GetXPFromProgress();
    void IncrementXPStat();
    void GetXPNeededAt();
    void GetPerkBuild();
    void GetPerkLevel();
    void eventSaveBuildToStats();
    void eventGetPerkBuildFromStats();
    void eventCacheStatsValue();
    void LogStatValue();
    void LogStats();
    void LogSubsystemIntStat();
    void NotifyReadSucceeded();
    void HasReadStats();
    void NotifyReadFailure();
    void HasReadFailure();
    void NotifyCheats();
    void HasCheated();
    void SetFloatStat();
    void SetIntStat();
    void IncrementFloatStat();
    void IncrementIntStat();
};

UClass* UKFOnlineStatsWrite::pClassPointer = NULL;

// Class KFGame.KFPerk
// 0x0248 (0x048C - 0x0244)
class AKFPerk : public AReplicationInfo {
   public:
    int ProgressStatID;            // 0x0244 (0x0004) [0x0000000000000000]
    int PerkBuildStatID;           // 0x0248 (0x0004) [0x0000000000000000]
    int SecondaryXPModifier[0x4];  // 0x024C (0x0010) [0x0000000000000000]
    struct FString PerkName;       // 0x025C (0x0010) [0x0000000000000000]
    TArray<struct FPassivePerk>
        Passives;  // 0x026C (0x0010) [0x0000000000000000]
    struct FString
        SkillCatagories[0x5];    // 0x027C (0x0050) [0x0000000000000000]
    struct FString EXPAction1;   // 0x02CC (0x0010) [0x0000000000000000]
    struct FString EXPAction2;   // 0x02DC (0x0010) [0x0000000000000000]
    struct FString LevelString;  // 0x02EC (0x0010) [0x0000000000000000]
    class UTexture2D* PerkIcon;  // 0x02FC (0x0008) [0x0000000000000000]
    TArray<struct FString>
        ColumnOneIcons;  // 0x0304 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        ColumnTwoIcons;              // 0x0314 (0x0010) [0x0000000000000000]
    class UTexture2D* InteractIcon;  // 0x0324 (0x0008) [0x0000000000000000]
    struct FString
        WeaponDroppedMessage;  // 0x032C (0x0010) [0x0000000000000000]
    float AssistDoshModifier;  // 0x033C (0x0004) [0x0000000000000000]
    TArray<struct FPerkSkill>
        PerkSkills;                     // 0x0340 (0x0010) [0x0000000000000000]
    unsigned char SelectedSkills[0x5];  // 0x0350 (0x0005) [0x0000000000000000]
    unsigned char MaxAbilityPoints;     // 0x0355 (0x0001) [0x0000000000000000]
    unsigned char CurrentLevel;  // 0x0356 (0x0001) [0x0000000000150000] (
                                 // CPF_Travel | CPF_GlobalConfig )
    unsigned char CurrentPrestigeLevel;  // 0x0357 (0x0001) [0x0000000000000000]
    float RegenerationInterval;          // 0x0358 (0x0004) [0x0000000000000000]
    int RegenerationAmount;              // 0x035C (0x0004) [0x0000000000000000]
    float TimeUntilNextRegen;            // 0x0360 (0x0004) [0x0000000000000000]
    float BarrageDamageModifier;         // 0x0364 (0x0004) [0x0000000000000000]
    float FormidableDamageModifier;      // 0x0368 (0x0004) [0x0000000000000000]
    float VaccinationDuration;           // 0x036C (0x0004) [0x0000000000000000]
    TArray<struct FBuffedPlayerInfo>
        BuffedPlayerInfos;  // 0x0370 (0x0010) [0x0000000000000000]
    class AKFUsablePerkTrigger*
        InteractionTrigger;  // 0x0380 (0x0008) [0x0000000000000000]
    TArray<struct FName>
        ZedTimeModifyingStates;  // 0x0388 (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        BodyPartsCanStumble;  // 0x0398 (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        BodyPartsCanKnockDown;     // 0x03A8 (0x0010) [0x0000000000000000]
    DWORD bCanSeeCloakedZeds : 1;  // 0x03B8 (0x0004) [0x0000000000000000]
                                   // [0x00000001]
    DWORD
        bHasTempSkill_TacticalReload : 1;  // 0x03B8 (0x0004)
                                           // [0x0000000000000000] [0x00000002]
    DWORD
        bInitialized : 1;  // 0x03B8 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bLogPerk : 1;    // 0x03B8 (0x0004) [0x0000000000000000] [0x00000008]
    float SignatureDamageScale;        // 0x03BC (0x0004) [0x0000000000000000]
    float SignatureRecoilScale;        // 0x03C0 (0x0004) [0x0000000000000000]
    int CurrentAbilityPoints;          // 0x03C4 (0x0004) [0x0000000000000000]
    struct FPerkSkill TacticalReload;  // 0x03C8 (0x0038) [0x0000000000000000]
    class UClass* ToxicDmgTypeClass;   // 0x0400 (0x0008) [0x0000000000000000]
    int SavedBuild;                    // 0x0408 (0x0004) [0x0000000000000000]
    class UClass* PrimaryWeaponDef;    // 0x040C (0x0008) [0x0000000000000000]
    class UClass* SecondaryWeaponDef;  // 0x0414 (0x0008) [0x0000000000000000]
    class UClass* KnifeWeaponDef;      // 0x041C (0x0008) [0x0000000000000000]
    class UClass* GrenadeWeaponDef;    // 0x0424 (0x0008) [0x0000000000000000]
    class UClass* GrenadeClass;        // 0x042C (0x0008) [0x0000000000000000]
    int InitialGrenadeCount;           // 0x0434 (0x0004) [0x0000000000000000]
    int MaxGrenadeCount;               // 0x0438 (0x0004) [0x0000000000000000]
    TArray<struct FName>
        BackupWeaponDamageTypeNames;  // 0x043C (0x0010) [0x0000000000000000]
    TArray<class UClass*>
        AutoBuyLoadOutPath;          // 0x044C (0x0010) [0x0000000000000000]
    float HitAccuracyHandicap;       // 0x045C (0x0004) [0x0000000000000000]
    float HeadshotAccuracyHandicap;  // 0x0460 (0x0004) [0x0000000000000000]
    class AKFPlayerReplicationInfo*
        MyPRI;                  // 0x0464 (0x0008) [0x0000000000000000]
    class AKFGameInfo* MyKFGI;  // 0x046C (0x0008) [0x0000000000000000]
    class AKFGameReplicationInfo*
        MyKFGRI;                         // 0x0474 (0x0008) [0x0000000000000000]
    class AKFPlayerController* OwnerPC;  // 0x047C (0x0008) [0x0000000000000000]
    class AKFPawn_Human* OwnerPawn;      // 0x0484 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3221];

        return pClassPointer;
    };

    void PlayerDied();
    void FormatPerkSkills();
    void LogPerkSkills();
    void ClientLogPerks();
    void ServerLogPerks();
    void GetPercentage();
    void GetGrenadeWeaponDef();
    void GetGrenadeImagePath();
    void GetInteractIcon();
    void GetPerkLensEffect();
    void TickRegen();
    void ShouldAutosellWeapon();
    void HitShouldKnockdown();
    void HitShouldStumble();
    void eventGetOwnerPawn();
    void NotifyZedTimeEnded();
    void NotifyZedTimeStarted();
    void DrawSpecialPerkHUD();
    void GetUsingTactialReload();
    void OnWaveEnded();
    void GetOwnerWeapon();
    void ModifyBloatBileDoT();
    void GetModifierString();
    void GetAssistDoshModifer();
    void ModifyAssistDosh();
    void GetArmorDamageAmount();
    void ShouldKnockDownOnBump();
    void HasHeavyArmor();
    void eventGetCrouchSpeedModifier();
    void IgnoresPenetrationDmgReduction();
    void eventGetCameraViewShakeModifier();
    void ModifyWeaponBopDamping();
    void ShouldInstantlySwitchWeapon();
    void ModifyWeaponSwitchTime();
    void eventGetIronSightSpeedModifier();
    void ModifyRateOfFire();
    void eventServerResetHeadShotCombo();
    void eventGetIsHeadShotComboActive();
    void ResetHeadShotCombo();
    void AddToHeadShotCombo();
    void UpdatePerkHeadShots();
    void GetIsUberAmmoActive();
    void GetLastHX25NukeTime();
    void SetLastHX25NukeTime();
    void ShouldNeverDud();
    void GetDaZedEMPPower();
    void ShouldGetDaZeD();
    void DoorShouldNuke();
    void GetAoEDamageModifier();
    void GetAoERadiusModifier();
    void CanExplosiveWeld();
    void ShouldRandSirenResist();
    void ShouldSacrifice();
    void IsSharedExplosiveResistaneActive();
    void IsOnContactActive();
    void IsRangeActive();
    void GetSplashDamageModifier();
    void ShouldShrapnel();
    void CouldBeZedShrapnel();
    void CanSpreadNapalm();
    void GetFireStumble();
    void ModifyDoTScaler();
    void IsFlarotovActive();
    void IsSlugActive();
    void GetHealingShieldActive();
    void GetHealingDamageBoostActive();
    void GetHealingSpeedBoostActive();
    void GetSelfHealingSurgePct();
    void IsHealingSurgeActive();
    void GetSirenScreamStrength();
    void ModifyToxicDmg();
    void GetToxicDmgTypeClass();
    void IsToxicDmgActive();
    void RepairArmor();
    void CanRepairDoors();
    void GetArmorDiscountMod();
    void ModifyArmor();
    void ModifyHealAmount();
    void ModifyHealerRechargeTime();
    void eventShouldUseFastInstigatorDilation();
    void IsUnAffectedByZedTime();
    void ShouldKnockdown();
    void AddVampireHealth();
    void SetSuccessfullParry();
    void SetSuccessfullBlock();
    void ModifyLightAttackDamage();
    void ModifyHardAttackDamage();
    void CanEarnSmallRadiusKillXP();
    void CanNotBeGrabbed();
    void ModifyScreamEffectDuration();
    void ModifyMeleeAttackSpeed();
    void ModifySpread();
    void GetZedTimeModifier();
    void IsRapidFireActive();
    void HasNightVision();
    void IsShootAndMoveActive();
    void IsCallOutActive();
    void GetTightChokeModifier();
    void GetBarrageDamageModifier();
    void GetPenetrationModifier();
    void Interact();
    void CanInteract();
    void ModifyWeldingRate();
    void ShouldGetAllTheXP();
    void GetExplosionTemplate();
    void GetSnarePowerModifier();
    void GetReactionModifier();
    void GetStunPowerModifier();
    void GetStumblePowerModifier();
    void GetKnockdownPowerModifier();
    void GetZedTimeExtension();
    void ModifyHealth();
    void ShouldMagSizeModifySpareAmmo();
    void ModifyMaxSpareAmmoAmount();
    void MaximizeSpareAmmoAmount();
    void ModifySpareAmmoAmount();
    void ModifyMagSizeAndNumber();
    void ModifyDamageTaken();
    void ModifyDamageGiven();
    void ModifyRecoil();
    void FinalizeSpeedVariables();
    void ModifySprintSpeed();
    void ModifySpeed();
    void GetReloadRateScale();
    void GetSuppressingFireSnareScale();
    void GetAwarenessDamageScale();
    void GetCloakDetectionRange();
    void BuildDroppedMessageString();
    void CheckForOverWeight();
    void PerkNeedsTick();
    void GetKnifeWeaponClassPath();
    void GetSecondaryWeaponClassPath();
    void GetPrimaryWeaponClassPath();
    void GetGrenadeClass();
    void AddDefaultInventory();
    void eventPostLevelUp();
    void NotifyPawnTeamChanged();
    void ApplyWeightLimits();
    void ApplySkillsToPawn();
    void PerkSetOwnerHealthAndArmor();
    void eventNotifyPerkModified();
    void SetPlayerDefaults();
    void eventPreBeginPlay();
    void GetSavedBuild();
    void eventGetPerkIconPath();
    void GetPassiveValue();
    void GetSkillValue();
    void GetPassiveStrings();
    void eventPostSkillUpdate();
    void UnpackSkill();
    void eventGetUnpackedSkillsArray();
    void eventSetPerkBuild();
    void eventPackSkill();
    void eventPackPerkBuild();
    void eventUpdatePerkBuild();
    void eventUpdateSkills();
    void eventPerkLevelUpdated();
    void IsPerkLevelAllowed();
    void SetLevel();
    void GetLevel();
    void IsBackupWeapon();
    void MultiplySecondaryXPPoints();
    void IsDamageTypeOnThisPerk();
    void IsBackupDamageTypeOnPerk();
    void IsDamageTypeOnPerk();
    void IsWeaponOnPerk();
    void GetPerkFromProjectile();
    void GetPerkFromDamageCauser();
    void GetWeaponFromDamageCauser();
    void DumpPerkLoadout();
    void GetPerkClass();
    void GetPerkBuildStatID();
    void GetProgressStatID();
    void eventClientACK();
    void eventServerSetPerkBuild();
    void SavePerkDataToConfig();
    void SaveBuildToStats();
    void SaveTierUnlockToConfig();
    void LoadPerkData();
    void LoadTierUnlockFromConfig();
    void LoadPerk();
    void CheckOwnerPawn();
};

UClass* AKFPerk::pClassPointer = NULL;

// Class KFGame.KFPerk_Berserker
// 0x00FC (0x0588 - 0x048C)
class AKFPerk_Berserker : public AKFPerk {
   public:
    struct FPerkSkill BerserkerDamage;   // 0x048C (0x0038) [0x0000000000000000]
    struct FPerkSkill DamageResistance;  // 0x04C4 (0x0038) [0x0000000000000000]
    struct FPerkSkill NightVision;       // 0x04FC (0x0038) [0x0000000000000000]
    float NinjaSprintModifer;            // 0x0534 (0x0004) [0x0000000000000000]
    float SmashStumbleModifier;          // 0x0538 (0x0004) [0x0000000000000000]
    int SmallRadiusSizeSQ;               // 0x053C (0x0004) [0x0000000000000000]
    DWORD
        bParryActive : 1;  // 0x0540 (0x0004) [0x0000000000000000] [0x00000001]
    float ParryDuration;   // 0x0544 (0x0004) [0x0000000000000000]
    float ParrySpeed;      // 0x0548 (0x0004) [0x0000000000000000]
    float FurySpeed;       // 0x054C (0x0004) [0x0000000000000000]
    float SmashKnockdownMultiplier;    // 0x0550 (0x0004) [0x0000000000000000]
    float SpartanZedTimeResistance;    // 0x0554 (0x0004) [0x0000000000000000]
    float SpeedDamageModifier;         // 0x0558 (0x0004) [0x0000000000000000]
    float SmashHeadDamageModifier;     // 0x055C (0x0004) [0x0000000000000000]
    float VampireAttackSpeedModifier;  // 0x0560 (0x0004) [0x0000000000000000]
    float ParryDamageReduction;        // 0x0564 (0x0004) [0x0000000000000000]
    int RageRadius;                    // 0x0568 (0x0004) [0x0000000000000000]
    float RageFleeDuration;            // 0x056C (0x0004) [0x0000000000000000]
    int RageFleeDistance;              // 0x0570 (0x0004) [0x0000000000000000]
    int RageDialogEvent;               // 0x0574 (0x0004) [0x0000000000000000]
    class UAkEvent*
        ParrySkillSoundModeStart;  // 0x0578 (0x0008) [0x0000000000000000]
    class UAkEvent*
        ParrySkillSoundModeStop;  // 0x0580 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3223];

        return pClassPointer;
    };

    void LogPerkSkills();
    void GetPerkLensEffect();
    void eventShouldUseFastInstigatorDilation();
    void IsFastInZedTime();
    void eventCouldSpartanBeActive();
    void eventIsSpartanActive();
    void eventIsRageActive();
    void CanNotBeGrabbed();
    void IsFuryActive();
    void eventIsSmashActive();
    void HasNightVision();
    void eventGetParryActive();
    void IsResistanceActive();
    void IsParryActive();
    void SetSuccessfullParry();
    void PerkNeedsTick();
    void IsSpeedActive();
    void IsVampireActive();
    void IsNinjaActive();
    void IsFortitudeActive();
    void GetParryDamageModifier();
    void GetVampireAttackSpeedModifier();
    void GetSmashHeadDamageModifier();
    void GetSpeedDamageModifier();
    void GetZedTimeModifier();
    void GetRageFleeDistance();
    void GetRageFleeDuration();
    void GetRageRadius();
    void NotifyZedTimeStarted();
    void GetSirenScreamStrength();
    void CanEarnSmallRadiusKillXP();
    void GetSmallRadiusKillDistanceSQ();
    void GetSmallRadiusKillXP();
    void GetSmashStumbleModifier();
    void GetStumblePowerModifier();
    void ModifyScreamEffectDuration();
    void ParryTimer();
    void ModifyLightAttackDamage();
    void ModifyHardAttackDamage();
    void AddVampireHealth();
    void ModifyHealth();
    void GetPassiveStrings();
    void ModifyBloatBileDoT();
    void GetPassiveDamageResistance();
    void ModifyDamageTaken();
    void GetNinjaSprintModifier();
    void ModifySprintSpeed();
    void ModifySpeed();
    void GetFurySpeed();
    void ModifyMeleeAttackSpeed();
    void ModifyDamageGiven();
    void eventTick();
    void eventPostSkillUpdate();
    void ApplySkillsToPawn();
};

UClass* AKFPerk_Berserker::pClassPointer = NULL;

// Class KFGame.KFPerk_Commando
// 0x0168 (0x05F4 - 0x048C)
class AKFPerk_Commando : public AKFPerk {
   public:
    struct FPerkSkill WeaponDamage;  // 0x048C (0x0038) [0x0000000000000000]
    struct FPerkSkill
        CloakedEnemyDetection;           // 0x04C4 (0x0038) [0x0000000000000000]
    struct FPerkSkill ZedTimeExtension;  // 0x04FC (0x0038) [0x0000000000000000]
    struct FPerkSkill ReloadSpeed;       // 0x0534 (0x0038) [0x0000000000000000]
    struct FPerkSkill CallOut;           // 0x056C (0x0038) [0x0000000000000000]
    struct FPerkSkill NightVision;       // 0x05A4 (0x0038) [0x0000000000000000]
    float RapidFireFiringRate;           // 0x05DC (0x0004) [0x0000000000000000]
    float BackupWeaponSwitchModifier;    // 0x05E0 (0x0004) [0x0000000000000000]
    float HollowPointRecoilModifier;     // 0x05E4 (0x0004) [0x0000000000000000]
    float HealthArmorModifier;           // 0x05E8 (0x0004) [0x0000000000000000]
    class UTexture2D* WhiteMaterial;     // 0x05EC (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3225];

        return pClassPointer;
    };

    void LogPerkSkills();
    void LogTacticalReload();
    void DrawZedHealthbar();
    void DrawSpecialPerkHUD();
    void GetStalkerKillXP();
    void GetPassiveStrings();
    void IsProfessionalActive();
    void IsAmmoVestActive();
    void IsEatLeadActive();
    void IsHealthIncreaseActive();
    void IsImpactActive();
    void IsTacticalReloadActive();
    void IsHollowPointsActive();
    void IsBackupActive();
    void IsLargeMagActive();
    void CouldRapidFireActive();
    void IsRapidFireActive();
    void HasNightVision();
    void IsCallOutActive();
    void GetHealthArmorModifier();
    void GetHollowPointRecoilModifier();
    void ModifyRecoil();
    void GetBackupWeaponSwitchModifier();
    void ModifyWeaponSwitchTime();
    void GetStumblePowerModifier();
    void GetZedTimeModifier();
    void Is9mm();
    void ModifyMaxSpareAmmoAmount();
    void ModifyMagSizeAndNumber();
    void GetUsingTactialReload();
    void ModifyArmor();
    void ModifyHealth();
    void GetReloadRateScale();
    void GetExtraReloadSpeed();
    void GetZedTimeExtension();
    void GetCloakDetectionRange();
    void ModifyDamageGiven();
    void SetPlayerDefaults();
};

UClass* AKFPerk_Commando::pClassPointer = NULL;

// Class KFGame.KFPerk_Demolitionist
// 0x0158 (0x05E4 - 0x048C)
class AKFPerk_Demolitionist : public AKFPerk {
   public:
    struct FPerkSkill ExplosiveDamage;  // 0x048C (0x0038) [0x0000000000000000]
    struct FPerkSkill
        ExplosiveResistance;          // 0x04C4 (0x0038) [0x0000000000000000]
    struct FPerkSkill ExplosiveAmmo;  // 0x04FC (0x0038) [0x0000000000000000]
    TArray<class AKFPawn_Human*>
        SuppliedPawnList;             // 0x0534 (0x0010) [0x0000000000000000]
    float SharedExplosiveResistance;  // 0x0544 (0x0004) [0x0000000000000000]
    class UClass*
        ExplosiveResistableDamageTypeSuperClass;  // 0x0548 (0x0008)
                                                  // [0x0000000000000000]
    float ExplosiveResistanceRadius;  // 0x0550 (0x0004) [0x0000000000000000]
    class UKFGameExplosion*
        SacrificeExplosionTemplate;  // 0x0554 (0x0008) [0x0000000000000000]
    class UKFGameExplosion*
        NukeExplosionTemplate;  // 0x055C (0x0008) [0x0000000000000000]
    class UKFGameExplosion*
        DoorTrapExplosionTemplate;  // 0x0564 (0x0008) [0x0000000000000000]
    class UClass*
        NukeExplosionActorClass;  // 0x056C (0x0008) [0x0000000000000000]
    float NukeDamageModifier;     // 0x0574 (0x0004) [0x0000000000000000]
    float NukeRadiusModifier;     // 0x0578 (0x0004) [0x0000000000000000]
    class UAkEvent*
        ConcussiveExplosionSound;   // 0x057C (0x0008) [0x0000000000000000]
    float AoeDamageModifier;        // 0x0584 (0x0004) [0x0000000000000000]
    int LingeringNukePoisonDamage;  // 0x0588 (0x0004) [0x0000000000000000]
    TArray<struct FName>
        PassiveExtraAmmoIgnoredClassNames;  // 0x058C (0x0010)
                                            // [0x0000000000000000]
    TArray<struct FName>
        ExtraAmmoIgnoredClassNames;  // 0x059C (0x0010) [0x0000000000000000]
    TArray<struct FName>
        OnlySecondaryAmmoWeapons;  // 0x05AC (0x0010) [0x0000000000000000]
    TArray<struct FName>
        DamageIgnoredDTs;           // 0x05BC (0x0010) [0x0000000000000000]
    float DaZedEMPPower;            // 0x05CC (0x0004) [0x0000000000000000]
    float ProfessionalAoEModifier;  // 0x05D0 (0x0004) [0x0000000000000000]
    DWORD bUsedSacrifice : 1;       // 0x05D4 (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    class UClass*
        LingeringNukeDamageType;  // 0x05D8 (0x0008) [0x0000000000000000]
    float LastHX25NukeTime;       // 0x05E0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3227];

        return pClassPointer;
    };

    void LogPerkSkills();
    void GetPassiveStrings();
    void GetFleshpoundKillXP();
    void GetConcussiveExplosionSound();
    void IsConcussiveForceActive();
    void GetLingeringDamageType();
    void GetLingeringPoisonDamage();
    void GetNukeRadiusModifier();
    void GetNukeDamageModifier();
    void GetNukeExplosionActorClass();
    void GetNukeExplosionTemplate();
    void IsNukeActive();
    void IsSirenResistanceActive();
    void GetDoorTrapsExplosionTemplate();
    void IsSacrificeActive();
    void IsDoorTrapsActive();
    void GetSacrificeExplosionTemplate();
    void IsDmgTypeExplosiveResistable();
    void GetExplosiveResistanceRadius();
    void GetSharedExplosiveResistance();
    void IsProfessionalActive();
    void IsCriticalHitActive();
    void IsAoEActive();
    void IsAmmoActive();
    void IsDirectHitActive();
    void IsTacticalReloadActive();
    void IsDamageActive();
    void GetZedTimeModifier();
    void ShouldNeverDud();
    void DoorShouldNuke();
    void ProjectileShouldNuke();
    void GetReactionModifier();
    void GetStunPowerModifier();
    void GetStumblePowerModifier();
    void GetKnockdownPowerModifier();
    void ShouldRandSirenResist();
    void CanExplosiveWeld();
    void ModifyExplosiveDamage();
    void NotifyPerkSacrificeExploded();
    void ShouldSacrifice();
    void CanInteract();
    void Interact();
    void ResetSupplier();
    void GetUsingTactialReload();
    void GetAmmoExtraAmmo();
    void GetAoEDamageModifier();
    void GetAoERadiusModifier();
    void GetLastHX25NukeTime();
    void SetLastHX25NukeTime();
    void PrepareExplosive();
    void GetExtraAmmo();
    void ModifyMaxSpareAmmoAmount();
    void ShouldGiveOnlySecondaryAmmo();
    void GiveAmmoExtraAmmo();
    void GivePassiveExtraAmmo();
    void ModifySpareAmmoAmount();
    void ModifyDamageTaken();
    void IsDamageTypeOnPerk();
    void IsCriticalHitZone();
    void IsDamageIgnoredDT();
    void ModifyDamageGiven();
    void OnWaveEnded();
    void ApplySkillsToPawn();
};

UClass* AKFPerk_Demolitionist::pClassPointer = NULL;

// Class KFGame.KFPerk_FieldMedic
// 0x0158 (0x05E4 - 0x048C)
class AKFPerk_FieldMedic : public AKFPerk {
   public:
    struct FPerkSkill HealerRecharge;  // 0x048C (0x0038) [0x0000000000000000]
    struct FPerkSkill HealPotency;     // 0x04C4 (0x0038) [0x0000000000000000]
    struct FPerkSkill
        BloatBileResistance;           // 0x04FC (0x0038) [0x0000000000000000]
    struct FPerkSkill MovementSpeed;   // 0x0534 (0x0038) [0x0000000000000000]
    struct FPerkSkill Armor;           // 0x056C (0x0038) [0x0000000000000000]
    float SelfHealingSurgePct;         // 0x05A4 (0x0004) [0x0000000000000000]
    float MaxSurvivalistResistance;    // 0x05A8 (0x0004) [0x0000000000000000]
    float CombatantSpeedModifier;      // 0x05AC (0x0004) [0x0000000000000000]
    float MaxHealingSpeedBoost;        // 0x05B0 (0x0004) [0x0000000000000000]
    float HealingSpeedBoostDuration;   // 0x05B4 (0x0004) [0x0000000000000000]
    float MaxHealingDamageBoost;       // 0x05B8 (0x0004) [0x0000000000000000]
    float HealingDamageBoostDuration;  // 0x05BC (0x0004) [0x0000000000000000]
    float MaxHealingShield;            // 0x05C0 (0x0004) [0x0000000000000000]
    float HealingShieldDuration;       // 0x05C4 (0x0004) [0x0000000000000000]
    class UParticleSystem*
        AAParticleSystem;  // 0x05C8 (0x0008) [0x0000000000000000]
    float SnarePower;      // 0x05D0 (0x0004) [0x0000000000000000]
    class UKFGameExplosion*
        AAExplosionTemplate;  // 0x05D4 (0x0008) [0x0000000000000000]
    class UClass*
        AAExplosionDamageType;  // 0x05DC (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3229];

        return pClassPointer;
    };

    void LogPerkSkills();
    void GetPassiveStrings();
    void GetPerkLensEffect();
    void IsSlugActive();
    void IsSurvivalistActive();
    void IsHealingSurgeActive();
    void IsEnforcerActive();
    void IsCombatantActive();
    void IsHealingShieldActive();
    void IsHealingDamageBoostActive();
    void IsHealingSpeedBoostActive();
    void IsToxicDmgActive();
    void IsAcidicCompoundActive();
    void IsAirborneAgentActive();
    void GetSnarePowerModifier();
    void GetAAEffect();
    void GetAAExplosionActorClass();
    void GetAADamageTypeClass();
    void GetAAExplosionTemplate();
    void NotifyZedTimeStarted();
    void ModifyToxicDmg();
    void ModifyDamageGiven();
    void GetHealingShieldDuration();
    void GetMaxHealingShield();
    void GetHealingShield();
    void GetHealingShieldActive();
    void GetHealingDamageBoostDuration();
    void GetMaxHealingDamageBoost();
    void GetHealingDamageBoost();
    void GetHealingDamageBoostActive();
    void GetHealingSpeedBoostDuration();
    void GetMaxHealingSpeedBoost();
    void GetHealingSpeedBoost();
    void GetHealingSpeedBoostActive();
    void ModifyMagSizeAndNumber();
    void GetSelfHealingSurgePct();
    void ModifyHealth();
    void ModifyArmor();
    void GetComabatantSpeedModifier();
    void ModifySpeed();
    void ModifyDamageTaken();
    void ModifyHealAmount();
    void ModifyHealerRechargeTime();
};

UClass* AKFPerk_FieldMedic::pClassPointer = NULL;

// Class KFGame.KFPerk_Firebug
// 0x013C (0x05C8 - 0x048C)
class AKFPerk_Firebug : public AKFPerk {
   public:
    struct FPerkSkill WeaponDamage;    // 0x048C (0x0038) [0x0000000000000000]
    struct FPerkSkill WeaponReload;    // 0x04C4 (0x0038) [0x0000000000000000]
    struct FPerkSkill FireResistance;  // 0x04FC (0x0038) [0x0000000000000000]
    struct FPerkSkill
        OwnFireResistance;           // 0x0534 (0x0038) [0x0000000000000000]
    struct FPerkSkill StartingAmmo;  // 0x056C (0x0038) [0x0000000000000000]
    int HeatWaveRadiusSQ;            // 0x05A4 (0x0004) [0x0000000000000000]
    float ShrapnelChance;            // 0x05A8 (0x0004) [0x0000000000000000]
    class UGameExplosion*
        ExplosionTemplate;  // 0x05AC (0x0008) [0x0000000000000000]
    float SnarePower;       // 0x05B4 (0x0004) [0x0000000000000000]
    class UClass*
        SnareCausingDmgTypeClass;     // 0x05B8 (0x0008) [0x0000000000000000]
    int NapalmDamage;                 // 0x05C0 (0x0004) [0x0000000000000000]
    float NapalmCheckCollisionScale;  // 0x05C4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3231];

        return pClassPointer;
    };

    void LogPerkSkills();
    void GetPassiveStrings();
    void GetBloatKillXP();
    void GetCrawlerKillXP();
    void IsScorchActive();
    void GetScorchActive();
    void IsInfernoActive();
    void IsSplashDamageActive();
    void IsRangeActive();
    void IsNapalmActive();
    void IsZedShrapnelActive();
    void IsHeatWaveActive();
    void IsFlarotovActive();
    void IsGroundFireActive();
    void IsFuseActive();
    void IsHighCapFuelTankActive();
    void IsBringTheHeatActive();
    void GetIsUberAmmoActive();
    void GetSnarePowerModifier();
    void GetStumblePowerModifier();
    void GetZedTimeModifier();
    void GetExplosionTemplate();
    void ShouldShrapnel();
    void GetSplashDamageModifier();
    void CouldBeZedShrapnel();
    void GetNapalmCheckCollisionScale();
    void CanSpreadNapalm();
    void ModifyMagSizeAndNumber();
    void InHeatRange();
    void GetNapalmDamage();
    void ModifyDoTScaler();
    void GetStartingAmmoPercent();
    void MaximizeSpareAmmoAmount();
    void ModifySpareAmmoAmount();
    void ModifyDamageTaken();
    void GetReloadRateScale();
    void ModifyDamageGiven();
    void ApplySkillsToPawn();
};

UClass* AKFPerk_Firebug::pClassPointer = NULL;

// Class KFGame.KFPerk_Gunslinger
// 0x019C (0x0628 - 0x048C)
class AKFPerk_Gunslinger : public AKFPerk {
   public:
    struct FPerkSkill WeaponDamage;      // 0x048C (0x0038) [0x0000000000000000]
    struct FPerkSkill BulletResistance;  // 0x04C4 (0x0038) [0x0000000000000000]
    struct FPerkSkill MovementSpeed;     // 0x04FC (0x0038) [0x0000000000000000]
    struct FPerkSkill Recoil;            // 0x0534 (0x0038) [0x0000000000000000]
    struct FPerkSkill ZedTimeReload;     // 0x056C (0x0038) [0x0000000000000000]
    TArray<struct FName>
        SpecialZedClassNames;  // 0x05A4 (0x0010) [0x0000000000000000]
    TArray<struct FName>
        AdditionalOnPerkWeaponNames;  // 0x05B4 (0x0010) [0x0000000000000000]
    TArray<struct FName>
        AdditionalOnPerkDTNames;  // 0x05C4 (0x0010) [0x0000000000000000]
    class UAkEvent*
        RhythmMethodSoundReset;  // 0x05D4 (0x0008) [0x0000000000000000]
    class UAkEvent*
        RhythmMethodSoundHit;  // 0x05DC (0x0008) [0x0000000000000000]
    class UAkEvent*
        RhythmMethodSoundTop;          // 0x05E4 (0x0008) [0x0000000000000000]
    struct FName RhytmMethodRTPCName;  // 0x05EC (0x0008) [0x0000000000000000]
    float QuickSwitchSpeedModifier;    // 0x05F4 (0x0004) [0x0000000000000000]
    float QuickSwitchRecoilModifier;   // 0x05F8 (0x0004) [0x0000000000000000]
    float ShootnMooveBobDamp;          // 0x05FC (0x0004) [0x0000000000000000]
    TArray<unsigned char>
        BoneBreakerBodyParts;          // 0x0600 (0x0010) [0x0000000000000000]
    float BoneBreakerDamage;           // 0x0610 (0x0004) [0x0000000000000000]
    float SnarePower;                  // 0x0614 (0x0004) [0x0000000000000000]
    int HeadShotComboCount;            // 0x0618 (0x0004) [0x0000000000000000]
    int HeadShotComboCountDisplay;     // 0x061C (0x0004) [0x0000000000000000]
    int MaxHeadShotComboCount;         // 0x0620 (0x0004) [0x0000000000000000]
    float HeadShotCountdownIntervall;  // 0x0624 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3233];

        return pClassPointer;
    };

    void LogPerkSkills();
    void GetPassiveStrings();
    void GetMaxHeadShotsValue();
    void PlayerDied();
    void eventDestroyed();
    void GetQuickSwitychSpeedModifier();
    void IsDamageTypeOnPerk();
    void IsWeaponOnPerk();
    void IsSkullCrackerActive();
    void IsUberAmmoActive();
    void GetFanfareActive();
    void IsFanfareActive();
    void IsKnockEmDownActive();
    void IsPenetrationActive();
    void IsSpeedReloadActive();
    void IsBoneBreakerActive();
    void IsRhythmMethodActive();
    void IsQuickSwitchActive();
    void IsShootnMooveActive();
    void GetSnarePowerModifier();
    void IgnoresPenetrationDmgReduction();
    void GetBoneBreakerDamage();
    void HitShouldGiveBodyPartDamage();
    void ModifyWeaponSwitchTime();
    void ModifyWeaponBopDamping();
    void eventGetIronSightSpeedModifier();
    void GetPenetrationModifier();
    void eventGetIsHeadShotComboActive();
    void ServerClearHeadShotsCombo();
    void SubstractHeadShotCombo();
    void HeadShotMessage();
    void UpdatePerkHeadShots();
    void AddToHeadShotCombo();
    void GetIsUberAmmoActive();
    void GetZedTimeModifier();
    void CheckSpecialZedBodyPart();
    void GetStumblePowerModifier();
    void GetKnockdownPowerModifier();
    void GetUsingTactialReload();
    void IsZedTimeReloadAllowed();
    void GetReloadRateScale();
    void GetQuickSwitchRecoilModifier();
    void ModifyRecoil();
    void ModifyDamageTaken();
    void ModifyDamageGiven();
    void GetHeadshotXP();
    void eventPostSkillUpdate();
    void ModifySpeed();
};

UClass* AKFPerk_Gunslinger::pClassPointer = NULL;

// Class KFGame.KFPerk_Monster
// 0x0000 (0x048C - 0x048C)
class AKFPerk_Monster : public AKFPerk {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3235];

        return pClassPointer;
    };

    void eventPostBeginPlay();
};

UClass* AKFPerk_Monster::pClassPointer = NULL;

// Class KFGame.KFPerk_Sharpshooter
// 0x010C (0x0598 - 0x048C)
class AKFPerk_Sharpshooter : public AKFPerk {
   public:
    struct FPerkSkill HeadshotDamage;  // 0x048C (0x0038) [0x0000000000000000]
    struct FPerkSkill Recoil;          // 0x04C4 (0x0038) [0x0000000000000000]
    struct FPerkSkill
        WeaponSwitchSpeed;  // 0x04FC (0x0038) [0x0000000000000000]
    class UAkEvent*
        RhythmMethodSoundReset;  // 0x0534 (0x0008) [0x0000000000000000]
    class UAkEvent*
        RhythmMethodSoundHit;  // 0x053C (0x0008) [0x0000000000000000]
    class UAkEvent*
        RhythmMethodSoundTop;            // 0x0544 (0x0008) [0x0000000000000000]
    struct FName RhytmMethodRTPCName;    // 0x054C (0x0008) [0x0000000000000000]
    int HeadShotComboCount;              // 0x0554 (0x0004) [0x0000000000000000]
    int HeadShotComboCountDisplay;       // 0x0558 (0x0004) [0x0000000000000000]
    float HeadShotCountdownIntervall;    // 0x055C (0x0004) [0x0000000000000000]
    int MaxHeadShotComboCount;           // 0x0560 (0x0004) [0x0000000000000000]
    float CameraViewShakeScale;          // 0x0564 (0x0004) [0x0000000000000000]
    float TriggerMovementSpeedModifier;  // 0x0568 (0x0004) [0x0000000000000000]
    float
        CrouchAimMovementSpeedModifier;  // 0x056C (0x0004) [0x0000000000000000]
    float CrouchAimReloadSpeedModifier;  // 0x0570 (0x0004) [0x0000000000000000]
    TArray<struct FName>
        AdditionalOnPerkWeaponNames;  // 0x0574 (0x0010) [0x0000000000000000]
    TArray<struct FName>
        AdditionalOnPerkDTNames;  // 0x0584 (0x0010) [0x0000000000000000]
    float SkillZedTimeChance;     // 0x0594 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3237];

        return pClassPointer;
    };

    void IsWeaponOnPerk();
    void IsDamageTypeOnPerk();
    void GetCrouchAimReloadSpeedModifier();
    void GetCrouchAimMovementSpeedModifier();
    void GetTriggerMovementSpeedModifier();
    void eventGetIsHeadShotComboActive();
    void ServerClearHeadShotsCombo();
    void SubstractHeadShotCombo();
    void HeadShotMessage();
    void UpdatePerkHeadShots();
    void AddToHeadShotCombo();
    void GetMaxHeadShotComboCount();
    void GetZTStunActive();
    void IsZTStunActive();
    void GetZTKnockdownActive();
    void IsZTKnockdownActive();
    void IsAmmoPouchActive();
    void GetScopedActive();
    void IsScopedActive();
    void IsTacticalReloadActive();
    void IsRhythmMethodActive();
    void IsStunActive();
    void IsCrouchAimActive();
    void IsTriggerActive();
    void IsStationaryAimActive();
    void GetStunPowerModifier();
    void GetUsingTactialReload();
    void eventDestroyed();
    void eventPostSkillUpdate();
    void ModifyMaxSpareAmmoAmount();
    void GetCameraViewShakeScale();
    void eventGetCameraViewShakeModifier();
    void ModifyRecoil();
    void GetReloadRateScale();
    void ModifyRateOfFire();
    void ModifyDamageGiven();
    void ModifyWeaponSwitchTime();
    void ModifySpeed();
    void GetHeadshotXP();
    void GetPassiveStrings();
};

UClass* AKFPerk_Sharpshooter::pClassPointer = NULL;

// Class KFGame.KFPerk_Support
// 0x0170 (0x05FC - 0x048C)
class AKFPerk_Support : public AKFPerk {
   public:
    struct FPerkSkill Ammo;  // 0x048C (0x0038) [0x0000000000000000]
    struct FPerkSkill
        WeldingProficiency;           // 0x04C4 (0x0038) [0x0000000000000000]
    struct FPerkSkill ShotgunDamage;  // 0x04FC (0x0038) [0x0000000000000000]
    struct FPerkSkill
        ShotgunPenetration;      // 0x0534 (0x0038) [0x0000000000000000]
    struct FPerkSkill Strength;  // 0x056C (0x0038) [0x0000000000000000]
    TArray<struct FsSuppliedPawnInfo>
        SuppliedPawnList;                // 0x05A4 (0x0010) [0x0000000000000000]
    float BarrageFiringRate;             // 0x05B4 (0x0004) [0x0000000000000000]
    float ResupplyMaxSpareAmmoModifier;  // 0x05B8 (0x0004) [0x0000000000000000]
    class UAkEvent* ReceivedAmmoSound;   // 0x05BC (0x0008) [0x0000000000000000]
    class UAkEvent* ReceivedArmorSound;  // 0x05C4 (0x0008) [0x0000000000000000]
    class UAkEvent*
        ReceivedAmmoAndArmorSound;    // 0x05CC (0x0008) [0x0000000000000000]
    struct FName BoomstickClassName;  // 0x05D4 (0x0008) [0x0000000000000000]
    TArray<struct FName>
        AdditionalOnPerkDTNames;  // 0x05DC (0x0010) [0x0000000000000000]
    int DoorRepairXP[0x4];        // 0x05EC (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3239];

        return pClassPointer;
    };

    void PlayerDied();
    void LogPerkSkills();
    void LogTacticalReload();
    void GetDoorRepairXP();
    void CanRepairDoors();
    void IsPerforateActive();
    void IsResupplyActive();
    void IsConcussionRoundsActive();
    void IsTacticalReloadActive();
    void IsTightChokeActive();
    void IsAPShotActive();
    void IsSalvoActive();
    void IsFortitudeActive();
    void IsHighCapMagsMagActive();
    void CouldBarrageActive();
    void IsBarrageActive();
    void IsSupplierActive();
    void IsDamageTypeOnPerk();
    void GetPassiveStrings();
    void OnWaveEnded();
    void GetZedTimeModifier();
    void GetReceivedAmmoAndArmorSound();
    void GetReceivedArmorSound();
    void GetReceivedAmmoSound();
    void CanInteract();
    void Interact();
    void GetStumblePowerModifier();
    void GetTightChokeModifier();
    void ModifyHealth();
    void GetUsingTactialReload();
    void GetResupplyMaxSpareAmmoModifier();
    void ModifyMaxSpareAmmoAmount();
    void ModifySpareAmmoAmount();
    void ModifyMagSizeAndNumber();
    void IgnoresPenetrationDmgReduction();
    void GetPenetrationModifier();
    void ModifyWeldingRate();
    void ModifyDamageGiven();
    void ResetSupplier();
    void GetExtraStrength();
    void ApplyWeightLimits();
    void ApplySkillsToPawn();
};

UClass* AKFPerk_Support::pClassPointer = NULL;

// Class KFGame.KFPerk_Survivalist
// 0x0130 (0x05BC - 0x048C)
class AKFPerk_Survivalist : public AKFPerk {
   public:
    struct FPerkSkill WeaponDamage;      // 0x048C (0x0038) [0x0000000000000000]
    struct FPerkSkill DamageResistance;  // 0x04C4 (0x0038) [0x0000000000000000]
    struct FPerkSkill HeavyBodyArmor;    // 0x04FC (0x0038) [0x0000000000000000]
    struct FPerkSkill ZedTimeReload;     // 0x0534 (0x0038) [0x0000000000000000]
    float InjectionPotencyModifier;      // 0x056C (0x0004) [0x0000000000000000]
    float
        MeleeExpertAttackSpeedModifier;  // 0x0570 (0x0004) [0x0000000000000000]
    class UGameExplosion*
        ShrapnelExplosionTemplate;  // 0x0574 (0x0008) [0x0000000000000000]
    float ShrapnelChance;           // 0x057C (0x0004) [0x0000000000000000]
    float SnarePower;               // 0x0580 (0x0004) [0x0000000000000000]
    float MeleeExpertMovementSpeedModifier;  // 0x0584 (0x0004)
                                             // [0x0000000000000000]
    class UClass*
        HealingGrenadeWeaponDef;  // 0x0588 (0x0008) [0x0000000000000000]
    class UClass*
        MolotovGrenadeWeaponDef;  // 0x0590 (0x0008) [0x0000000000000000]
    TArray<class UClass*>
        PrimaryWeaponPaths;  // 0x0598 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        KnifeWeaponPaths;          // 0x05A8 (0x0010) [0x0000000000000000]
    int StartingWeaponClassIndex;  // 0x05B8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3241];

        return pClassPointer;
    };

    void GetGrenadeWeaponDef();
    void GetGrenadeImagePath();
    void GetPassiveStrings();
    void IsIncapMasterActive();
    void GetIncapMasterActive();
    void IsMadManActive();
    void GetMadManActive();
    void IsMakeThingsGoBoomActive();
    void IsZedShrapnelActive();
    void IsBigPocketsActive();
    void IsAmmoVestActive();
    void IsMeleeExpertActive();
    void IsFieldMedicActive();
    void IsHeavyReloadActive();
    void IsTacticalReloadActive();
    void GetGrenadeClass();
    void GetSnarePowerModifier();
    void GetStunPowerModifier();
    void GetStumblePowerModifier();
    void GetKnockdownPowerModifier();
    void GetZedTimeModifier();
    void GetAoERadiusModifier();
    void ShouldShrapnel();
    void GetExplosionTemplate();
    void CouldBeZedShrapnel();
    void ModifyMaxSpareAmmoAmount();
    void GetInjectionPotencyModifier();
    void ModifyHealAmount();
    void ModifyHealerRechargeTime();
    void IsWeaponOnPerkHeavy();
    void IsWeaponOnPerkLight();
    void GetUsingTactialReload();
    void ModifyArmor();
    void IsZedTimeReloadAllowed();
    void GetReloadRateScale();
    void HasHeavyArmor();
    void GetMeleeExpertAttackSpeedModifier();
    void GetMeleeExpertMovementSpeedModifier();
    void ModifySpeed();
    void ModifyMeleeAttackSpeed();
    void ModifyDamageTaken();
    void ModifyDamageGiven();
    void ShouldAutosellWeapon();
    void GetPrimaryWeaponClassPath();
    void ShouldGetAllTheXP();
    void ApplyWeightLimits();
    void SetPlayerDefaults();
};

UClass* AKFPerk_Survivalist::pClassPointer = NULL;

// Class KFGame.KFPerk_SWAT
// 0x00FC (0x0588 - 0x048C)
class AKFPerk_SWAT : public AKFPerk {
   public:
    struct FPerkSkill WeaponDamage;      // 0x048C (0x0038) [0x0000000000000000]
    struct FPerkSkill BulletResistance;  // 0x04C4 (0x0038) [0x0000000000000000]
    struct FPerkSkill MagSize;           // 0x04FC (0x0038) [0x0000000000000000]
    struct FPerkSkill
        WeaponSwitchSpeed;          // 0x0534 (0x0038) [0x0000000000000000]
    float RapidAssaultFiringRate;   // 0x056C (0x0004) [0x0000000000000000]
    float SnarePower;               // 0x0570 (0x0004) [0x0000000000000000]
    float TacticalMovementBobDamp;  // 0x0574 (0x0004) [0x0000000000000000]
    class UClass*
        BackupSecondaryWeaponDef;   // 0x0578 (0x0008) [0x0000000000000000]
    float HeavyArmorAbsorptionPct;  // 0x0580 (0x0004) [0x0000000000000000]
    float CurrentHealthPenalty;     // 0x0584 (0x0004) [0x0000000000160000] (
                                 // CPF_EditConst | CPF_GlobalConfig )

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3243];

        return pClassPointer;
    };

    void GetPassiveStrings();
    void GetClotKillXP();
    void IsRapidAssaultActive();
    void IsSWATEnforcerActive();
    void IsCrippleActive();
    void IsBodyArmorActive();
    void IsAmmoVestActive();
    void IsSpecialAmmunitionActive();
    void GetUsingTactialReload();
    void IsTacticalReloadActive();
    void IsBackupActive();
    void IsTacticalMovementActive();
    void IsHeavyArmorActive();
    void GetArmorDamageAmount();
    void ShouldKnockDownOnBump();
    void GetIsUberAmmoActive();
    void GetStumblePowerModifier();
    void GetZedTimeModifier();
    void ModifyArmor();
    void GetSnarePowerModifier();
    void GetSnareSpeedModifier();
    void ModifyMaxSpareAmmoAmount();
    void ModifyDamageGiven();
    void ModifyWeaponBopDamping();
    void eventGetCrouchSpeedModifier();
    void FinalizeSpeedVariables();
    void eventGetIronSightSpeedModifier();
    void Is9mm();
    void HasHeavyArmor();
    void CanNotBeGrabbed();
    void ModifyWeaponSwitchTime();
    void ModifyMagSizeAndNumber();
    void ModifyDamageTaken();
    void GetSecondaryWeaponClassPath();
    void ApplySkillsToPawn();
    void SetPlayerDefaults();
};

UClass* AKFPerk_SWAT::pClassPointer = NULL;

// Class KFGame.KFPickupFactory
// 0x0008 (0x03B0 - 0x03A8)
class AKFPickupFactory : public APickupFactory {
   public:
    DWORD bToBeActivated : 1;  // 0x03A8 (0x0004) [0x0000000000000000]
                               // [0x00000001]
    DWORD
        bKismetDriven : 1;  // 0x03A8 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bUseRespawnTimeOverride : 1;  // 0x03A8 (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    DWORD bEnabledAtStart : 1;          // 0x03A8 (0x0004) [0x0000000000000000]
                                        // [0x00000008]
    DWORD bKismetEnabled : 1;           // 0x03A8 (0x0004) [0x0000000000000000]
                                        // [0x00000010]
    float RespawnTime;                  // 0x03AC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3245];

        return pClassPointer;
    };

    void SetPickupVisible();
    void SetPickupHidden();
    void CurrentPickupIsAmmo();
    void CurrentPickupIsArmor();
    void CurrentPickupIsWeapon();
    void DelayRespawn();
    void StartSleeping();
    void GetRespawnTime();
    void SetRespawn();
    void OnToggle();
    void eventSetInitialState();
    void Reset();
};

UClass* AKFPickupFactory::pClassPointer = NULL;

// Class KFGame.KFPickupFactory_Item
// 0x0019 (0x03C9 - 0x03B0)
class AKFPickupFactory_Item : public AKFPickupFactory {
   public:
    TArray<struct FItemPickup>
        ItemPickups;              // 0x03B0 (0x0010) [0x0000000000000000]
    struct FName ArmorClassName;  // 0x03C0 (0x0008) [0x0000000000000000]
    unsigned char
        PickupIndex;  // 0x03C8 (0x0001) [0x0000000000170000]              (
                      // CPF_Travel | CPF_EditConst | CPF_GlobalConfig )

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3247];

        return pClassPointer;
    };

    void CurrentPickupIsArmor();
    void CurrentPickupIsWeapon();
    void ActivateNewPickup();
    void GiveWeapon();
    void GiveArmor();
    void GiveTo();
    void SetPickupMesh();
    void ChooseWeaponPickup();
    void SetRespawn();
    void Reset();
    void eventSetInitialState();
    void InitializePickup();
    void eventReplicatedEvent();
};

UClass* AKFPickupFactory_Item::pClassPointer = NULL;

// Class KFGame.KFProfileSettings
// 0x0034 (0x00F8 - 0x00C4)
class UKFProfileSettings : public UOnlineProfileSettings {
   public:
    TArray<struct FCustomizationInfo>
        Characters;  // 0x00C4 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        FavoriteWeapons;  // 0x00D4 (0x0010) [0x0000000000000000]
    TArray<struct FWeaponSkinPairs>
        ActiveSkins;  // 0x00E4 (0x0010) [0x0000000000000000]
    DWORD Dirty : 1;  // 0x00F4 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3249];

        return pClassPointer;
    };

    void ExpandExtraFromProfileSettings();
    void FlattenExtraToProfileSettings();
    void eventSetToDefaults();
    void PushProfileSettingsToClasses();
    void SetCharacterGear();
    void GetDefaultFloat();
    void GetDefaultBool();
    void GetDefaultInt();
    void eventGetProfileString();
    void eventGetProfileFloat();
    void eventGetProfileBool();
    void eventGetProfileInt();
    void SetProfileSettingValueFloat();
    void SetProfileSettingValueBool();
    void SetProfileSettingValueInt();
    void HasSafeFrameSet();
    void eventApplyWeaponSkin();
    void ClearWeaponSkin();
    void SaveWeaponSkin();
    void eventSave();
    void eventUnFavoriteWeapon();
    void eventFavoriteWeapon();
};

UClass* UKFProfileSettings::pClassPointer = NULL;

// Class KFGame.KFProjectile
// 0x00FC (0x039C - 0x02A0)
class AKFProjectile : public AProjectile {
   public:
    struct FVector
        OriginalLocation;  // 0x02A0 (0x000C) [0x0000000000150019] ( CPF_Edit |
                           // CPF_ExportObject | CPF_OptionalParm | CPF_Travel |
                           // CPF_GlobalConfig )
    DWORD bSyncToOriginalLocation : 1;  // 0x02AC (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bSyncToThirdPersonMuzzleLocation : 1;  // 0x02AC (0x0004)
                                                 // [0x0000000000000000]
                                                 // [0x00000002]
    DWORD bFiredFromLeftHandWeapon : 1;  // 0x02AC (0x0004) [0x0000000000160032]
                                         // [0x00000004] ( CPF_Const |
                                         // CPF_OptionalParm | CPF_Net |
                                         // CPF_EditConst | CPF_GlobalConfig )
    DWORD bNoReplicationToInstigator : 1;  // 0x02AC (0x0004)
                                           // [0x0000000000000000] [0x00000008]
    DWORD bUseClientSideHitDetection : 1;  // 0x02AC (0x0004)
                                           // [0x0000000000000000] [0x00000010]
    DWORD bReplicateClientHitsAsFragments : 1;  // 0x02AC (0x0004)
                                                // [0x0000000000000000]
                                                // [0x00000020]
    DWORD bDamageDestructiblesOnTouch : 1;      // 0x02AC (0x0004)
                                            // [0x0000000000000000] [0x00000040]
    DWORD bHasExploded : 1;  // 0x02AC (0x0004) [0x000000000017004B]
                             // [0x00000080] ( CPF_Edit | CPF_Const |
                             // CPF_ExportObject | CPF_EditConstArray |
                             // CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
    DWORD bWasTimeDilated : 1;  // 0x02AC (0x0004) [0x000000000018004B]
                                // [0x00000100] ( CPF_Edit | CPF_Const |
                                // CPF_ExportObject | CPF_EditConstArray |
                                // CPF_Component )
    DWORD
        bReplicateLocationOnExplosion : 1;  // 0x02AC (0x0004)
                                            // [0x0000000000000000] [0x00000200]
    DWORD bValidateExplosionNormalOnClient : 1;  // 0x02AC (0x0004)
                                                 // [0x0000000000000000]
                                                 // [0x00000400]
    DWORD bHasDisintegrated : 1;  // 0x02AC (0x0004) [0x0000000000190000]
                                  // [0x00000800] ( CPF_Travel | CPF_Component )
    DWORD bAlwaysReplicateDisintegration : 1;  // 0x02AC (0x0004)
                                               // [0x0000000000000000]
                                               // [0x00001000]
    DWORD bAlwaysReplicateExplosion : 1;       // 0x02AC (0x0004)
                                          // [0x0000000000000000] [0x00002000]
    DWORD bAttachExplosionToHitMover : 1;  // 0x02AC (0x0004)
                                           // [0x0000000000000000] [0x00004000]
    DWORD bCanDisintegrate : 1;       // 0x02AC (0x0004) [0x0000000000000000]
                                      // [0x00008000]
    DWORD bAltExploEffects : 1;       // 0x02AC (0x0004) [0x00000000001A0064]
                                      // [0x00010000] ( CPF_Input | CPF_Net |
                                      // CPF_EditConstArray | CPF_EditConst |
                                      // CPF_Component )
    DWORD bFadingOutProjEffects : 1;  // 0x02AC (0x0004) [0x0000000000000000]
                                      // [0x00020000]
    DWORD bWaitForEffects : 1;        // 0x02AC (0x0004) [0x0000000000000000]
                                      // [0x00040000]
    DWORD
        bShuttingDown : 1;  // 0x02AC (0x0004) [0x0000000000000000] [0x00080000]
    DWORD bSuppressSounds : 1;         // 0x02AC (0x0004) [0x0000000000000000]
                                       // [0x00100000]
    DWORD bAutoStartAmbientSound : 1;  // 0x02AC (0x0004) [0x0000000000000000]
                                       // [0x00200000]
    DWORD bStopAmbientSoundOnExplode : 1;  // 0x02AC (0x0004)
                                           // [0x0000000000000000] [0x00400000]
    DWORD bImportantAmbientSound : 1;    // 0x02AC (0x0004) [0x0000000000000000]
                                         // [0x00800000]
    DWORD bAmbientSoundZedTimeOnly : 1;  // 0x02AC (0x0004) [0x0000000000000000]
                                         // [0x01000000]
    DWORD bIsAIProjectile : 1;           // 0x02AC (0x0004) [0x0000000000000000]
                                         // [0x02000000]
    DWORD bWarnAIWhenFired : 1;          // 0x02AC (0x0004) [0x0000000000000000]
                                         // [0x04000000]
    float
        AlwaysRelevantDistanceSquared;  // 0x02B0 (0x0004) [0x0000000000000000]
    unsigned char WeaponFireMode;  // 0x02B4 (0x0001) [0x00000000001B006E] (
                                   // CPF_Const | CPF_Input | CPF_ExportObject |
                                   // CPF_Net | CPF_EditConstArray | CPF_Travel
                                   // | CPF_EditConst | CPF_Component )
    unsigned char GlassShatterType;  // 0x02B5 (0x0001) [0x0000000000000000]
    unsigned char
        ProjFlightLightPriority;    // 0x02B6 (0x0001) [0x0000000000000000]
    float InitialPenetrationPower;  // 0x02B8 (0x0004) [0x00000000001C0064] (
                                    // CPF_Input | CPF_Net | CPF_EditConstArray
                                    // | CPF_GlobalConfig | CPF_Component )
    float PenetrationPower;         // 0x02BC (0x0004) [0x0000000000000000]
    struct FTouchInfo LastTouched;  // 0x02C0 (0x000C) [0x0000000000000000]
    struct FTouchInfo LastBounced;  // 0x02CC (0x000C) [0x0000000000000000]
    float TouchTimeThreshhold;      // 0x02D8 (0x0004) [0x0000000000000000]
    float TossZ;                    // 0x02DC (0x0004) [0x0000000000000000]
    float GravityScale;             // 0x02E0 (0x0004) [0x0000000000000000]
    class UPrimitiveComponent*
        LastTouchComponent;  // 0x02E4 (0x0008) [0x0000000000000000]
    TArray<struct FVector>
        ExtraLineCollisionOffsets;      // 0x02EC (0x0010) [0x0000000000000000]
    float TerminalVelocity;             // 0x02FC (0x0004) [0x0000000000000000]
    class UClass* ExplosionActorClass;  // 0x0300 (0x0008) [0x0000000000000000]
    class UKFGameExplosion*
        ExplosionTemplate;              // 0x0308 (0x0008) [0x0000000000000000]
    class UAkEvent* DisintegrateSound;  // 0x0310 (0x0008) [0x0000000000000000]
    class UParticleSystem*
        ProjDisintegrateTemplate;  // 0x0318 (0x0008) [0x0000000000000000]
    class UParticleSystemComponent*
        ProjDisintegrateEffects;  // 0x0320 (0x0008) [0x0000000000000000]
    struct FRotator
        DisintegrateEffectRotation;  // 0x0328 (0x000C) [0x00000000001D0000] (
                                     // CPF_Travel | CPF_GlobalConfig |
                                     // CPF_Component )
    class AGameExplosionActor*
        ExplosionActor;           // 0x0334 (0x0008) [0x0000000000000000]
    float PostExplosionLifetime;  // 0x033C (0x0004) [0x0000000000000000]
    class UKFImpactEffectInfo*
        AltExploEffects;  // 0x0340 (0x0008) [0x0000000000000000]
    class UParticleSystemComponent*
        ProjEffects;  // 0x0348 (0x0008) [0x0000000000000000]
    class UParticleSystem*
        ProjFlightTemplate;            // 0x0350 (0x0008) [0x0000000000000000]
    float ProjEffectsFadeOutDuration;  // 0x0358 (0x0004) [0x0000000000000000]
    class UPointLightComponent*
        ProjFlightLight;  // 0x035C (0x0008) [0x0000000000000000]
    class UParticleSystem*
        ProjFlightTemplateZedTime;  // 0x0364 (0x0008) [0x0000000000000000]
    class UAkEvent*
        AmbientSoundPlayEvent;  // 0x036C (0x0008) [0x0000000000000000]
    class UAkEvent*
        AmbientSoundStopEvent;  // 0x0374 (0x0008) [0x0000000000000000]
    class UAkComponent*
        AmbientComponent;  // 0x037C (0x0008) [0x0000000000000000]
    class UKFImpactEffectInfo*
        ImpactEffects;                  // 0x0384 (0x0008) [0x0000000000000000]
    class UClass* AssociatedPerkClass;  // 0x038C (0x0008) [0x0000000000000000]
    float MaxAIWarningDistSQ;           // 0x0394 (0x0004) [0x0000000000000000]
    float MaxAIWarningDistFromPointSQ;  // 0x0398 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3251];

        return pClassPointer;
    };

    void SpawnResidualFlame();
    void CalculateResidualFlameVelocity();
    void OnInstigatorControllerLeft();
    void Timer_Explode();
    void Detonate();
    void StopFlightEffects();
    void SpawnFlightEffects();
    void GetGravityZ();
    void Destroyed();
    void DeferredDestroy();
    void StopSimulating();
    void ShutDown();
    void SetExplosionActorClass();
    void PrepareExplosionActor();
    void GetExplosionDirection();
    void GetRadialDamageValues();
    void PrepareExplosionTemplate();
    void AllowNuke();
    void TriggerExplosion();
    void Disintegrate();
    void AdjustCanDisintigrate();
    void Explode();
    void eventLanded();
    void TraceProjHitZones();
    void CallExplode();
    void ProcessBulletTouch();
    void ProcessDestructibleTouchOnBounce();
    void Bounce();
    void CheckRepeatingTouch();
    void ProcessTouch();
    void eventTouch();
    void NotifyHitDestructible();
    void eventHitWall();
    void CalculateStickOrientation();
    void GetPredictedHitLocation();
    void SyncOriginalLocation();
    void ValidateExplosionNormal();
    void eventReplicatedEvent();
    void IsAIProjectile();
    void ShouldWarnAIWhenFired();
    void WarnAI();
    void Init();
    void PostBeginPlay();
    void eventPreBeginPlay();
    void StopAmbientSound();
    void GetTerminalVelocity();
};

UClass* AKFProjectile::pClassPointer = NULL;

// Class KFGame.KFProj_Bullet
// 0x0004 (0x03A0 - 0x039C)
class AKFProj_Bullet : public AKFProjectile {
   public:
    float ProjEffectsScale;  // 0x039C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3253];

        return pClassPointer;
    };

    void TriggerExplosion();
    void PassThroughDamage();
    void ProcessTouch();
    void Init();
};

UClass* AKFProj_Bullet::pClassPointer = NULL;

// Class KFGame.KFProj_Grenade
// 0x002D (0x03C9 - 0x039C)
class AKFProj_Grenade : public AKFProjectile {
   public:
    float FuseTime;  // 0x039C (0x0004) [0x0000000000000000]
    class UKFImpactEffectInfo*
        GrenadeBounceEffectInfo;  // 0x03A0 (0x0008) [0x0000000000000000]
    float DampenFactor;           // 0x03A8 (0x0004) [0x0000000000000000]
    float DampenFactorParallel;   // 0x03AC (0x0004) [0x0000000000000000]
    struct FVector
        LandedTranslationOffset;  // 0x03B0 (0x000C) [0x0000000000000000]
    DWORD bAllowTossDuringZedGrabRotation : 1;  // 0x03BC (0x0004)
                                                // [0x0000000000000000]
                                                // [0x00000001]
    class UTexture2D*
        WeaponSelectTexture;  // 0x03C0 (0x0008) [0x0000000000000000]
    unsigned char
        TeamNum;  // 0x03C8 (0x0001) [0x00000000001E0000]              (
                  // CPF_EditConst | CPF_GlobalConfig | CPF_Component )

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3255];

        return pClassPointer;
    };

    void ProcessTouch();
    void eventGrenadeIsAtRest();
    void Bounce();
    void eventHitWall();
    void GetExplodeEffectLocation();
    void Destroyed();
    void ExplodeTimer();
    void GetTeamNum();
    void EnableGrenadeWarning();
    void SpawnFlightEffects();
    void eventPostBeginPlay();
    void eventPreBeginPlay();
    void eventReplicatedEvent();
};

UClass* AKFProj_Grenade::pClassPointer = NULL;

// Class KFGame.KFPruneSkeletalMeshCommandlet
// 0x0000 (0x00B4 - 0x00B4)
class UKFPruneSkeletalMeshCommandlet : public UCommandlet {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3257];

        return pClassPointer;
    };

    void eventMain();
};

UClass* UKFPruneSkeletalMeshCommandlet::pClassPointer = NULL;

// Class KFGame.KFRealtimeTimerHelper
// 0x0000 (0x0244 - 0x0244)
class AKFRealtimeTimerHelper : public AActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3259];

        return pClassPointer;
    };

    void eventDestroyed();
    void ClientStopNetworkedVoice();
};

UClass* AKFRealtimeTimerHelper::pClassPointer = NULL;

// Class KFGame.KFSkeletalMeshComponent
// 0x0038 (0x0858 - 0x0820)
class UKFSkeletalMeshComponent : public USkeletalMeshComponent {
   public:
    struct FBoneAtom
        CachedExtractedRootMotionDelta;  // 0x0820 (0x0020) [0x0000000000000000]
    int bCachedHasRootMotion;            // 0x0840 (0x0004) [0x0000000000000000]
    DWORD bNeedsProcessRootMotion : 1;   // 0x0844 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bForceLoadTextures : 1;        // 0x0844 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bPendingDeferredWork : 1;      // 0x0844 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    float FOV;                           // 0x0848 (0x0004) [0x0000000000000000]
    float ClearStreamingTime;            // 0x084C (0x0004) [0x0000000000000000]
    float MinTickTimeStep;               // 0x0850 (0x0004) [0x0000000000000000]
    float HeadBoneScale;                 // 0x0854 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3261];

        return pClassPointer;
    };

    void GetAnimNotifyTime();
    void GetReloadAmmoTime();
    void GetAnimInterruptTime();
    void eventPlayParticleEffect();
    void SetFOV();
    void eventPreloadTextures();
};

UClass* UKFSkeletalMeshComponent::pClassPointer = NULL;

// Class KFGame.KFSpawner
// 0x005C (0x02A0 - 0x0244)
class AKFSpawner : public AActor {
   public:
    DWORD bIsTriggeredSpawner : 1;    // 0x0244 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bRandomizeSpawnYawRot : 1;  // 0x0244 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bRequiredZedAmountTouching : 1;  // 0x0244 (0x0004)
                                           // [0x0000000000000000] [0x00000004]
    DWORD bIsActive : 1;    // 0x0244 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bIsSpawning : 1;  // 0x0244 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bDebugSpawning : 1;         // 0x0244 (0x0004) [0x0000000000000000]
                                      // [0x00000020]
    DWORD bIgnoreChildren : 1;        // 0x0244 (0x0004) [0x0000000000000000]
                                      // [0x00000040]
    unsigned char LargestSquadType;   // 0x0248 (0x0001) [0x0000000000000000]
    unsigned char LastAnimDirection;  // 0x0249 (0x0001) [0x0000000000000000]
    unsigned char EmergeAnim;         // 0x024A (0x0001) [0x0000000000000000]
    float MaxStayActiveTime;          // 0x024C (0x0004) [0x0000000000000000]
    float CoolDownTime;               // 0x0250 (0x0004) [0x0000000000000000]
    float SpawnInterval;              // 0x0254 (0x0004) [0x0000000000000000]
    int LastSpawnYawRot;              // 0x0258 (0x0004) [0x0000000000000000]
    class AActor*
        ActorToReacquirePlayerTouch;  // 0x025C (0x0008) [0x0000000000000000]
    float MinReacquireTouchTime;      // 0x0264 (0x0004) [0x0000000000000000]
    float ReacquireTouchTimeLeft;     // 0x0268 (0x0004) [0x0000000000000000]
    int NumTouchingZedsRequired;      // 0x026C (0x0004) [0x0000000000000000]
    TArray<class AKFSpawner*>
        ChildSpawners;  // 0x0270 (0x0010) [0x0000000000000000]
    TArray<class UClass*>
        PendingSpawns;         // 0x0280 (0x0010) [0x0000000000000000]
    float LastActivationTime;  // 0x0290 (0x0004) [0x0000000000000000]
    float LastSpawnTime;       // 0x0294 (0x0004) [0x0000000000000000]
    class AKFDestructibleActor*
        DestructibleToBreak;  // 0x0298 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3263];

        return pClassPointer;
    };

    void TestSpawn();
    void eventHandleFailedSpawn();
    void eventHandleSpawn();
    void AddPendingSpawns();
    void SpawnSquad();
    void ReacquireZedTouch();
    void ReacquirePlayerTouch();
    void CanSpawnHere();
    void DeactivateSpawner();
    void ActivateSpawner();
    void OnToggle();
};

UClass* AKFSpawner::pClassPointer = NULL;

// Class KFGame.KFSpawnRenderingComponent
// 0x0000 (0x0238 - 0x0238)
class UKFSpawnRenderingComponent : public UPrimitiveComponent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3265];

        return pClassPointer;
    };
};

UClass* UKFSpawnRenderingComponent::pClassPointer = NULL;

// Class KFGame.KFSpawnVolume
// 0x00A4 (0x0324 - 0x0280)
class AKFSpawnVolume : public AVolume {
   public:
    TArray<struct FSpawnMarkerInfo>
        SpawnMarkerInfoList;  // 0x0280 (0x0010) [0x0000000000000000]
    int MaxSpawnMarkers;      // 0x0290 (0x0004) [0x0000000000000000]
    TArray<struct FDoorListInfo>
        DoorList;                        // 0x0294 (0x0010) [0x0000000000000000]
    struct FRotator SpawnRotation;       // 0x02A4 (0x000C) [0x0000000000000000]
    DWORD bCanUseForSpawning : 1;        // 0x02B0 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bNoCollisionFailForSpawn : 1;  // 0x02B0 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bUsePredictiveVisibilityChecks : 1;  // 0x02B0 (0x0004)
                                               // [0x0000000000000000]
                                               // [0x00000004]
    DWORD bDebugVisibilityChecks : 1;  // 0x02B0 (0x0004) [0x0000000000000000]
                                       // [0x00000008]
    DWORD bDebugRatingChecks : 1;      // 0x02B0 (0x0004) [0x0000000000000000]
                                       // [0x00000010]
    DWORD bMinimalDebugRatingChecks : 1;  // 0x02B0 (0x0004)
                                          // [0x0000000000000000] [0x00000020]
    DWORD bDebugSpawning : 1;  // 0x02B0 (0x0004) [0x0000000000000000]
                               // [0x00000040]
    DWORD bNoPlayers : 1;  // 0x02B0 (0x0004) [0x0000000000000000] [0x00000080]
    DWORD bNoZAxisDistPenalty : 1;  // 0x02B0 (0x0004) [0x0000000000000000]
                                    // [0x00000100]
    DWORD bOutOfSight : 1;  // 0x02B0 (0x0004) [0x0000000000000000] [0x00000200]
    DWORD bCachedVisibility : 1;      // 0x02B0 (0x0004) [0x0000000000000000]
                                      // [0x00000400]
    DWORD bExclusiveBossVolumes : 1;  // 0x02B0 (0x0004) [0x0000000000000000]
                                      // [0x00000800]
    DWORD bDisabled : 1;  // 0x02B0 (0x0004) [0x0000000000000000] [0x00001000]
    struct FColor
        DefaultSpawnMarkerColor;  // 0x02B4 (0x0004) [0x0000000000000000]
    struct FColor
        SpawnInteriorBoxColor;  // 0x02B8 (0x0004) [0x0000000000000000]
    struct FBoxSphereBounds
        VisibilityBounds;             // 0x02BC (0x001C) [0x0000000000000000]
    struct FVector SpawnBoundsScale;  // 0x02D8 (0x000C) [0x0000000000000000]
    unsigned char LargestSquadType;   // 0x02E4 (0x0001) [0x0000000000000000]
    float DesirabilityMod;            // 0x02E8 (0x0004) [0x0000000000000000]
    float MaxHeightDiffToPlayers;     // 0x02EC (0x0004) [0x0000000000000000]
    float MinDistanceToPlayer;        // 0x02F0 (0x0004) [0x0000000000000000]
    float MaxDistanceToPlayer;        // 0x02F4 (0x0004) [0x0000000000000000]
    float CurrentRating;              // 0x02F8 (0x0004) [0x0000000000000000]
    float CachedVisibilityTime;       // 0x02FC (0x0004) [0x0000000000000000]
    float SpawnDerateTime;            // 0x0300 (0x0004) [0x0000000000000000]
    float TeleportDerateTime;         // 0x0304 (0x0004) [0x0000000000000000]
    float LastSpawnTime;              // 0x0308 (0x0004) [0x0000000000000000]
    float NextSpawnTime;              // 0x030C (0x0004) [0x0000000000000000]
    float UnTouchCoolDownTime;        // 0x0310 (0x0004) [0x0000000000000000]
    float LastUnTouchTime;            // 0x0314 (0x0004) [0x0000000000000000]
    class UKFSpawnRenderingComponent*
        DebugComponent;     // 0x0318 (0x0008) [0x0000000000000000]
    int VolumeChosenCount;  // 0x0320 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3267];

        return pClassPointer;
    };

    void HandleTeleportedTo();
    void SetLastSpawnTime();
    void eventRateVolume();
    void IsValidForSpawn();
    void OnToggle();
    void eventUnTouch();
    void IsTouchingAlivePawn();
    void IsVisibleFrom();
    void IsVisible();
    void RateDistance();
    void FindSpawnLocation();
    void FindTeleportLocation();
    void SpawnWave();
};

UClass* AKFSpawnVolume::pClassPointer = NULL;

// Class KFGame.KFSteamWebAPICall
// 0x0048 (0x00A8 - 0x0060)
class UKFSteamWebAPICall : public UObject {
   public:
    struct FPointer
        VfTable_FTickableObject;  // 0x0060 (0x0008) [0x0000000000000000]
    float RequestTimeout;         // 0x0068 (0x0004) [0x0000000000000000]
    struct FString steamAPIAddr;  // 0x006C (0x0010) [0x0000000000000000]
    struct FString Format;        // 0x007C (0x0010) [0x0000000000000000]
    struct FPointer Downloader;   // 0x008C (0x0008) [0x0000000000000000]
    DWORD bDebug : 1;  // 0x0094 (0x0004) [0x0000000000000000] [0x00000001]
    struct FString APICall;  // 0x0098 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3269];

        return pClassPointer;
    };

    void ProcessResponse();
    void eventFinished();
    void SendHTTPGet();
    void CallWebProcedure();
};

UClass* UKFSteamWebAPICall::pClassPointer = NULL;

// Class KFGame.KFSteamWebUpToDateCheck
// 0x0004 (0x00AC - 0x00A8)
class UKFSteamWebUpToDateCheck : public UKFSteamWebAPICall {
   public:
    int APIAppID;  // 0x00A8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3271];

        return pClassPointer;
    };

    void ProcessResponse();
    void eventSendUpToDateCheck();
};

UClass* UKFSteamWebUpToDateCheck::pClassPointer = NULL;

// Class KFGame.KFTraderTrigger
// 0x0030 (0x0284 - 0x0254)
class AKFTraderTrigger : public ATrigger_PawnsOnly {
   public:
    class ASkeletalMeshActor*
        TraderMeshActor;               // 0x0254 (0x0008) [0x0000000000000000]
    struct FName OpenAnimName;         // 0x025C (0x0008) [0x0000000000000000]
    struct FName IdleLoopAnimName;     // 0x0264 (0x0008) [0x0000000000000000]
    class UAkEvent* TraderOpenSound;   // 0x026C (0x0008) [0x0000000000000000]
    class UAkEvent* TraderCloseSound;  // 0x0274 (0x0008) [0x0000000000000000]
    DWORD bOpened : 1;     // 0x027C (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bLogTrader : 1;  // 0x027C (0x0004) [0x0000000000000000] [0x00000002]
    float DistanceOffNavMeshTheTragerIsAllowedToBe;  // 0x0280 (0x0004)
                                                     // [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3273];

        return pClassPointer;
    };

    void HideTraderPath();
    void CloseTrader();
    void ShowTraderPath();
    void StartTraderLoopAnim();
    void OpenTrader();
    void UsedBy();
    void eventUnTouch();
    void eventTouch();
    void GetInteractionIndex();
    void GetIsUsable();
};

UClass* AKFTraderTrigger::pClassPointer = NULL;

// Class KFGame.KFTrigger_ChokePoint
// 0x0008 (0x025C - 0x0254)
class AKFTrigger_ChokePoint : public ATrigger_PawnsOnly {
   public:
    DWORD bReduceCollisionRadius : 1;    // 0x0254 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bReduceTeammateCollision : 1;  // 0x0254 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    float MaxCollisionRadius;            // 0x0258 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3275];

        return pClassPointer;
    };

    void PartialReduceTeammateCollision();
    void CanReduceTeammateCollision();
    void CanRestoreChokeCollision();
    void eventUnTouch();
    void eventTouch();
};

UClass* AKFTrigger_ChokePoint::pClassPointer = NULL;

// Class KFGame.KFDoorTrigger
// 0x0008 (0x0264 - 0x025C)
class AKFDoorTrigger : public AKFTrigger_ChokePoint {
   public:
    class AKFDoorActor* DoorActor;  // 0x025C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3277];

        return pClassPointer;
    };

    void PartialReduceTeammateCollision();
    void CanReduceTeammateCollision();
    void CanRestoreChokeCollision();
    void UsedBy();
    void GetInteractionIndex();
    void GetIsUsable();
    void OnDestroyOrReset();
    void eventUnTouch();
    void eventTouch();
    void eventPostBeginPlay();
};

UClass* AKFDoorTrigger::pClassPointer = NULL;

// Class KFGame.KFTrigger_MinigameButton
// 0x0038 (0x028C - 0x0254)
class AKFTrigger_MinigameButton : public ATrigger_PawnsOnly {
   public:
    DWORD bActiveGame : 1;  // 0x0254 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bDeactivateOnPress : 1;  // 0x0254 (0x0004) [0x0000000000000000]
                                   // [0x00000002]
    DWORD bInProgress : 1;  // 0x0254 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bAllowActivation : 1;  // 0x0254 (0x0004) [0x0000000000000000]
                                 // [0x00000008]
    float DeactivationTime;      // 0x0258 (0x0004) [0x0000000000000000]
    float ReactivationTime;      // 0x025C (0x0004) [0x0000000000000000]
    TArray<class UKFInterface_MinigameActor*>
        MinigameActors;  // 0x0260 (0x0010) [0x0000000000000000]
    TArray<class AKFTrigger_MinigameButton*>
        LinkedButtons;                // 0x0270 (0x0010) [0x0000000000000000]
    float ActivationDelay;            // 0x0280 (0x0004) [0x0000000000000000]
    class APawn* LastActivatingUser;  // 0x0284 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3279];

        return pClassPointer;
    };

    void MinigameStateUpdated();
    void SetMinigameInactive();
    void SetMinigameActive();
    void DeActivate();
    void LinkedButtonsAllowActivation();
    void ActorsAllowActivation();
    void AllowReactivation();
    void ActivateGame();
    void UsedBy();
    void eventUnTouch();
    void eventTouch();
    void GetInteractionIndex();
    void ReadyToActivate();
    void GetIsUsable();
};

UClass* AKFTrigger_MinigameButton::pClassPointer = NULL;

// Class KFGame.KFTrigger_MinigameCash
// 0x0000 (0x028C - 0x028C)
class AKFTrigger_MinigameCash : public AKFTrigger_MinigameButton {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3281];

        return pClassPointer;
    };

    void eventTouch();
    void GetIsUsable();
};

UClass* AKFTrigger_MinigameCash::pClassPointer = NULL;

// Class KFGame.KFUnlockManager
// 0x001C (0x007C - 0x0060)
class UKFUnlockManager : public UObject {
   public:
    TArray<struct FSharedContent>
        SharedContentList;  // 0x0060 (0x0010) [0x0000000000000000]
    class UOnlineSubsystem*
        MyOnlineSubsystem;  // 0x0070 (0x0008) [0x0000000000000000]
    DWORD
        bDebugUnlocks : 1;  // 0x0078 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3283];

        return pClassPointer;
    };

    void TestSteamAPI();
    void ClearCharacterCustomization();
    void eventCheckCustomizationOwnership();
    void GetAvailableAttachment();
    void GetAvailableOutfit();
    void GetAvailableSkin();
    void GetAvailable();
    void eventGetAvailableCharacterArchetype();
    void eventGetEmoteAvailable();
    void GetWeaponSkinAvailable();
    void GetIDAvailable();
    void IsPlatformRestricted();
    void GetSharedContentPlayerList();
    void IsSharedContentUnlocked();
    void InitSharedUnlocksFor();
};

UClass* UKFUnlockManager::pClassPointer = NULL;

// Class KFGame.KFUsablePerkTrigger
// 0x0004 (0x0258 - 0x0254)
class AKFUsablePerkTrigger : public ATrigger_PawnsOnly {
   public:
    int InteractionIndex;  // 0x0254 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3285];

        return pClassPointer;
    };

    void UsedBy();
    void DestroyTrigger();
    void GetCanInteract();
    void eventUnTouch();
    void eventTouch();
    void GetInteractionIndex();
    void SetInteractionIndex();
    void GetIsUsable();
};

UClass* AKFUsablePerkTrigger::pClassPointer = NULL;

// Class KFGame.KFVersusNoGoVolume
// 0x0028 (0x04D8 - 0x04B0)
class AKFVersusNoGoVolume : public APostProcessVolume {
   public:
    TArray<class AStaticMeshActor*>
        NoGoWallActors;   // 0x04B0 (0x0010) [0x0000000000000000]
    DWORD bIsActive : 1;  // 0x04C0 (0x0004) [0x0000000000000000] [0x00000001]
    float LastTouchingCheckTime;   // 0x04C4 (0x0004) [0x0000000000000000]
    float NoGoHurtStartDelay;      // 0x04C8 (0x0004) [0x0000000000000000]
    class UClass* NoGoDamageType;  // 0x04CC (0x0008) [0x0000000000000000]
    float NoGoHurtInterval;        // 0x04D4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3287];

        return pClassPointer;
    };

    void GetNoGoHurtInterval();
    void GetNoGoDTClass();
    void eventTick();
    void SetActive();
    void IsLocalPlayerTouching();
    void CheckActivate();
    void eventTouch();
    void NotifyNoGoActive();
};

UClass* AKFVersusNoGoVolume::pClassPointer = NULL;

// Class KFGame.KFWeapon
// 0x0538 (0x08C0 - 0x0388)
class AKFWeapon : public AWeapon {
   public:
    class UMeshComponent* OverlayMesh;  // 0x0388 (0x0008) [0x0000000000000000]
    class UKFSkeletalMeshComponent*
        MySkelMesh;  // 0x0390 (0x0008) [0x0000000000000000]
    TArray<class UTexture2D*>
        FireModeIconPaths;               // 0x0398 (0x0010) [0x0000000000000000]
    unsigned char SingleFireSoundIndex;  // 0x03A8 (0x0001) [0x0000000000000000]
    unsigned char BurstAmount;           // 0x03A9 (0x0001) [0x0000000000000000]
    unsigned char InventoryGroup;        // 0x03AA (0x0001) [0x0000000000000000]
    unsigned char InventorySize;         // 0x03AB (0x0001) [0x0000000000000000]
    unsigned char
        AmmoCount[0x2];  // 0x03AC (0x0002) [0x0000000000170000]              (
                         // CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
    unsigned char
        MagazineCapacity[0x2];  // 0x03AE (0x0002) [0x000000000019002A] (
                                // CPF_Const | CPF_ExportObject | CPF_Net |
                                // CPF_Travel | CPF_Component )
    unsigned char ReloadStatus;         // 0x03B0 (0x0001) [0x0000000000000000]
    unsigned char ReloadAmountLeft;     // 0x03B1 (0x0001) [0x0000000000000000]
    unsigned char InitialReloadAmount;  // 0x03B2 (0x0001) [0x0000000000000000]
    DWORD bUseAltFireMode : 1;          // 0x03B4 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bStopAltFireOnNextRelease : 1;  // 0x03B4 (0x0004)
                                          // [0x0000000000000000] [0x00000002]
    DWORD bGamepadFireEntry : 1;       // 0x03B4 (0x0004) [0x0000000000000000]
                                       // [0x00000004]
    DWORD bTargetFrictionEnabled : 1;  // 0x03B4 (0x0004) [0x0000000000000000]
                                       // [0x00000008]
    DWORD bTargetAdhesionEnabled : 1;  // 0x03B4 (0x0004) [0x0000000000000000]
                                       // [0x00000010]
    DWORD
        bUsingSights : 1;  // 0x03B4 (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bHasIronSights : 1;       // 0x03B4 (0x0004) [0x0000000000000000]
                                    // [0x00000040]
    DWORD bIronSightOnBringUp : 1;  // 0x03B4 (0x0004) [0x0000000000000000]
                                    // [0x00000080]
    DWORD
        bForceHidden : 1;   // 0x03B4 (0x0004) [0x0000000000000000] [0x00000100]
    DWORD bZoomingIn : 1;   // 0x03B4 (0x0004) [0x0000000000000000] [0x00000200]
    DWORD bZoomingOut : 1;  // 0x03B4 (0x0004) [0x0000000000000000] [0x00000400]
    DWORD bDoingQuickDownZoom : 1;  // 0x03B4 (0x0004) [0x0000000000000000]
                                    // [0x00000800]
    DWORD bSkipZoomInRotation : 1;  // 0x03B4 (0x0004) [0x0000000000000000]
                                    // [0x00001000]
    DWORD bZoomInInterrupted : 1;   // 0x03B4 (0x0004) [0x0000000000000000]
                                    // [0x00002000]
    DWORD bZoomOutInterrupted : 1;  // 0x03B4 (0x0004) [0x0000000000000000]
                                    // [0x00004000]
    DWORD
        bFastZoomOut : 1;  // 0x03B4 (0x0004) [0x0000000000000000] [0x00008000]
    DWORD bHasScopePosition : 1;    // 0x03B4 (0x0004) [0x0000000000000000]
                                    // [0x00010000]
    DWORD bUsingScopePosition : 1;  // 0x03B4 (0x0004) [0x0000000000000000]
                                    // [0x00020000]
    DWORD DOF_bOverrideEnvironmentDOF : 1;  // 0x03B4 (0x0004)
                                            // [0x0000000000000000] [0x00040000]
    DWORD bWeaponNeedsServerPosition : 1;   // 0x03B4 (0x0004)
                                            // [0x0000000000000000] [0x00080000]
    DWORD bFollowAnimSeqCamera : 1;     // 0x03B4 (0x0004) [0x0000000000000000]
                                        // [0x00100000]
    DWORD bWarnAIWhenAiming : 1;        // 0x03B4 (0x0004) [0x0000000000000000]
                                        // [0x00200000]
    DWORD bCanRefillSecondaryAmmo : 1;  // 0x03B4 (0x0004) [0x0000000000000000]
                                        // [0x00400000]
    DWORD
        bGivenAtStart : 1;  // 0x03B4 (0x0004) [0x00000000001B002A] [0x00800000]
                            // ( CPF_Const | CPF_ExportObject | CPF_Net |
                            // CPF_Travel | CPF_EditConst | CPF_Component )
    DWORD bNoMagazine : 1;  // 0x03B4 (0x0004) [0x0000000000000000] [0x01000000]
    DWORD bCanBeReloaded : 1;       // 0x03B4 (0x0004) [0x0000000000000000]
                                    // [0x02000000]
    DWORD bReloadFromMagazine : 1;  // 0x03B4 (0x0004) [0x0000000000000000]
                                    // [0x04000000]
    DWORD bInfiniteSpareAmmo : 1;   // 0x03B4 (0x0004) [0x0000000000000000]
                                    // [0x08000000]
    DWORD
        bInfiniteAmmo : 1;  // 0x03B4 (0x0004) [0x0000000000000000] [0x10000000]
    DWORD bAllowClientAmmoTracking : 1;  // 0x03B4 (0x0004) [0x0000000000000000]
                                         // [0x20000000]
    DWORD bPlayingLoopingFireSnd : 1;    // 0x03B4 (0x0004) [0x0000000000000000]
                                         // [0x40000000]
    DWORD bPlayingLoopingFireAnim : 1;   // 0x03B4 (0x0004) [0x0000000000000000]
                                         // [0x80000000]
    DWORD bUseAnimLenEquipTime : 1;      // 0x03B8 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bHasFireLastAnims : 1;         // 0x03B8 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bUseAdditiveMoveAnim : 1;      // 0x03B8 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD bEnableTiltSkelControl : 1;    // 0x03B8 (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    DWORD bCheckBoltLockPostReload : 1;  // 0x03B8 (0x0004) [0x0000000000000000]
                                         // [0x00000010]
    DWORD bSuppressSounds : 1;           // 0x03B8 (0x0004) [0x0000000000000000]
                                         // [0x00000020]
    DWORD bPendingAutoSwitchOnDryFire : 1;  // 0x03B8 (0x0004)
                                            // [0x0000000000000000] [0x00000040]
    DWORD
        bPendingShow : 1;  // 0x03B8 (0x0004) [0x0000000000000000] [0x00000080]
    DWORD bHasFlashlight : 1;   // 0x03B8 (0x0004) [0x0000000000000000]
                                // [0x00000100]
    DWORD bHasLaserSight : 1;   // 0x03B8 (0x0004) [0x0000000000000000]
                                // [0x00000200]
    DWORD bIsBackupWeapon : 1;  // 0x03B8 (0x0004) [0x0000000000000000]
                                // [0x00000400]
    DWORD
        bLogAnimation : 1;  // 0x03B8 (0x0004) [0x0000000000000000] [0x00000800]
    DWORD bLogStates : 1;   // 0x03B8 (0x0004) [0x0000000000000000] [0x00001000]
    DWORD bPauseWithPlayersOnly : 1;  // 0x03B8 (0x0004) [0x0000000000000000]
                                      // [0x00002000]
    DWORD bDebugRecoilPosition : 1;   // 0x03B8 (0x0004) [0x0000000000000000]
                                      // [0x00004000]
    DWORD bLogAmmo : 1;  // 0x03B8 (0x0004) [0x0000000000000000] [0x00008000]
    float MinFiringPutDownPct;       // 0x03BC (0x0004) [0x0000000000000000]
    TArray<float> PenetrationPower;  // 0x03C0 (0x0010) [0x0000000000000000]
    TArray<struct FInterpCurveFloat>
        PenetrationDamageReductionCurve;  // 0x03D0 (0x0010)
                                          // [0x0000000000000000]
    float PenetrationPowerRemaining;  // 0x03E0 (0x0004) [0x0000000000000000]
    float ZedTimeResistance;          // 0x03E4 (0x0004) [0x0000000000000000]
    float
        GrenadeTossWeakZedGrabCooldown;  // 0x03E8 (0x0004) [0x0000000000000000]
    float ZedGrabGrenadeTossCooldown;    // 0x03EC (0x0004) [0x0000000000000000]
    float TargetFrictionDistanceMax;     // 0x03F0 (0x0004) [0x0000000000000000]
    float TargetAdhesionDistanceMax;     // 0x03F4 (0x0004) [0x0000000000000000]
    struct FInterpCurveFloat
        TargetAdhesionOffsetScaleCurve;  // 0x03F8 (0x0014) [0x0000000000000000]
    struct FInterpCurveFloat
        TargetAdhesionDistanceScaleCurve;  // 0x040C (0x0014)
                                           // [0x0000000000000000]
    struct FInterpCurveFloat
        TargetFrictionOffsetScaleCurve;  // 0x0420 (0x0014) [0x0000000000000000]
    struct FInterpCurveFloat
        TargetFrictionDistanceScaleCurve;  // 0x0434 (0x0014)
                                           // [0x0000000000000000]
    float AimCorrectionSize;  // 0x0448 (0x0004) [0x0000000000000000]
    class AKFPlayerController*
        KFPlayer;                        // 0x044C (0x0008) [0x0000000000000000]
    struct FVector HiddenWeaponsOffset;  // 0x0454 (0x000C) [0x0000000000000000]
    float MeshFOV;                       // 0x0460 (0x0004) [0x0000000000000000]
    float MeshIronSightFOV;              // 0x0464 (0x0004) [0x0000000000000000]
    float PlayerIronSightFOV;            // 0x0468 (0x0004) [0x0000000000000000]
    float PlayerSprintFOV;               // 0x046C (0x0004) [0x0000000000000000]
    struct FVector IronSightPosition;    // 0x0470 (0x000C) [0x0000000000000000]
    float ZoomTime;                      // 0x047C (0x0004) [0x0000000000000000]
    float ZoomInTime;                    // 0x0480 (0x0004) [0x0000000000000000]
    float ZoomOutTime;                   // 0x0484 (0x0004) [0x0000000000000000]
    struct FRotator ZoomInRotation;      // 0x0488 (0x000C) [0x0000000000000000]
    struct FRotator
        QuickWeaponDownRotation;         // 0x0494 (0x000C) [0x0000000000000000]
    float QuickWeaponDownTime;           // 0x04A0 (0x0004) [0x0000000000000000]
    float QuickWeaponDownFinishTime;     // 0x04A4 (0x0004) [0x0000000000000000]
    struct FRotator ZoomRotInterp;       // 0x04A8 (0x000C) [0x0000000000000000]
    struct FVector ZoomStartOffset;      // 0x04B4 (0x000C) [0x0000000000000000]
    float ZoomPartialTime;               // 0x04C0 (0x0004) [0x0000000000000000]
    struct FRotator ZoomRotStartOffset;  // 0x04C4 (0x000C) [0x0000000000000000]
    float ZoomWeaponFOVStart;            // 0x04D0 (0x0004) [0x0000000000000000]
    float LastZoomOutTime;               // 0x04D4 (0x0004) [0x0000000000000000]
    float FastZoomOutTime;               // 0x04D8 (0x0004) [0x0000000000000000]
    struct FVector ZoomTargetOffset;     // 0x04DC (0x000C) [0x0000000000000000]
    struct FVector ScopePosition;        // 0x04E8 (0x000C) [0x0000000000000000]
    float DOF_SharpRadius;               // 0x04F4 (0x0004) [0x0000000000000000]
    float DOF_FocalRadius;               // 0x04F8 (0x0004) [0x0000000000000000]
    float DOF_MinBlurSize;               // 0x04FC (0x0004) [0x0000000000000000]
    float DOF_MaxNearBlurSize;           // 0x0500 (0x0004) [0x0000000000000000]
    float DOF_MaxFarBlurSize;            // 0x0504 (0x0004) [0x0000000000000000]
    float DOF_ExpFalloff;                // 0x0508 (0x0004) [0x0000000000000000]
    float DOF_MaxFocalDistance;          // 0x050C (0x0004) [0x0000000000000000]
    float DOF_BlendInSpeed;              // 0x0510 (0x0004) [0x0000000000000000]
    float DOF_BlendOutSpeed;             // 0x0514 (0x0004) [0x0000000000000000]
    float DOF_FG_SharpRadius;            // 0x0518 (0x0004) [0x0000000000000000]
    float DOF_FG_FocalRadius;            // 0x051C (0x0004) [0x0000000000000000]
    float DOF_FG_MinBlurSize;            // 0x0520 (0x0004) [0x0000000000000000]
    float DOF_FG_MaxNearBlurSize;        // 0x0524 (0x0004) [0x0000000000000000]
    float DOF_FG_ExpFalloff;             // 0x0528 (0x0004) [0x0000000000000000]
    struct FVector GrenadeFireOffset;    // 0x052C (0x000C) [0x0000000000000000]
    float MaxAIWarningDistSQ;            // 0x0538 (0x0004) [0x0000000000000000]
    float MaxAIWarningDistFromPointSQ;   // 0x053C (0x0004) [0x0000000000000000]
    struct FVector2D AimWarningDelay;    // 0x0540 (0x0008) [0x0000000000000000]
    float AimWarningCooldown;            // 0x0548 (0x0004) [0x0000000000000000]
    struct FRotator LastAimRotation;     // 0x054C (0x000C) [0x0000000000000000]
    float LastAimWarningTime;            // 0x0558 (0x0004) [0x0000000000000000]
    float CurrentAimSettledTime;         // 0x055C (0x0004) [0x0000000000000000]
    float GroupPriority;                 // 0x0560 (0x0004) [0x0000000000000000]
    class UTexture2D*
        WeaponSelectTexture;  // 0x0564 (0x0008) [0x0000000000000000]
    class UTexture2D*
        SecondaryAmmoTexture;        // 0x056C (0x0008) [0x0000000000000000]
    float EquipAbortTime;            // 0x0574 (0x0004) [0x0000000000000000]
    class UClass* DualClass;         // 0x0578 (0x0008) [0x0000000000000000]
    TArray<unsigned char> AmmoCost;  // 0x0580 (0x0010) [0x0000000000000000]
    int SpareAmmoCount[0x2];         // 0x0590 (0x0008) [0x00000000001C002A] (
                              // CPF_Const | CPF_ExportObject | CPF_Net |
                              // CPF_GlobalConfig | CPF_Component )
    int SpareAmmoCapacity[0x2];  // 0x0598 (0x0008) [0x00000000001E002A] (
                                 // CPF_Const | CPF_ExportObject | CPF_Net |
                                 // CPF_EditConst | CPF_GlobalConfig |
                                 // CPF_Component )
    int InitialSpareMags[0x2];   // 0x05A0 (0x0008) [0x0000000000000000]
    float AmmoPickupScale[0x2];  // 0x05A8 (0x0008) [0x0000000000000000]
    int InitialReloadSpareAmmo;  // 0x05B0 (0x0004) [0x0000000000000000]
    float LastReloadAbortTime;   // 0x05B4 (0x0004) [0x0000000000000000]
    TArray<class UCameraAnim*>
        FireCameraAnim;        // 0x05B8 (0x0010) [0x0000000000000000]
    float ShakeScaleSighted;   // 0x05C8 (0x0004) [0x0000000000000000]
    float ShakeScaleStandard;  // 0x05CC (0x0004) [0x0000000000000000]
    class UForceFeedbackWaveform*
        WeaponFireWaveForm;  // 0x05D0 (0x0008) [0x0000000000000000]
    class UKFAnimSeq_Tween*
        WeaponAnimSeqNode;  // 0x05D8 (0x0008) [0x0000000000000000]
    class UAnimNodeAdditiveBlending*
        IdleBobBlendNode;  // 0x05E0 (0x0008) [0x0000000000000000]
    class UAnimNodeBlendPerBone*
        EmptyMagBlendNode;           // 0x05E8 (0x0008) [0x0000000000000000]
    TArray<DWORD> bLoopingFireAnim;  // 0x05F0 (0x0010) [0x0000000000000000]
    TArray<DWORD> bLoopingFireSnd;   // 0x0600 (0x0010) [0x0000000000000000]
    float FireTweenTime;             // 0x0610 (0x0004) [0x0000000000000000]
    struct FName FireAnim;           // 0x0614 (0x0008) [0x0000000000000000]
    struct FName FireLoopAnim;       // 0x061C (0x0008) [0x0000000000000000]
    struct FName FireLastAnim;       // 0x0624 (0x0008) [0x0000000000000000]
    struct FName PutDownAnim;        // 0x062C (0x0008) [0x0000000000000000]
    struct FName EquipAnim;          // 0x0634 (0x0008) [0x0000000000000000]
    TArray<struct FName> IdleAnims;  // 0x063C (0x0010) [0x0000000000000000]
    TArray<struct FName>
        IdleFidgetAnims;           // 0x064C (0x0010) [0x0000000000000000]
    float LastIdleFidgetAnimTime;  // 0x065C (0x0004) [0x0000000000000000]
    TArray<struct FName>
        FireSightedAnims;              // 0x0660 (0x0010) [0x0000000000000000]
    struct FName FireLoopSightedAnim;  // 0x0670 (0x0008) [0x0000000000000000]
    struct FName FireLastSightedAnim;  // 0x0678 (0x0008) [0x0000000000000000]
    TArray<struct FName>
        IdleSightedAnims;            // 0x0680 (0x0010) [0x0000000000000000]
    struct FName FireLoopStartAnim;  // 0x0690 (0x0008) [0x0000000000000000]
    struct FName
        FireLoopStartSightedAnim;  // 0x0698 (0x0008) [0x0000000000000000]
    struct FName FireLoopEndAnim;  // 0x06A0 (0x0008) [0x0000000000000000]
    struct FName
        FireLoopEndSightedAnim;       // 0x06A8 (0x0008) [0x0000000000000000]
    struct FName FireScopedAnim;      // 0x06B0 (0x0008) [0x0000000000000000]
    struct FName FireLoopScopedAnim;  // 0x06B8 (0x0008) [0x0000000000000000]
    struct FName FireLastScopedAnim;  // 0x06C0 (0x0008) [0x0000000000000000]
    TArray<struct FName>
        MeleeAttackAnims;  // 0x06C8 (0x0010) [0x0000000000000000]
    class UCameraAnim*
        SprintCameraAnim;  // 0x06D8 (0x0008) [0x0000000000000000]
    class UCameraAnimInst*
        SprintCameraAnimInst;  // 0x06E0 (0x0008) [0x0000000000000000]
    float SprintAnimRate;      // 0x06E8 (0x0004) [0x0000000000000000]
    TArray<struct FName>
        BonesToLockOnEmpty;  // 0x06EC (0x0010) [0x0000000000000000]
    TArray<struct FWeaponFireSndInfo>
        WeaponFireSnd;  // 0x06FC (0x0010) [0x0000000000000000]
    TArray<struct FWeaponFireSndInfo>
        WeaponFireLoopEndSnd;  // 0x070C (0x0010) [0x0000000000000000]
    TArray<class UAkBaseSoundObject*>
        WeaponDryFireSnd;             // 0x071C (0x0010) [0x0000000000000000]
    float BobDamping;                 // 0x072C (0x0004) [0x0000000000000000]
    float JumpDamping;                // 0x0730 (0x0004) [0x0000000000000000]
    struct FVector PlayerViewOffset;  // 0x0734 (0x000C) [0x0000000000000000]
    TArray<class UMaterialInstanceConstant*>
        WeaponMICs;                 // 0x0740 (0x0010) [0x0000000000000000]
    int NumBloodMapMaterials;       // 0x0750 (0x0004) [0x0000000000000000]
    float BloodParamValue;          // 0x0754 (0x0004) [0x0000000000000000]
    int SkinItemId;                 // 0x0758 (0x0004) [0x0000000000000000]
    struct FVector WeaponLag;       // 0x075C (0x000C) [0x0000000000000000]
    float LagHorizontal;            // 0x0768 (0x0004) [0x0000000000000000]
    float LagVertical;              // 0x076C (0x0004) [0x0000000000000000]
    float LagVelocityHorizontal;    // 0x0770 (0x0004) [0x0000000000000000]
    float LagVelocityVertical;      // 0x0774 (0x0004) [0x0000000000000000]
    float LagTensionHorizontal;     // 0x0778 (0x0004) [0x0000000000000000]
    float LagVerticalTension;       // 0x077C (0x0004) [0x0000000000000000]
    float LagResistanceHorizontal;  // 0x0780 (0x0004) [0x0000000000000000]
    float LagResistanceVertical;    // 0x0784 (0x0004) [0x0000000000000000]
    float LagLimit;                 // 0x0788 (0x0004) [0x0000000000000000]
    float LagYawCoefficient;        // 0x078C (0x0004) [0x0000000000000000]
    float LagStrengthIronSights;    // 0x0790 (0x0004) [0x0000000000000000]
    float LagStrengthCrouch;        // 0x0794 (0x0004) [0x0000000000000000]
    float LagStrengthWalk;          // 0x0798 (0x0004) [0x0000000000000000]
    float LagStrengthJog;           // 0x079C (0x0004) [0x0000000000000000]
    float LagStrengthSprint;        // 0x07A0 (0x0004) [0x0000000000000000]
    float StrafeLag;                // 0x07A4 (0x0004) [0x0000000000000000]
    float StrafeLagVelocity;        // 0x07A8 (0x0004) [0x0000000000000000]
    float StrafeLagLimit;           // 0x07AC (0x0004) [0x0000000000000000]
    float StrafeLagRate;            // 0x07B0 (0x0004) [0x0000000000000000]
    float StrafeLagReturnRate;      // 0x07B4 (0x0004) [0x0000000000000000]
    int AimYawSpeed;                // 0x07B8 (0x0004) [0x0000000000000000]
    int AimPitchSpeed;              // 0x07BC (0x0004) [0x0000000000000000]
    class AKFWeaponAttachment*
        AttachmentArchetype;  // 0x07C0 (0x0008) [0x0000000000000000]
    class UKFMeleeHelperWeapon*
        MeleeAttackHelper;              // 0x07C8 (0x0008) [0x0000000000000000]
    class UKFMuzzleFlash* MuzzleFlash;  // 0x07D0 (0x0008) [0x0000000000000000]
    class UKFMuzzleFlash*
        MuzzleFlashTemplate;  // 0x07D8 (0x0008) [0x0000000000000000]
    float
        EjectedShellForegroundDuration;  // 0x07E0 (0x0004) [0x0000000000000000]
    class UKFLaserSightAttachment*
        LaserSight;  // 0x07E4 (0x0008) [0x0000000000000000]
    class UKFLaserSightAttachment*
        LaserSightTemplate;              // 0x07EC (0x0008) [0x0000000000000000]
    float LastPelletFireTime;            // 0x07F4 (0x0004) [0x0000000000000000]
    float MovingSpreadMod;               // 0x07F8 (0x0004) [0x0000000000000000]
    float IronSightsSpreadMod;           // 0x07FC (0x0004) [0x0000000000000000]
    float CrouchSpreadMod;               // 0x0800 (0x0004) [0x0000000000000000]
    int maxRecoilPitch;                  // 0x0804 (0x0004) [0x0000000000000000]
    int minRecoilPitch;                  // 0x0808 (0x0004) [0x0000000000000000]
    int maxRecoilYaw;                    // 0x080C (0x0004) [0x0000000000000000]
    int minRecoilYaw;                    // 0x0810 (0x0004) [0x0000000000000000]
    float RecoilRate;                    // 0x0814 (0x0004) [0x0000000000000000]
    float RecoilBlendOutRatio;           // 0x0818 (0x0004) [0x0000000000000000]
    float RecoilViewRotationScale;       // 0x081C (0x0004) [0x0000000000000000]
    float RecoilCompensationScale;       // 0x0820 (0x0004) [0x0000000000000000]
    float FullRecoilPitchPct;            // 0x0824 (0x0004) [0x0000000000000000]
    float FullRecoilYawPct;              // 0x0828 (0x0004) [0x0000000000000000]
    int RecoilMaxYawLimit;               // 0x082C (0x0004) [0x0000000000000000]
    int RecoilMinYawLimit;               // 0x0830 (0x0004) [0x0000000000000000]
    int RecoilMaxPitchLimit;             // 0x0834 (0x0004) [0x0000000000000000]
    int RecoilMinPitchLimit;             // 0x0838 (0x0004) [0x0000000000000000]
    int RecoilISMaxYawLimit;             // 0x083C (0x0004) [0x0000000000000000]
    int RecoilISMinYawLimit;             // 0x0840 (0x0004) [0x0000000000000000]
    int RecoilISMaxPitchLimit;           // 0x0844 (0x0004) [0x0000000000000000]
    int RecoilISMinPitchLimit;           // 0x0848 (0x0004) [0x0000000000000000]
    struct FRotator RecoilRotator;       // 0x084C (0x000C) [0x0000000000000000]
    struct FRotator TotalRecoilRotator;  // 0x0858 (0x000C) [0x0000000000000000]
    float RecoilTimeLeft;                // 0x0864 (0x0004) [0x0000000000000000]
    float RecoilSpeed;                   // 0x0868 (0x0004) [0x0000000000000000]
    int RecoilYawBlendOutRate;           // 0x086C (0x0004) [0x0000000000000000]
    int RecoilPitchBlendOutRate;         // 0x0870 (0x0004) [0x0000000000000000]
    float RecoilPitchPercentage;         // 0x0874 (0x0004) [0x0000000000000000]
    float RecoilYawPercentage;           // 0x0878 (0x0004) [0x0000000000000000]
    struct FRotator
        SuppressRecoilRotator;     // 0x087C (0x000C) [0x0000000000000000]
    float SuppressRecoilTimeLeft;  // 0x0888 (0x0004) [0x0000000000000000]
    float SuppressRecoilSpeed;     // 0x088C (0x0004) [0x0000000000000000]
    float SuppressRecoilViewRotationScale;  // 0x0890 (0x0004)
                                            // [0x0000000000000000]
    float HippedRecoilModifier;          // 0x0894 (0x0004) [0x0000000000000000]
    float JoggingRecoilModifier;         // 0x0898 (0x0004) [0x0000000000000000]
    float WalkingRecoilModifier;         // 0x089C (0x0004) [0x0000000000000000]
    float FallingRecoilModifier;         // 0x08A0 (0x0004) [0x0000000000000000]
    float StanceCrouchedRecoilModifier;  // 0x08A4 (0x0004) [0x0000000000000000]
    float LastRecoilModifier;            // 0x08A8 (0x0004) [0x0000000000000000]
    float IronSightMeshFOVCompensationScale;  // 0x08AC (0x0004)
                                              // [0x0000000000000000]
    TArray<class UClass*>
        AssociatedPerkClasses;  // 0x08B0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3289];

        return pClassPointer;
    };

    void eventGetAltTraderFilter();
    void eventGetTraderFilter();
    void CalculateTraderWeaponStatFireRate();
    void CalculateTraderWeaponStatDamage();
    void eventSetTraderWeaponStats();
    void ServerSyncWeaponFiring();
    void GetForceReloadDelay();
    void GetMeleeDamage();
    void PlayMeleeAnimation();
    void NotifyMeleeCollision();
    void ShouldContinueMelee();
    void IsMeleeing();
    void GetSprintAnimRate();
    void GetSprintEndAnimName();
    void PlaySprintEnd();
    void GetSprintLoopAnimName();
    void PlaySprintLoop();
    void GetSprintStartAnimName();
    void PlaySprintStart();
    void SprintRetryTimer();
    void SprintLoopTimer();
    void CheckBoltLockPostReload();
    void PerformReload();
    void GetReloadAnimName();
    void GetNextReloadStatus();
    void UseTacticalReload();
    void GetReloadRateScale();
    void TimeWeaponReloading();
    void CanOverrideMagReload();
    void ServerSendToReload();
    void InitializeReload();
    void AbortReload();
    void ReloadComplete();
    void ReloadAmmoTimer();
    void ReloadStatusTimer();
    void GetGrenadeThrowAnim();
    void PlayGrenadeThrow();
    void SetWeakZedGrabCooldownOnPawn();
    void ServerGotoGrenadeFiring();
    void GetBurstAmount();
    void TimeWeaponFiring();
    void FiringPutDownWeapon();
    void TryPutDown();
    void GetWeaponPutDownAnimName();
    void PlayWeaponPutDown();
    void TimeWeaponPutDown();
    void CanSwitchWeapons();
    void SetSimplePutDown();
    void GetEquipAnimName();
    void PlayWeaponEquip();
    void WeaponEquipped();
    void TimeWeaponEquipping();
    void CheckPendingIronsights();
    void ANIMNOTIFY_EnableAdditiveBob();
    void PlayIdleFidgetAnim();
    void CanPlayIdleFidget();
    void IdleFidgetTimer();
    void StartIdleFidgetTimer();
    void PlayIdleAnim();
    void Activate();
    void ServerSyncReload();
    void NotifyEndState();
    void NotifyBeginState();
    void UpdateWeaponAttachmentAnimRate();
    void GetThirdPersonAnimRate();
    void GetWeaponStateId();
    void IsMultiPerkWeapn();
    void eventGetWeaponPerkClassByIndex();
    void eventGetAssociatedPerkClasses();
    void AllowedForAllPerks();
    void eventGetWeaponPerkClass();
    void DisplayDebug();
    void GetWeaponDebug();
    void SetMeshLightingChannels();
    void ServerPlayDryFireSound();
    void ShouldAutoReloadGunslinger();
    void ShouldAutoReload();
    void CanReload();
    void ForceReload();
    void GetSecondaryAmmoForHUD();
    void GetSpareAmmoForHUD();
    void GetAmmoPercentage();
    void eventGetMissingSpareAmmoAmount();
    void eventGetMaxAmmoAmount();
    void eventGetTotalAmmoAmount();
    void eventHasSpareAmmo();
    void HasAnyAmmo();
    void eventHasAmmo();
    void NotifyHUDofWeapon();
    void ClientForceSecondaryAmmoUpdate();
    void ClientForceAmmoUpdate();
    void AddSecondaryAmmo();
    void AddTransactionAmmo();
    void AddAmmo();
    void ConsumeAmmo();
    void ReInitializeAmmoCounts();
    void InitializeAmmo();
    void eventCanRefillSecondaryAmmo();
    void eventUsesSecondaryAmmo();
    void eventUsesAmmo();
    void GetAmmoType();
    void eventRecieveClientImpactList();
    void HandleClientProjectileExplosion();
    void eventRecieveClientProjectileExplosion();
    void eventRecieveClientImpact();
    void InstantFireClient();
    void InstantFireClient_AddImpacts();
    void GetSafeStartTraceLocation();
    void SendClientFragmentImpact();
    void SendClientProjectileExplosion();
    void SendClientProjectileImpact();
    void SendClientImpactList();
    void eventServerRegisterFragmentImpact();
    void eventServerRegisterProjectileExplosion();
    void eventServerRegisterProjectileImpact();
    void eventServerRegisterImpact8();
    void eventServerRegisterImpact7();
    void eventServerRegisterImpact6();
    void eventServerRegisterImpact5();
    void eventServerRegisterImpact4();
    void eventServerRegisterImpact3();
    void eventServerRegisterImpact2();
    void eventServerRegisterImpact1();
    void IsHeavyWeapon();
    void ProcessGrenadeProjectileImpact();
    void HandleGrenadeProjectileImpact();
    void eventRecieveClientFragmentImpact();
    void HandleProjectileImpact();
    void ProcessInstantHitEx();
    void eventGetInitialPenetrationPower();
    void SpawnProjectile();
    void ShouldIncrementFlashCountOnFire();
    void ProjectileFire();
    void GetKFProjectileClass();
    void SetRecoil();
    void eventHandleRecoil();
    void ModifyRecoil();
    void AddSpread();
    void PassThroughDamage();
    void TraceImpactHitZones();
    void CalcWeaponFire();
    void HandleWeaponShotTaken();
    void FireAmmunition();
    void CacheKFPlayerController();
    void GetCurrentMuzzleID();
    void eventGetMuzzleLoc();
    void SendToFiringState();
    void AltFireModeRelease();
    void AltFireMode();
    void StopFire();
    void BeginFire();
    void StartFire();
    void AddBlood();
    void ShakeView();
    void Timer_RestoreShellEjectDepth();
    void SetShellEjectsToForeground();
    void AttachMuzzleFlash();
    void ANIMNOTIFY_ShellEject();
    void CauseMuzzleFlash();
    void WeaponPlaySound();
    void WeaponPlayFireSound();
    void PlayFiringSound();
    void StopLoopingFireSound();
    void StartLoopingFireSound();
    void ShouldForceSingleFireSound();
    void StopLoopingFireEffects();
    void StartLoopingFireEffects();
    void StopFireEffects();
    void PlayFireEffects();
    void ChangeVisibility();
    void eventSetPosition();
    void GetAnimSeqCameraPosition();
    void UpdateOutOfAmmoEffects();
    void ToggleAdditiveBobAnim();
    void ANIMNOTIFY_UnLockBolt();
    void ANIMNOTIFY_LockBolt();
    void GetArmAnimNodeSeq();
    void GetMeleeAnimName();
    void GetLoopEndFireAnim();
    void GetLoopStartFireAnim();
    void GetLoopingFireAnim();
    void GetWeaponFireAnim();
    void ShouldPlayFireLast();
    void PlayCameraAnim();
    void WeaponIsAnimating();
    void GetWeaponAnimNodeSeq();
    void PlayWeaponAnimation();
    void PlayAnimation();
    void PlayTakeHitEffects();
    void AdjustDamage();
    void GotoWeaponSprinting();
    void AllowSprinting();
    void StopPawnSprint();
    void SetWeaponSprint();
    void IsGrappleBlocked();
    void ShouldOwnerWalk();
    void Timer_CheckForAIWarning();
    void IsWarningAI();
    void eventOnZoomOutFinished();
    void eventOnZoomInFinished();
    void ServerZoomOut();
    void ZoomOut();
    void ServerZoomIn();
    void ZoomIn();
    void PerformZoom();
    void EnablePlayerZoom();
    void EnableIronSightsDoF();
    void AllowIronSights();
    void SetIronSights();
    void eventSetFOV();
    void eventTick();
    void GetWeaponRating();
    void IsMeleeWeapon();
    void DenyPerkResupply();
    void ClientNotifyPickedUp();
    void NotifyPickedUp();
    void DenyPickupQuery();
    void SetOriginalValuesFromPickup();
    void SetupDroppedPickup();
    void DropFrom();
    void AttachLaserSight();
    void DetachMuzzleFlash();
    void DetachWeapon();
    void AttachThirdPersonWeapon();
    void AttachWeaponTo();
    void ClientWeaponSet();
    void ItemRemovedFromInvManager();
    void GivenTo();
    void ClearSkinItemId();
    void eventServerUpdateWeaponSkin();
    void ClientSetFirstPersonSkin();
    void InitFOV();
    void InitializeEquipTime();
    void BuildEmptyMagNodeWeightList();
    void eventPostInitAnimTree();
    void SetShownInInventory();
    void eventPreBeginPlay();
    void HasAlwaysOnZedTimeResist();
    void ClearZedTimeResist();
    void SetZedTimeResist();
    void GetPerk();
    void WeaponProcessViewRotation();
    void EnsureWeaponOverlayComponentLast();
};

UClass* AKFWeapon::pClassPointer = NULL;

// Class KFGame.KFWeap_MeleeBase
// 0x0098 (0x0958 - 0x08C0)
class AKFWeap_MeleeBase : public AKFWeapon {
   public:
    DWORD bIsBloody : 1;  // 0x08C0 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bMoveAtWalkingSpeed : 1;    // 0x08C0 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    unsigned char MaxChainAtkCount;   // 0x08C4 (0x0001) [0x0000000000000000]
    unsigned char ParryStrength;      // 0x08C5 (0x0001) [0x0000000000000000]
    unsigned char EstimatedFireRate;  // 0x08C6 (0x0001) [0x0000000000000000]
    float MinMeleeSustainedTime;      // 0x08C8 (0x0004) [0x0000000000000000]
    float MeleeSustainedWarmupTime;   // 0x08CC (0x0004) [0x0000000000000000]
    TArray<struct FBlockEffectInfo>
        BlockTypes;                      // 0x08D0 (0x0010) [0x0000000000000000]
    float BlockDamageMitigation;         // 0x08E0 (0x0004) [0x0000000000000000]
    float ParryDamageMitigationPercent;  // 0x08E4 (0x0004) [0x0000000000000000]
    float BlockHitAnimCooldownTime;      // 0x08E8 (0x0004) [0x0000000000000000]
    float LastBlockHitAnimTime;          // 0x08EC (0x0004) [0x0000000000000000]
    TArray<struct FName>
        MeleeAttackSettleAnims;  // 0x08F0 (0x0010) [0x0000000000000000]
    TArray<struct FName>
        MeleeBlockHitAnims;  // 0x0900 (0x0010) [0x0000000000000000]
    class UParticleSystem*
        DistortTrailParticle;  // 0x0910 (0x0008) [0x0000000000000000]
    class UParticleSystem*
        WhiteTrailParticle;  // 0x0918 (0x0008) [0x0000000000000000]
    class UParticleSystem*
        BlueTrailParticle;  // 0x0920 (0x0008) [0x0000000000000000]
    class UParticleSystem*
        RedTrailParticle;  // 0x0928 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        BlockSound;  // 0x0930 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        ParrySound;  // 0x0938 (0x0008) [0x0000000000000000]
    class UParticleSystem*
        BlockParticleSystem;  // 0x0940 (0x0008) [0x0000000000000000]
    class UParticleSystem*
        ParryParticleSystem;  // 0x0948 (0x0008) [0x0000000000000000]
    struct FName
        BlockEffectsSocketName;  // 0x0950 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3291];

        return pClassPointer;
    };

    void eventGetTraderFilter();
    void CalculateTraderWeaponStatFireRate();
    void CalculateTraderWeaponStatDamage();
    void eventSetTraderWeaponStats();
    void AttemptDrawStrike();
    void ANIMNOTIFY_DrawAtk();
    void BlockCooldownTimer();
    void GetParryEffects();
    void GetBlockEffects();
    void CanBlockDamageType();
    void PlayLocalBlockEffects();
    void PlayBlockStart();
    void ClientPlayParryEffects();
    void ClientPlayBlockEffects();
    void ParryCheckTimer();
    void BlockLoopTimer();
    void SustainedWarmupEndTimer();
    void SustainedMinFireTimer();
    void IsHeavyAttack();
    void PlayMeleeSettleAnim();
    void IsLightAttack();
    void CanReload();
    void UpkeepComplete();
    void PlayMeleeAnimation();
    void PlayWeaponAnimation();
    void ANIMNOTIFY_CleanBlood();
    void ServerSetBloody();
    void AddBlood();
    void GetMeleeDamage();
    void eventRecieveClientImpact();
    void SendToFiringState();
    void SetIronSights();
    void AltFireMode();
    void ServerStartMeleeFire();
    void StartMeleeFire();
    void StartFire();
    void ServerSetSlowMovement();
    void SetSlowMovement();
    void ShouldOwnerWalk();
};

UClass* AKFWeap_MeleeBase::pClassPointer = NULL;

// Class KFGame.KFWeap_PistolBase
// 0x0054 (0x0914 - 0x08C0)
class AKFWeap_PistolBase : public AKFWeapon {
   public:
    DWORD bRevolver : 1;  // 0x08C0 (0x0004) [0x0000000000000000] [0x00000001]
    class USkeletalMesh*
        UnusedBulletMeshTemplate;  // 0x08C4 (0x0008) [0x0000000000000000]
    class USkeletalMesh*
        UsedBulletMeshTemplate;  // 0x08CC (0x0008) [0x0000000000000000]
    TArray<struct FName>
        BulletFXSocketNames;  // 0x08D4 (0x0010) [0x0000000000000000]
    TArray<class UKFSkeletalMeshComponent*>
        BulletMeshComponents;  // 0x08E4 (0x0010) [0x0000000000000000]
    struct FCylinderRotationInfo
        CylinderRotInfo;  // 0x08F4 (0x0020) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3293];

        return pClassPointer;
    };

    void eventGetTraderFilter();
    void eventSetFOV();
    void ShouldAutoReload();
    void ProcessInstantHitEx();
    void ResetBulletMeshes();
    void ResetCylinder();
    void ANIMNOTIFY_ResetBulletMeshes();
    void InitializeReload();
    void SetCylinderRotation();
    void eventOnCylinderRotationFinished();
    void ResetCylinderInfo();
    void IncrementCylinderRotation();
    void RotateCylinder();
    void ANIMNOTIFY_RotateCylinder();
    void CheckCylinderRotation();
    void ConsumeAmmoRevolver();
    void eventPostInitAnimTreeRevolver();
    void ConsumeAmmo();
    void eventPostInitAnimTree();
    void eventPreBeginPlay();
};

UClass* AKFWeap_PistolBase::pClassPointer = NULL;

// Class KFGame.KFWeap_DualBase
// 0x00E0 (0x09F4 - 0x0914)
class AKFWeap_DualBase : public AKFWeap_PistolBase {
   public:
    struct FName LeftFireAnim;  // 0x0914 (0x0008) [0x0000000000000000]
    TArray<struct FName>
        LeftFireSightedAnims;  // 0x091C (0x0010) [0x0000000000000000]
    class UKFMuzzleFlash*
        LeftMuzzleFlash;             // 0x092C (0x0008) [0x0000000000000000]
    struct FVector LeftFireOffset;   // 0x0934 (0x000C) [0x0000000000000000]
    DWORD bFireFromRightWeapon : 1;  // 0x0940 (0x0004) [0x0000000000000000]
                                     // [0x00000001]
    class UClass* SingleClass;       // 0x0944 (0x0008) [0x0000000000000000]
    class UAnimNodeBlendPerBone*
        EmptyMagBlendNode_L;  // 0x094C (0x0008) [0x0000000000000000]
    TArray<struct FName>
        BonesToLockOnEmpty_L;          // 0x0954 (0x0010) [0x0000000000000000]
    struct FName IdleToIronSightAnim;  // 0x0964 (0x0008) [0x0000000000000000]
    struct FName
        IdleToIronSightAnim_Alt;       // 0x096C (0x0008) [0x0000000000000000]
    struct FName IronSightToIdleAnim;  // 0x0974 (0x0008) [0x0000000000000000]
    struct FName
        IronSightToIdleAnim_Alt;  // 0x097C (0x0008) [0x0000000000000000]
    TArray<struct FName>
        IdleSightedAnims_Alt;          // 0x0984 (0x0010) [0x0000000000000000]
    struct FName FireSightedAnim_Alt;  // 0x0994 (0x0008) [0x0000000000000000]
    struct FName
        LeftFireSightedAnim_Alt;    // 0x099C (0x0008) [0x0000000000000000]
    struct FName EquipAnimIS;       // 0x09A4 (0x0008) [0x0000000000000000]
    struct FName EquipAnimISAlt;    // 0x09AC (0x0008) [0x0000000000000000]
    struct FName LeftFireLastAnim;  // 0x09B4 (0x0008) [0x0000000000000000]
    struct FName
        LeftFireLastSightedAnim;  // 0x09BC (0x0008) [0x0000000000000000]
    struct FName
        FireLastSightedAnim_Alt;  // 0x09C4 (0x0008) [0x0000000000000000]
    struct FName
        LeftFireLastSightedAnim_Alt;  // 0x09CC (0x0008) [0x0000000000000000]
    struct FCylinderRotationInfo
        CylinderRotInfo_L;  // 0x09D4 (0x0020) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3295];

        return pClassPointer;
    };

    void StartFire();
    void AltFireMode();
    void ShouldAutoReload();
    void AddAmmoToSingleOnSell();
    void ResetBulletMeshesLeft();
    void ResetBulletMeshes();
    void RepositionUsedBullets();
    void ResetCylinderLeft();
    void ResetCylinder();
    void ANIMNOTIFY_ResetBulletMeshesLeft();
    void InitializeReload();
    void ANIMNOTIFY_RotateCylinder();
    void ConsumeAmmoRevolver();
    void eventPostInitAnimTreeRevolver();
    void UpdateOutOfAmmoEffects();
    void ANIMNOTIFY_UnLockBolt();
    void ANIMNOTIFY_LockBolt();
    void PerformReload();
    void SetupDroppedPickup();
    void GetCurrentMuzzleID();
    void StopFireEffects();
    void eventSetFOV();
    void DetachMuzzleFlash();
    void CauseMuzzleFlash();
    void eventGetLeftMuzzleLoc();
    void eventGetMuzzleLoc();
    void GetLeftWeaponFireAnim();
    void GetWeaponFireAnim();
    void ShouldPlayFireLast();
    void IncrementFlashCount();
    void GetReloadAnimName();
    void GetIronToIdleAnim();
    void GetIdleToIronAnim();
    void GetEquipAnimName();
    void AttachMuzzleFlash();
    void eventPostInitAnimTree();
};

UClass* AKFWeap_DualBase::pClassPointer = NULL;

// Class KFGame.KFWeaponAttachment
// 0x01A4 (0x03E8 - 0x0244)
class AKFWeaponAttachment : public AActor {
   public:
    class USkeletalMesh* SkelMesh;     // 0x0244 (0x0008) [0x0000000000000000]
    class UAnimSet* CharacterAnimSet;  // 0x024C (0x0008) [0x0000000000000000]
    class UAnimSet* WeaponAnimSet;     // 0x0254 (0x0008) [0x0000000000000000]
    class USkeletalMeshComponent*
        WeapMesh;                   // 0x025C (0x0008) [0x0000000000000000]
    DWORD bWeapMeshIsPawnMesh : 1;  // 0x0264 (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    DWORD bHasLaserSight : 1;       // 0x0264 (0x0004) [0x0000000000000000]
                                    // [0x00000002]
    DWORD
        bPlayIKRecoil : 1;  // 0x0264 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bSynchronizeWeaponAnim : 1;   // 0x0264 (0x0004) [0x0000000000000000]
                                        // [0x00000008]
    DWORD bSyncAnimCheckRelevance : 1;  // 0x0264 (0x0004) [0x0000000000000000]
                                        // [0x00000010]
    DWORD bLoopSynchedWeaponAnim : 1;   // 0x0264 (0x0004) [0x0000000000000000]
                                        // [0x00000020]
    DWORD
        bIsReloading : 1;  // 0x0264 (0x0004) [0x0000000000000000] [0x00000040]
    class UKFLaserSightAttachment*
        LaserSightArchetype;  // 0x0268 (0x0008) [0x0000000000000000]
    class UKFLaserSightAttachment*
        LaserSight;                     // 0x0270 (0x0008) [0x0000000000000000]
    class UKFMuzzleFlash* MuzzleFlash;  // 0x0278 (0x0008) [0x0000000000000000]
    class UKFMuzzleFlash*
        MuzzleFlashTemplate;      // 0x0280 (0x0008) [0x0000000000000000]
    float MaxFireEffectDistance;  // 0x0288 (0x0004) [0x0000000000000000]
    TArray<struct FKFTracerInfo>
        TracerInfos;  // 0x028C (0x0010) [0x0000000000000000]
    class UMaterialInstanceConstant*
        WeaponMIC;                      // 0x029C (0x0008) [0x0000000000000000]
    float BloodParamValue;              // 0x02A4 (0x0004) [0x0000000000000000]
    float ThirdPersonAnimRate;          // 0x02A8 (0x0004) [0x0000000000000000]
    struct FRecoilDef Recoil_Hand;      // 0x02AC (0x0070) [0x0000000000000000]
    struct FRecoilDef Recoil_Spine;     // 0x031C (0x0070) [0x0000000000000000]
    float DefaultBlendInTime;           // 0x038C (0x0004) [0x0000000000000000]
    float DefaultBlendOutTime;          // 0x0390 (0x0004) [0x0000000000000000]
    float ShootBlendInTime;             // 0x0394 (0x0004) [0x0000000000000000]
    float ShootBlendOutTime;            // 0x0398 (0x0004) [0x0000000000000000]
    unsigned char LastMeleeAnimIdx;     // 0x039C (0x0001) [0x0000000000000000]
    class UAnimNodeSlot* SyncPawnNode;  // 0x03A0 (0x0008) [0x0000000000000000]
    struct FName SyncAnimName;          // 0x03A8 (0x0008) [0x0000000000000000]
    struct FName LoopingAnim;           // 0x03B0 (0x0008) [0x0000000000000000]
    struct FName LoopIntroAnim;         // 0x03B8 (0x0008) [0x0000000000000000]
    struct FName LoopOutroAnim;         // 0x03C0 (0x0008) [0x0000000000000000]
    class UAnimNodeSequence*
        WeapAnimNode;                   // 0x03C8 (0x0008) [0x0000000000000000]
    struct FName AimOffsetProfileName;  // 0x03D0 (0x0008) [0x0000000000000000]
    struct FScriptDelegate
        __OnWeaponStateChanged__Delegate;  // 0x03D8 (0x0010)
                                           // [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x03DC (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3297];

        return pClassPointer;
    };

    void PlayLoopAnim();
    void StartLoopingAnim();
    void HasOutdoorLighting();
    void HasIndoorLighting();
    void SetMeshLightingChannels();
    void InterruptWeaponAnim();
    void eventTick();
    void PlayWeaponMeshAnim();
    void PlayWeldAnim();
    void PlayHealAnim();
    void PlayReloadSingleAnim();
    void PlayReloadMagazineAnim();
    void PlayMeleeSustainedAnim();
    void PlayMeleeBlockAnim();
    void LoopWeaponMeleeAnim();
    void GetRandomDirectionalMeleeAnim();
    void PlayMeleeAtkAnim();
    void UpdateThirdPersonWeaponAction();
    void DecodeThirdPersonAnimRate();
    void PlayCharacterMeshAnim();
    void OnWeaponStateChanged();
    void AddBattleBlood();
    void ANIMNOTIFY_ShellEject();
    void CauseMuzzleFlash();
    void SpawnTracer();
    void GetMuzzleLocation();
    void StopThirdPersonFireEffects();
    void PlayPawnFireAnim();
    void PlayWeaponFireAnim();
    void ThirdPersonFireEffects();
    void StopFirstPersonFireEffects();
    void FirstPersonFireEffects();
    void ActorEffectIsRelevant();
    void eventSetWeaponSkin();
    void AttachLaserSight();
    void AttachMuzzleFlash();
    void DetachFrom();
    void AttachTo();
    void eventPreBeginPlay();
    void eventChangeVisibility();
};

UClass* AKFWeaponAttachment::pClassPointer = NULL;

// Class KFGame.KFWeaponDefinition
// 0x0043 (0x00A3 - 0x0060)
class UKFWeaponDefinition : public UObject {
   public:
    struct FString WeaponClassPath;  // 0x0060 (0x0010) [0x0000000000000000]
    struct FString
        AttachmentArchtypePath;         // 0x0070 (0x0010) [0x0000000000000000]
    struct FString ImagePath;           // 0x0080 (0x0010) [0x0000000000000000]
    int BuyPrice;                       // 0x0090 (0x0004) [0x0000000000000000]
    int AmmoPricePerMag;                // 0x0094 (0x0004) [0x0000000000000000]
    int SecondaryAmmoMagSize;           // 0x0098 (0x0004) [0x0000000000000000]
    int SecondaryAmmoMagPrice;          // 0x009C (0x0004) [0x0000000000000000]
    unsigned char SharedUnlockId;       // 0x00A0 (0x0001) [0x0000000000000000]
    unsigned char PlatformRestriction;  // 0x00A1 (0x0001) [0x0000000000000000]
    unsigned char EffectiveRange;       // 0x00A2 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3299];

        return pClassPointer;
    };

    void UsesSecondaryAmmo();
    void UsesAmmo();
    void GetItemLocalization();
    void GetItemDescription();
    void GetItemCategory();
    void GetItemName();
    void GetImagePath();
};

UClass* UKFWeaponDefinition::pClassPointer = NULL;

// Class KFGame.KFWeaponSkinList
// 0x0010 (0x0070 - 0x0060)
class UKFWeaponSkinList : public UObject {
   public:
    TArray<struct FWeaponSkin> Skins;  // 0x0060 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3301];

        return pClassPointer;
    };

    void IsSkinEquip();
    void SaveWeaponSkin();
    void GetWeaponSkin();
};

UClass* UKFWeaponSkinList::pClassPointer = NULL;

// Class KFGame.KFAIController
// 0x0554 (0x0AA0 - 0x054C)
class AKFAIController : public ABaseAIController {
   public:
    DWORD bAllowScriptTeamCheck : 1;    // 0x054C (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bIdleMoveToNearestEnemy : 1;  // 0x054C (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bReachedMoveGoal : 1;         // 0x054C (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    DWORD bReevaluatePath : 1;          // 0x054C (0x0004) [0x0000000000000000]
                                        // [0x00000008]
    DWORD
        bMovingToGoal : 1;  // 0x054C (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bMovingToEnemy : 1;          // 0x054C (0x0004) [0x0000000000000000]
                                       // [0x00000020]
    DWORD bDirectMoveToGoal : 1;       // 0x054C (0x0004) [0x0000000000000000]
                                       // [0x00000040]
    DWORD bMoveGoalInterruptable : 1;  // 0x054C (0x0004) [0x0000000000000000]
                                       // [0x00000080]
    DWORD bSkipRouteCacheUpdates : 1;  // 0x054C (0x0004) [0x0000000000000000]
                                       // [0x00000100]
    DWORD bFailedToMoveToEnemy : 1;    // 0x054C (0x0004) [0x0000000000000000]
                                       // [0x00000200]
    DWORD bAvoidChokePoints : 1;       // 0x054C (0x0004) [0x0000000000000000]
                                       // [0x00000400]
    DWORD
        bProbeNotifyOnAddToRouteCache : 1;  // 0x054C (0x0004)
                                            // [0x0000000000000000] [0x00000800]
    DWORD
        bPlannedJump : 1;  // 0x054C (0x0004) [0x0000000000000000] [0x00001000]
    DWORD CachedLOSCheck : 1;          // 0x054C (0x0004) [0x0000000000000000]
                                       // [0x00002000]
    DWORD bIgnoreBlockedPathList : 1;  // 0x054C (0x0004) [0x0000000000000000]
                                       // [0x00004000]
    DWORD bShouldUsePathLanes : 1;     // 0x054C (0x0004) [0x0000000000000000]
                                       // [0x00008000]
    DWORD bShouldOffsetCorners : 1;    // 0x054C (0x0004) [0x0000000000000000]
                                       // [0x00010000]
    DWORD bAlwaysAcceptPartialPaths : 1;  // 0x054C (0x0004)
                                          // [0x0000000000000000] [0x00020000]
    DWORD bCanSprint : 1;  // 0x054C (0x0004) [0x0000000000000000] [0x00040000]
    DWORD bCanSprintWhenDamaged : 1;  // 0x054C (0x0004) [0x0000000000000000]
                                      // [0x00080000]
    DWORD bSprintingDisabled : 1;     // 0x054C (0x0004) [0x0000000000000000]
                                      // [0x00100000]
    DWORD bConfigShowMovePointsDebugInfo : 1;  // 0x054C (0x0004)
                                               // [0x0000000000000000]
                                               // [0x00200000]
    DWORD bShowMovePointsDebugInfo : 1;  // 0x054C (0x0004) [0x0000000000000000]
                                         // [0x00400000]
    DWORD bConfigShowHighDetailCombatMovementDebugInfo : 1;  // 0x054C (0x0004)
                                                             // [0x0000000000000000]
                                                             // [0x00800000]
    DWORD bShowHighDetailCombatMovementDebugInfo : 1;  // 0x054C (0x0004)
                                                       // [0x0000000000000000]
                                                       // [0x01000000]
    DWORD bConfigShowVisualStuckZedDebugInfo : 1;      // 0x054C (0x0004)
                                                       // [0x0000000000000000]
                                                       // [0x02000000]
    DWORD
        bShowVisualStuckZedDebugInfo : 1;  // 0x054C (0x0004)
                                           // [0x0000000000000000] [0x04000000]
    DWORD
        bConfigShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState : 1;  // 0x054C (0x0004) [0x0000000000000000] [0x08000000]
    DWORD
        bShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState : 1;  // 0x054C (0x0004) [0x0000000000000000] [0x10000000]
    DWORD bShowLeapDownDebugArtifacts : 1;  // 0x054C (0x0004)
                                            // [0x0000000000000000] [0x20000000]
    DWORD bConfigShowLeapDownDebugArtifacts : 1;        // 0x054C (0x0004)
                                                        // [0x0000000000000000]
                                                        // [0x40000000]
    DWORD bShowDoorNavigationDebugArtifacts : 1;        // 0x054C (0x0004)
                                                        // [0x0000000000000000]
                                                        // [0x80000000]
    DWORD bConfigShowDoorNavigationDebugArtifacts : 1;  // 0x0550 (0x0004)
                                                        // [0x0000000000000000]
                                                        // [0x00000001]
    DWORD bShowDestructibleNavigationDebugArtifacts : 1;  // 0x0550 (0x0004)
                                                          // [0x0000000000000000]
                                                          // [0x00000002]
    DWORD
        bConfigShowDestructibleNavigationDebugArtifacts : 1;  // 0x0550 (0x0004)
                                                              // [0x0000000000000000]
                                                              // [0x00000004]
    DWORD bMindLeader : 1;  // 0x0550 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD LastPathFailTime : 1;  // 0x0550 (0x0004) [0x0000000000000000]
                                 // [0x00000010]
    DWORD IsRotationLocked : 1;  // 0x0550 (0x0004) [0x0000000000000000]
                                 // [0x00000020]
    DWORD bSpawnedByEmergeSpecialMove : 1;  // 0x0550 (0x0004)
                                            // [0x0000000000000000] [0x00000040]
    DWORD bUseTargetedByPlayerEvent : 1;    // 0x0550 (0x0004)
                                            // [0x0000000000000000] [0x00000080]
    DWORD bBumpedThisFrame : 1;       // 0x0550 (0x0004) [0x0000000000000000]
                                      // [0x00000100]
    DWORD bDoNotBlockFriendlyAI : 1;  // 0x0550 (0x0004) [0x0000000000000000]
                                      // [0x00000200]
    DWORD bSuperSpeedDoNotBlockFriendlyAI : 1;  // 0x0550 (0x0004)
                                                // [0x0000000000000000]
                                                // [0x00000400]
    DWORD bSpecialBumpHandling : 1;      // 0x0550 (0x0004) [0x0000000000000000]
                                         // [0x00000800]
    DWORD bTryingToGetUnstuck : 1;       // 0x0550 (0x0004) [0x0000000000000000]
                                         // [0x00001000]
    DWORD bCanTeleportCloser : 1;        // 0x0550 (0x0004) [0x0000000000000000]
                                         // [0x00002000]
    DWORD bIgnoreStepAside : 1;          // 0x0550 (0x0004) [0x0000000000000000]
                                         // [0x00004000]
    DWORD bCanStrikeThroughEnemies : 1;  // 0x0550 (0x0004) [0x0000000000000000]
                                         // [0x00008000]
    DWORD bIsBodyBlocked : 1;            // 0x0550 (0x0004) [0x0000000000000000]
                                         // [0x00010000]
    DWORD bEnemyIsVisible : 1;           // 0x0550 (0x0004) [0x0000000000000000]
                                         // [0x00020000]
    DWORD bIsVisibleToEnemy : 1;         // 0x0550 (0x0004) [0x0000000000000000]
                                         // [0x00040000]
    DWORD bWasVisibleToEnemy : 1;        // 0x0550 (0x0004) [0x0000000000000000]
                                         // [0x00080000]
    DWORD bUseDesiredRotationForMelee : 1;  // 0x0550 (0x0004)
                                            // [0x0000000000000000] [0x00100000]
    DWORD bIamAsClosesToTheEnemyAsICanGet : 1;  // 0x0550 (0x0004)
                                                // [0x0000000000000000]
                                                // [0x00200000]
    DWORD bForceFrustration : 1;        // 0x0550 (0x0004) [0x0000000000000000]
                                        // [0x00400000]
    DWORD bDefaultCanSprint : 1;        // 0x0550 (0x0004) [0x0000000000000000]
                                        // [0x00800000]
    DWORD bCanDoHeavyBump : 1;          // 0x0550 (0x0004) [0x0000000000000000]
                                        // [0x01000000]
    DWORD bAllowCombatTransitions : 1;  // 0x0550 (0x0004) [0x0000000000000000]
                                        // [0x02000000]
    DWORD bIsProbingMeleeRangeEvents : 1;  // 0x0550 (0x0004)
                                           // [0x0000000000000000] [0x04000000]
    DWORD bDebug_DrawAIDebug : 1;        // 0x0550 (0x0004) [0x0000000000000000]
                                         // [0x08000000]
    DWORD bDebug_DrawAnchor : 1;         // 0x0550 (0x0004) [0x0000000000000000]
                                         // [0x10000000]
    DWORD bDebug_ShowPreparingMove : 1;  // 0x0550 (0x0004) [0x0000000000000000]
                                         // [0x20000000]
    DWORD bDebug_ShowStrikeRange : 1;    // 0x0550 (0x0004) [0x0000000000000000]
                                         // [0x40000000]
    DWORD bDebug_ShowAllStrikeRange : 1;  // 0x0550 (0x0004)
                                          // [0x0000000000000000] [0x80000000]
    DWORD bDebug_LogToProfiler : 1;     // 0x0554 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bDebug_DrawPath : 1;          // 0x0554 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bDebug_DrawOverheadInfo : 1;  // 0x0554 (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    DWORD bUseUniqueAILogFile : 1;      // 0x0554 (0x0004) [0x0000000000000000]
                                        // [0x00000008]
    DWORD bDebug_PostRenderInfo : 1;    // 0x0554 (0x0004) [0x0000000000000000]
                                        // [0x00000010]
    DWORD
        bDebug_DrawSeparationSteering : 1;  // 0x0554 (0x0004)
                                            // [0x0000000000000000] [0x00000020]
    DWORD bHasDebugCommand : 1;    // 0x0554 (0x0004) [0x0000000000000000]
                                   // [0x00000040]
    DWORD bForceDebugCommand : 1;  // 0x0554 (0x0004) [0x0000000000000000]
                                   // [0x00000080]
    DWORD bDebug_DrawAttackAnimInfo : 1;  // 0x0554 (0x0004)
                                          // [0x0000000000000000] [0x00000100]
    DWORD bDebug_ShowViewCone : 1;   // 0x0554 (0x0004) [0x0000000000000000]
                                     // [0x00000200]
    DWORD bDisablePartialPaths : 1;  // 0x0554 (0x0004) [0x0000000000000000]
                                     // [0x00000400]
    DWORD
        bIsSimulatedPlayerController : 1;  // 0x0554 (0x0004)
                                           // [0x0000000000000000] [0x00000800]
    DWORD bDebugCommandHistory : 1;  // 0x0554 (0x0004) [0x0000000000000000]
                                     // [0x00001000]
    DWORD bDumpCommandHistoryOnExit : 1;  // 0x0554 (0x0004)
                                          // [0x0000000000000000] [0x00002000]
    DWORD bDumpedCommandHistory : 1;     // 0x0554 (0x0004) [0x0000000000000000]
                                         // [0x00004000]
    class AKFGameInfo* MyKFGameInfo;     // 0x0558 (0x0008) [0x0000000000000000]
    class AKFPawn_Monster* MyKFPawn;     // 0x0560 (0x0008) [0x0000000000000000]
    class UKFAIDirector* MyAIDirector;   // 0x0568 (0x0008) [0x0000000000000000]
    class UKFAISteering* Steering;       // 0x0570 (0x0008) [0x0000000000000000]
    class UClass* DefaultCommandClass;   // 0x0578 (0x0008) [0x0000000000000000]
    class UClass* MeleeCommandClass;     // 0x0580 (0x0008) [0x0000000000000000]
    class AActor* IntermediateMoveGoal;  // 0x0588 (0x0008) [0x0000000000000000]
    int FailedMoveToEnemyCount;          // 0x0590 (0x0004) [0x0000000000000000]
    float MoveOffset;                    // 0x0594 (0x0004) [0x0000000000000000]
    class AActor* MoveGoal;              // 0x0598 (0x0008) [0x0000000000000000]
    struct FBasedPosition MovePosition;  // 0x05A0 (0x0038) [0x0000000000000000]
    class AActor* MoveFocus;             // 0x05D8 (0x0008) [0x0000000000000000]
    float LastDetourCheckTime;           // 0x05E0 (0x0004) [0x0000000000000000]
    float LastObstructionTime;           // 0x05E4 (0x0004) [0x0000000000000000]
    float LastSprintChangeTime;          // 0x05E8 (0x0004) [0x0000000000000000]
    struct FRotator LockedRotation;      // 0x05EC (0x000C) [0x0000000000000000]
    class UAICommand*
        CachedAICommandList;             // 0x05F8 (0x0008) [0x0000000000000000]
    float NextDirectPathCheckTime;       // 0x0600 (0x0004) [0x0000000000000000]
    float DirectPathCheckFrequency_Min;  // 0x0604 (0x0004) [0x0000000000000000]
    float DirectPathCheckFrequency_Max;  // 0x0608 (0x0004) [0x0000000000000000]
    float DirectPathExtentModifier;      // 0x060C (0x0004) [0x0000000000000000]
    struct FVector2D
        SprintWithinEnemyRange;       // 0x0610 (0x0008) [0x0000000000000000]
    float RotationRateMultiplier;     // 0x0618 (0x0004) [0x0000000000000000]
    class AKFDoorActor* PendingDoor;  // 0x061C (0x0008) [0x0000000000000000]
    float LastLOSCheckTime;           // 0x0624 (0x0004) [0x0000000000000000]
    float MinTimeBetweenLOSChecks;    // 0x0628 (0x0004) [0x0000000000000000]
    class AKFPathnode* BlockedPath;   // 0x062C (0x0008) [0x0000000000000000]
    float MaxBlockedPathDuration;     // 0x0634 (0x0004) [0x0000000000000000]
    struct FColor
        PathNodeShowRouteCacheColor;  // 0x0638 (0x0004) [0x0000000000000000]
    struct FVector PathNodeShowRouteCacheCrossOffset;  // 0x063C (0x000C)
                                                       // [0x0000000000000000]
    float PathNodeShowRouteCacheCrossSize;             // 0x0648 (0x0004)
                                                       // [0x0000000000000000]
    struct FVector
        PathNodeShowRouteCacheNumberLabelOffset;      // 0x064C (0x000C)
                                                      // [0x0000000000000000]
    float PathNodeShowRouteCacheNumberLabelDuration;  // 0x0658 (0x0004)
                                                      // [0x0000000000000000]
    class UAIPluginMovement*
        KfMovementPlugin;               // 0x065C (0x0008) [0x0000000000000000]
    class UAIPluginLeap* KfLeapPlugin;  // 0x0664 (0x0008) [0x0000000000000000]
    class UAIPluginStuckFix*
        KfStuckFixPlugin;  // 0x066C (0x0008) [0x0000000000000000]
    class UAIPluginMovement*
        KfWallWalkingPlugIn;             // 0x0674 (0x0008) [0x0000000000000000]
    unsigned char CurrentMovementPhase;  // 0x067C (0x0001) [0x0000000000000000]
    unsigned char
        TypeOfMovementStuckOn;  // 0x067D (0x0001) [0x0000000000000000]
    unsigned char
        AIRemainingTeleportThreshold;  // 0x067E (0x0001) [0x0000000000000000]
    unsigned char
        PendingAnimStrikeIndex;          // 0x067F (0x0001) [0x0000000000000000]
    unsigned char FrustrationThreshold;  // 0x0680 (0x0001) [0x0000000000000000]
    unsigned char
        CurrentEnemysHistoryIndex;  // 0x0681 (0x0001) [0x0000000000000000]
    unsigned char
        DebugCurrentStrikeIndex;  // 0x0682 (0x0001) [0x0000000000000000]
    struct FColor
        Move_failure_type_none_color;  // 0x0684 (0x0004) [0x0000000000000000]
    struct FColor
        Move_failure_type_no_nav_mesh_path_color;  // 0x0688 (0x0004)
                                                   // [0x0000000000000000]
    struct FColor
        Move_failure_type_same_intermediate_point_too_many_times_color;  // 0x068C
                                                                         // (0x0004)
                                                                         // [0x0000000000000000]
    struct FColor
        MoveFailureTypeTargetOffNavMeshAndCanNotFindLocaitonNearThemICanMoveTo;  // 0x0690 (0x0004) [0x0000000000000000]
    float
        DefaultMaxTimeAllowedToStayStuckBeforeSuicide;  // 0x0694 (0x0004)
                                                        // [0x0000000000000000]
    float
        NoNavMeshPathMaxTimeAllowedToStayStuckBeforeSuicide;  // 0x0698 (0x0004)
                                                              // [0x0000000000000000]
    float
        SameIntermediatePointToManyTimesMaxTimeAllowedToStayStuckBeforeSuicide;  // 0x069C (0x0004) [0x0000000000000000]
    float
        TargetOffNavMeshAndCanNotFindLocaitonNearThemICanMoveTooMaxTimeAllowedToStayStuckBeforeSuicide;  // 0x06A0 (0x0004) [0x0000000000000000]
    float
        SameIntermediatePointToManyTimesDurationAfterStartedMovingAgaintToStopStuckCheck;  // 0x06A4 (0x0004) [0x0000000000000000]
    float
        DefaultMinDistaceToHaveToMoveToBeConcideredStuckBeforeSuicide;  // 0x06A8
                                                                        // (0x0004)
                                                                        // [0x0000000000000000]
    float
        NoNavMeshPathMinDistaceToHaveToMoveToBeConcideredStuckBeforeSuicide;  // 0x06AC (0x0004) [0x0000000000000000]
    float
        SameIntermediatePointToManyTimesMinDistaceToHaveToMoveToBeConcideredStuckBeforeSuicide;  // 0x06B0 (0x0004) [0x0000000000000000]
    class UTexture2D*
        MovementPhaseTypePathNodeNormalMoveToIcon;  // 0x06B4 (0x0008)
                                                    // [0x0000000000000000]
    class UTexture2D*
        MovementPhaseTypePathNodeMoveFailedIcon;  // 0x06BC (0x0008)
                                                  // [0x0000000000000000]
    class UTexture2D*
        MovementPhaseTypePathNodeMoveToPointIcon;  // 0x06C4 (0x0008)
                                                   // [0x0000000000000000]
    class UTexture2D*
        MovementPhaseTypePathNodeRotateToFocusIcon;  // 0x06CC (0x0008)
                                                     // [0x0000000000000000]
    class UTexture2D*
        MovementPhaseTypePathNodeDelayMoveIcon;  // 0x06D4 (0x0008)
                                                 // [0x0000000000000000]
    class UTexture2D*
        MovementPhaseTypeUnknownIcon;  // 0x06DC (0x0008) [0x0000000000000000]
    class UTexture2D*
        MovementPhaseTypeNavMeshNormalMoveToIcon;  // 0x06E4 (0x0008)
                                                   // [0x0000000000000000]
    class UTexture2D*
        MovementPhaseTypeFinalDestMoveTowardsIcon;  // 0x06EC (0x0008)
                                                    // [0x0000000000000000]
    class UTexture2D*
        MovementPhaseTypeEMT_LOS_MoveTowardsIcon;  // 0x06F4 (0x0008)
                                                   // [0x0000000000000000]
    class UTexture2D*
        MovementPhaseTypeMovingToNavMeshUsingPathNodesIcon;  // 0x06FC (0x0008)
                                                             // [0x0000000000000000]
    class UTexture2D*
        MovementPhaseTypeFALLBACK_REFUSED_TO_BE_EXPLOTIED_FIND_NEARBY_MESH_POINT_MOVE_TO_DIRECT_NON_PATH_POSIcon;  // 0x0704 (0x0008) [0x0000000000000000]
    class UTexture2D*
        MovementPhaseTypeFALLBACK_FIND_NEARBY_MESH_POINT_MOVE_TO_DIRECT_NON_PATH_POSIcon;  // 0x070C (0x0008) [0x0000000000000000]
    class UTexture2D*
        TypeOfMovementStuckOnUnknownWhyIcon;  // 0x0714 (0x0008)
                                              // [0x0000000000000000]
    class UTexture2D*
        TypeOfMovementStuckOnMOVE_FAILURE_TYPE_NO_NAV_MESH_PATHIcon;  // 0x071C
                                                                      // (0x0008)
                                                                      // [0x0000000000000000]
    class UTexture2D*
        TypeOfMovementStuckOnMOVE_FAILURE_TYPE_SAME_INTERMEDIATE_POINT_TOO_MANY_TIMESIcon;  // 0x0724 (0x0008) [0x0000000000000000]
    class UTexture2D*
        TypeOfMovementStuckOnMOVE_FAILURE_TYPE_TARGET_OFF_NAV_MESH_AND_CAN_NOT_FIND_LOCAITON_NEAR_THEM_I_CAN_MOVE_TOIcon;  // 0x072C (0x0008) [0x0000000000000000]
    class UTexture2D*
        TypeOfMovementStuckOnLookingForBetterIntermediateLoc;  // 0x0734
                                                               // (0x0008)
                                                               // [0x0000000000000000]
    class UTexture2D*
        TypeOfMovementStuckOnMoveToBetterIntermediate;  // 0x073C (0x0008)
                                                        // [0x0000000000000000]
    struct FColor
        ColorForCollisionRadiusForReducedZedOnZedPinchPointCollisionStateOff;  // 0x0744 (0x0004) [0x0000000000000000]
    struct FColor
        ColorForCollisionRadiusForReducedZedOnZedPinchPointCollisionStateOn;  // 0x0748 (0x0004) [0x0000000000000000]
    float
        DistanceToCheckForClearPathOnNavMeshLocWhenOffNavMesh;  // 0x074C
                                                                // (0x0004)
                                                                // [0x0000000000000000]
    float
        DistanceToCheckForNonExploitedOnNavMeshLocWhenOffNavMesh;  // 0x0750
                                                                   // (0x0004)
                                                                   // [0x0000000000000000]
    float
        DistanceToCheckForNonExploitedOnNavMeshLocWhenOnDeadEndOfNavMesh;  // 0x0754
                                                                           // (0x0004)
                                                                           // [0x0000000000000000]
    struct FColor
        DefaultColorOfValidLocationWhenLookingForLocationsOnNavMesh;  // 0x0758
                                                                      // (0x0004)
                                                                      // [0x0000000000000000]
    struct FColor
        DefaultColorOfSearchSphereWhenNoValidLocationsFoundWhenLookingForLocationsOnNavMesh;  // 0x075C (0x0004) [0x0000000000000000]
    struct FColor
        ColorOfValidLocationFoundFor1stTryLookingForLocationsOnNavMesh;  // 0x0760
                                                                         // (0x0004)
                                                                         // [0x0000000000000000]
    struct FColor
        ColorOfSearchSphereWhenNoValidLocationsFoundFor1stTryLookingForLocationsOnNavMesh;  // 0x0764 (0x0004) [0x0000000000000000]
    struct FColor
        ColorOfValidLocationFoundFor2ndTryLookingForLocationsOnNavMesh;  // 0x0768
                                                                         // (0x0004)
                                                                         // [0x0000000000000000]
    struct FColor
        ColorOfSearchSphereWhenNoValidLocationsFoundFor2ndTryLookingForLocationsOnNavMesh;  // 0x076C (0x0004) [0x0000000000000000]
    struct FColor
        ColorOfValidLocationFoundFor3rdTryLookingForLocationsOnNavMesh;  // 0x0770
                                                                         // (0x0004)
                                                                         // [0x0000000000000000]
    struct FColor
        ColorOfSearchSphereWhenNoValidLocationsFoundFor3rdTryLookingForLocationsOnNavMesh;  // 0x0774 (0x0004) [0x0000000000000000]
    struct FColor
        ColorOfValidLocationFoundForLookingForLocationsOnNavMeshWhenOnDeadEndOfNavMesh;  // 0x0778 (0x0004) [0x0000000000000000]
    struct FColor
        ColorOfSearchSphereWhenNoValidLocationsFoundForTryLookingForLocationsOnNavMeshWhenOnDeadEndOfNavMesh;  // 0x077C (0x0004) [0x0000000000000000]
    float
        DistanceToCheckForClearPathOnNavMeshLocWhenEnemyIsOffNavMesh;  // 0x0780
                                                                       // (0x0004)
                                                                       // [0x0000000000000000]
    float
        DistanceToCheckForNonExploitedOnNavMeshLocWhenEnemyIsOffNavMesh;  // 0x0784
                                                                          // (0x0004)
                                                                          // [0x0000000000000000]
    float GeneralGoalDistanceForMovingToDoor;  // 0x0788 (0x0004)
                                               // [0x0000000000000000]
    float RecastEnemyRepathDistance;  // 0x078C (0x0004) [0x0000000000000000]
    struct FVector
        DropEdgeLeapVelocity;  // 0x0790 (0x000C) [0x0000000000000000]
    float MaxRangeToDropEdgeAllowedToLeadFrom;      // 0x079C (0x0004)
                                                    // [0x0000000000000000]
    float DistanceDownRangeToFocusForDropEdgeLeap;  // 0x07A0 (0x0004)
                                                    // [0x0000000000000000]
    float TimeToShowEdgeTypeForNavMeshPathting;     // 0x07A4 (0x0004)
                                                    // [0x0000000000000000]
    struct FVector LastLeaderPosOffset;  // 0x07A8 (0x000C) [0x0000000000000000]
    float LastNotifyHitWallTime;         // 0x07B4 (0x0004) [0x0000000000000000]
    class AActor* LastHitWall;           // 0x07B8 (0x0008) [0x0000000000000000]
    struct FVector LastWallHitNormal;    // 0x07C0 (0x000C) [0x0000000000000000]
    int HitWallCount;                    // 0x07CC (0x0004) [0x0000000000000000]
    TArray<struct FsBlockedPathInfo>
        BlockedPathList;        // 0x07D0 (0x0010) [0x0000000000000000]
    class AKFPawn* LastBumper;  // 0x07E0 (0x0008) [0x0000000000000000]
    float CurBumpVal;           // 0x07E8 (0x0004) [0x0000000000000000]
    float BumpThreshold;        // 0x07EC (0x0004) [0x0000000000000000]
    float BumpDecayRate;        // 0x07F0 (0x0004) [0x0000000000000000]
    float BumpGrowthRate;       // 0x07F4 (0x0004) [0x0000000000000000]
    float LastStuckCheckTime;   // 0x07F8 (0x0004) [0x0000000000000000]
    float
        TotalStuckCheckCloseRangeTime;   // 0x07FC (0x0004) [0x0000000000000000]
    float LastStuckCheckCloseRangeTime;  // 0x0800 (0x0004) [0x0000000000000000]
    float StuckCheckInterval;            // 0x0804 (0x0004) [0x0000000000000000]
    float
        StuckVelocityThreshholdSquared;  // 0x0808 (0x0004) [0x0000000000000000]
    float StuckPossiblity;               // 0x080C (0x0004) [0x0000000000000000]
    float StuckPossiblityThreshhold;     // 0x0810 (0x0004) [0x0000000000000000]
    float LastStuckTime;                 // 0x0814 (0x0004) [0x0000000000000000]
    float LastTeleportCheckTime;         // 0x0818 (0x0004) [0x0000000000000000]
    float LastTeleportTime;              // 0x081C (0x0004) [0x0000000000000000]
    float TeleportCheckInterval;         // 0x0820 (0x0004) [0x0000000000000000]
    float TeleportCooldown;              // 0x0824 (0x0004) [0x0000000000000000]
    float HiddenRelocateTeleportThreshold;    // 0x0828 (0x0004)
                                              // [0x0000000000000000]
    float PostSpawnRelocateTeleportCooldown;  // 0x082C (0x0004)
                                              // [0x0000000000000000]
    struct FVector
        LastTeleportLocation;      // 0x0830 (0x000C) [0x0000000000000000]
    float LastSpecialMoveEndTime;  // 0x083C (0x0004) [0x0000000000000000]
    struct FVector
        LastStuckCheckLocation;         // 0x0840 (0x000C) [0x0000000000000000]
    float XYMoveStuckThresholdSquared;  // 0x084C (0x0004) [0x0000000000000000]
    float ZMoveStuckThresholdSquared;   // 0x0850 (0x0004) [0x0000000000000000]
    float StuckCheckEnemyDistThreshholdSquared;          // 0x0854 (0x0004)
                                                         // [0x0000000000000000]
    float NavigationBumpTeamCollisionThreshholdSquared;  // 0x0858 (0x0004)
                                                         // [0x0000000000000000]
    float FallingStuckNoZVelocityTime;  // 0x085C (0x0004) [0x0000000000000000]
    int NumFailedLatentWalkMoves;       // 0x0860 (0x0004) [0x0000000000000000]
    class APawn* StepAsideGoal;         // 0x0864 (0x0008) [0x0000000000000000]
    float MaxStepAsideDist;             // 0x086C (0x0004) [0x0000000000000000]
    float LastFailedToFindStepAsideLocation;  // 0x0870 (0x0004)
                                              // [0x0000000000000000]
    class APawn* LastBumpedPawn;        // 0x0874 (0x0008) [0x0000000000000000]
    float LastBumpTime;                 // 0x087C (0x0004) [0x0000000000000000]
    float AttackRange;                  // 0x0880 (0x0004) [0x0000000000000000]
    float StrikeRange;                  // 0x0884 (0x0004) [0x0000000000000000]
    float StrikeRangePercentage;        // 0x0888 (0x0004) [0x0000000000000000]
    float DoorMeleeDistance;            // 0x088C (0x0004) [0x0000000000000000]
    float MaxMeleeHeightAngle;          // 0x0890 (0x0004) [0x0000000000000000]
    float LastAttackTime_Melee;         // 0x0894 (0x0004) [0x0000000000000000]
    float LastMeleeAttackDecisionTime;  // 0x0898 (0x0004) [0x0000000000000000]
    float LastSelectEnemyTime;          // 0x089C (0x0004) [0x0000000000000000]
    float LastSetEnemyTime;             // 0x08A0 (0x0004) [0x0000000000000000]
    float MinTimeBetweenStatusUpdates;  // 0x08A4 (0x0004) [0x0000000000000000]
    float MaxTimeBetweenStatusUPdates;  // 0x08A8 (0x0004) [0x0000000000000000]
    float LastMoveFinishTime;           // 0x08AC (0x0004) [0x0000000000000000]
    float MinTimeBetweenEnemyChanges;   // 0x08B0 (0x0004) [0x0000000000000000]
    float LastDestructibleBumpTime;     // 0x08B4 (0x0004) [0x0000000000000000]
    class AActor* ActorEnemy;           // 0x08B8 (0x0008) [0x0000000000000000]
    class AKFDoorActor* DoorEnemy;      // 0x08C0 (0x0008) [0x0000000000000000]
    class AKFPawn* MeleeTarget;         // 0x08C8 (0x0008) [0x0000000000000000]
    float EnemyVisibilityTime;          // 0x08D0 (0x0004) [0x0000000000000000]
    float LastEnemySwitchTime;          // 0x08D4 (0x0004) [0x0000000000000000]
    class APawn* CachedVisibleEnemy;    // 0x08D8 (0x0008) [0x0000000000000000]
    class AProjectile*
        PendingEvadeProjectile;      // 0x08E0 (0x0008) [0x0000000000000000]
    float EvadeGrenadeChance;        // 0x08E8 (0x0004) [0x0000000000000000]
    float LastGetStrikeTime;         // 0x08EC (0x0004) [0x0000000000000000]
    float MaxGetStrikeTime;          // 0x08F0 (0x0004) [0x0000000000000000]
    float FrustrationDelay;          // 0x08F4 (0x0004) [0x0000000000000000]
    float LastFrustrationCheckTime;  // 0x08F8 (0x0004) [0x0000000000000000]
    float
        GoalDistanceWhenMovingToLocationForMeleeStrikeWhenEnemyIsOffNavMesh;  // 0x08FC (0x0004) [0x0000000000000000]
    TArray<struct FCooldownData>
        CooldownTimers;  // 0x0900 (0x0010) [0x0000000000000000]
    struct FCooldownData
        OverallAttackCooldownTimer;    // 0x0910 (0x0010) [0x0000000000000000]
    float LowIntensityAttackCooldown;  // 0x0920 (0x0004) [0x0000000000000000]
    class UKFAiDirectProjectileFireBehavior*
        DirectProjectileFireBehavior;  // 0x0924 (0x0008) [0x0000000000000000]
    class UKFAiLeapBehavior*
        LeapBehavior;  // 0x092C (0x0008) [0x0000000000000000]
    struct FVector
        BaseShapeOfProjectileForCalc;  // 0x0934 (0x000C) [0x0000000000000000]
    float LastShotTime;                // 0x0940 (0x0004) [0x0000000000000000]
    int ZedBumpEffectThreshold;        // 0x0944 (0x0004) [0x0000000000000000]
    float ZedBumpObliterationEffectChance;  // 0x0948 (0x0004)
                                            // [0x0000000000000000]
    TArray<struct FsDangerEvadeInfo>
        DangerEvadeSettings;  // 0x094C (0x0010) [0x0000000000000000]
    struct FsEvadeOnDamageInfo
        EvadeOnDamageSettings;   // 0x095C (0x0010) [0x0000000000000000]
    int AccumulatedEvadeDamage;  // 0x096C (0x0004) [0x0000000000000000]
    int AccumulatedBlockDamage;  // 0x0970 (0x0004) [0x0000000000000000]
    TArray<struct FsFriendlyDamageInfo>
        FriendlyDamageHistory;          // 0x0974 (0x0010) [0x0000000000000000]
    float AggroPlayerHealthPercentage;  // 0x0984 (0x0004) [0x0000000000000000]
    float AggroPlayerResetTime;         // 0x0988 (0x0004) [0x0000000000000000]
    float MinDistanceToAggroZed;        // 0x098C (0x0004) [0x0000000000000000]
    float AggroZedResetTime;            // 0x0990 (0x0004) [0x0000000000000000]
    float AggroZedHealthPercentage;     // 0x0994 (0x0004) [0x0000000000000000]
    float AggroEnemySwitchWaitTime;     // 0x0998 (0x0004) [0x0000000000000000]
    float LastTauntTime;                // 0x099C (0x0004) [0x0000000000000000]
    float RepeatWalkingTauntTime;       // 0x09A0 (0x0004) [0x0000000000000000]
    float NextTauntTime;                // 0x09A4 (0x0004) [0x0000000000000000]
    float NextRandomTauntTime;          // 0x09A8 (0x0004) [0x0000000000000000]
    float TauntTeamFactor;              // 0x09AC (0x0004) [0x0000000000000000]
    struct FVector2D TauntTimeDelay;    // 0x09B0 (0x0008) [0x0000000000000000]
    struct FVector2D
        RandomTauntTimeDelay;  // 0x09B8 (0x0008) [0x0000000000000000]
    TArray<struct FInvalidAnchorItem>
        InvalidAnchorList;            // 0x09C0 (0x0010) [0x0000000000000000]
    float TimeFirstSawPlayer;         // 0x09D0 (0x0004) [0x0000000000000000]
    struct FVector ChargeLocation;    // 0x09D4 (0x000C) [0x0000000000000000]
    struct FString RecentActionInfo;  // 0x09E0 (0x0010) [0x0000000000000000]
    struct FRotator Debug_StepRot;    // 0x09F0 (0x000C) [0x0000000000000000]
    struct FBasedPosition
        Debug_StepLoc;              // 0x09FC (0x0038) [0x0000000000000000]
    class AKFPawn* ChargeTarget;    // 0x0A34 (0x0008) [0x0000000000000000]
    struct FString AIActionStatus;  // 0x0A3C (0x0010) [0x0000000000000000]
    struct FColor
        Debug_TextColorOverride;  // 0x0A4C (0x0004) [0x0000000000000000]
    TArray<struct FName>
        EnabledDebugTextCategories;  // 0x0A50 (0x0010) [0x0000000000000000]
    class AKFSpawnVolume*
        MySpawnVolume;  // 0x0A60 (0x0008) [0x0000000000000000]
    struct FVector
        LocationAtStartOfStuckCheck;  // 0x0A68 (0x000C) [0x0000000000000000]
    struct FVector
        LocationAtLastStuckCheck;  // 0x0A74 (0x000C) [0x0000000000000000]
    class UAICommand*
        CmdTriggeringHardCoreStuckChecking;  // 0x0A80 (0x0008)
                                             // [0x0000000000000000]
    class UAITickablePlugin*
        PlugInTriggeringTriggeringHardCoreStuckChecking;  // 0x0A88 (0x0008)
                                                          // [0x0000000000000000]
    TArray<struct FKFAICmdHistoryItem>
        KFAICommandHistory;  // 0x0A90 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3303];

        return pClassPointer;
    };

    void GetCommandStack();
    void DrawMaxHitRange();
    void DrawAttackRangeText();
    void eventDrawStrikeRangeLines();
    void DrawStrikeRange();
    void eventDrawStrikeRanges();
    void eventEvaluateThreatFrom();
    void eventGetPlayerViewPoint();
    void EnterZedVictoryState();
    void GetIsInZedVictoryState();
    void ResetKFAIC();
    void SpawnEnraged();
    void NotifyEnRaged();
    void GetMinDistanceToAnyPlayer();
    void DebugLogRoute();
    void CanAttackDestructibles();
    void NotifyAttackActor();
    void NotifyAttackDoor();
    void DoorFinished();
    void Timer_WaitingForDoor();
    void eventWaitForDoor();
    void CanReachEvadeLocation();
    void GetBestEvadeDir();
    void CanEvade();
    void Timer_DoProjectileEvade();
    void CanEvadeGrenade();
    void HandleProjectileWarning();
    void DoProjectileWarning();
    void UpdateFriendlyDamageHistory();
    void NotifyFriendlyAIDamageTaken();
    void NotifyTakeHit();
    void ReceiveLocationalWarning();
    void ReceiveProjectileWarning();
    void ReceiveMeleeWarning();
    void GetDangerEvadeDelay();
    void DrawBehaviorTreeIconOverhead();
    void DrawDebugOverheadMovementPhaseData();
    void IsAggroEnemySwitchAllowed();
    void DoDebugTurnInPlace();
    void BeginDebugCommand();
    void DrawDebug();
    void IsDebugTextCategoryEnabled();
    void DrawAttackInfo();
    void eventPostRenderFor();
    void SetPostRendering();
    void DumpStack();
    void eventDebug_AIPaused();
    void Debug_CheckRecentMoveTime();
    void AmIAllowedToStillUsePathNodes();
    void AmIAllowedToSuicideWhenStuck();
    void HardCoreCheckStuckTimer();
    void GetMinDistaceToHaveToMoveToBeConcideredStuckByStuckType();
    void ToggleHardCoreStuckNpcs();
    void GetMaxTimeAllowedToStayStuckBasedOnStuckType();
    void Debug_CheckStuckTimer();
    void ShowStuckNpcsToggle();
    void LogToProfiler();
    void KFDebug_DrawPathGoal();
    void KFDebug_DrawPathTo();
    void KFDebug_DrawMyPath();
    void KFDebug_DrawPath();
    void KFDebug_ClearDebugText();
    void KFDebug_ClearSpheres();
    void KFDebug_ClearLines();
    void GetDebugLines();
    void ScreenMessagePlayer();
    void eventPauseAndShowMsg();
    void AIBugItStringCreator();
    void eventAILog_Internal();
    void eventmsg();
    void OnDestroy();
    void eventSetRecentActionInfo();
    void IsInDebugMode();
    void SetupDebug();
    void DrawDebugTextToHud();
    void DrawDebugText();
    void DumpCommandHistory();
    void StartSteering();
    void NotifySpecialMoveStarted();
    void NotifySpecialMoveEnded();
    void SpecialMoveTimeout();
    void NotifyMeleeDamageDealt();
    void DrawFireAttackDebug();
    void eventNotifyBump();
    void eventHearNoise();
    void eventEnemyNotVisible();
    void eventSeePlayer();
    void RestoreCollisionCylinderReducedPercentForSameTeamIgnoreBlockingBy();
    void ReduceCollisionCylinderReducedPercentForSameTeamIgnoreBlockingBy();
    void SpecialBumpHandling();
    void ShouldReduceZedOnZedCollisionOnBumpForNavigating();
    void RelocateTeleport();
    void StuckTeleportToPathNode();
    void StuckTeleportToSpawnVolume();
    void StuckSuicide();
    void HandleStuck();
    void EvaluateStuckPossibility();
    void EvaluateTeleportPossibility();
    void Tick();
    void eventTouch();
    void eventDisableBump();
    void eventEnableBump();
    void RecordBump();
    void eventDisableHearNoise();
    void eventEnableHearNoise();
    void IsPawnVisibleViaTrace();
    void eventDisableEnemyNotVisible();
    void eventEnableEnemyNotVisible();
    void eventDisableSeePlayer();
    void eventEnableSeePlayer();
    void eventNotifyFallingHitWall();
    void eventNotifyHitWall();
    void DisableNotifyHitWall();
    void EnableNotifyHitWall();
    void NotifyHuskSuicide();
    void eventEnemyIsSurrounded();
    void eventNotifyLanded();
    void NotifyBaseChange();
    void RecordHitWall();
    void RecordLeapToWall();
    void GetDropEdgeLeapVelocity();
    void Timer_EnableJumpOverWalls();
    void eventJumpedOverWall();
    void eventMayFall();
    void eventNotifyOnAddToRouteCache();
    void IsNavInRouteCache();
    void FailedToFindFallbackAnchor();
    void GetFallbackAnchor();
    void InvalidateAnchor();
    void NotifyNeedRepath();
    void eventForcePauseAndRepath();
    void eventMoveUnreachable();
    void eventFailMove();
    void HandleZedBlockedPath();
    void eventHandlePathObstruction();
    void eventFindDirectPath();
    void eventAllowDetourTo();
    void SetFailedPathToEnemy();
    void IsValidDirectMoveGoal();
    void eventNotifyPathChanged();
    void eventNotifyFailMove();
    void eventNotifyLatentPostPhysWalking();
    void NotifyReachedLatentMoveGoal();
    void NotifyFleeFinished();
    void NotifyCommandFinished();
    void IsFrustrated();
    void UpdateSprintFrustration();
    void ShouldSprint();
    void CanSetSprinting();
    void SetCanSprintWhenDamaged();
    void SetSprintingDisabled();
    void SetCanSprint();
    void GetMoveTimeOutDuration();
    void GetEstimatedGroundSpeedForMoveTimout();
    void MoveToEnemy_GetMoveFocus();
    void eventFailedMove();
    void ShouldDelayStepAside();
    void eventStepAsideFor();
    void eventAttitudeStateChanged();
    void EndPanicWander();
    void DoPanicWander();
    void DoHeadlessWander();
    void DoStumble();
    void DoEvade();
    void PreMoveToEnemy();
    void DoProjectileEvade();
    void eventRunOverWarning();
    void CanDoStrike();
    void DoStrike();
    void eventSetEnemyMoveGoal();
    void eventSetMovePoint();
    void eventSetMoveGoal();
    void DoFleeFrom();
    void DoWander();
    void DoPauseAI();
    void ShowAdvancedRouteEdgeDebugInfo();
    void AddBlockedReachSpec();
    void eventGenerateDoorlessPathTo();
    void eventGenerateNavMeshPathToLocation();
    void eventGenerateNavMeshPathTo();
    void eventGeneratePathTo();
    void MovePointIsValid();
    void MoveGoalIsValid();
    void MoveIsInterruptable();
    void ReachedIntermediateMoveGoal();
    void eventReachedMoveGoal();
    void eventAllowedToMove();
    void eventStoppingMovement();
    void eventStartingMovement();
    void StopMovement();
    void AIZeroMovementVariables();
    void eventAbortMovementPlugIns();
    void eventAbortMovementCommands();
    void ClearMovementInfo();
    void eventStopAllLatentMovement();
    void IsDoingLatentMove();
    void SetDirectPathCheckTime();
    void CalcClosestPointTime();
    void GetRouteCacheDistance();
    void GetSteering();
    void InitSteering();
    void IsMovingToJumpPoint();
    void ActorReachableNoAnchorCheck();
    void CheckInterruptCombatTransitions();
    void CheckOverallCooldownTimer();
    void SetOverallCooldownTimer();
    void AddCooldownTimer();
    void CheckCooldownTimer();
    void AreZedsNear();
    void CanSeeByPointsEx();
    void GetZedCount();
    void OtherZedsTargetingMyEnemy();
    void NumberOfZedsTargetingPawn();
    void eventDoGrabAttack();
    void eventCanGrabAttack();
    void ChooseStrikeByName();
    void UpdateLastMeleeTime();
    void NotifyCommandMeleeAttackAborted();
    void EndOfMeleeAttackNotification();
    void WithinMeleeHeightDifference();
    void IsWithinAttackRange();
    void IsValidAttackTarget();
    void BeginMeleeCommand();
    void NotifyMeleeAttackFinished();
    void DoHeavyZedBump();
    void SelectTarget();
    void SelectEnemy();
    void HasValidEnemy();
    void NotifyKilled();
    void CheckCombatTransition();
    void eventIsDoingAttackSpecialMove();
    void GetClosestEnemy();
    void CleanOutCommandListOnCombatTransition();
    void InitalizeBaseCommand();
    void BeginCombatCommand();
    void CanTargetBeGrabbed();
    void IsDoingGrabSpecialMove();
    void IsSuicidal();
    void eventReadyToMelee();
    void ResetProbingMeleeRangeEvents();
    void EnableProbingMeleeRangeEvents();
    void GetAggroRating();
    void CheckForEnemiesInFOV();
    void ChangeEnemy();
    void eventSetEnemy();
    void eventSetEnemyToZed();
    void GetHasAcceptableEnemyCount();
    void eventFindNewEnemy();
    void IsTargetedByPlayer();
    void StopAllLatentMoveExecution();
    void IsMeleeRangeEventProbingEnabled();
    void DisableMeleeRangeEventProbing();
    void EnableMeleeRangeEventProbing();
    void InChargeRange();
    void InAnyAttackTagRange();
    void InAttackTagRange();
    void InMeleeRange();
    void IsCloseEnoughToEnemy();
    void GetClosestTimeAndDistToPawn();
    void HasEnemyWithinDistance();
    void eventDestroyed();
    void eventTeleportToLocation();
    void AttemptToTeleport();
    void PawnDied();
    void GetHealthPercentage();
    void AddBasePathConstraints();
    void ReturnToIdle();
    void SetBestAnchor();
    void ShouldReturnToIdle();
    void GetDefaultCommand();
    void eventSetInitialState();
    void Timer_EvaluateStatus();
    void CreateTemporaryBlockedReach();
    void eventCreateTemporaryBlockedPath();
    void UpdateStrikeRange();
    void UpdatePendingStrike();
    void eventPossess();
    void eventPostBeginPlay();
    void eventTargetedByPlayer();
    void eventSetChargeLocation();
    void CleanUpOnDestroy();
    void IsLookingAtWall();
    void GetTeamNum();
    void SuggestNewWanderPoint();
    void IsPawnInFireLine();
    void TestTrace();
    void ActorBlockTest();
    void FastActorTrace();
    void EstimateProjectileTimeToTarget();
    void CalcAimLocToHit();
    void IsFriendlyBlockingFireLine();
    void UnlockPawnRotation();
    void LockPawnRotationTo();
    void GetPawnBlockingPathTo();
    void IsPawnMovingAwayFromMe();
    void IgnoreNotifies();
    void PopCommand();
    void PushCommand();
    void AbortCommand();
    void Cleanup();
    void ComputeTrajectoryByTime();
    void IsPawnBlockingLine();
    void LineBlockedByActor();
    void BumperSomewhereToGo();
};

UClass* AKFAIController::pClassPointer = NULL;

// Class KFGame.AICommand
// 0x0024 (0x00B8 - 0x0094)
class UAICommand : public UGameAICommand {
   public:
    class AKFAIController* AIOwner;  // 0x0094 (0x0008) [0x0000000000000000]
    class UAICommand*
        CachedChildCommand;            // 0x009C (0x0008) [0x0000000000000000]
    DWORD bAllowedToAttack : 1;        // 0x00A4 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bInterruptPauseCommand : 1;  // 0x00A4 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD bDisableMovementPluginOnPushed : 1;  // 0x00A4 (0x0004)
                                               // [0x0000000000000000]
                                               // [0x00000004]
    struct FString OverrideLogCategory;  // 0x00A8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3305];

        return pClassPointer;
    };

    void CanInterruptPauseCommand();
    void eventGetDebugVerboseText();
    void eventDrawDebug();
    void UpdateHistoryString();
    void UpdateCommandHistory();
    void NotifyNeedRepath();
    void MoveUnreachable();
    void FindDirectPath();
    void AdjustEnemyRating();
    void ShouldSelectTarget();
    void IsControllerAlive();
    void IsPawnAlive();
    void IsAllowedToAttack();
    void ShouldIgnoreTimeTransitions();
    void NotifyNpcInGrannyMode();
    void NotifyNpcTerminallyStuck();
    void NotifyMovingOnToDestructibleEdge();
    void NotifyTouch();
    void NotifyLatentPostPhysWalking();
    void NotifyBump();
    void NotifyHuskSuicide();
    void NotifyFallingHitWall();
    void NotifyHitWall();
    void EnemyIsSurrounded();
    void NotifyLanded();
    void NotifyBaseChange();
    void NotifyEnemyNotVisible();
    void NotifyPlayerBecameVisible();
    void NotifyDoorOpened();
    void NotifyEnemyChanged();
    void CanChangeEnemy();
    void NotifyCombatBehaviorChange();
    void NotifyHearNoise();
    void GetParentCommand();
    void AllowPushOfDefaultCommandForSpecialMove();
    void eventHandleAICommandSpecialAction();
    void Popped();
    void Resumed();
    void Paused();
    void PostPopped();
    void Pushed();
    void PrePushed();
};

UClass* UAICommand::pClassPointer = NULL;

// Class KFGame.AICommand_Base_Combat
// 0x0018 (0x00D0 - 0x00B8)
class UAICommand_Base_Combat : public UAICommand {
   public:
    struct FVector2D
        InitialTransitionCheckTime;  // 0x00B8 (0x0008) [0x0000000000000000]
    struct FVector2D
        TransitionCheckTime;        // 0x00C0 (0x0008) [0x0000000000000000]
    struct FName DefaultStateName;  // 0x00C8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3307];

        return pClassPointer;
    };

    void CombatSelectTarget();
    void CheckTransition();
    void TimedTransitionCheck();
    void GetTransitionCheckTime();
    void GetInitialTransitionCheckTime();
    void Paused();
    void Popped();
    void Pushed();
};

UClass* UAICommand_Base_Combat::pClassPointer = NULL;

// Class KFGame.KFAIController_Monster
// 0x0020 (0x0AC0 - 0x0AA0)
class AKFAIController_Monster : public AKFAIController {
   public:
    DWORD bCompletedInitialGrabAttack : 1;  // 0x0AA0 (0x0004)
                                            // [0x0000000000000000] [0x00000001]
    DWORD bPathAroundDestructiblesICantBreak : 1;  // 0x0AA0 (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00000002]
    DWORD bRepathOnInvalidStrike : 1;  // 0x0AA0 (0x0004) [0x0000000000000000]
                                       // [0x00000004]
    DWORD bUseRunOverWarning : 1;      // 0x0AA0 (0x0004) [0x0000000000000000]
                                       // [0x00000008]
    DWORD bEvadeOnRunOverWarning : 1;  // 0x0AA0 (0x0004) [0x0000000000000000]
                                       // [0x00000010]
    float
        MinDistanceToPerformGrabAttack;  // 0x0AA4 (0x0004) [0x0000000000000000]
    float MinTimeBetweenGrabAttacks;     // 0x0AA8 (0x0004) [0x0000000000000000]
    float LastAttackTime_Grab;           // 0x0AAC (0x0004) [0x0000000000000000]
    float MinRunOverSpeed;               // 0x0AB0 (0x0004) [0x0000000000000000]
    float LastRunOverWarningTime;        // 0x0AB4 (0x0004) [0x0000000000000000]
    float MinRunOverWarningAim;          // 0x0AB8 (0x0004) [0x0000000000000000]
    float RunOverEvadeDelayScale;        // 0x0ABC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3309];

        return pClassPointer;
    };

    void eventRunOverWarning();
    void HandleZedBlockedPath();
    void DoMeleeAttack();
    void DoStrike();
    void CanDoStrike();
    void eventCanGrabAttack();
    void eventGeneratePathTo();
    void eventReadyToMelee();
    void Timer_EnableMeleeRangeEventProbing();
    void SetPawnDefaults();
    void eventPossess();
    void InitPlayerReplicationInfo();
};

UClass* AKFAIController_Monster::pClassPointer = NULL;

// Class KFGame.AICommand_Base_Zed
// 0x0018 (0x00E8 - 0x00D0)
class UAICommand_Base_Zed : public UAICommand_Base_Combat {
   public:
    struct FPointer
        VfTable_ILatentActionObserver;   // 0x00D0 (0x0008) [0x0000000000000000]
    struct FName CachedAttackTag;        // 0x00D8 (0x0008) [0x0000000000000000]
    unsigned char AttackFlags;           // 0x00E0 (0x0001) [0x0000000000000000]
    DWORD bFailedPathfind : 1;           // 0x00E4 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bWaitingOnMovementPlugIn : 1;  // 0x00E4 (0x0004) [0x0000000000000000]
                                         // [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3311];

        return pClassPointer;
    };

    void ShouldSelectTarget();
    void ShouldAttackWhileMoving();
    void NotifyPlayerBecameVisible();
    void NotifyEnemyChanged();
    void NotifyBump();
    void OnLatentFinished();
    void Resumed();
    void Paused();
    void Pushed();
};

UClass* UAICommand_Base_Zed::pClassPointer = NULL;

// Class KFGame.KFAIController_ZedFleshpound
// 0x0050 (0x0B10 - 0x0AC0)
class AKFAIController_ZedFleshpound : public AKFAIController_Monster {
   public:
    float LastChargeStuckCheckTime;  // 0x0AC0 (0x0004) [0x0000000000000000]
    struct FVector
        LastChargeStuckCheckLocation;  // 0x0AC4 (0x000C) [0x0000000000000000]
    float ChargeStuckCheckInterval;    // 0x0AD0 (0x0004) [0x0000000000000000]
    int ChargeStuckCount;              // 0x0AD4 (0x0004) [0x0000000000000000]
    float ChargeStuckCheckDistance;    // 0x0AD8 (0x0004) [0x0000000000000000]
    DWORD bReadyToBecomeEnraged : 1;   // 0x0ADC (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bSawEnemy : 1;  // 0x0ADC (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bDebugLeaveTargetAngleThreshold : 1;  // 0x0ADC (0x0004)
                                                // [0x0000000000000000]
                                                // [0x00000004]
    float LastKickClotTime;  // 0x0AE0 (0x0004) [0x0000000000000000]
    class UKFAIPluginRage_Fleshpound*
        RagePlugin;                  // 0x0AE4 (0x0008) [0x0000000000000000]
    class UClass* RagePluginClass;   // 0x0AEC (0x0008) [0x0000000000000000]
    TArray<float> SpawnRagedChance;  // 0x0AF4 (0x0010) [0x0000000000000000]
    struct FVector ChargePivot;      // 0x0B04 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3313];

        return pClassPointer;
    };

    void UpdateSprintFrustration();
    void NotifyEnRaged();
    void DoRageTauntAt();
    void SpawnEnraged();
    void DoSpawnRageCheck();
    void CanAttackDestructibles();
    void eventSetEnemy();
    void eventSeePlayer();
    void RestoreCollisionSize();
    void StartSteering();
    void CanSetSprinting();
    void ShouldSprint();
    void eventIsEnraged();
    void CanEvadeGrenade();
    void eventAttitudeStateChanged();
    void NotifyTakeHit();
    void NotifyMeleeDamageDealt();
    void eventFindNewEnemy();
    void AmIAllowedToSuicideWhenStuck();
    void Tick();
    void Cleanup();
    void eventPossess();
};

UClass* AKFAIController_ZedFleshpound::pClassPointer = NULL;

// Class KFGame.AICommand_Base_Fleshpound
// 0x0000 (0x00E8 - 0x00E8)
class UAICommand_Base_Fleshpound : public UAICommand_Base_Zed {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3315];

        return pClassPointer;
    };

    void NotifyCombatBehaviorChange();
    void NotifyEnemyChanged();
    void NotifyPlayerBecameVisible();
    void Popped();
    void Pushed();
};

UClass* UAICommand_Base_Fleshpound::pClassPointer = NULL;

// Class KFGame.AICommand_MoveToGoal
// 0x011C (0x01D4 - 0x00B8)
class UAICommand_MoveToGoal : public UAICommand {
   public:
    DWORD
        bCanPathfind : 1;  // 0x00B8 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bValidRouteCache : 1;   // 0x00B8 (0x0004) [0x0000000000000000]
                                  // [0x00000002]
    DWORD bAllowPartialPath : 1;  // 0x00B8 (0x0004) [0x0000000000000000]
                                  // [0x00000004]
    DWORD bAllowedToAttackDuringMove : 1;  // 0x00B8 (0x0004)
                                           // [0x0000000000000000] [0x00000008]
    DWORD bSavedIgnoreStepAside : 1;   // 0x00B8 (0x0004) [0x0000000000000000]
                                       // [0x00000010]
    DWORD bEnableSkipAheadChecks : 1;  // 0x00B8 (0x0004) [0x0000000000000000]
                                       // [0x00000020]
    DWORD bSkipAheadFail : 1;          // 0x00B8 (0x0004) [0x0000000000000000]
                                       // [0x00000040]
    DWORD bGoalChangedDueToSkipAhead : 1;  // 0x00B8 (0x0004)
                                           // [0x0000000000000000] [0x00000080]
    DWORD bGoalSurrounded : 1;           // 0x00B8 (0x0004) [0x0000000000000000]
                                         // [0x00000100]
    class AActor* IntermediateMoveGoal;  // 0x00BC (0x0008) [0x0000000000000000]
    struct FBasedPosition
        LastPawnTargetPathLocation;  // 0x00C4 (0x0038) [0x0000000000000000]
    class AActor* MoveToActor;       // 0x00FC (0x0008) [0x0000000000000000]
    int NumTimesGetNextMoveGoalReturnedSameNode;  // 0x0104 (0x0004)
                                                  // [0x0000000000000000]
    int Retries;                    // 0x0108 (0x0004) [0x0000000000000000]
    int LoopFailSafeCounter;        // 0x010C (0x0004) [0x0000000000000000]
    struct FVector LastMovePoint;   // 0x0110 (0x000C) [0x0000000000000000]
    float TimeOutTime;              // 0x011C (0x0004) [0x0000000000000000]
    class AActor* TurnFocus;        // 0x0120 (0x0008) [0x0000000000000000]
    struct FVector TurnFocalPoint;  // 0x0128 (0x000C) [0x0000000000000000]
    int WallHitCount;               // 0x0134 (0x0004) [0x0000000000000000]
    struct FBasedPosition
        SkipAheadLastUpdatePos;        // 0x0138 (0x0038) [0x0000000000000000]
    float SkipAheadUpdateThreshold;    // 0x0170 (0x0004) [0x0000000000000000]
    int SkipAheadMaxNodes;             // 0x0174 (0x0004) [0x0000000000000000]
    float SkipAheadMaxDist;            // 0x0178 (0x0004) [0x0000000000000000]
    float SkipAheadPitCheckInterval;   // 0x017C (0x0004) [0x0000000000000000]
    float SkipAheadPitCheckHeight;     // 0x0180 (0x0004) [0x0000000000000000]
    int SkipAheadNumActiveTests;       // 0x0184 (0x0004) [0x0000000000000000]
    int SkipAheadCurrentTestingIndex;  // 0x0188 (0x0004) [0x0000000000000000]
    unsigned char UnknownData00
        [0x48];  // 0x018C (0x0048) UNKNOWN PROPERTY: MapProperty
                 // KFGame.AICommand_MoveToGoal.NonSkippableWaypoints

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3317];

        return pClassPointer;
    };

    void NotifyLatentPostPhysWalking();
    void NotifyBump();
    void AdjustAround();
    void Timer_DelayMoveTimeOut();
    void CheckForStuckPath();
    void NotifyNeedRepath();
    void eventGetDumpString();
    void NotifyPlayerBecameVisible();
    void StartingMove();
    void Obstruction_Fail();
    void Obstruction_Repath();
    void HandlePathObstruction();
    void CheckForIntermediateEnemies();
    void ReachedIntermediateMoveGoal();
    void ReachedMoveGoal();
    void MoveUnreachable();
    void HasReachedMoveGoal();
    void MovePointIsValid();
    void MoveGoalIsValid();
    void MoveToGoalTimedOut();
    void RouteCache_RemoveIndex();
    void FindPathTo();
    void FindPathToward();
    void ReEvaluatePath();
    void eventEnemyIsSurrounded();
    void Resumed();
    void Paused();
    void Popped();
    void Pushed();
    void MoveToPoint();
    void MoveToGoal();
    void AddNonSkippableWayPoint();
    void ClearNonSkippableWayPoints();
};

UClass* UAICommand_MoveToGoal::pClassPointer = NULL;

// Class KFGame.AICommand_SpecialMove
// 0x003C (0x00F4 - 0x00B8)
class UAICommand_SpecialMove : public UAICommand {
   public:
    unsigned char SpecialMove;          // 0x00B8 (0x0001) [0x0000000000000000]
    struct FName DefaultStartState;     // 0x00BC (0x0008) [0x0000000000000000]
    float TerminationTime;              // 0x00C4 (0x0004) [0x0000000000000000]
    DWORD bShouldCheckSpecialMove : 1;  // 0x00C8 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bUpdateStartAnchor : 1;       // 0x00C8 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bUpdateAnchorOnSuccess : 1;   // 0x00C8 (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    DWORD bForceReady : 1;  // 0x00C8 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bWaitForLanding : 1;      // 0x00C8 (0x0004) [0x0000000000000000]
                                    // [0x00000010]
    float TimeOutDelaySeconds;      // 0x00CC (0x0004) [0x0000000000000000]
    float FailureSleepTimeSeconds;  // 0x00D0 (0x0004) [0x0000000000000000]
    struct FVector EndDest;         // 0x00D4 (0x000C) [0x0000000000000000]
    float FailSafeReadyTime;        // 0x00E0 (0x0004) [0x0000000000000000]
    int MaxExecuteSMAttemptsBeforeAbort;  // 0x00E4 (0x0004)
                                          // [0x0000000000000000]
    int ExecuteSMCount;       // 0x00E8 (0x0004) [0x0000000000000000]
    class UObject* Observer;  // 0x00EC (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3319];

        return pClassPointer;
    };

    void Timer_FailSafeReadyTriggered();
    void GetFailSafeReadyTime();
    void SpecialMoveTimeout();
    void UnlockAI();
    void LockdownAI();
    void GetUpdatedAnchor();
    void GetStartAnchor();
    void ClearTimeout();
    void Popped();
    void Paused();
    void Resumed();
    void Pushed();
};

UClass* UAICommand_SpecialMove::pClassPointer = NULL;

// Class KFGame.AICommand_SM_Attack
// 0x001C (0x0110 - 0x00F4)
class UAICommand_SM_Attack : public UAICommand_SpecialMove {
   public:
    unsigned char AttackSpecialMove;  // 0x00F4 (0x0001) [0x0000000000000000]
    unsigned char SMFlags;            // 0x00F5 (0x0001) [0x0000000000000000]
    class AActor* AttackTarget;       // 0x00F8 (0x0008) [0x0000000000000000]
    DWORD
        bSingleAttack : 1;  // 0x0100 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD
        bCanBeAborted : 1;  // 0x0100 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bAttackAborted : 1;  // 0x0100 (0x0004) [0x0000000000000000]
                               // [0x00000004]
    DWORD bLockDownAI : 1;  // 0x0100 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bZeroPawnAccelWhenPopped : 1;  // 0x0100 (0x0004) [0x0000000000000000]
                                         // [0x00000010]
    DWORD bFinishRotationBeforeAttack : 1;  // 0x0100 (0x0004)
                                            // [0x0000000000000000] [0x00000020]
    float PostSpecialMoveSleepTime;  // 0x0104 (0x0004) [0x0000000000000000]
    float PostSpecialMoveAbortedSleepTime;  // 0x0108 (0x0004)
                                            // [0x0000000000000000]
    float TimePlayed;  // 0x010C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3321];

        return pClassPointer;
    };

    void IsSpecialMoveComplete();
    void GetSpecialMove();
    void ShouldIgnoreTimeTransitions();
    void ShouldSelectTarget();
    void AllowTransitionTo();
    void Popped();
    void Paused();
    void Pushed();
};

UClass* UAICommand_SM_Attack::pClassPointer = NULL;

// Class KFGame.AICommand_Attack_Melee
// 0x002C (0x013C - 0x0110)
class UAICommand_Attack_Melee : public UAICommand_SM_Attack {
   public:
    DWORD bDebugShowAbortSequence : 1;  // 0x0110 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bNewEnemyPending : 1;         // 0x0110 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    struct FVector StepAheadLocation;   // 0x0114 (0x000C) [0x0000000000000000]
    struct FVector CircleDistance;      // 0x0120 (0x000C) [0x0000000000000000]
    struct FVector CirclePoint;         // 0x012C (0x000C) [0x0000000000000000]
    int CircleDir;                      // 0x0138 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3323];

        return pClassPointer;
    };

    void GetStepAheadLocation();
    void CircleTimer();
    void NotifyEnemyChanged();
    void GetAbortAttackDistanceSq();
    void eventGetDumpString();
    void NotifyPlayerBecameVisible();
    void CanChangeEnemy();
    void Resumed();
    void Paused();
    void eventNotifyBump();
    void Popped();
    void Pushed();
    void Melee();
};

UClass* UAICommand_Attack_Melee::pClassPointer = NULL;

// Class KFGame.KFAiBaseRangedBehavior
// 0x0134 (0x0194 - 0x0060)
class UKFAiBaseRangedBehavior : public UObject {
   public:
    class AKFAIController* MyAiCtrl;  // 0x0060 (0x0008) [0x0000000000000000]
    TArray<struct FRangedLocValidationData>
        StrikeLocValidationInfoList;  // 0x0068 (0x0010) [0x0000000000000000]
    int StrikeZoneForCurrentAttack;   // 0x0078 (0x0004) [0x0000000000000000]
    TArray<struct FVector>
        ProjMeshLocations;              // 0x007C (0x0010) [0x0000000000000000]
    struct FVector ProjImpactLocation;  // 0x008C (0x000C) [0x0000000000000000]
    struct FVector
        ProjExplosionLocation;       // 0x0098 (0x000C) [0x0000000000000000]
    int StrikeLastCalcArcSuccessId;  // 0x00A4 (0x0004) [0x0000000000000000]
    TArray<struct FVector>
        LogAlgosSegmentEnds;  // 0x00A8 (0x0010) [0x0000000000000000]
    TArray<DWORD>
        LogAlgosSegmentValiditys;  // 0x00B8 (0x0010) [0x0000000000000000]
    struct FVector
        FireLastLocOfBlockage;           // 0x00C8 (0x000C) [0x0000000000000000]
    struct FVector FireLastLocOfTarget;  // 0x00D4 (0x000C) [0x0000000000000000]
    struct FVector ProjStartLocation;    // 0x00E0 (0x000C) [0x0000000000000000]
    int TotalNumberOfPossibileFireLocationsPerFormationSlot;  // 0x00EC (0x0004)
                                                              // [0x0000000000000000]
    DWORD bIntentionalMiss : 1;  // 0x00F0 (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    DWORD bUseTargetsCurrentLocAtRelease : 1;  // 0x00F0 (0x0004)
                                               // [0x0000000000000000]
                                               // [0x00000002]
    DWORD
        bCheckIfCanMoveToStrikeLocationBeforeTestingForLane : 1;  // 0x00F0
                                                                  // (0x0004)
                                                                  // [0x0000000000000000]
                                                                  // [0x00000004]
    DWORD bAbleToAdjustAimPositionForGameplay : 1;     // 0x00F0 (0x0004)
                                                       // [0x0000000000000000]
                                                       // [0x00000008]
    float SleepTimeDuringRangeAttackDamageAssessment;  // 0x00F4 (0x0004)
                                                       // [0x0000000000000000]
    float NumOfStrikeLocationsToLookForAtEachRange;    // 0x00F8 (0x0004)
                                                       // [0x0000000000000000]
    float HorizontalSeperationBetweenPointsForStrike;  // 0x00FC (0x0004)
                                                       // [0x0000000000000000]
    struct FVector
        OffsetForCalcOfForStrike;  // 0x0100 (0x000C) [0x0000000000000000]
    float
        MinRangeFromOrbitBeforeLookingForTierOffsetStrikeLocations;  // 0x010C
                                                                     // (0x0004)
                                                                     // [0x0000000000000000]
    int ForceAllAttacksFromThisTier;  // 0x0110 (0x0004) [0x0000000000000000]
    int ForceAllAttacksFromThisZone;  // 0x0114 (0x0004) [0x0000000000000000]
    TArray<struct FRangedStrikeData>
        StrikeInfoByZone;  // 0x0118 (0x0010) [0x0000000000000000]
    float HieghtOffTargetPointForEndOfFireArc;  // 0x0128 (0x0004)
                                                // [0x0000000000000000]
    float IntentionalMissChance;  // 0x012C (0x0004) [0x0000000000000000]
    int TotalNumOfAttemptsToFindFireStrikeLaneThisEngagement;  // 0x0130
                                                               // (0x0004)
                                                               // [0x0000000000000000]
    struct FImpactInfo
        StrikeLaneBlockageImpactInfo;  // 0x0134 (0x0060) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3325];

        return pClassPointer;
    };

    void SetAllPastStrikeLocValidationInfoToExpired();
    void DrawFireAttackDebug();
    void SetStrikeZoneInfo();
    void GetBestCurrentVelocityForThisTarget();
    void FindCurrentFireFromAnywhereZone();
    void GetRangedFireMidZoneRangeForThisZone();
    void InitRangeFireData();
    void Setup();
};

UClass* UKFAiBaseRangedBehavior::pClassPointer = NULL;

// Class KFGame.KFAiDirectProjectileFireBehavior
// 0x0000 (0x0194 - 0x0194)
class UKFAiDirectProjectileFireBehavior : public UKFAiBaseRangedBehavior {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3327];

        return pClassPointer;
    };

    void IsThereClearDirectFireAttackLaneFromGivenLoc();
    void LosTestForAttackLane();
};

UClass* UKFAiDirectProjectileFireBehavior::pClassPointer = NULL;

// Class KFGame.KFAiLeapBehavior
// 0x0028 (0x01BC - 0x0194)
class UKFAiLeapBehavior : public UKFAiBaseRangedBehavior {
   public:
    TArray<struct FVector>
        CalculatedArc;                  // 0x0194 (0x0010) [0x0000000000000000]
    TArray<struct FVector> ArcImpacts;  // 0x01A4 (0x0010) [0x0000000000000000]
    struct FColor ValidArcColor;        // 0x01B4 (0x0004) [0x0000000000000000]
    struct FColor InValidArcColor;      // 0x01B8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3329];

        return pClassPointer;
    };

    void DrawDebugLastLeapArcCalcedArcImpacts();
    void DrawDebugLastValidLeapArcCalced();
    void SuggestLeapVelocity();
};

UClass* UKFAiLeapBehavior::pClassPointer = NULL;

// Class KFGame.KFAiBehaviorTypes
// 0x0000 (0x0060 - 0x0060)
class UKFAiBehaviorTypes : public UObject {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3331];

        return pClassPointer;
    };

    void DebugDumpPathingFlags();
};

UClass* UKFAiBehaviorTypes::pClassPointer = NULL;

// Class KFGame.KFAIController_ZedBoss
// 0x0004 (0x0AC4 - 0x0AC0)
class AKFAIController_ZedBoss : public AKFAIController_Monster {
   public:
    DWORD bSummonedThisPhase : 1;  // 0x0AC0 (0x0004) [0x0000000000000000]
                                   // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3333];

        return pClassPointer;
    };

    void EnterZedVictoryState();
    void Timer_StopSummoningZeds();
    void DebugNextPhase();
    void PlayDamagePlayerDialog();
    void UpdateSprintFrustration();
    void eventSetEnemy();
    void eventEnemyNotVisible();
};

UClass* AKFAIController_ZedBoss::pClassPointer = NULL;

// Class KFGame.KFAIController_Hans
// 0x0120 (0x0BE4 - 0x0AC4)
class AKFAIController_Hans : public AKFAIController_ZedBoss {
   public:
    class AKFPawn_ZedHansBase*
        MyHansPawn;                      // 0x0AC4 (0x0008) [0x0000000000000000]
    struct FVector RangedAttackMoveLoc;  // 0x0ACC (0x000C) [0x0000000000000000]
    DWORD bFoundGrenadeThrowLocation : 1;  // 0x0AD8 (0x0004)
                                           // [0x0000000000000000] [0x00000001]
    DWORD bWantsToThrowGrenade : 1;  // 0x0AD8 (0x0004) [0x0000000000000000]
                                     // [0x00000002]
    DWORD
        bHasUsedSmokeScreenThisPhase : 1;  // 0x0AD8 (0x0004)
                                           // [0x0000000000000000] [0x00000004]
    DWORD bFleeing : 1;  // 0x0AD8 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD
        bWantsToFlee : 1;  // 0x0AD8 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bHasFledThisPhase : 1;  // 0x0AD8 (0x0004) [0x0000000000000000]
                                  // [0x00000020]
    DWORD bFleeInterrupted : 1;   // 0x0AD8 (0x0004) [0x0000000000000000]
                                  // [0x00000040]
    struct FVector CalcedGreanadeTossVelForNavMeshLoc;  // 0x0ADC (0x000C)
                                                        // [0x0000000000000000]
    float TimeCalcedGreanadeTossVelWasFound;            // 0x0AE8 (0x0004)
                                                        // [0x0000000000000000]
    struct FVector EnemysLocationWhenTossVelWasFound;   // 0x0AEC (0x000C)
                                                        // [0x0000000000000000]
    float LostSightSprintDelay;       // 0x0AF8 (0x0004) [0x0000000000000000]
    float BarrageStartTime;           // 0x0AFC (0x0004) [0x0000000000000000]
    float LastFireTime;               // 0x0B00 (0x0004) [0x0000000000000000]
    float StartDrawGunsTime;          // 0x0B04 (0x0004) [0x0000000000000000]
    float StartGunAttackTime;         // 0x0B08 (0x0004) [0x0000000000000000]
    class AActor* LastTarget;         // 0x0B0C (0x0008) [0x0000000000000000]
    float TimeFirstSawTarget;         // 0x0B14 (0x0004) [0x0000000000000000]
    float LastStanceChangeTime;       // 0x0B18 (0x0004) [0x0000000000000000]
    float StanceChangeCooldown;       // 0x0B1C (0x0004) [0x0000000000000000]
    float LastAttackMoveFinishTime;   // 0x0B20 (0x0004) [0x0000000000000000]
    float PostAttackMoveGunCooldown;  // 0x0B24 (0x0004) [0x0000000000000000]
    TArray<struct FTrackedEnemyInfo>
        RecentlySeenEnemyList;  // 0x0B28 (0x0010) [0x0000000000000000]
    class AKFPawn*
        LastRecentlySeenEnemyGunned;  // 0x0B38 (0x0008) [0x0000000000000000]
    class AKFPawn*
        LastRecentlySeenEnemyGrenaded;  // 0x0B40 (0x0008) [0x0000000000000000]
    float RecentSeenEnemyListUpdateInterval;  // 0x0B48 (0x0004)
                                              // [0x0000000000000000]
    float LastRecentSeenEnemyListUpdateTime;  // 0x0B4C (0x0004)
                                              // [0x0000000000000000]
    float LastRetargetTime;  // 0x0B50 (0x0004) [0x0000000000000000]
    struct FVector2D
        RetargetWaitTimeRange;     // 0x0B54 (0x0008) [0x0000000000000000]
    float ActualRetargetWaitTime;  // 0x0B5C (0x0004) [0x0000000000000000]
    int MinBurstAmount;            // 0x0B60 (0x0004) [0x0000000000000000]
    int MaxBurstAmount;            // 0x0B64 (0x0004) [0x0000000000000000]
    float BurstWaitTime;           // 0x0B68 (0x0004) [0x0000000000000000]
    float BarrageWaitTime;         // 0x0B6C (0x0004) [0x0000000000000000]
    struct FInterpCurveFloat
        BarrageWaitDistanceCurve;  // 0x0B70 (0x0014) [0x0000000000000000]
    struct FInterpCurveFloat
        BurstWaitDistanceCurve;      // 0x0B84 (0x0014) [0x0000000000000000]
    float BarrageLength;             // 0x0B98 (0x0004) [0x0000000000000000]
    int BurstAmount;                 // 0x0B9C (0x0004) [0x0000000000000000]
    float LostSightStopFireDelay;    // 0x0BA0 (0x0004) [0x0000000000000000]
    float LastFireMode;              // 0x0BA4 (0x0004) [0x0000000000000000]
    float DrawGunFireDelay;          // 0x0BA8 (0x0004) [0x0000000000000000]
    float TargetAquisitionDelay;     // 0x0BAC (0x0004) [0x0000000000000000]
    float MaxGunAttackLength;        // 0x0BB0 (0x0004) [0x0000000000000000]
    float GrenadeGunInterruptDelay;  // 0x0BB4 (0x0004) [0x0000000000000000]
    float StartShootingRange;        // 0x0BB8 (0x0004) [0x0000000000000000]
    float MinShootingRange;          // 0x0BBC (0x0004) [0x0000000000000000]
    float ShootingCooldown;          // 0x0BC0 (0x0004) [0x0000000000000000]
    unsigned char
        CurrentNadeAttackType;        // 0x0BC4 (0x0001) [0x0000000000000000]
    float GrenadeAttackEvalInterval;  // 0x0BC8 (0x0004) [0x0000000000000000]
    float LastGrenadeAttackEvalTime;  // 0x0BCC (0x0004) [0x0000000000000000]
    float MinFleeDuration;            // 0x0BD0 (0x0004) [0x0000000000000000]
    float MaxFleeDuration;            // 0x0BD4 (0x0004) [0x0000000000000000]
    float MaxFleeDistance;            // 0x0BD8 (0x0004) [0x0000000000000000]
    float FleeStartTime;              // 0x0BDC (0x0004) [0x0000000000000000]
    float TotalFleeTime;              // 0x0BE0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3335];

        return pClassPointer;
    };

    void PlayDamagePlayerDialog();
    void NotifyKilled();
    void InitalizeBaseCommand();
    void AmIAllowedToSuicideWhenStuck();
    void eventEdgeAndPolySubRegionRejectedDueToProximityToTarget();
    void eventEdgeAndPolySubRegionRejectedDueToAdjustToss();
    void eventEdgeAndPolySubRegionRejectedDueToLOS();
    void eventEntireEdgeAndPolyRejectedDueToRating();
    void eventEdgeAndPolySubRegionRejectedDueToRating();
    void eventEdgeAndPolySubRegionRejectedDueToDist();
    void CanDoStrike();
    void DoHeavyZedBump();
    void eventDoGrabAttack();
    void CanTargetBeGrabbed();
    void eventCanGrabAttack();
    void CancelFlee();
    void NotifyFleeFinished();
    void NotifyCommandFinished();
    void Timer_SearchForFleeObstructions();
    void Flee();
    void DoFleeFrom();
    void CanSwitchEnemies();
    void NextBattlePhase();
    void DoorFinished();
    void NotifyAttackDoor();
    void CanAttackDestructibles();
    void IsWithinAttackRange();
    void DoStrike();
    void SetupGrenadeAttack();
    void GrenadeAttackInterruptGuns();
    void DrawRangedAttackInfo();
    void TickGunSystem();
    void TickRangedCombatDecision();
    void Tick();
    void CanStanceChange();
    void CanPerformShotAttack();
    void StartFireTiming();
    void GetAimingLocation();
    void SelectNewGunFireEnemy();
    void eventChangeEnemy();
    void eventSetEnemy();
    void ClearFireTiming();
    void FireTimer();
    void ShouldSprint();
    void DoNerveGasGrenadeThrow();
    void Timer_DoHuntAndHealSmokeGrenadeThrow();
    void eventSeePlayer();
    void EvaluateSprinting();
    void NotifySpecialMoveEnded();
    void NotifyTakeHit();
    void DoSmokeGrenadeThrow();
    void DoGrenadeThrow();
    void eventDestroyed();
    void PawnDied();
    void eventPossess();
};

UClass* AKFAIController_Hans::pClassPointer = NULL;

// Class KFGame.KFAIController_ZedClot
// 0x0000 (0x0AC0 - 0x0AC0)
class AKFAIController_ZedClot : public AKFAIController_Monster {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3337];

        return pClassPointer;
    };

    void eventDoGrabAttack();
    void CanDoStrike();
    void ShouldSprint();
};

UClass* AKFAIController_ZedClot::pClassPointer = NULL;

// Class KFGame.KFAIController_ZedCrawler
// 0x0048 (0x0B08 - 0x0AC0)
class AKFAIController_ZedCrawler : public AKFAIController_Monster {
   public:
    class AActor* LastAmbushNode;   // 0x0AC0 (0x0008) [0x0000000000000000]
    struct FVector LastRMVelocity;  // 0x0AC8 (0x000C) [0x0000000000000000]
    int MinExtraCostForFloorNodes;  // 0x0AD4 (0x0004) [0x0000000000000000]
    int MaxExtraCostForFloorNodes;  // 0x0AD8 (0x0004) [0x0000000000000000]
    struct FVector
        OriginalMeshTranslation;     // 0x0ADC (0x000C) [0x0000000000000000]
    int FailedToFindAnchorCount;     // 0x0AE8 (0x0004) [0x0000000000000000]
    int MaxFailedToFindAnchorCount;  // 0x0AEC (0x0004) [0x0000000000000000]
    struct FVector LastCrawlerX;     // 0x0AF0 (0x000C) [0x0000000000000000]
    struct FVector OldFloor;         // 0x0AFC (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3339];

        return pClassPointer;
    };

    void ShouldSprint();
    void AmIAllowedToStillUsePathNodes();
    void Timer_ResetFailedToFindAnchorCount();
    void eventFailedToFindAnchor();
};

UClass* AKFAIController_ZedCrawler::pClassPointer = NULL;

// Class KFGame.KFAIDirector
// 0x008C (0x00EC - 0x0060)
class UKFAIDirector : public UObject {
   public:
    TArray<class AKFAIController*>
        AIList;                       // 0x0060 (0x0010) [0x0000000000000000]
    DWORD bAISprintToGrabVictim : 1;  // 0x0070 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD
        bShowAINames : 1;   // 0x0070 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bDebugAllAI : 1;  // 0x0070 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bUseGrabAlerts : 1;     // 0x0070 (0x0004) [0x0000000000000000]
                                  // [0x00000008]
    DWORD bForceFrustration : 1;  // 0x0070 (0x0004) [0x0000000000000000]
                                  // [0x00000010]
    DWORD bLoadDebugPackageResourcesAtStart : 1;  // 0x0070 (0x0004)
                                                  // [0x0000000000000000]
                                                  // [0x00000020]
    DWORD
        bShowVisualStuckZedDebugInfo : 1;  // 0x0070 (0x0004)
                                           // [0x0000000000000000] [0x00000040]
    DWORD bShowMovePointsDebugInfo : 1;  // 0x0070 (0x0004) [0x0000000000000000]
                                         // [0x00000080]
    DWORD bShowHighDetailCombatMovementDebugInfo : 1;  // 0x0070 (0x0004)
                                                       // [0x0000000000000000]
                                                       // [0x00000100]
    DWORD
        bShowCollisionRadiusForReducedZedOnZedPinchPointCollisionState : 1;  // 0x0070 (0x0004) [0x0000000000000000] [0x00000200]
    DWORD bShowLeapDownDebugArtifacts : 1;  // 0x0070 (0x0004)
                                            // [0x0000000000000000] [0x00000400]
    DWORD bShowDoorNavigationDebugArtifacts : 1;  // 0x0070 (0x0004)
                                                  // [0x0000000000000000]
                                                  // [0x00000800]
    DWORD bShowDestructibleNavigationDebugArtifacts : 1;  // 0x0070 (0x0004)
                                                          // [0x0000000000000000]
                                                          // [0x00001000]
    float GrabAlertMaxZedDistance;  // 0x0074 (0x0004) [0x0000000000000000]
    struct FVector
        CurrentLocationSortingDoorsFor;  // 0x0078 (0x000C) [0x0000000000000000]
    class UFont*
        AiDebugScreenLargeFont;  // 0x0084 (0x0008) [0x0000000000000000]
    struct FString
        AiDebugScreenLargeFontName;  // 0x008C (0x0010) [0x0000000000000000]
    class UTexture2D*
        DebugIsSprintingIcon;  // 0x009C (0x0008) [0x0000000000000000]
    struct FString
        DebugIsSprintingIconName;  // 0x00A4 (0x0010) [0x0000000000000000]
    class UTexture2D*
        DebugIsWalkingIcon;  // 0x00B4 (0x0008) [0x0000000000000000]
    struct FString
        DebugIsWalkingIconName;  // 0x00BC (0x0010) [0x0000000000000000]
    TArray<struct FActiveAIInfo>
        ActiveZeds;  // 0x00CC (0x0010) [0x0000000000000000]
    struct FScriptDelegate
        __ClosestDoorSort__Delegate;   // 0x00DC (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x00E0 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3341];

        return pClassPointer;
    };

    void FindClosedDoorsWithInRange();
    void ClosestDoorSort();
    void FindDoorsWithInRange();
    void NotifyPawnGrabbed();
    void FindEnemyFor();
    void UnRegisterAIMember();
    void RegisterAIMember();
    void NotifyNewPossess();
    void GetDebugIsWalkingIcon();
    void GetDebugIsSprintingIcon();
    void GetAiDebugScreenLargeFont();
    void SetAIDebug();
    void Initialize();
    void LoadAiDebugResources();
    void RebuildAIList();
};

UClass* UKFAIDirector::pClassPointer = NULL;

// Class KFGame.KFAIPluginRage_Fleshpound
// 0x0028 (0x00D8 - 0x00B0)
class UKFAIPluginRage_Fleshpound : public UAITickablePlugin {
   public:
    struct FVector StartLocation;      // 0x00B0 (0x000C) [0x0000000000000000]
    int AccumulatedDOT;                // 0x00BC (0x0004) [0x0000000000000000]
    float RageFrustrationStartTime;    // 0x00C0 (0x0004) [0x0000000000000000]
    float MaxEnemyNotVisibleRageTime;  // 0x00C4 (0x0004) [0x0000000000000000]
    float RageFrustrationBaseTime;     // 0x00C8 (0x0004) [0x0000000000000000]
    float RageFrustrationTime;         // 0x00CC (0x0004) [0x0000000000000000]
    float RageDamageThreshold;         // 0x00D0 (0x0004) [0x0000000000000000]
    DWORD bIsEnraged : 1;  // 0x00D4 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3343];

        return pClassPointer;
    };

    void EndRage();
    void SetRageTime();
    void StartRageTimer();
    void CanDoRage();
    void DoSpawnRage();
    void eventTickRage();
};

UClass* UKFAIPluginRage_Fleshpound::pClassPointer = NULL;

// Class KFGame.KFAISpawnManager
// 0x0164 (0x01C4 - 0x0060)
class UKFAISpawnManager : public UObject {
   public:
    TArray<struct FDifficultyWaveInfo>
        DifficultyWaveSettings;  // 0x0060 (0x0010) [0x0000000000000000]
    struct FDifficultyWaveInfo
        WaveSettings;  // 0x0070 (0x0010) [0x0000000000000000]
    TArray<class UKFAISpawnSquad*>
        AvailableSquads;                 // 0x0080 (0x0010) [0x0000000000000000]
    float SineWaveFreq;                  // 0x0090 (0x0004) [0x0000000000000000]
    float WaveStartTime;                 // 0x0094 (0x0004) [0x0000000000000000]
    float TotalWavesActiveTime;          // 0x0098 (0x0004) [0x0000000000000000]
    float TimeUntilNextSpawn;            // 0x009C (0x0004) [0x0000000000000000]
    int WaveTotalAI;                     // 0x00A0 (0x0004) [0x0000000000000000]
    unsigned char MaxMonsters;           // 0x00A4 (0x0001) [0x0000000000000000]
    unsigned char MaxMonstersSolo[0x4];  // 0x00A5 (0x0004) [0x0000000000000000]
    unsigned char DesiredSquadType;      // 0x00A9 (0x0001) [0x0000000000000000]
    struct FSpawnRateModifier
        SoloWaveSpawnRateModifier[0x4];  // 0x00AC (0x0040) [0x0000000000000000]
    float EarlyWaveSpawnRateModifier[0x4];  // 0x00EC (0x0010)
                                            // [0x0000000000000000]
    int EarlyWaveIndex;  // 0x00FC (0x0004) [0x0000000000000000]
    float EarlyWavesSpawnTimeModByPlayers[0x6];  // 0x0100 (0x0018)
                                                 // [0x0000000000000000]
    float LateWavesSpawnTimeModByPlayers[0x6];   // 0x0118 (0x0018)
                                                 // [0x0000000000000000]
    DWORD bForceRequiredSquad : 1;      // 0x0130 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bRecycleSpecialSquad : 1;     // 0x0130 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bSummoningBossMinions : 1;    // 0x0130 (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    DWORD bLogAISpawning : 1;           // 0x0130 (0x0004) [0x0000000000000000]
                                        // [0x00000008]
    DWORD bLogWaveSpawnTiming : 1;      // 0x0130 (0x0004) [0x0000000000000000]
                                        // [0x00000010]
    DWORD bLogRateVolume : 1;           // 0x0130 (0x0004) [0x0000000000000000]
                                        // [0x00000020]
    TArray<DWORD> RecycleSpecialSquad;  // 0x0134 (0x0010) [0x0000000000000000]
    int MaxSpecialSquadRecycles;        // 0x0144 (0x0004) [0x0000000000000000]
    int NumSpecialSquadRecycles;        // 0x0148 (0x0004) [0x0000000000000000]
    int NumSpawnListCycles;             // 0x014C (0x0004) [0x0000000000000000]
    TArray<class AKFSpawnVolume*>
        SpawnVolumes;  // 0x0150 (0x0010) [0x0000000000000000]
    class AKFSpawnVolume*
        LastAISpawnVolume;            // 0x0160 (0x0008) [0x0000000000000000]
    class AKFSpawner* ActiveSpawner;  // 0x0168 (0x0008) [0x0000000000000000]
    int ObjExtraAI;                   // 0x0170 (0x0004) [0x0000000000000000]
    TArray<class UClass*>
        LeftoverSpawnSquad;  // 0x0174 (0x0010) [0x0000000000000000]
    TArray<class UKFAISpawnSquad*>
        BossMinionsSpawnSquads;  // 0x0184 (0x0010) [0x0000000000000000]
    int MaxBossMinions;          // 0x0194 (0x0004) [0x0000000000000000]
    float MaxBossMinionScaleByPlayers[0x6];  // 0x0198 (0x0018)
                                             // [0x0000000000000000]
    TArray<class AController*>
        RecentSpawnSelectedHumanControllerList;  // 0x01B0 (0x0010)
                                                 // [0x0000000000000000]
    int ForcedBossNum;  // 0x01C0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3345];

        return pClassPointer;
    };

    void ResetSpawnManager();
    void CanSpawnPlayerBoss();
    void ResetSpawnCurveIntensity();
    void UpdateSpawnCurveIntensity();
    void NeedPlayerSpawnVolume();
    void GetBestSpawnVolume();
    void InitControllerList();
    void GetAIAliveCount();
    void GetNumAINeeded();
    void GetMaxMonsters();
    void ShouldAddAI();
    void Update();
    void RecordSpawnInformation();
    void SpawnSquad();
    void StopSummoningBossMinions();
    void SummonBossMinions();
    void SetSineWaveFreq();
    void GetSineWaveFreq();
    void GetSineMod();
    void GetNextSpawnTimeMod();
    void CalcNextGroupSpawnTime();
    void IsFinishedSpawning();
    void IsAISquadAvailable();
    void LogAvailableSquads();
    void LogMonsterList();
    void GetNextSpawnList();
    void GetSpawnListFromSquad();
    void SetDesiredSquadTypeForZedList();
    void GetDesiredSquadTypeForZedList();
    void SpawnRemainingReservedZeds();
    void GetAvailableSquads();
    void GetWaveSettings();
    void SetupNextWave();
    void RegisterSpawnVolumes();
    void Initialize();
    void ZedTypeToString();
    void SortSpawnVolumes();
};

UClass* UKFAISpawnManager::pClassPointer = NULL;

// Class KFGame.KFAISteering
// 0x005C (0x00BC - 0x0060)
class UKFAISteering : public UObject {
   public:
    class AKFAIController*
        AIController;                 // 0x0060 (0x0008) [0x0000000000000000]
    class AKFPawn* AIPawn;            // 0x0068 (0x0008) [0x0000000000000000]
    int SteeringFlags;                // 0x0070 (0x0004) [0x0000000000000000]
    float UnrealAccelMaxForce;        // 0x0074 (0x0004) [0x0000000000000000]
    struct FVector UnrealAccel;       // 0x0078 (0x000C) [0x0000000000000000]
    float SeparateMaxForce;           // 0x0084 (0x0004) [0x0000000000000000]
    float DefaultSeparationDistance;  // 0x0088 (0x0004) [0x0000000000000000]
    TArray<class UClass*>
        SeparationExcludeClasses;  // 0x008C (0x0010) [0x0000000000000000]
    TArray<class UClass*>
        SeparationClasses;             // 0x009C (0x0010) [0x0000000000000000]
    TArray<float> SeparationDistance;  // 0x00AC (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3347];

        return pClassPointer;
    };

    void IsClassExcluded();
    void IsSeparationClass();
    void SeparateStopExclude();
    void SeparateExclude();
    void SeparationOff();
    void SeparationOn();
    void SeparationGetForce();
    void UnrealAccelGetForce();
    void UnrealAccelSet();
    void DisableDefaultAcceleration();
    void EnableDefaultAcceleration();
    void AccumulateForce();
    void CalculateAcceleration();
    void OnOwnerDestroy();
    void GetGroundSpeed();
    void GetAccelRate();
    void On();
    void ClearAllFlags();
    void ClearFlag();
    void AddFlag();
    void Initialize();
};

UClass* UKFAISteering::pClassPointer = NULL;

// Class KFGame.KFAISubsystem
// 0x0000 (0x00A4 - 0x00A4)
class UKFAISubsystem : public UBaseAISubsystem {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3349];

        return pClassPointer;
    };

    void eventGetDifficultyValue();
};

UClass* UKFAISubsystem::pClassPointer = NULL;

// Class KFGame.KFScout
// 0x0038 (0x0628 - 0x05F0)
class AKFScout : public AScout {
   public:
    DWORD bReplacePathNodesWithKFPathNodes : 1;  // 0x05F0 (0x0004)
                                                 // [0x0000000000000000]
                                                 // [0x00000001]
    DWORD bDebugReplacePathNodes : 1;  // 0x05F0 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    TArray<class UClass*>
        PrototypePawnClasses;  // 0x05F4 (0x0010) [0x0000000000000000]
    int PrototypeIndex;        // 0x0604 (0x0004) [0x0000000000000000]
    TArray<class AKFDoorMarker*>
        KFDoorMarkerList;         // 0x0608 (0x0010) [0x0000000000000000]
    float TestSprintSpeed;        // 0x0618 (0x0004) [0x0000000000000000]
    float TestHiddenGroundSpeed;  // 0x061C (0x0004) [0x0000000000000000]
    float DefaultMaxFallSpeed;    // 0x0620 (0x0004) [0x0000000000000000]
    float DefaultJumpZ;           // 0x0624 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3351];

        return pClassPointer;
    };
};

UClass* AKFScout::pClassPointer = NULL;

// Class KFGame.ActorFactoryKFPathNode
// 0x0000 (0x009C - 0x009C)
class UActorFactoryKFPathNode : public UActorFactory {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3353];

        return pClassPointer;
    };
};

UClass* UActorFactoryKFPathNode::pClassPointer = NULL;

// Class KFGame.ActorFactoryKFScriptedPlayerPathGoal
// 0x0000 (0x009C - 0x009C)
class UActorFactoryKFScriptedPlayerPathGoal : public UActorFactory {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3355];

        return pClassPointer;
    };
};

UClass* UActorFactoryKFScriptedPlayerPathGoal::pClassPointer = NULL;

// Class KFGame.ActorFactoryKFWallPathNode
// 0x0000 (0x009C - 0x009C)
class UActorFactoryKFWallPathNode : public UActorFactory {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3357];

        return pClassPointer;
    };
};

UClass* UActorFactoryKFWallPathNode::pClassPointer = NULL;

// Class KFGame.Goal_AwayFromPosition
// 0x0028 (0x00A4 - 0x007C)
class UGoal_AwayFromPosition : public UPathGoalEvaluator {
   public:
    struct FVector AvoidPos;           // 0x007C (0x000C) [0x0000000000000000]
    struct FVector AvoidDir;           // 0x0088 (0x000C) [0x0000000000000000]
    int MaxDist;                       // 0x0094 (0x0004) [0x0000000000000000]
    class ANavigationPoint* BestNode;  // 0x0098 (0x0008) [0x0000000000000000]
    int BestRating;                    // 0x00A0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3359];

        return pClassPointer;
    };

    void eventRecycle();
    void FleeFrom();
};

UClass* UGoal_AwayFromPosition::pClassPointer = NULL;

// Class KFGame.Goal_Random
// 0x0010 (0x008C - 0x007C)
class UGoal_Random : public UPathGoalEvaluator {
   public:
    int MinDist;                   // 0x007C (0x0004) [0x0000000000000000]
    float BestRating;              // 0x0080 (0x0004) [0x0000000000000000]
    class ANavigationPoint* Best;  // 0x0084 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3361];

        return pClassPointer;
    };

    void Recycle();
    void FindRandom();
};

UClass* UGoal_Random::pClassPointer = NULL;

// Class KFGame.Goal_WallToEnemy
// 0x0010 (0x008C - 0x007C)
class UGoal_WallToEnemy : public UPathGoalEvaluator {
   public:
    class ANavigationPoint* BestNode;  // 0x007C (0x0008) [0x0000000000000000]
    int OptimalMaxDist;                // 0x0084 (0x0004) [0x0000000000000000]
    float BestNavDist;                 // 0x0088 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3363];

        return pClassPointer;
    };

    void Recycle();
    void WallToEnemy();
};

UClass* UGoal_WallToEnemy::pClassPointer = NULL;

// Class KFGame.KFDoorMarker
// 0x0010 (0x03A4 - 0x0394)
class AKFDoorMarker : public ADoorMarker {
   public:
    class AKFDoorActor* MyKFDoor;  // 0x0394 (0x0008) [0x0000000000000000]
    float AdjustedReachThreshold;  // 0x039C (0x0004) [0x0000000000000000]
    int ExtraCostWhenWelded;       // 0x03A0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3365];

        return pClassPointer;
    };

    void eventSpecialHandling();
    void ProceedWithMove();
    void UpdatePathingCost();
    void MoverClosed();
    void MoverOpened();
    void eventSuggestMovePreparation();
};

UClass* AKFDoorMarker::pClassPointer = NULL;

// Class KFGame.KFLeapReachSpec
// 0x0010 (0x00D8 - 0x00C8)
class UKFLeapReachSpec : public UAdvancedReachSpec {
   public:
    struct FVector CachedVelocity;  // 0x00C8 (0x000C) [0x0000000000000000]
    float RequiredJumpZ;            // 0x00D4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3367];

        return pClassPointer;
    };
};

UClass* UKFLeapReachSpec::pClassPointer = NULL;

// Class KFGame.KFPathnode
// 0x0020 (0x039C - 0x037C)
class AKFPathnode : public APathNode {
   public:
    DWORD bIsJumpDest : 1;  // 0x037C (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bIsDropDownDest : 1;           // 0x037C (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bDebugLogAnchorUsability : 1;  // 0x037C (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD bAutoConnectToOtherFloors : 1;  // 0x037C (0x0004)
                                          // [0x0000000000000000] [0x00000008]
    DWORD bPauseWhenReached : 1;  // 0x037C (0x0004) [0x0000000000000000]
                                  // [0x00000010]
    DWORD bHasDoorLOS : 1;  // 0x037C (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bAutoAdjustZToCeiling : 1;  // 0x037C (0x0004) [0x0000000000000000]
                                      // [0x00000040]
    DWORD bAutoFlushPersistentDebugLines : 1;  // 0x037C (0x0004)
                                               // [0x0000000000000000]
                                               // [0x00000080]
    DWORD bIgnoredByTraderTrail : 1;   // 0x037C (0x0004) [0x0000000000000000]
                                       // [0x00000100]
    struct FVector JumpVelocity;       // 0x0380 (0x000C) [0x0000000000000000]
    float JumpTime;                    // 0x038C (0x0004) [0x0000000000000000]
    float PauseDuration;               // 0x0390 (0x0004) [0x0000000000000000]
    class UClass* WallReachSpecClass;  // 0x0394 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3369];

        return pClassPointer;
    };

    void DrawDebugInfo();
    void eventGetDebugAbbrev();
    void eventNotifyReachedBy();
    void GetNearestValidFloorNavWithinRadiusToPawn();
    void GetNearestFloorNavToActor();
    void IsUsableAnchorFor();
    void GetUpVector();
    void ComputeTrajectoryByTime();
};

UClass* AKFPathnode::pClassPointer = NULL;

// Class KFGame.KFCostTimerNode
// 0x0014 (0x03B0 - 0x039C)
class AKFCostTimerNode : public AKFPathnode {
   public:
    DWORD bEnableCostTimer : 1;  // 0x039C (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    int MinCost;                 // 0x03A0 (0x0004) [0x0000000000000000]
    int MaxCost;                 // 0x03A4 (0x0004) [0x0000000000000000]
    float TimerMin;              // 0x03A8 (0x0004) [0x0000000000000000]
    float TimerMax;              // 0x03AC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3371];

        return pClassPointer;
    };

    void StartCostTimer();
    void CostTimer();
    void PostBeginPlay();
};

UClass* AKFCostTimerNode::pClassPointer = NULL;

// Class KFGame.KFWallPathNode
// 0x0020 (0x03BC - 0x039C)
class AKFWallPathNode : public AKFPathnode {
   public:
    float MaxJumpDist;      // 0x039C (0x0004) [0x0000000000000000]
    DWORD bMustJumpTo : 1;  // 0x03A0 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bAutoConnectDropDownNodes : 1;  // 0x03A0 (0x0004)
                                          // [0x0000000000000000] [0x00000002]
    float MaxFloorToWallDistance;       // 0x03A4 (0x0004) [0x0000000000000000]
    float Max2DDistToFloorNodes;        // 0x03A8 (0x0004) [0x0000000000000000]
    float MaxDistToNodesOnOtherFloors;  // 0x03AC (0x0004) [0x0000000000000000]
    float MaxDropFromWallDistance;      // 0x03B0 (0x0004) [0x0000000000000000]
    class AKFPathnode* DropDownNode;    // 0x03B4 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3373];

        return pClassPointer;
    };

    void eventSuggestMovePreparation();
    void eventDetourWeight();
    void eventAccept();
    void eventSpecialCost();
    void eventGetDebugAbbrev();
    void IsUsableAnchorFor();
};

UClass* AKFWallPathNode::pClassPointer = NULL;

// Class KFGame.KFReachSpec
// 0x0004 (0x00CC - 0x00C8)
class UKFReachSpec : public UReachSpec {
   public:
    DWORD bBlockedForSuperSpeed : 1;  // 0x00C8 (0x0004) [0x0000000000000000]
                                      // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3375];

        return pClassPointer;
    };

    void IsPathBlockedByPawn();
    void IsWallToCeiling();
    void IsForcedSpec();
    void HasJumpAndWalkFlag();
    void HasJumpFlag();
};

UClass* UKFReachSpec::pClassPointer = NULL;

// Class KFGame.KFDoorReachSpec
// 0x0000 (0x00CC - 0x00CC)
class UKFDoorReachSpec : public UKFReachSpec {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3377];

        return pClassPointer;
    };
};

UClass* UKFDoorReachSpec::pClassPointer = NULL;

// Class KFGame.KFForcedReachSpec
// 0x001C (0x00E8 - 0x00CC)
class UKFForcedReachSpec : public UKFReachSpec {
   public:
    struct FVector2D ForcedSpec;  // 0x00CC (0x0008) [0x0000000000000000]
    TArray<struct FForcedSpecInfo>
        ForcedSpecInfoList;         // 0x00D4 (0x0010) [0x0000000000000000]
    DWORD bSupportsHumanSize : 1;   // 0x00E4 (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    DWORD bSupportsCommonSize : 1;  // 0x00E4 (0x0004) [0x0000000000000000]
                                    // [0x00000002]
    DWORD bSupportsMaxSize : 1;     // 0x00E4 (0x0004) [0x0000000000000000]
                                    // [0x00000004]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3379];

        return pClassPointer;
    };
};

UClass* UKFForcedReachSpec::pClassPointer = NULL;

// Class KFGame.FloorToWallReachSpec
// 0x0000 (0x00E8 - 0x00E8)
class UFloorToWallReachSpec : public UKFForcedReachSpec {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3381];

        return pClassPointer;
    };
};

UClass* UFloorToWallReachSpec::pClassPointer = NULL;

// Class KFGame.WallToFloorReachSpec
// 0x0004 (0x00EC - 0x00E8)
class UWallToFloorReachSpec : public UKFForcedReachSpec {
   public:
    DWORD bJumpDownTo : 1;  // 0x00E8 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3383];

        return pClassPointer;
    };
};

UClass* UWallToFloorReachSpec::pClassPointer = NULL;

// Class KFGame.WallReachSpec
// 0x0004 (0x00D0 - 0x00CC)
class UWallReachSpec : public UKFReachSpec {
   public:
    DWORD bMustJump : 1;  // 0x00CC (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3385];

        return pClassPointer;
    };
};

UClass* UWallReachSpec::pClassPointer = NULL;

// Class KFGame.KFScriptedPlayerPathGoal
// 0x0000 (0x037C - 0x037C)
class AKFScriptedPlayerPathGoal : public APathNode {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3387];

        return pClassPointer;
    };

    void IsUsableAnchorFor();
};

UClass* AKFScriptedPlayerPathGoal::pClassPointer = NULL;

// Class KFGame.Path_AroundDestructibles
// 0x001C (0x0088 - 0x006C)
class UPath_AroundDestructibles : public UPathConstraint {
   public:
    float LargeNPCCollisionRadius;  // 0x006C (0x0004) [0x0000000000000000]
    DWORD bDebug_DrawMyBlockedPathConnections : 1;  // 0x0070 (0x0004)
                                                    // [0x0000000000000000]
                                                    // [0x00000001]
    DWORD bAddCostInsteadOfBlocking : 1;            // 0x0070 (0x0004)
                                          // [0x0000000000000000] [0x00000002]
    DWORD bAffectLargeNPCs : 1;     // 0x0070 (0x0004) [0x0000000000000000]
                                    // [0x00000004]
    DWORD bAffectStandardNPCs : 1;  // 0x0070 (0x0004) [0x0000000000000000]
                                    // [0x00000008]
    int AddedCost;                  // 0x0074 (0x0004) [0x0000000000000000]
    TArray<struct FDestructiblesInfo>
        Destructibles;  // 0x0078 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3389];

        return pClassPointer;
    };

    void Recycle();
    void AvoidDestructibles();
};

UClass* UPath_AroundDestructibles::pClassPointer = NULL;

// Class KFGame.Path_AvoidChokePoints
// 0x0000 (0x006C - 0x006C)
class UPath_AvoidChokePoints : public UPathConstraint {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3391];

        return pClassPointer;
    };

    void Recycle();
    void AvoidChokePoints();
};

UClass* UPath_AvoidChokePoints::pClassPointer = NULL;

// Class KFGame.Path_AvoidClosedDoors
// 0x0004 (0x0070 - 0x006C)
class UPath_AvoidClosedDoors : public UPathConstraint {
   public:
    DWORD bOnlyAvoidWeldedDoors : 1;  // 0x006C (0x0004) [0x0000000000000000]
                                      // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3393];

        return pClassPointer;
    };

    void Recycle();
    void AvoidClosedDoors();
};

UClass* UPath_AvoidClosedDoors::pClassPointer = NULL;

// Class KFGame.Path_PreferDarkness
// 0x0004 (0x0070 - 0x006C)
class UPath_PreferDarkness : public UPathConstraint {
   public:
    float MaxLuminance;  // 0x006C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3395];

        return pClassPointer;
    };

    void Recycle();
    void DontGoIntoTheLight();
};

UClass* UPath_PreferDarkness::pClassPointer = NULL;

// Class KFGame.Path_PreferWalls
// 0x0008 (0x0074 - 0x006C)
class UPath_PreferWalls : public UPathConstraint {
   public:
    DWORD bOnlyAcceptWallNodes : 1;  // 0x006C (0x0004) [0x0000000000000000]
                                     // [0x00000001]
    DWORD bAvoidEnemy : 1;  // 0x006C (0x0004) [0x0000000000000000] [0x00000002]
    int FloorNodeCost;      // 0x0070 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3397];

        return pClassPointer;
    };

    void Recycle();
    void PreferWalls();
};

UClass* UPath_PreferWalls::pClassPointer = NULL;

// Class KFGame.Path_ToTrader
// 0x0000 (0x006C - 0x006C)
class UPath_ToTrader : public UPathConstraint {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3399];

        return pClassPointer;
    };

    void ToTrader();
};

UClass* UPath_ToTrader::pClassPointer = NULL;

// Class KFGame.KFGameplayEventsWriter
// 0x0010 (0x01D8 - 0x01C8)
class UKFGameplayEventsWriter : public UGameplayEventsWriter {
   public:
    DWORD bRecordAIDebugInfo : 1;  // 0x01C8 (0x0004) [0x0000000000000000]
                                   // [0x00000001]
    int StatsFileIndex;            // 0x01CC (0x0004) [0x0000000000000000]
    class AController*
        LastDiedController;  // 0x01D0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3401];

        return pClassPointer;
    };

    void LogAIChangedEnemy();
    void LogAIDoor();
    void LogAIWall();
    void LogAIBump();
    void LogAIChargeAttack();
    void LogAIGetNextMoveGoalFailure();
    void LogAIMoveFailure();
    void LogAIRedirectedPath();
    void LogAIBlockedPath();
    void LogAIPathObstruction();
    void LogAIFailedAnchor();
    void LogAIDestroyedDoor();
    void LogAIPathGoalEvalAbort();
    void LogAIBasedOnPawn();
    void LogAIHeadlessWander();
    void LogAIPathFailure();
    void LogBestSpawnVolume();
    void LogPlayersAtSpawn();
    void LogSpawnVolumeRating();
    void CanAcquireFile();
    void OpenStatsFile();
    void ResolveActorIndex();
    void ResolvePawnIndex();
    void ResolveProjectileClassIndex();
    void ResolveDamageClassIndex();
    void ResolveWeaponClassIndex();
};

UClass* UKFGameplayEventsWriter::pClassPointer = NULL;

// Class KFGame.KFAnim_AimOffset
// 0x0035 (0x01CD - 0x0198)
class UKFAnim_AimOffset : public UAnimNodeAimOffset {
   public:
    class AKFPawn* PawnOwner;  // 0x0198 (0x0008) [0x0000000000000000]
    class UKFAnim_TurnInPlace*
        TurnInPlaceNode;               // 0x01A0 (0x0008) [0x0000000000000000]
    DWORD bUseInteractionPawnAim : 1;  // 0x01A8 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bOnlyUpdateOnBecomeRelevant : 1;  // 0x01A8 (0x0004)
                                            // [0x0000000000000000] [0x00000002]
    DWORD bTurnOffWhenReloadingWeapon : 1;  // 0x01A8 (0x0004)
                                            // [0x0000000000000000] [0x00000004]
    DWORD bDoingWeaponReloadInterp : 1;  // 0x01A8 (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    float ReloadingBlendTime;            // 0x01AC (0x0004) [0x0000000000000000]
    float ReloadingBlendTimeToGo;        // 0x01B0 (0x0004) [0x0000000000000000]
    struct FVector2D LastAimOffset;      // 0x01B4 (0x0008) [0x0000000000000000]
    struct FVector2D
        LastPostProcessedAimOffset;  // 0x01BC (0x0008) [0x0000000000000000]
    float TurnAroundTimeToGo;        // 0x01C4 (0x0004) [0x0000000000000000]
    float TurnAroundBlendTime;       // 0x01C8 (0x0004) [0x0000000000000000]
    unsigned char AimInput;          // 0x01CC (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3403];

        return pClassPointer;
    };
};

UClass* UKFAnim_AimOffset::pClassPointer = NULL;

// Class KFGame.KFAnim_BlendByTargetingMode
// 0x0020 (0x0184 - 0x0164)
class UKFAnim_BlendByTargetingMode : public UAnimNodeBlendList {
   public:
    class AKFPawn* PawnOwner;         // 0x0164 (0x0008) [0x0000000000000000]
    DWORD bAllowDownSightsChild : 1;  // 0x016C (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bAllowAimingChild : 1;      // 0x016C (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bSynchronizeNodesInEditor : 1;  // 0x016C (0x0004)
                                          // [0x0000000000000000] [0x00000004]
    TArray<float> ChildBlendInTime;  // 0x0170 (0x0010) [0x0000000000000000]
    float AimTimeAfterFiring;        // 0x0180 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3405];

        return pClassPointer;
    };

    void SetActiveChild();
};

UClass* UKFAnim_BlendByTargetingMode::pClassPointer = NULL;

// Class KFGame.KFAnim_BlendFacialExpression
// 0x0004 (0x0188 - 0x0184)
class UKFAnim_BlendFacialExpression : public UAnimNodeBlendPerBone {
   public:
    int IgnoreAtOrAboveLOD;  // 0x0184 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3407];

        return pClassPointer;
    };
};

UClass* UKFAnim_BlendFacialExpression::pClassPointer = NULL;

// Class KFGame.KFAnim_BlendList
// 0x0020 (0x0184 - 0x0164)
class UKFAnim_BlendList : public UAnimNodeBlendList {
   public:
    TArray<float> ChildBlendInTime;  // 0x0164 (0x0010) [0x0000000000000000]
    TArray<DWORD> BlockSetActiveChildWhenRelevant;  // 0x0174 (0x0010)
                                                    // [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3409];

        return pClassPointer;
    };

    void SetActiveChild();
};

UClass* UKFAnim_BlendList::pClassPointer = NULL;

// Class KFGame.KFAnim_Movement
// 0x0018 (0x01B0 - 0x0198)
class UKFAnim_Movement : public UAnimNodeBlendBySpeed {
   public:
    DWORD bScaleAnimPlayRateBySpeed : 1;  // 0x0198 (0x0004)
                                          // [0x0000000000000000] [0x00000001]
    DWORD bSynchronizeNodesInEditor : 1;  // 0x0198 (0x0004)
                                          // [0x0000000000000000] [0x00000002]
    DWORD bUseOwnersBase : 1;  // 0x0198 (0x0004) [0x0000000000000000]
                               // [0x00000004]
    DWORD bUse2DMovement : 1;  // 0x0198 (0x0004) [0x0000000000000000]
                               // [0x00000008]
    float MoveCycleFirstStepStartPosition;  // 0x019C (0x0004)
                                            // [0x0000000000000000]
    class UAnimTree* RootNode;    // 0x01A0 (0x0008) [0x0000000000000000]
    struct FName SynchGroupName;  // 0x01A8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3411];

        return pClassPointer;
    };

    void SetActiveChild();
};

UClass* UKFAnim_Movement::pClassPointer = NULL;

// Class KFGame.KFAnim_PhysFalling
// 0x0020 (0x0184 - 0x0164)
class UKFAnim_PhysFalling : public UAnimNodeBlendList {
   public:
    TArray<float> ChildBlendInTime;  // 0x0164 (0x0010) [0x0000000000000000]
    float MinLandPlayTime;           // 0x0174 (0x0004) [0x0000000000000000]
    float SkipLandTimeLeft;          // 0x0178 (0x0004) [0x0000000000000000]
    class UAnimNodeSequence*
        LandNodeSeq;  // 0x017C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3413];

        return pClassPointer;
    };
};

UClass* UKFAnim_PhysFalling::pClassPointer = NULL;

// Class KFGame.KFAnim_Random
// 0x0004 (0x0188 - 0x0184)
class UKFAnim_Random : public UAnimNodeRandom {
   public:
    DWORD bNoResumeOnRelevant : 1;  // 0x0184 (0x0004) [0x0000000000000000]
                                    // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3415];

        return pClassPointer;
    };
};

UClass* UKFAnim_Random::pClassPointer = NULL;

// Class KFGame.KFAnim_RandomScripted
// 0x0004 (0x018C - 0x0188)
class UKFAnim_RandomScripted : public UKFAnim_Random {
   public:
    DWORD
        bHasTauntAnim : 1;  // 0x0188 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3417];

        return pClassPointer;
    };

    void QueueTauntWalk();
    void QueueAnimChild();
};

UClass* UKFAnim_RandomScripted::pClassPointer = NULL;

// Class KFGame.KFAnim_ScaleRateBySpeed
// 0x0014 (0x015C - 0x0148)
class UKFAnim_ScaleRateBySpeed : public UAnimNodeScaleRateBySpeed {
   public:
    TArray<struct FKFScaleRateInfo>
        PawnList;                // 0x0148 (0x0010) [0x0000000000000000]
    DWORD bUseBaseVelocity : 1;  // 0x0158 (0x0004) [0x0000000000000000]
                                 // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3419];

        return pClassPointer;
    };
};

UClass* UKFAnim_ScaleRateBySpeed::pClassPointer = NULL;

// Class KFGame.KFAnim_Slot
// 0x0004 (0x0168 - 0x0164)
class UKFAnim_Slot : public UAnimNodeSlot {
   public:
    DWORD bDelayedAnimSetsUpdate : 1;  // 0x0164 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bPendingAnimSetsUpdate : 1;  // 0x0164 (0x0004) [0x0000000000000000]
                                       // [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3421];

        return pClassPointer;
    };
};

UClass* UKFAnim_Slot::pClassPointer = NULL;

// Class KFGame.KFAnim_TurnInPlace
// 0x004C (0x019C - 0x0150)
class UKFAnim_TurnInPlace : public UAnimNodeBlend {
   public:
    DWORD
        bInitialized : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bDelayBlendOutToPlayAnim : 1;  // 0x0150 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bPlayingTurnTransition : 1;    // 0x0150 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    int LastPawnYaw;                     // 0x0154 (0x0004) [0x0000000000000000]
    float PawnRotationRate;              // 0x0158 (0x0004) [0x0000000000000000]
    int YawOffset;                       // 0x015C (0x0004) [0x0000000000000000]
    class AKFPawn* PawnOwner;            // 0x0160 (0x0008) [0x0000000000000000]
    class AActor* CachedBase;            // 0x0168 (0x0008) [0x0000000000000000]
    TArray<struct FRotTransitionInfo>
        RotTransitions;              // 0x0170 (0x0010) [0x0000000000000000]
    float TransitionBlendInTime;     // 0x0180 (0x0004) [0x0000000000000000]
    int CurrentTransitionIndex;      // 0x0184 (0x0004) [0x0000000000000000]
    float TransitionThresholdAngle;  // 0x0188 (0x0004) [0x0000000000000000]
    TArray<class UKFAnimSeq_TurnInPlace*>
        PlayerNodes;  // 0x018C (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3423];

        return pClassPointer;
    };

    void ResetRotation();
};

UClass* UKFAnim_TurnInPlace::pClassPointer = NULL;

// Class KFGame.KFAnim_TurnInPlace_Rotator
// 0x000B (0x0148 - 0x013D)
class UKFAnim_TurnInPlace_Rotator : public UAnimNodeBlendBase {
   public:
    class UKFAnim_TurnInPlace*
        TurnInPlaceNode;  // 0x0140 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3425];

        return pClassPointer;
    };
};

UClass* UKFAnim_TurnInPlace_Rotator::pClassPointer = NULL;

// Class KFGame.KFAnimNotify_AkEvent_NotEmpty_1P
// 0x0000 (0x007C - 0x007C)
class UKFAnimNotify_AkEvent_NotEmpty_1P : public UAnimNotify_AkEvent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3427];

        return pClassPointer;
    };
};

UClass* UKFAnimNotify_AkEvent_NotEmpty_1P::pClassPointer = NULL;

// Class KFGame.KFAnimNotify_CameraAnim
// 0x001C (0x0080 - 0x0064)
class UKFAnimNotify_CameraAnim : public UAnimNotify {
   public:
    class UCameraAnim* CameraAnim;  // 0x0064 (0x0008) [0x0000000000000000]
    DWORD bLoopCameraAnim : 1;      // 0x006C (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    DWORD bRandomizeCameraAnimLoopStartTime : 1;  // 0x006C (0x0004)
                                                  // [0x0000000000000000]
                                                  // [0x00000002]
    float CameraAnimScale;         // 0x0070 (0x0004) [0x0000000000000000]
    float CameraAnimPlayRate;      // 0x0074 (0x0004) [0x0000000000000000]
    float CameraAnimBlendInTime;   // 0x0078 (0x0004) [0x0000000000000000]
    float CameraAnimBlendOutTime;  // 0x007C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3429];

        return pClassPointer;
    };
};

UClass* UKFAnimNotify_CameraAnim::pClassPointer = NULL;

// Class KFGame.KFAnimNotify_Decal
// 0x004C (0x00B0 - 0x0064)
class UKFAnimNotify_Decal : public UAnimNotify {
   public:
    DWORD bIgnoreIfActorHidden : 1;    // 0x0064 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bOnlyTraceDown : 1;          // 0x0064 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    struct FName BoneOrSocketName;     // 0x0068 (0x0008) [0x0000000000000000]
    struct FVector RelativeLocation;   // 0x0070 (0x000C) [0x0000000000000000]
    struct FRotator RelativeRotation;  // 0x007C (0x000C) [0x0000000000000000]
    float TraceDistance;               // 0x0088 (0x0004) [0x0000000000000000]
    struct FDecalData Decal;           // 0x008C (0x001C) [0x0000000000000000]
    class UArrowComponent*
        MyArrowComponent;  // 0x00A8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3431];

        return pClassPointer;
    };

    void CreateDecal();
    void eventSpawnDecal();
};

UClass* UKFAnimNotify_Decal::pClassPointer = NULL;

// Class KFGame.KFAnimNotify_HideBone
// 0x000C (0x0070 - 0x0064)
class UKFAnimNotify_HideBone : public UAnimNotify {
   public:
    struct FName BoneName;  // 0x0064 (0x0008) [0x0000000000000000]
    DWORD bUnhideBone : 1;  // 0x006C (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3433];

        return pClassPointer;
    };
};

UClass* UKFAnimNotify_HideBone::pClassPointer = NULL;

// Class KFGame.KFAnimNotify_MeleeImpact
// 0x0019 (0x007D - 0x0064)
class UKFAnimNotify_MeleeImpact : public UAnimNotify {
   public:
    float DamageScale;  // 0x0064 (0x0004) [0x0000000000000000]
    DWORD
        bDoAreaDamage : 1;  // 0x0068 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bDoSwipeDamage : 1;        // 0x0068 (0x0004) [0x0000000000000000]
                                     // [0x00000002]
    DWORD bCanDoKnockback : 1;       // 0x0068 (0x0004) [0x0000000000000000]
                                     // [0x00000004]
    DWORD bCanCauseZedTime : 1;      // 0x0068 (0x0004) [0x0000000000000000]
                                     // [0x00000008]
    float MomentumTransferScale;     // 0x006C (0x0004) [0x0000000000000000]
    class UClass* CustomDamageType;  // 0x0070 (0x0008) [0x0000000000000000]
    float AttackReachOverride;       // 0x0078 (0x0004) [0x0000000000000000]
    unsigned char SwipeDirection;    // 0x007C (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3435];

        return pClassPointer;
    };

    void eventNotifyThirdPerson();
    void eventNotifyFirstPerson();
};

UClass* UKFAnimNotify_MeleeImpact::pClassPointer = NULL;

// Class KFGame.KFAnimNotify_MeleeImpact_1P
// 0x0004 (0x0068 - 0x0064)
class UKFAnimNotify_MeleeImpact_1P : public UAnimNotify {
   public:
    DWORD bAdvancedCollisionDetection : 1;  // 0x0064 (0x0004)
                                            // [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3437];

        return pClassPointer;
    };

    void eventNotifyThirdPerson();
    void eventNotifyFirstPerson();
};

UClass* UKFAnimNotify_MeleeImpact_1P::pClassPointer = NULL;

// Class KFGame.KFAnimNotify_MeleeTrails
// 0x0010 (0x00E0 - 0x00D0)
class UKFAnimNotify_MeleeTrails : public UAnimNotify_Trails {
   public:
    class UParticleSystem*
        BlueTrailParticle;  // 0x00D0 (0x0008) [0x0000000000000000]
    class UParticleSystem*
        RedTrailParticle;  // 0x00D8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3439];

        return pClassPointer;
    };
};

UClass* UKFAnimNotify_MeleeTrails::pClassPointer = NULL;

// Class KFGame.KFAnimNotify_ZedVoiceAkEvent
// 0x000C (0x0088 - 0x007C)
class UKFAnimNotify_ZedVoiceAkEvent : public UAnimNotify_AkEvent {
   public:
    class UAkEvent* MouthlessAkEvent;  // 0x007C (0x0008) [0x0000000000000000]
    DWORD bTestMouthlessAkEvent : 1;   // 0x0084 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bTreatAsDialog : 1;          // 0x0084 (0x0004) [0x0000000000000000]
                                       // [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3441];

        return pClassPointer;
    };
};

UClass* UKFAnimNotify_ZedVoiceAkEvent::pClassPointer = NULL;

// Class KFGame.KFAnimSeq_ByWeaponClass
// 0x0030 (0x01C8 - 0x0198)
class UKFAnimSeq_ByWeaponClass : public UAnimNodeSequence {
   public:
    TArray<struct FWeaponClassNameInfo>
        WeaponList;                      // 0x0198 (0x0010) [0x0000000000000000]
    struct FName WeaponDefaultAnimName;  // 0x01A8 (0x0008) [0x0000000000000000]
    DWORD bSynchronizeNodesInEditor : 1;  // 0x01B0 (0x0004)
                                          // [0x0000000000000000] [0x00000001]
    DWORD bTemporaryHolster : 1;     // 0x01B0 (0x0004) [0x0000000000000000]
                                     // [0x00000002]
    float WeaponListSliderPosition;  // 0x01B4 (0x0004) [0x0000000000000000]
    class APawn* PawnOwner;          // 0x01B8 (0x0008) [0x0000000000000000]
    class AWeapon* CurrentWeapon;    // 0x01C0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3443];

        return pClassPointer;
    };
};

UClass* UKFAnimSeq_ByWeaponClass::pClassPointer = NULL;

// Class KFGame.KFAnimSeq_Directional
// 0x0034 (0x01DC - 0x01A8)
class UKFAnimSeq_Directional : public UAnimNodeSequenceBlendBase {
   public:
    DWORD bAddRotationRate : 1;  // 0x01A8 (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    DWORD bSynchronizeNodesInEditor : 1;  // 0x01A8 (0x0004)
                                          // [0x0000000000000000] [0x00000002]
    DWORD bRestartOnBecomeRelevant : 1;  // 0x01A8 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    float DirAngle;                      // 0x01AC (0x0004) [0x0000000000000000]
    float TargetAngle;                   // 0x01B0 (0x0004) [0x0000000000000000]
    struct FVector MoveDir;              // 0x01B4 (0x000C) [0x0000000000000000]
    int LastYaw;                         // 0x01C0 (0x0004) [0x0000000000000000]
    float YawRotationRate;               // 0x01C4 (0x0004) [0x0000000000000000]
    class AKFPawn* PawnOwner;            // 0x01C8 (0x0008) [0x0000000000000000]
    unsigned char DirectionInterpType;   // 0x01D0 (0x0001) [0x0000000000000000]
    float CircularInterpSpeed;           // 0x01D4 (0x0004) [0x0000000000000000]
    float LinearInterpSpeed;             // 0x01D8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3445];

        return pClassPointer;
    };
};

UClass* UKFAnimSeq_Directional::pClassPointer = NULL;

// Class KFGame.KFAnimSeq_TurnInPlace
// 0x0024 (0x01CC - 0x01A8)
class UKFAnimSeq_TurnInPlace : public UAnimNodeSequenceBlendBase {
   public:
    TArray<struct FTIP_Transition>
        TIP_Transitions;        // 0x01A8 (0x0010) [0x0000000000000000]
    float TransitionBlendTime;  // 0x01B8 (0x0004) [0x0000000000000000]
    int ActiveChildIndex;       // 0x01BC (0x0004) [0x0000000000000000]
    float BlendTimeToGo;        // 0x01C0 (0x0004) [0x0000000000000000]
    class AKFPawn* PawnOwner;   // 0x01C4 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3447];

        return pClassPointer;
    };
};

UClass* UKFAnimSeq_TurnInPlace::pClassPointer = NULL;

// Class KFGame.KFAnimSeq_Tween
// 0x002C (0x01C4 - 0x0198)
class UKFAnimSeq_Tween : public UAnimNodeSequence {
   public:
    float TweenTime;      // 0x0198 (0x0004) [0x0000000000000000]
    float BlendTimeToGo;  // 0x019C (0x0004) [0x0000000000000000]
    TArray<struct FBoneAtom>
        CachedPrevBoneAtoms;  // 0x01A0 (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        CachedRequiredBones;          // 0x01B0 (0x0010) [0x0000000000000000]
    DWORD bSetAnimWasCalled : 1;      // 0x01C0 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bUsesCameraAnimNotify : 1;  // 0x01C0 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bSkipBlendWhenNotRendered : 1;  // 0x01C0 (0x0004)
                                          // [0x0000000000000000] [0x00000004]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3449];

        return pClassPointer;
    };

    void PlayAnim();
    void SetTweenTime();
    void SetAnim();
};

UClass* UKFAnimSeq_Tween::pClassPointer = NULL;

// Class KFGame.KFSkelControl_AmmoSlider
// 0x001C (0x0140 - 0x0124)
class UKFSkelControl_AmmoSlider : public USkelControlSingleBone {
   public:
    struct FVector MaxBoneTranslation;  // 0x0124 (0x000C) [0x0000000000000000]
    float BoneInterpInSpeed;            // 0x0130 (0x0004) [0x0000000000000000]
    float BoneInterpOutSpeed;           // 0x0134 (0x0004) [0x0000000000000000]
    class AKFWeapon* WeaponOwner;       // 0x0138 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3451];

        return pClassPointer;
    };
};

UClass* UKFSkelControl_AmmoSlider::pClassPointer = NULL;

// Class KFGame.KFSkelControl_FootPlacement
// 0x0068 (0x01D8 - 0x0170)
class UKFSkelControl_FootPlacement : public USkelControlFootPlacement {
   public:
    DWORD bProjectOntoPlane : 1;    // 0x0170 (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    float InterpUpSpeed;            // 0x0174 (0x0004) [0x0000000000000000]
    float InterpDownSpeed;          // 0x0178 (0x0004) [0x0000000000000000]
    struct FVector FloorNormal;     // 0x017C (0x000C) [0x0000000000000000]
    float MinAdjustment;            // 0x0188 (0x0004) [0x0000000000000000]
    float MaxLegAdjustForSkipRate;  // 0x018C (0x0004) [0x0000000000000000]
    int SkipRateForLineTrace;       // 0x0190 (0x0004) [0x0000000000000000]
    int UpdateTransformsCount;      // 0x0194 (0x0004) [0x0000000000000000]
    struct FVector HitNormal;       // 0x0198 (0x000C) [0x0000000000000000]
    float LegAdjust;                // 0x01A4 (0x0004) [0x0000000000000000]
    float LegAdjustInterp;          // 0x01A8 (0x0004) [0x0000000000000000]
    class AKFPawn* PawnOwner;       // 0x01AC (0x0008) [0x0000000000000000]
    struct FVector DebugStartLoc;   // 0x01B4 (0x000C) [0x0000000000000000]
    struct FVector DebugEndLoc;     // 0x01C0 (0x000C) [0x0000000000000000]
    struct FVector DebugIKLoc;      // 0x01CC (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3453];

        return pClassPointer;
    };
};

UClass* UKFSkelControl_FootPlacement::pClassPointer = NULL;

// Class KFGame.KFSkelControl_SpinBone
// 0x000C (0x0130 - 0x0124)
class UKFSkelControl_SpinBone : public USkelControlSingleBone {
   public:
    struct FRotator RotationRate;  // 0x0124 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3455];

        return pClassPointer;
    };
};

UClass* UKFSkelControl_SpinBone::pClassPointer = NULL;

// Class KFGame.KFSkelControl_SprayScaling
// 0x0020 (0x0114 - 0x00F4)
class UKFSkelControl_SprayScaling : public USkelControlBase {
   public:
    float CurrentAge;                    // 0x00F4 (0x0004) [0x0000000000000000]
    float CurrentVel;                    // 0x00F8 (0x0004) [0x0000000000000000]
    float LastVel;                       // 0x00FC (0x0004) [0x0000000000000000]
    float VelocitySmoothingInterpSpeed;  // 0x0100 (0x0004) [0x0000000000000000]
    TArray<struct FSprayBoneScaleParams>
        ScaleParams;  // 0x0104 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3457];

        return pClassPointer;
    };

    void ResetTransients();
};

UClass* UKFSkelControl_SprayScaling::pClassPointer = NULL;

// Class KFGame.KFSkelControl_SprayWhipDir
// 0x0000 (0x00F4 - 0x00F4)
class UKFSkelControl_SprayWhipDir : public USkelControlBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3459];

        return pClassPointer;
    };
};

UClass* UKFSkelControl_SprayWhipDir::pClassPointer = NULL;

// Class KFGame.KFSkelControl_WeaponTilt
// 0x001C (0x0140 - 0x0124)
class UKFSkelControl_WeaponTilt : public USkelControlSingleBone {
   public:
    struct FRotator WeaponBoneRotation;  // 0x0124 (0x000C) [0x0000000000000000]
    float StrafeDeadzoneCos;             // 0x0130 (0x0004) [0x0000000000000000]
    float BoneRotationRate;              // 0x0134 (0x0004) [0x0000000000000000]
    class AKFWeapon* WeaponOwner;        // 0x0138 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3461];

        return pClassPointer;
    };
};

UClass* UKFSkelControl_WeaponTilt::pClassPointer = NULL;

// Class KFGame.KFSceneCaptureDebugCam
// 0x0080 (0x02D4 - 0x0254)
class AKFSceneCaptureDebugCam : public ASceneCapture2DActor {
   public:
    class UTexture2D* BlackTexture;  // 0x0254 (0x0008) [0x0000000000000000]
    class USceneCapture2DComponent*
        CaptureComponent;                // 0x025C (0x0008) [0x0000000000000000]
    class AActor* FocusActor;            // 0x0264 (0x0008) [0x0000000000000000]
    class UClass* FocusClass;            // 0x026C (0x0008) [0x0000000000000000]
    class APawn* FocusPawn;              // 0x0274 (0x0008) [0x0000000000000000]
    class AKFPlayerController* PCOwner;  // 0x027C (0x0008) [0x0000000000000000]
    DWORD bWatchNPCPathFailures : 1;     // 0x0284 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bWatchActorSpawn : 1;          // 0x0284 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bWatchTouch : 1;  // 0x0284 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bOrbitFocus : 1;  // 0x0284 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bSetBaseToFocus : 1;  // 0x0284 (0x0004) [0x0000000000000000]
                                // [0x00000010]
    DWORD
        bNoAnimPause : 1;  // 0x0284 (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bOverrideFocus : 1;  // 0x0284 (0x0004) [0x0000000000000000]
                               // [0x00000040]
    DWORD bLockFocus : 1;  // 0x0284 (0x0004) [0x0000000000000000] [0x00000080]
    DWORD
        bTickAnimNodesWhenNotRendered : 1;  // 0x0284 (0x0004)
                                            // [0x0000000000000000] [0x00000100]
    DWORD bUpdateSkelWhenNotRendered : 1;   // 0x0284 (0x0004)
                                            // [0x0000000000000000] [0x00000200]
    DWORD bIgnoreControllersWhenNotRendered : 1;  // 0x0284 (0x0004)
                                                  // [0x0000000000000000]
                                                  // [0x00000400]
    DWORD bPauseAnims : 1;  // 0x0284 (0x0004) [0x0000000000000000] [0x00000800]
    DWORD bTextOnly : 1;    // 0x0284 (0x0004) [0x0000000000000000] [0x00001000]
    struct FName
        ActorNameToWatchOnSpawn;  // 0x0288 (0x0008) [0x0000000000000000]
    int ActiveDebugWindows;       // 0x0290 (0x0004) [0x0000000000000000]
    float MinDistFactorForKinematicUpdate;  // 0x0294 (0x0004)
                                            // [0x0000000000000000]
    struct FString
        CurrentDebugSceneMessage;  // 0x0298 (0x0010) [0x0000000000000000]
    class UMaterialInterface*
        DebugViewMaterial;  // 0x02A8 (0x0008) [0x0000000000000000]
    class UMaterialInstanceConstant*
        DebugViewMaterialInstance;  // 0x02B0 (0x0008) [0x0000000000000000]
    class AKFAIController*
        FocusController;          // 0x02B8 (0x0008) [0x0000000000000000]
    class AKFPawn* FocusKFPawn;   // 0x02C0 (0x0008) [0x0000000000000000]
    struct FVector LastLocation;  // 0x02C8 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3463];

        return pClassPointer;
    };

    void eventPostRenderFor();
    void RestoreFocusPawnMeshProperties();
    void CacheAndUpdateFocusPawnMeshProperties();
    void PauseDebugSceneUpdate();
    void SetDebugSceneViewMode();
    void ToggleLockFocus();
    void MoveToMyPawnLocation();
    void ToggleDebugSceneOrbit();
    void eventDestroyDebugScene();
    void InitDebugScene();
    void GetDebugSceneViewPoint();
    void NativePostRenderFor();
    void CreateDebugTexture();
};

UClass* AKFSceneCaptureDebugCam::pClassPointer = NULL;

// Class KFGame.KFDebugCameraController
// 0x0028 (0x07F4 - 0x07CC)
class AKFDebugCameraController : public ADebugCameraController {
   public:
    DWORD bDebugSceneEnabled : 1;  // 0x07CC (0x0004) [0x0000000000000000]
                                   // [0x00000001]
    DWORD bViewFromFocus : 1;      // 0x07CC (0x0004) [0x0000000000000000]
                                   // [0x00000002]
    DWORD bForceSprinting : 1;     // 0x07CC (0x0004) [0x0000000000000000]
                                   // [0x00000004]
    DWORD bMoveToActorOnly : 1;    // 0x07CC (0x0004) [0x0000000000000000]
                                   // [0x00000008]
    class AKFSceneCaptureDebugCam*
        DebugSceneCamera;  // 0x07D0 (0x0008) [0x0000000000000000]
    class AKFPawn_Monster*
        SelectedKFPawn;                  // 0x07D8 (0x0008) [0x0000000000000000]
    float SelectedNPCMoveOffset;         // 0x07E0 (0x0004) [0x0000000000000000]
    class AAIDebugGoal* DebugGoal;       // 0x07E4 (0x0008) [0x0000000000000000]
    class AKFPawn_Monster* DebugTarget;  // 0x07EC (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3465];

        return pClassPointer;
    };

    void NativeInputKey();
    void eventGetPlayerViewPoint();
    void ServerUpdateCamera();
    void GetDebugSceneViewPoint();
    void ToggleSelectedActorView();
    void SetMoveOffset();
    void ToggleDebugViewFocus();
    void AIShowSelectedInfo();
    void AIMoveForward();
    void ServerCauseEvent();
    void GetDebugCommand();
    void AddCheats();
    void OnActivate();
    void DisableDebugCamera();
    void OnDeactivate();
    void eventPostBeginPlay();
    void Unselect();
    void SecondarySelect();
    void PrimarySelect();
};

UClass* AKFDebugCameraController::pClassPointer = NULL;

// Class KFGame.KFPlayerController
// 0x0604 (0x0D84 - 0x0780)
class AKFPlayerController : public AGamePlayerController {
   public:
    unsigned char
        CurrentTextChatChannel;         // 0x0780 (0x0001) [0x0000000000000000]
    unsigned char CurrentVoiceChannel;  // 0x0781 (0x0001) [0x0000000000000000]
    unsigned char SavedPerkIndex;       // 0x0782 (0x0001) [0x0000000000000000]
    unsigned char CurrentSpectateMode;  // 0x0783 (0x0001) [0x0000000000000000]
    unsigned char
        CurrentTrackerRangeMode;        // 0x0784 (0x0001) [0x0000000000000000]
    unsigned char CurrentTrackingMode;  // 0x0785 (0x0001) [0x0000000000000000]
    unsigned char
        CurrentGameConductorDebugMode;  // 0x0786 (0x0001) [0x0000000000000000]
    TArray<struct FPlayerSteamAvatar>
        AvatarList;  // 0x0788 (0x0010) [0x0000000000000000]
    TArray<struct FPlayerAvatarPS4>
        AvatarListPS4;                  // 0x0798 (0x0010) [0x0000000000000000]
    TArray<struct FPerkInfo> PerkList;  // 0x07A8 (0x0010) [0x0000000000000000]
    class AKFPerk* CurrentPerk;  // 0x07B8 (0x0008) [0x0000000000190000] (
                                 // CPF_Travel | CPF_Component )
    class UClass* ServPendingPerkClass;  // 0x07C0 (0x0008) [0x0000000000000000]
    int ServPendingPerkBuild;            // 0x07C8 (0x0004) [0x0000000000000000]
    int ServPendingPerkLevel;            // 0x07CC (0x0004) [0x0000000000000000]
    DWORD bWaitingForClientPerkData : 1;  // 0x07D0 (0x0004)
                                          // [0x0000000000000000] [0x00000001]
    DWORD bPerkStatsLoaded : 1;  // 0x07D0 (0x0004) [0x0000000000000000]
                                 // [0x00000002]
    DWORD
        bAcuteHearing : 1;  // 0x07D0 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bUsePhysicsRotation : 1;    // 0x07D0 (0x0004) [0x0000000000000000]
                                      // [0x00000008]
    DWORD bIsAchievementPlayer : 1;   // 0x07D0 (0x0004) [0x0000000000000000]
                                      // [0x00000010]
    DWORD bHideTraderPaths : 1;       // 0x07D0 (0x0004) [0x0000000000000000]
                                      // [0x00000020]
    DWORD bClientTraderMenuOpen : 1;  // 0x07D0 (0x0004) [0x0000000000000000]
                                      // [0x00000040]
    DWORD bPlayerUsedUpdatePerk : 1;  // 0x07D0 (0x0004) [0x0000000000000000]
                                      // [0x00000080]
    DWORD bDownloadingContent : 1;    // 0x07D0 (0x0004) [0x0000000000000000]
                                      // [0x00000100]
    DWORD bNoEarRingingSound : 1;     // 0x07D0 (0x0004) [0x0000000000000000]
                                      // [0x00000200]
    DWORD bNightVisionActive : 1;     // 0x07D0 (0x0004) [0x0000000000000000]
                                      // [0x00000400]
    DWORD bPerkEffectIsActive : 1;    // 0x07D0 (0x0004) [0x0000000000000000]
                                      // [0x00000800]
    DWORD bGrabEffectIsActive : 1;    // 0x07D0 (0x0004) [0x0000000000000000]
                                      // [0x00001000]
    DWORD bPlayingLowHealthSFX : 1;   // 0x07D0 (0x0004) [0x0000000000000000]
                                      // [0x00002000]
    DWORD bCachedSeeZedTimePawn : 1;  // 0x07D0 (0x0004) [0x0000000000000000]
                                      // [0x00004000]
    DWORD bRecursingZedTimeVisibility : 1;  // 0x07D0 (0x0004)
                                            // [0x0000000000000000] [0x00008000]
    DWORD bShowKillTicker : 1;      // 0x07D0 (0x0004) [0x0000000000000000]
                                    // [0x00010000]
    DWORD bDisableAutoUpgrade : 1;  // 0x07D0 (0x0004) [0x0000000000000000]
                                    // [0x00020000]
    DWORD bHideBossHealthBar : 1;   // 0x07D0 (0x0004) [0x0000000000000000]
                                    // [0x00040000]
    DWORD bDOFEnabled : 1;  // 0x07D0 (0x0004) [0x0000000000000000] [0x00080000]
    DWORD bGamePlayDOFActive : 1;    // 0x07D0 (0x0004) [0x0000000000000000]
                                     // [0x00100000]
    DWORD bIronSightsDOFActive : 1;  // 0x07D0 (0x0004) [0x0000000000000000]
                                     // [0x00200000]
    DWORD bReflectionsEnabled : 1;   // 0x07D0 (0x0004) [0x0000000000000000]
                                     // [0x00400000]
    DWORD
        bBlurEnabled : 1;  // 0x07D0 (0x0004) [0x0000000000000000] [0x00800000]
    DWORD bProcessingGameInvite : 1;    // 0x07D0 (0x0004) [0x0000000000000000]
                                        // [0x01000000]
    DWORD bLoggingInForOnlinePlay : 1;  // 0x07D0 (0x0004) [0x0000000000000000]
                                        // [0x02000000]
    DWORD
        bOnlinePrivilegeCheckPending : 1;  // 0x07D0 (0x0004)
                                           // [0x0000000000000000] [0x04000000]
    DWORD bDebugTargetAdhesion : 1;    // 0x07D0 (0x0004) [0x0000000000000000]
                                       // [0x08000000]
    DWORD bDebugAutoTarget : 1;        // 0x07D0 (0x0004) [0x0000000000000000]
                                       // [0x10000000]
    DWORD bLockToForceLookAtPawn : 1;  // 0x07D0 (0x0004) [0x0000000000000000]
                                       // [0x20000000]
    DWORD bSkipNonCriticalForceLookAt : 1;  // 0x07D0 (0x0004)
                                            // [0x0000000000000000] [0x40000000]
    DWORD bDebugPartialZedTime : 1;  // 0x07D0 (0x0004) [0x0000000000000000]
                                     // [0x80000000]
    DWORD bForcePartialZedTime : 1;  // 0x07D4 (0x0004) [0x0000000000000000]
                                     // [0x00000001]
    DWORD bTrackingMapTopView : 1;   // 0x07D4 (0x0004) [0x0000000000000000]
                                     // [0x00000002]
    DWORD bNoGoActive : 1;  // 0x07D4 (0x0004) [0x0000000000000000] [0x00000004]
    class UClass* MonsterPerkClass;  // 0x07D8 (0x0008) [0x0000000000000000]
    struct FName MusicMessageType;   // 0x07E0 (0x0008) [0x0000000000000000]
    struct FsPlayerZedSpawnInfo
        PlayerZedSpawnInfo;           // 0x07E8 (0x0018) [0x0000000000000000]
    class AKFPawn_Human* UsablePawn;  // 0x0800 (0x0008) [0x0000000000000000]
    float UnmodifiedFOV;              // 0x0808 (0x0004) [0x0000000000000000]
    int BenefactorDosh;               // 0x080C (0x0004) [0x0000000000000000]
    int BenefactorDoshReq;            // 0x0810 (0x0004) [0x0000000000000000]
    struct FPostProcessSettings
        PostProcessModifier;       // 0x0814 (0x0220) [0x0000000000000000]
    float NextAdminCmdTime;        // 0x0A34 (0x0004) [0x0000000000000000]
    float RefreshObjectiveUITime;  // 0x0A38 (0x0004) [0x0000000000000000]
    int ShotsFired;                // 0x0A3C (0x0004) [0x0000000000000000]
    int ShotsHit;                  // 0x0A40 (0x0004) [0x0000000000000000]
    int ShotsHitHeadshot;          // 0x0A44 (0x0004) [0x0000000000000000]
    class UKFGFxMoviePlayer_Manager*
        MyGFxManager;  // 0x0A48 (0x0008) [0x0000000000000000]
    class UKFGFxMoviePlayer_HUD*
        MyGFxHUD;  // 0x0A50 (0x0008) [0x0000000000000000]
    class UKFGFxMoviePlayer_PostRoundMenu*
        MyGFxPostRoundMenu;             // 0x0A58 (0x0008) [0x0000000000000000]
    class UClass* PostRoundMenuClass;   // 0x0A60 (0x0008) [0x0000000000000000]
    class UClass* PurchaseHelperClass;  // 0x0A68 (0x0008) [0x0000000000000000]
    class UKFAutoPurchaseHelper*
        PurchaseHelper;        // 0x0A70 (0x0008) [0x0000000000000000]
    float NextSpectatorDelay;  // 0x0A78 (0x0004) [0x0000000000000000]
    class AKFPawn_Customization*
        LocalCustomizationPawn;         // 0x0A7C (0x0008) [0x0000000000000000]
    class UAkEvent* ZedTimeEnterSound;  // 0x0A84 (0x0008) [0x0000000000000000]
    class UAkEvent* ZedTimeExitSound;   // 0x0A8C (0x0008) [0x0000000000000000]
    class UAkEvent*
        ZedTimePartialEnterSound;  // 0x0A94 (0x0008) [0x0000000000000000]
    class UAkEvent*
        ZedTimePartialExitSound;       // 0x0A9C (0x0008) [0x0000000000000000]
    float LastTimeDilation;            // 0x0AA4 (0x0004) [0x0000000000000000]
    class UAkEvent* PauseWwiseEvent;   // 0x0AA8 (0x0008) [0x0000000000000000]
    class UAkEvent* ResumeWwiseEvent;  // 0x0AB0 (0x0008) [0x0000000000000000]
    class UAkEvent*
        EarsRingingPlayEvent;  // 0x0AB8 (0x0008) [0x0000000000000000]
    class UAkEvent*
        EarsRingingStopEvent;  // 0x0AC0 (0x0008) [0x0000000000000000]
    class UAkEvent*
        LowHealthStartEvent;             // 0x0AC8 (0x0008) [0x0000000000000000]
    class UAkEvent* LowHealthStopEvent;  // 0x0AD0 (0x0008) [0x0000000000000000]
    class UAkComponent*
        StingerAkComponent;              // 0x0AD8 (0x0008) [0x0000000000000000]
    class UAkEvent* ResetFiltersEvent;   // 0x0AE0 (0x0008) [0x0000000000000000]
    class UAkEvent* FlashlightOnEvent;   // 0x0AE8 (0x0008) [0x0000000000000000]
    class UAkEvent* FlashlightOffEvent;  // 0x0AF0 (0x0008) [0x0000000000000000]
    class UAkEvent* NightVisionOnEvent;  // 0x0AF8 (0x0008) [0x0000000000000000]
    class UAkEvent*
        NightVisionOffEvent;  // 0x0B00 (0x0008) [0x0000000000000000]
    class UAkEvent*
        AllMapCollectiblesFoundEvent;  // 0x0B08 (0x0008) [0x0000000000000000]
    class UMaterialEffect*
        GameplayPostProcessEffects;  // 0x0B10 (0x0008) [0x0000000000000000]
    struct FName
        GameplayPostProcessEffectName;  // 0x0B18 (0x0008) [0x0000000000000000]
    class UMaterialInstanceConstant*
        GameplayPostProcessEffectMIC;  // 0x0B20 (0x0008) [0x0000000000000000]
    struct FName EffectPainParamName;  // 0x0B28 (0x0008) [0x0000000000000000]
    struct FName
        EffectLowHealthParamName;  // 0x0B30 (0x0008) [0x0000000000000000]
    struct FName
        EffectZedTimeParamName;  // 0x0B38 (0x0008) [0x0000000000000000]
    struct FName
        EffectNightVisionParamName;  // 0x0B40 (0x0008) [0x0000000000000000]
    struct FName
        EffectSirenScreamParamName;  // 0x0B48 (0x0008) [0x0000000000000000]
    struct FName
        EffectBloatsPukeParamName;     // 0x0B50 (0x0008) [0x0000000000000000]
    struct FName EffectHealParamName;  // 0x0B58 (0x0008) [0x0000000000000000]
    struct FName EffectPerkParamName;  // 0x0B60 (0x0008) [0x0000000000000000]
    struct FName
        EffectFlashBangParamName;     // 0x0B68 (0x0008) [0x0000000000000000]
    float PainEffectDuration;         // 0x0B70 (0x0004) [0x0000000000000000]
    float PainEffectTimeRemaining;    // 0x0B74 (0x0004) [0x0000000000000000]
    float HealEffectDuration;         // 0x0B78 (0x0004) [0x0000000000000000]
    float HealEffectTimeRemaining;    // 0x0B7C (0x0004) [0x0000000000000000]
    float SonicScreamEffectDuration;  // 0x0B80 (0x0004) [0x0000000000000000]
    float
        SirenScreamEffectTimeRemaining;  // 0x0B84 (0x0004) [0x0000000000000000]
    float BloatPukeEffectDuration;       // 0x0B88 (0x0004) [0x0000000000000000]
    float BloatPukeEffectTimeRemaining;  // 0x0B8C (0x0004) [0x0000000000000000]
    float FlashBangEffectDuration;       // 0x0B90 (0x0004) [0x0000000000000000]
    float FlashBangEffectTimeRemaining;  // 0x0B94 (0x0004) [0x0000000000000000]
    int LowHealthThreshold;              // 0x0B98 (0x0004) [0x0000000000000000]
    float TargetZEDTimeEffectIntensity;  // 0x0B9C (0x0004) [0x0000000000000000]
    float
        CurrentZEDTimeEffectIntensity;  // 0x0BA0 (0x0004) [0x0000000000000000]
    float ZEDTimeEffectInterpTimeRemaining;  // 0x0BA4 (0x0004)
                                             // [0x0000000000000000]
    float
        PartialZEDTimeEffectIntensity;  // 0x0BA8 (0x0004) [0x0000000000000000]
    float ExplosionEarRingDuration;     // 0x0BAC (0x0004) [0x0000000000000000]
    float
        ExplosionEarRingTimeRemaining;  // 0x0BB0 (0x0004) [0x0000000000000000]
    float ExplosionEarRingEffectIntensity;  // 0x0BB4 (0x0004)
                                            // [0x0000000000000000]
    float ExplosionEarRingDelay;        // 0x0BB8 (0x0004) [0x0000000000000000]
    float CachedZedTimeVisibilityTime;  // 0x0BBC (0x0004) [0x0000000000000000]
    float ZedTimeSightCounter;          // 0x0BC0 (0x0004) [0x0000000000000000]
    class UPointLightComponent*
        AmplificationLightTemplate;  // 0x0BC4 (0x0008) [0x0000000000000000]
    class UPointLightComponent*
        AmplificationLight;        // 0x0BCC (0x0008) [0x0000000000000000]
    float PauseMoveInputTimeLeft;  // 0x0BD4 (0x0004) [0x0000000000000000]
    class UPointLightComponent*
        NVGLightTemplate;  // 0x0BD8 (0x0008) [0x0000000000000000]
    class UPointLightComponent*
        NVGLight;                       // 0x0BE0 (0x0008) [0x0000000000000000]
    float DOFFocalRange;                // 0x0BE8 (0x0004) [0x0000000000000000]
    float DOFFocalAperture;             // 0x0BEC (0x0004) [0x0000000000000000]
    float DOFFocusBlendRate;            // 0x0BF0 (0x0004) [0x0000000000000000]
    float DOFFocusDepth;                // 0x0BF4 (0x0004) [0x0000000000000000]
    float DOFMaxFocusDepth;             // 0x0BF8 (0x0004) [0x0000000000000000]
    float DOFStaticFocusDepth;          // 0x0BFC (0x0004) [0x0000000000000000]
    float DOFMaxEnemyAngle;             // 0x0C00 (0x0004) [0x0000000000000000]
    float DOF_GP_LerpControl;           // 0x0C04 (0x0004) [0x0000000000000000]
    float DOF_IS_LerpControl;           // 0x0C08 (0x0004) [0x0000000000000000]
    float DOF_NVG_BlendInSpeed;         // 0x0C0C (0x0004) [0x0000000000000000]
    float DOF_NVG_BlendOutSpeed;        // 0x0C10 (0x0004) [0x0000000000000000]
    float CIN_ImageGrainScale;          // 0x0C14 (0x0004) [0x0000000000000000]
    float NVG_FocusBlendRate;           // 0x0C18 (0x0004) [0x0000000000000000]
    float NVG_ImageGrainScale;          // 0x0C1C (0x0004) [0x0000000000000000]
    float NVG_DOF_FocalDistance;        // 0x0C20 (0x0004) [0x0000000000000000]
    float NVG_DOF_SharpRadius;          // 0x0C24 (0x0004) [0x0000000000000000]
    float NVG_DOF_FocalRadius;          // 0x0C28 (0x0004) [0x0000000000000000]
    float NVG_DOF_MinBlurSize;          // 0x0C2C (0x0004) [0x0000000000000000]
    float NVG_DOF_MaxNearBlurSize;      // 0x0C30 (0x0004) [0x0000000000000000]
    float NVG_DOF_MaxFarBlurSize;       // 0x0C34 (0x0004) [0x0000000000000000]
    float NVG_DOF_ExpFalloff;           // 0x0C38 (0x0004) [0x0000000000000000]
    float DOF_Cinematic_BlendInSpeed;   // 0x0C3C (0x0004) [0x0000000000000000]
    float DOF_Cinematic_BlendOutSpeed;  // 0x0C40 (0x0004) [0x0000000000000000]
    float DOF_Cinematic_FocalDistance;  // 0x0C44 (0x0004) [0x0000000000000000]
    float DOF_Cinematic_SharpRadius;    // 0x0C48 (0x0004) [0x0000000000000000]
    float DOF_Cinematic_FocalRadius;    // 0x0C4C (0x0004) [0x0000000000000000]
    float DOF_Cinematic_MinBlurSize;    // 0x0C50 (0x0004) [0x0000000000000000]
    float
        DOF_Cinematic_MaxNearBlurSize;   // 0x0C54 (0x0004) [0x0000000000000000]
    float DOF_Cinematic_MaxFarBlurSize;  // 0x0C58 (0x0004) [0x0000000000000000]
    float DOF_Cinematic_ExpFalloff;      // 0x0C5C (0x0004) [0x0000000000000000]
    float DOF_GP_BlendInSpeed;           // 0x0C60 (0x0004) [0x0000000000000000]
    float DOF_GP_BlendOutSpeed;          // 0x0C64 (0x0004) [0x0000000000000000]
    float DOF_GP_FocalDistance;          // 0x0C68 (0x0004) [0x0000000000000000]
    float DOF_GP_SharpRadius;            // 0x0C6C (0x0004) [0x0000000000000000]
    float DOF_GP_FocalRadius;            // 0x0C70 (0x0004) [0x0000000000000000]
    float DOF_GP_MinBlurSize;            // 0x0C74 (0x0004) [0x0000000000000000]
    float DOF_GP_MaxNearBlurSize;        // 0x0C78 (0x0004) [0x0000000000000000]
    float DOF_GP_MaxFarBlurSize;         // 0x0C7C (0x0004) [0x0000000000000000]
    float DOF_GP_ExpFalloff;             // 0x0C80 (0x0004) [0x0000000000000000]
    float BlurStrength;                  // 0x0C84 (0x0004) [0x0000000000000000]
    float BlurBlendInSpeed;              // 0x0C88 (0x0004) [0x0000000000000000]
    float BlurBlendOutSpeed;             // 0x0C8C (0x0004) [0x0000000000000000]
    float BlurLerpControl;               // 0x0C90 (0x0004) [0x0000000000000000]
    class UKFOnlineStatsRead*
        StatsRead;  // 0x0C94 (0x0008) [0x0000000000000000]
    class UKFOnlineStatsWrite*
        StatsWrite;  // 0x0C9C (0x0008) [0x0000000000000000]
    TArray<struct FPlayerNameIdPair>
        RecentlyMetPlayers;  // 0x0CA4 (0x0010) [0x0000000000000000]
    struct FScriptDelegate
        OnLoginComplete;               // 0x0CB4 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x0CB8 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UOnlineGameSettings*
        PendingGameSessionCreateGameSettings;  // 0x0CC4 (0x0008)
                                               // [0x0000000000000000]
    struct FPostWaveReplicationInfo
        PWRI;  // 0x0CCC (0x002C) [0x00000000001A0000]              (
               // CPF_EditConst | CPF_Component )
    class UEphemeralMatchStats*
        MatchStats;                 // 0x0CF8 (0x0008) [0x0000000000000000]
    class UClass* MatchStatsClass;  // 0x0D00 (0x0008) [0x0000000000000000]
    float
        LastUpdateSpectatorActiveTime;  // 0x0D08 (0x0004) [0x0000000000000000]
    float
        UpdateSpectatorActiveInterval;  // 0x0D0C (0x0004) [0x0000000000000000]
    int TargetViewRotationPitch;  // 0x0D10 (0x0004) [0x00000000001B000A] (
                                  // CPF_Const | CPF_ExportObject | CPF_Travel |
                                  // CPF_EditConst | CPF_Component )
    int TargetViewRotationYaw;  // 0x0D14 (0x0004) [0x00000000001C000A] (
                                // CPF_Const | CPF_ExportObject |
                                // CPF_GlobalConfig | CPF_Component )
    struct FsSavedViewTargetInfo
        SavedViewTargetInfo;  // 0x0D18 (0x001C) [0x0000000000000000]
    struct FInterpCurveFloat
        ScoreTargetDistanceCurve;    // 0x0D34 (0x0014) [0x0000000000000000]
    float MaxAimCorrectionDistance;  // 0x0D48 (0x0004) [0x0000000000000000]
    float ForceLookAtPawnTime;       // 0x0D4C (0x0004) [0x0000000000000000]
    class AKFPawn* ForceLookAtPawn;  // 0x0D50 (0x0008) [0x0000000000000000]
    float TrackerXPosition;          // 0x0D58 (0x0004) [0x0000000000000000]
    float TrackerYPosition;          // 0x0D5C (0x0004) [0x0000000000000000]
    float TrackingMapScale;          // 0x0D60 (0x0004) [0x0000000000000000]
    float TrackerSpawnVolumeSizeX;   // 0x0D64 (0x0004) [0x0000000000000000]
    float TrackerSpawnVolumeSizeY;   // 0x0D68 (0x0004) [0x0000000000000000]
    float TrackingMapRange;          // 0x0D6C (0x0004) [0x0000000000000000]
    float NoGoStartTime;             // 0x0D70 (0x0004) [0x0000000000000000]
    struct FScriptDelegate
        __LoginCompleteCallback__Delegate;  // 0x0D74 (0x0010)
                                            // [0x0000000000000000]
    unsigned char UnknownData01[0x4];  // 0x0D78 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3467];

        return pClassPointer;
    };

    void PerformLogout();
    void OnClientTitleDataRead();
    void OnPlayfabLoginComplete();
    void OnCanPlayOnlineCheckForMatchmakingComplete();
    void OnBuyGamePressed();
    void CheckPrivilegesForMultiplayer();
    void OnOSSLoginComplete();
    void StartLogin();
    void LoginCompleteCallback();
    void OnLoginCompleted();
    void HasActiveUserEstablished();
    void CheckForConnectedControllers();
    void OnControllerDisconnectDialogDismissed();
    void ShowControllerDisconnectedDialog();
    void OnControllerChanged();
    void GCF();
    void MotivatePlayerToMove();
    void eventServerSetNoGoActive();
    void SetNoGoActive();
    void SwitchTeam();
    void RequestSwitchTeam();
    void ClearOnlineDelegates();
    void OnAttemptPassword();
    void eventDestroyOnlineGame();
    void eventNotifyDisconnect();
    void eventShowConnectionProgressPopup();
    void CanDisconnect();
    void ForceDisconnect();
    void ItemExchangeTimeOut();
    void DoEmote();
    void PlayVoiceCommsDialog();
    void ServerPlayVoiceCommsDialog();
    void ServerPlayLevelUpDialog();
    void PlayTraderSelectItemDialog();
    void ClientPlayTraderDialog();
    void PlayTraderDialog();
    void CheckForZedOnDeathAchievements();
    void NotifyKilled();
    void eventClientHearDialog();
    void ReceiveTopWeapons();
    void ClientReceiveAwardInfo();
    void GetPersonalBest();
    void SavePersonalBest();
    void SubmitPostWaveStats();
    void ServerViewPrevPlayer();
    void ServerViewNextPlayer();
    void TryViewNextPlayer();
    void ServerViewSelf();
    void SpectateRoaming();
    void SpectatePlayer();
    void ServerNextSpectateMode();
    void eventClientSetViewTarget();
    void NotifyChangeSpectateViewTarget();
    void MoveToValidSpectatorLocation();
    void ServerSetSpectatorActive();
    void NextSpectateMode();
    void StartSpectate();
    void eventDestroyed();
    void DrawNextSpawnTimeInfo();
    void DrawDebugConductor();
    void DrawMapElement();
    void DrawDebugMap();
    void DrawDebugSpawning();
    void DrawNextDebugLine();
    void DrawDebugDifficulty();
    void DrawDebugMemory();
    void DisplayDebug();
    void LogOutBugItAIGoToLogFile();
    void UnlockHoldOut();
    void UpdateBenefactor();
    void eventOnAllMapCollectiblesFound();
    void eventOnMapCollectibleFound();
    void ClientNotifyCheats();
    void ServerEnableCheats();
    void EnableCheats();
    void LogStats();
    void GetBenefactorDoshReq();
    void ResetStats();
    void ClientAddHealPoints();
    void AddHealPoints();
    void ClientDoorRepaired();
    void DoorRepaired();
    void ClientAddWeldPoints();
    void AddWeldPoints();
    void ClientAddSmallRadiusKill();
    void AddSmallRadiusKill();
    void eventOnPlayerXPAdded();
    void eventClientAddPlayerXP();
    void ClientAddZedHeadshot();
    void AddZedHeadshot();
    void ClientAddZedKill();
    void AddZedKill();
    void eventGetPerkLevelFromPerkList();
    void GetPerkLevelProgressPercentage();
    void eventClientUnlockAchievement();
    void ClientCompletedWeeklySurvival();
    void CompletedWeeklySurvival();
    void IsValidWeeklySurvivalMatch();
    void GetMapSpecialEventIndex();
    void IsValidSpecialEventMap();
    void CheckForEventMapCompletion();
    void eventClientFinishedSpecialEvent();
    void FinishedSpecialEvent();
    void ClientRoundEnded();
    void ClientWonGame();
    void ClientWriteAndFlushStats();
    void OnStatsInitialized();
    void ReadStats();
    void SetStatsReadOwningPlayerId();
    void LogStatValue();
    void eventInitializeStats();
    void LogPerkBuilds();
    void GiveXP();
    void GetPerkBuildByPerkClass();
    void GetPerkXP();
    void IsEventObjectiveComplete();
    void IsWeeklyEventComplete();
    void SetUIScale();
    void changeSafeFrame();
    void PerformedUseAction();
    void ServerPause();
    void OnExternalUIChanged();
    void SetPause();
    void ClientPauseWwise();
    void PauseWwiseForAllPlayers();
    void PlayEcho();
    void PlayDirectionalEcho();
    void HearEchoes();
    void ProcessAdvancedHearSound();
    void eventClientHearSoundAdvancedRelevant();
    void eventClientHearSoundAdvanced();
    void eventWwiseClientHearSound();
    void GetPooledAkComponent();
    void SetObjeciveUIIcon();
    void UpdateObjectiveUIProgress();
    void SetObjectiveUIActive();
    void UpdateRhythmCounterWidget();
    void ClosePostGameMenu();
    void ClientShowPostGameMenu();
    void ClosePostRoundSummary();
    void ClientOpenRoundSummary();
    void NotifyTraderDoshChanged();
    void CloseTraderMenu();
    void ClientOpenTraderMenu();
    void OpenTraderMenu();
    void ServerSetEnablePurchases();
    void DoAutoPurchase();
    void GetPurchaseHelper();
    void StartAltFire();
    void StartFire();
    void ClientSetOnlineStatus();
    void ClientResetCountdown();
    void ClientSetCountdown();
    void TeamTalk();
    void Talk();
    void OpenChatBox();
    void RecieveChatMessage();
    void GetChatChannel();
    void eventTeamMessage();
    void ServerTeamSay();
    void ServerSay();
    void OnPS4AvatarDownloadComplete();
    void OnAvatarURLPS4Received();
    void GetPS4Avatar();
    void OnAvatarReceived();
    void GetSteamAvatar();
    void OnLobbyStatusChanged();
    void NotifyUnsuccessfulSearch();
    void SkipLobby();
    void ClientSetFrontEnd();
    void HideBossNamePlate();
    void ShowBossNameplate();
    void SetGFxHUD();
    void ClientRecieveNewTeam();
    void ServerNotifyTeamChanged();
    void ClientFadeOutZedTime();
    void ClientEnterZedTime();
    void FadeOutZedTime();
    void EnterZedTime();
    void IsAffectedByZedTime();
    void eventNotifyPartialZedTimeExited();
    void StartPartialZedTimeSightCounter();
    void CanSeeZedTimePawn();
    void ClientSetCinematicMode();
    void SetNightVision();
    void SetAmplificationLightEnabled();
    void ToggleHealthEffects();
    void UpdateLowHealthEffect();
    void UpdateEarRingEffect();
    void PlayEarRingEffect();
    void UpdateZEDTimeEffects();
    void SetZedTimeEffectIntensity();
    void UpdateScreenEffect();
    void ShouldDisplayGameplayPostProcessFX();
    void ResetGameplayPostProcessFX();
    void InitGameplayPostProcessFX();
    void SetPerkEffect();
    void SetGrabEffect();
    void eventPlayerTick();
    void GetEffectTimeRemaining();
    void CheckForReducedSirenScreamEffect();
    void PlayScreenMaterialEffects();
    void PlayScreenEffects();
    void PlayScreenHitFX();
    void CheckCurrentUsableActor();
    void UpdateInteractionMessages();
    void UpdatePendingInteractionMessage();
    void SetPendingInteractionMessage();
    void eventReceiveLocalizedMessage();
    void GetTriggerUseList();
    void TriggerInteracted();
    void GetCurrentUsableActor();
    void AimingHelp();
    void StartAutoTargeting();
    void ModifyUpdateRotation();
    void SetForceLookAtPawn();
    void GetServerMoveDeltaTime();
    void CallServerMove();
    void DualServerMove();
    void ServerMove();
    void TickPauseMoveInput();
    void PauseMoveInput();
    void CheckJumpOrDuck();
    void HandleWalking();
    void ServerThrowOtherWeapon();
    void ProcessAimCorrection();
    void GetAdjustedAimFor();
    void SwitchToBestWeapon();
    void GetPickedAimAtTarget();
    void PickAimAtTarget();
    void eventClientWasKicked();
    void ServerAdmin();
    void Admin();
    void ServerAdminLogOut();
    void AdminLogout();
    void ServerAdminLogin();
    void AdminLogin();
    void AdminCmdOk();
    void DoForceFeedbackForScreenShake();
    void ClientPlayCameraShake();
    void ResetCustomizationCamera();
    void Camera();
    void EnableReflections();
    void EnableIronSights();
    void EnableBlur();
    void ClientCustomDepthOfField();
    void ClientEnableDepthOfField();
    void EnableDepthOfField();
    void eventResetCameraMode();
    void SetBossCamera();
    void ProcessViewRotation();
    void LandingShake();
    void MoveToAdjustedFreeCamPosition();
    void SetCameraMode();
    void GetBoss();
    void IsEmoteCameraMode();
    void IsBossCameraMode();
    void ClientSetCameraMode();
    void ResetFOV();
    void FixFOV();
    void CalcFOVForAspectRatio();
    void NotifyResolutionChanged();
    void HandleTransitionFOV();
    void HandleTransitionFOVAspectAdjusted();
    void ToggleScreenShotMode();
    void ShowTestDownloadNotification();
    void UpdateFullscreenBlur();
    void UpdateDOFIronSightsLerpControl();
    void UpdateDOFGamePlayLerpControl();
    void UpdateDOF();
    void CameraAnimHasEnoughSpace();
    void ChooseRandomCameraAnim();
    void SetViewTarget();
    void RecievedNewPerkClass();
    void PlayRMEffect();
    void eventGetPerkIndexFromClass();
    void PostTierUnlock();
    void NotifyLevelUp();
    void NotifyXPGain();
    void eventNotifyPerkUpdated();
    void eventNotifyPendingPerkChanges();
    void eventSetHaveUpdatePerk();
    void Timer_CheckForValidPerk();
    void WaitForPerkAndRespawn();
    void eventUpdatePerkLevelMenu();
    void ServerCallOutPawnCloaking();
    void GetPerkName();
    void ApplyPendingPerks();
    void eventWasPerkUpdatedThisRound();
    void CanUpdatePerkInfo();
    void eventServerSelectPerk();
    void eventServerSetSavedPerkIndex();
    void eventServerSetPendingPerkUpdate();
    void eventRequestPerkChange();
    void eventClientSetLevelCheat();
    void eventServerSetLevel();
    void SetActivePerkLevel();
    void GetLevel();
    void ReadStatsTimeout();
    void LoadAllPerkLevels();
    void ResetPerkStatsLoaded();
    void ClientInitializePerks();
    void IsForceFeedbackAllowed();
    void ClientSetIgnoreButtons();
    void SetCinematicMode();
    void ServerNotifyRegisteredAsLocalTalker();
    void ClientStopNetworkedVoice();
    void ClientStartNetworkedVoice();
    void OnPlayerTalking();
    void RegisterTalkerDelegate();
    void AddHeadHit();
    void AddShotsHit();
    void AddShotsFired();
    void NotifyPlayTogetherFailed();
    void OnCreateGameSessionForPlayTogetherComplete();
    void TryMainMenuPlayTogether();
    void OnGameDestroyedForPlayTogetherComplete();
    void OnLoginForPlayTogetherComplete();
    void TryAutoLoginForPlayTogether();
    void OnPlayTogetherStarted();
    void NotifyInviteFailed();
    void JoinPlayfabServer();
    void OnSessionJoinComplete();
    void OnGameDestroyedForInviteComplete();
    void OnLoginForGameInviteComplete();
    void TryAutoLoginForInvite();
    void OnGameInviteAccepted();
    void eventPreClientTravel();
    void OnJoinGameSessionComplete();
    void JoinGameSessionNow();
    void OnOldSessionDestroyedForNewGameSessionJoin();
    void TryJoinGameSession();
    void ServerGameSessionFailed();
    void ServerGameSessionCreated();
    void OnGameSessionCreateComplete();
    void TryCreateGameSessionNow();
    void OnOldSessionDestroyedForNewGameSessionCreate();
    void ClientCreateGameSession();
    void HandleConsoleSessions();
    void HandleReconnected();
    void HandleNetworkError();
    void HandleLoginStatusChange();
    void HandleConnectionStatusChange();
    void OnReadProfileSettingsComplete();
    void TestRegionQuery();
    void ShowBestRegionSelectedPopup();
    void RegisterOnlineDelegates();
    void ReturnToViewTarget();
    void SpawnMidGameCustomizationPawn();
    void GetBestCustomizationStart();
    void CreateCustomizationPawn();
    void eventInitInputSystem();
    void ResetPlayerMovementInput();
    void CanViewCinematics();
    void IsReadyToPlay();
    void CanRestartPlayer();
    void SpawnReconnectedPlayer();
    void ListConsoleEvents();
    void PawnDied();
    void ClientRestart();
    void eventPossess();
    void ReceivedGameClass();
    void AskForPawn();
    void eventReceivedPlayer();
    void eventReplicatedEvent();
    void eventGetSeasonalStateName();
    void ClearDownloadInfo();
    void eventUpdateSeasonalState();
    void CheckWeeklyEventID();
    void CheckSpecialEventID();
    void eventPostBeginPlay();
    void ShowPreClientTravelMovie();
    void eventPushPlayerStats();
    void GetPerk();
    void CheckBulletWhip();
    void GetTargetAdhesionFrictionTarget();
    void IsMouseAvailable();
    void IsKeyboardAvailable();
    void SyncInventoryProperties();
    void SetHardwarePhysicsEnabled();
};

UClass* AKFPlayerController::pClassPointer = NULL;

// Class KFGame.KFPlayerController_WeeklySurvival
// 0x0014 (0x0D98 - 0x0D84)
class AKFPlayerController_WeeklySurvival : public AKFPlayerController {
   public:
    DWORD bUsingPermanentZedTime : 1;  // 0x0D84 (0x0004) [0x00000000001D0000]
                                       // [0x00000001] ( CPF_Travel |
                                       // CPF_GlobalConfig | CPF_Component )
    float ZedTimeRadius;  // 0x0D88 (0x0004) [0x00000000001E0000]              (
                          // CPF_EditConst | CPF_GlobalConfig | CPF_Component )
    float ZedTimeBossRadius;  // 0x0D8C (0x0004) [0x00000000001F0000] (
                              // CPF_Travel | CPF_EditConst | CPF_GlobalConfig |
                              // CPF_Component )
    float ZedTimeHeight;   // 0x0D90 (0x0004) [0x0000000000200000]
    float ZedRecheckTime;  // 0x0D94 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3469];

        return pClassPointer;
    };

    void RecheckZedTime();
    void EnterZedTime();
};

UClass* AKFPlayerController_WeeklySurvival::pClassPointer = NULL;

// Class KFGame.KFPlayerInput
// 0x0164 (0x06B0 - 0x054C)
class UKFPlayerInput : public UMobilePlayerInput {
   public:
    DWORD bRequiresPushToTalk : 1;       // 0x054C (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bQuickWeaponSelect : 1;        // 0x054C (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bIronsightsHeld : 1;           // 0x054C (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD bGamePadWeaponSelectOpen : 1;  // 0x054C (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    DWORD
        bShowGamepadWeaponSelectHint : 1;  // 0x054C (0x0004)
                                           // [0x0000000000000000] [0x00000010]
    DWORD bInvertController : 1;         // 0x054C (0x0004) [0x0000000000000000]
                                         // [0x00000020]
    DWORD bUseGamepadLastWeapon : 1;     // 0x054C (0x0004) [0x0000000000000000]
                                         // [0x00000040]
    DWORD bExtendedSprinting : 1;        // 0x054C (0x0004) [0x0000000000000000]
                                         // [0x00000080]
    DWORD bAimAssistEnabled : 1;         // 0x054C (0x0004) [0x0000000000000000]
                                         // [0x00000100]
    DWORD bViewSmoothingEnabled : 1;     // 0x054C (0x0004) [0x0000000000000000]
                                         // [0x00000200]
    DWORD bViewAccelerationEnabled : 1;  // 0x054C (0x0004) [0x0000000000000000]
                                         // [0x00000400]
    DWORD bDebugViewAcceleration : 1;    // 0x054C (0x0004) [0x0000000000000000]
                                         // [0x00000800]
    DWORD bTargetFrictionEnabled : 1;    // 0x054C (0x0004) [0x0000000000000000]
                                         // [0x00001000]
    DWORD bDebugTargetFriction : 1;      // 0x054C (0x0004) [0x0000000000000000]
                                         // [0x00002000]
    DWORD bTargetAdhesionEnabled : 1;    // 0x054C (0x0004) [0x0000000000000000]
                                         // [0x00004000]
    DWORD bAutoTargetEnabled : 1;        // 0x054C (0x0004) [0x0000000000000000]
                                         // [0x00008000]
    DWORD bForceFeedbackEnabled : 1;     // 0x054C (0x0004) [0x0000000000000000]
                                         // [0x00010000]
    DWORD
        bVersusInput : 1;  // 0x054C (0x0004) [0x0000000000000000] [0x00020000]
    DWORD bUsingVersusGamepadScheme : 1;  // 0x054C (0x0004)
                                          // [0x0000000000000000] [0x00040000]
    float PressedJumpTime;               // 0x0550 (0x0004) [0x0000000000000000]
    float GamepadButtonHoldTime;         // 0x0554 (0x0004) [0x0000000000000000]
    float SprintAnalogThreshold;         // 0x0558 (0x0004) [0x0000000000000000]
    float ZedAutoSprintAnalogThreshold;  // 0x055C (0x0004) [0x0000000000000000]
    float GamepadSprintAnalogStart;      // 0x0560 (0x0004) [0x0000000000000000]
    int CurrentLayoutIndex;              // 0x0564 (0x0004) [0x0000000000000000]
    float RawJoyMagnitude;               // 0x0568 (0x0004) [0x0000000000000000]
    float RawJoyLookMagnitude;           // 0x056C (0x0004) [0x0000000000000000]
    struct FInterpCurveFloat
        LookSensitivityScaleCurve;  // 0x0570 (0x0014) [0x0000000000000000]
    struct FInterpCurveFloat
        MoveSensitivityScaleCurve;    // 0x0584 (0x0014) [0x0000000000000000]
    float GamepadSensitivityScale;    // 0x0598 (0x0004) [0x0000000000000000]
    float SprintingSensitivityScale;  // 0x059C (0x0004) [0x0000000000000000]
    float ZoomedSensitivityScale;     // 0x05A0 (0x0004) [0x0000000000000000]
    float
        GamepadZoomedSensitivityScale;  // 0x05A4 (0x0004) [0x0000000000000000]
    float ViewSmoothing_MaxAccel;       // 0x05A8 (0x0004) [0x0000000000000000]
    float ViewSmoothing_MaxDecel;       // 0x05AC (0x0004) [0x0000000000000000]
    float PrevTurn;                     // 0x05B0 (0x0004) [0x0000000000000000]
    float PrevLookUp;                   // 0x05B4 (0x0004) [0x0000000000000000]
    float CurrTurn;                     // 0x05B8 (0x0004) [0x0000000000000000]
    float CurrLookUp;                   // 0x05BC (0x0004) [0x0000000000000000]
    float ViewAccel_JoyMagThreshold;    // 0x05C0 (0x0004) [0x0000000000000000]
    float ViewAccel_JoyPitchThreshold;  // 0x05C4 (0x0004) [0x0000000000000000]
    float ViewAccel_MaxTurnSpeed;       // 0x05C8 (0x0004) [0x0000000000000000]
    float ViewAccel_BlendTime;          // 0x05CC (0x0004) [0x0000000000000000]
    float ViewAccel_BlendTimer;         // 0x05D0 (0x0004) [0x0000000000000000]
    float RemainingaTurn;               // 0x05D4 (0x0004) [0x0000000000000000]
    float RemainingaLookUp;             // 0x05D8 (0x0004) [0x0000000000000000]
    float FrictionScale;                // 0x05DC (0x0004) [0x0000000000000000]
    class APawn* LastFrictionTarget;    // 0x05E0 (0x0008) [0x0000000000000000]
    float LastFrictionTargetTime;       // 0x05E8 (0x0004) [0x0000000000000000]
    float LastaTurn;                    // 0x05EC (0x0004) [0x0000000000000000]
    float LastaLookUp;                  // 0x05F0 (0x0004) [0x0000000000000000]
    float LastaForward;                 // 0x05F4 (0x0004) [0x0000000000000000]
    float LastaStrafe;                  // 0x05F8 (0x0004) [0x0000000000000000]
    struct FInterpCurveFloat
        FrictionAngleCurve;  // 0x05FC (0x0014) [0x0000000000000000]
    float
        ViewAccelerationFrictionScale;  // 0x0610 (0x0004) [0x0000000000000000]
    struct FInterpCurveFloat
        AdhesionAngleCurve;           // 0x0614 (0x0014) [0x0000000000000000]
    float AdhesionFactor;             // 0x0628 (0x0004) [0x0000000000000000]
    class APawn* LastAdhesionTarget;  // 0x062C (0x0008) [0x0000000000000000]
    struct FVector
        AdhesionTargetLastLoc;           // 0x0634 (0x000C) [0x0000000000000000]
    struct FVector AdhesionPawnLastLoc;  // 0x0640 (0x000C) [0x0000000000000000]
    float AutoTargetTimeLeft;            // 0x064C (0x0004) [0x0000000000000000]
    struct FVector
        AutoTargetInitialLocation;       // 0x0650 (0x000C) [0x0000000000000000]
    class APawn* CurrentAutoTarget;      // 0x065C (0x0008) [0x0000000000000000]
    struct FName CurrentAutoTargetBone;  // 0x0664 (0x0008) [0x0000000000000000]
    float AutoTargetRotationRate;        // 0x066C (0x0004) [0x0000000000000000]
    struct FInterpCurveFloat
        AutoTargetAngleCurve;  // 0x0670 (0x0014) [0x0000000000000000]
    struct FInterpCurveFloat
        AutoTargetWeakspotCurve;        // 0x0684 (0x0014) [0x0000000000000000]
    float AutoTargetCooldown;           // 0x0698 (0x0004) [0x0000000000000000]
    float LastAutoTargetTime;           // 0x069C (0x0004) [0x0000000000000000]
    float ForceLookAtPawnMinAngle;      // 0x06A0 (0x0004) [0x0000000000000000]
    float ForceLookAtPawnRotationRate;  // 0x06A4 (0x0004) [0x0000000000000000]
    float ForceLookAtPawnDampenedRotationRate;  // 0x06A8 (0x0004)
                                                // [0x0000000000000000]
    float DoubleTapDelay;  // 0x06AC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3471];

        return pClassPointer;
    };

    void UnsuppressScoring();
    void SuppressScoring();
    void UnsuppressWaveSpawnLogging();
    void SuppressWaveSpawnLogging();
    void UnsuppressAISpawnLogging();
    void SuppressAISpawnLogging();
    void UnsuppressPerk();
    void SuppressPerk();
    void UnsuppressMelee();
    void SuppressMelee();
    void UnsuppressWeaponAnim();
    void SuppressWeaponAnim();
    void UnsuppressAffliction();
    void SuppressAffliction();
    void UnsuppressWeaponAttach();
    void SuppressWeaponAttach();
    void UnsuppressPawnAnim();
    void SuppressPawnAnim();
    void UnsuppressSpecialMove();
    void SuppressSpecialMove();
    void UnsuppressPhysicsBodyImpact();
    void SuppressPhysicsBodyImpact();
    void UnsuppressTakeDamage();
    void SuppressTakeDamage();
    void JumpVersus();
    void QuickHealVersus();
    void CustomStopFireVersus();
    void CustomStartFireVersus();
    void GetVersusZedMoveTypeGamepad();
    void GetVersusZedMoveType();
    void IsAimAssistAutoTargetEnabled();
    void IsAimAssistAdhesionEnabled();
    void IsAimAssistFrictionEnabled();
    void DebugTargetFriction();
    void DebugAutoTarget();
    void DebugTargetAdhesion();
    void DebugViewAcceleration();
    void GetSensitivityByFOV();
    void GetAimAssistViewOffsetFromTarget();
    void ApplyTargetFriction();
    void ApplyTargetAdhesion();
    void IsPawnSprinting();
    void ApplyForceLookAtPawn();
    void ApplyAutoTarget();
    void IsAutoTargetWithinCone();
    void GetBestAutoTargetLocation();
    void InitAutoTarget();
    void ApplyViewSmoothing();
    void ApplyingViewAcceleration();
    void CanApplyViewAcceleration();
    void ApplyViewAcceleration();
    void IsDirectingJoyStick();
    void UpdateExtendedSprint();
    void PreProcessGamepadInput();
    void PreProcessInput();
    void StopVoiceChat();
    void StartVoiceChat();
    void InteractTimer();
    void InteractRelease();
    void Interact();
    void OnVoteNoRelease();
    void OnVoteNoPressed();
    void OnVoteYesRelease();
    void OnVoteYesPressed();
    void HideVoiceComms();
    void ShowVoiceComms();
    void ChangeZedCamera();
    void GamepadDpadUp();
    void GamepadDpadRight();
    void GamepadDpadDown();
    void GamepadDpadLeft();
    void TossMoney();
    void QuickHeal();
    void QuickEmote();
    void SwitchWeaponGroup();
    void GamepadWeaponMenuTimer();
    void CheckForWeaponMenuTimerInterrupt();
    void ReleaseGamepadWeaponSelect();
    void GamepadWeaponSelect();
    void SelectLastWeapon();
    void SelectPrevWeapon();
    void SelectNextWeapon();
    void SwitchFireRelease();
    void SwitchFire();
    void CustomStopFire();
    void CustomStartFire();
    void InternalToggleNightVision();
    void InternalToggleFlashlight();
    void FlashlightTimer();
    void FlashlightRelease();
    void ToggleFlashlight();
    void IronSightsRelease();
    void IronSights();
    void ToggleCrouch();
    void StopCrouch();
    void StartCrouch();
    void Jump();
    void GamepadSwitchFire();
    void GamepadJumpTimer();
    void GamepadJumpRelease();
    void GamepadJump();
    void GamepadCrouchTimer();
    void GamepadCrouchRelease();
    void GamepadCrouch();
    void GamepadReloadTimer();
    void GamepadReloadRelease();
    void GamepadReload();
    void ShouldActivateGamepadSprint();
    void GetLeftAnalogDistance();
    void GamepadSprintRelease();
    void GamepadSprintTimer();
    void GamepadSprint();
    void SwapPositions();
    void BindKey();
    void eventReInitializeControlsUI();
    void AdjustMouseSensitivity();
    void eventPlayerInput();
    void CheckForDoubleClickMove();
    void SetZoomedSensitivity();
    void SetSensitivity();
    void UpdatePushToTalk();
    void ClientInitInputSystem();
    void DisplayDebug();
    void eventFilterButtonInput();
    void GetGameBindableAction();
    void GetBindDisplayName();
    void SetGamepadLayout();
    void ResetKeysToDefault();
    void GetBindingsIndex();
    void RemoveCommandFromBind();
    void SetKeyBind();
    void SwapBind();
    void GetKeyBindFromCommand();
};

UClass* UKFPlayerInput::pClassPointer = NULL;

// Class KFGame.KFExplosionLight
// 0x0010 (0x0070 - 0x0060)
class UKFExplosionLight : public UObject {
   public:
    TArray<struct FLightValues>
        TimeShift;  // 0x0060 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3473];

        return pClassPointer;
    };
};

UClass* UKFExplosionLight::pClassPointer = NULL;

// Class KFGame.KFExplosionLightComponent
// 0x0024 (0x0290 - 0x026C)
class UKFExplosionLightComponent : public UPointLightComponent {
   public:
    class UKFExplosionLight* Template;  // 0x026C (0x0008) [0x0000000000000000]
    DWORD
        bInitialized : 1;  // 0x0274 (0x0004) [0x0000000000000000] [0x00000001]
    float Lifetime;        // 0x0278 (0x0004) [0x0000000000000000]
    int TimeShiftIndex;    // 0x027C (0x0004) [0x0000000000000000]
    struct FScriptDelegate
        __OnLightFinished__Delegate;   // 0x0280 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x0284 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3475];

        return pClassPointer;
    };

    void OnLightFinished();
    void ResetLight();
    void SetTemplate();
};

UClass* UKFExplosionLightComponent::pClassPointer = NULL;

// Class KFGame.KFFlashlightAttachment
// 0x0054 (0x00B4 - 0x0060)
class UKFFlashlightAttachment : public UObject {
   public:
    class USkeletalMeshComponent*
        OwnerMesh;       // 0x0060 (0x0008) [0x0000000000000000]
    DWORD bEnabled : 1;  // 0x0068 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bLightInitialized : 1;  // 0x0068 (0x0004) [0x0000000000000000]
                                  // [0x00000002]
    DWORD bDebug : 1;  // 0x0068 (0x0004) [0x0000000000000000] [0x00000004]
    class USpotLightComponent*
        LightTemplate;                 // 0x006C (0x0008) [0x0000000000000000]
    class USpotLightComponent* Light;  // 0x0074 (0x0008) [0x0000000000000000]
    class UStaticMesh* LightConeMesh;  // 0x007C (0x0008) [0x0000000000000000]
    class UStaticMeshComponent*
        LightConeMeshComp;              // 0x0084 (0x0008) [0x0000000000000000]
    class UStaticMesh* AttachmentMesh;  // 0x008C (0x0008) [0x0000000000000000]
    class UStaticMeshComponent*
        AttachmentMeshComp;             // 0x0094 (0x0008) [0x0000000000000000]
    struct FName FlashlightSocketName;  // 0x009C (0x0008) [0x0000000000000000]
    float TeammateSwitchRadius;         // 0x00A4 (0x0004) [0x0000000000000000]
    float TeammateSwitchTimer;          // 0x00A8 (0x0004) [0x0000000000000000]
    float MaxAIWarningDistSQ;           // 0x00AC (0x0004) [0x0000000000000000]
    float MaxAIWarningDistFromPointSQ;  // 0x00B0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3477];

        return pClassPointer;
    };

    void ChooseBestFlashlight();
    void ChooseBestFlashlightTimer();
    void UpdateFlashlightFor();
    void SetFirstPersonVisibility();
    void IsOwnerFirstPerson();
    void SetLightingChannels();
    void OwnerDied();
    void AttachFlashlightComponent();
    void InitializeLight();
    void Timer_WarnAI();
    void SetEnabled();
    void DetachFlashlight();
    void Reattach();
    void AttachFlashlight();
};

UClass* UKFFlashlightAttachment::pClassPointer = NULL;

// Class KFGame.KFFracturedMeshActor
// 0x0034 (0x030C - 0x02D8)
class AKFFracturedMeshActor : public AFracturedStaticMeshActor {
   public:
    unsigned char ReplicationMode;       // 0x02D8 (0x0001) [0x0000000000000000]
    unsigned char VulnerableMultiplier;  // 0x02D9 (0x0001) [0x0000000000000000]
    int TotalHealth;                     // 0x02DC (0x0004) [0x0000000000000000]
    int DefaultTotalHealth;              // 0x02E0 (0x0004) [0x0000000000000000]
    struct FMaterialLightParamMod
        MaterialLightParams;             // 0x02E4 (0x0014) [0x0000000000000000]
    DWORD bSpawnPartsWhenDestroyed : 1;  // 0x02F8 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bHasBeenDestroyed : 1;         // 0x02F8 (0x0004) [0x0000000000150000]
                                         // [0x00000002] ( CPF_Travel |
                                         // CPF_GlobalConfig )
    DWORD
        bHasLostChunk : 1;  // 0x02F8 (0x0004) [0x0000000000160000] [0x00000004]
                            // ( CPF_EditConst | CPF_GlobalConfig )
    TArray<class UClass*>
        VulnerableDamageType;  // 0x02FC (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3479];

        return pClassPointer;
    };

    void Reset();
    void SimulateRemoteHit();
    void PlayBreakOffAllParticles();
    void eventBreakOffPartsInRadius();
    void BreakOffAllFragments();
    void eventSetLoseChunkReplacementMaterial();
    void FractureEffectIsRelevant();
    void IsVulnerableTo();
    void eventTakeDamage();
    void eventPreBeginPlay();
    void eventReplicatedEvent();
};

UClass* AKFFracturedMeshActor::pClassPointer = NULL;

// Class KFGame.KFFracturedMeshGlass
// 0x0010 (0x031C - 0x030C)
class AKFFracturedMeshGlass : public AKFFracturedMeshActor {
   public:
    int DestroyOnBumpThreshold;    // 0x030C (0x0004) [0x0000000000000000]
    DWORD bInstiKillOnAIBump : 1;  // 0x0310 (0x0004) [0x0000000000000000]
                                   // [0x00000001]
    DWORD bTickMaterialParam : 1;  // 0x0310 (0x0004) [0x0000000000000000]
                                   // [0x00000002]
    class UMaterialInstanceConstant*
        MIC;  // 0x0314 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3481];

        return pClassPointer;
    };

    void TakeRadiusDamage();
    void StopsProjectile();
    void eventBump();
    void eventTakeDamage();
    void eventPostBeginPlay();
    void eventPreBeginPlay();
};

UClass* AKFFracturedMeshGlass::pClassPointer = NULL;

// Class KFGame.KFGoreManager
// 0x00A8 (0x02EC - 0x0244)
class AKFGoreManager : public AActor {
   public:
    int DesiredGoreLevel;            // 0x0244 (0x0004) [0x0000000000000000]
    float GoreFXLifetimeMultiplier;  // 0x0248 (0x0004) [0x0000000000000000]
    float BodyWoundDecalLifetime;    // 0x024C (0x0004) [0x0000000000000000]
    float BloodSplatterLifetime;     // 0x0250 (0x0004) [0x0000000000000000]
    float BloodPoolLifetime;         // 0x0254 (0x0004) [0x0000000000000000]
    float GibletLifetime;            // 0x0258 (0x0004) [0x0000000000000000]
    float BloodSplatSize;            // 0x025C (0x0004) [0x0000000000000000]
    float BloodPoolSize;             // 0x0260 (0x0004) [0x0000000000000000]
    int MaxBodyWoundDecals;          // 0x0264 (0x0004) [0x0000000000000000]
    int MaxBloodSplatterDecals;      // 0x0268 (0x0004) [0x0000000000000000]
    int MaxBloodPoolDecals;          // 0x026C (0x0004) [0x0000000000000000]
    DWORD bAllowBloodSplatterDecals : 1;   // 0x0270 (0x0004)
                                           // [0x0000000000000000] [0x00000001]
    DWORD bShowPersistentBloodTraces : 1;  // 0x0270 (0x0004)
                                           // [0x0000000000000000] [0x00000002]
    DWORD bLogGore : 1;  // 0x0270 (0x0004) [0x0000000000000000] [0x00000004]
    class ADecalManager*
        BodyWoundDecalManager;  // 0x0274 (0x0008) [0x0000000000000000]
    class ADecalManager*
        BloodSplatterDecalManager;  // 0x027C (0x0008) [0x0000000000000000]
    class ADecalManager*
        BloodPoolDecalManager;  // 0x0284 (0x0008) [0x0000000000000000]
    int MaxBloodEffects;        // 0x028C (0x0004) [0x0000000000000000]
    int MaxGoreEffects;         // 0x0290 (0x0004) [0x0000000000000000]
    class AEmitterPool*
        BloodFXEmitterPool;  // 0x0294 (0x0008) [0x0000000000000000]
    class AEmitterPool*
        MiscGoreFXEmitterPool;          // 0x029C (0x0008) [0x0000000000000000]
    TArray<class AKFPawn*> CorpsePool;  // 0x02A4 (0x0010) [0x0000000000000000]
    int MaxDeadBodies;                  // 0x02B4 (0x0004) [0x0000000000000000]
    float MaxCorpseOffscreenTime;       // 0x02B8 (0x0004) [0x0000000000000000]
    float MaxCorpseOffscreenDistance;   // 0x02BC (0x0004) [0x0000000000000000]
    float PersistentSplatTraceLength;   // 0x02C0 (0x0004) [0x0000000000000000]
    int MaxPersistentSplatsPerFrame;    // 0x02C4 (0x0004) [0x0000000000000000]
    TArray<struct FPersistentSplatInfo>
        CurrentSplats;    // 0x02C8 (0x0010) [0x0000000000000000]
    int CurrentSplatIdx;  // 0x02D8 (0x0004) [0x0000000000000000]
    TArray<class UTWSplatterMapTexture2D*>
        CachedSplattermaps;  // 0x02DC (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3483];

        return pClassPointer;
    };

    void eventReset();
    void ResetPersistantGore();
    void AddCorpse();
    void DeleteCorpse();
    void RemoveAndDeleteCorpse();
    void RateCorpse();
    void MakeRoomForCorpse();
    void CauseObliteration();
    void SpawnObliterationBloodEffect();
    void SpawnGiblet();
    void CauseGibsAndApplyImpulse();
    void CauseDismemberment();
    void ConditionalApplyPartialGore();
    void CrushBone();
    void BreakConstraint();
    void AttachMutilationBloodEffects();
    void AllowHeadless();
    void AllowMutilation();
    void LeaveABloodPoolDecal();
    void GetTimeBetweenGibBloodSplats();
    void LeaveABloodSplatterDecal();
    void CausePersistentBlood();
    void FlushPersistentBloodSplats();
    void CacheCurrentSplattermaps();
    void ClearPersistentBloodSplats();
    void PerformTraceAndUpdateSplattermap();
    void LeaveAPersistentBloodSplat();
    void LeaveABodyWoundDecal();
    void eventPostBeginPlay();
};

UClass* AKFGoreManager::pClassPointer = NULL;

// Class KFGame.KFImpactEffectManager
// 0x0048 (0x028C - 0x0244)
class AKFImpactEffectManager : public AActor {
   public:
    class UKFImpactEffectInfo*
        DefaultImpactEffects;         // 0x0244 (0x0008) [0x0000000000000000]
    float MaxImpactEffectDistance;    // 0x024C (0x0004) [0x0000000000000000]
    float MaxDecalRangeSq;            // 0x0250 (0x0004) [0x0000000000000000]
    DWORD bAlignToSurfaceNormal : 1;  // 0x0254 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bSuppressSounds : 1;        // 0x0254 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    int MaxImpactEffectDecals;        // 0x0258 (0x0004) [0x0000000000000000]
    class ADecalManager*
        ImpactEffectDecalManager;  // 0x025C (0x0008) [0x0000000000000000]
    class UAkEvent*
        MostRecentImpactSound;  // 0x0264 (0x0008) [0x0000000000000000]
    struct FVector
        MostRecentImpactLocation;  // 0x026C (0x000C) [0x0000000000000000]
    float MostRecentImpactTime;    // 0x0278 (0x0004) [0x0000000000000000]
    int NumDuplicateImpactSounds;  // 0x027C (0x0004) [0x0000000000000000]
    float
        MinRepeatImpactSoundDistanceSq;  // 0x0280 (0x0004) [0x0000000000000000]
    float MinRepeatImpactSoundInterval;  // 0x0284 (0x0004) [0x0000000000000000]
    int MaxDuplicateImpactSounds;        // 0x0288 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3485];

        return pClassPointer;
    };

    void PlayMeleeImpact();
    void AllowImpactEffects();
    void GetImpactEffect();
    void ShouldExtendDecalThickness();
    void SpawnImpactDecal();
    void CheckBulletWhip();
    void PlayImpactSound();
    void ShouldPlayImpactSound();
    void PlayImpactEffects();
    void eventPostBeginPlay();
};

UClass* AKFImpactEffectManager::pClassPointer = NULL;

// Class KFGame.KFKActorSpawnable
// 0x0000 (0x037C - 0x037C)
class AKFKActorSpawnable : public AKActorSpawnable {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3487];

        return pClassPointer;
    };

    void eventReset();
    void UnHideTimer();
    void HideForInterval();
    void eventPostBeginPlay();
};

UClass* AKFKActorSpawnable::pClassPointer = NULL;

// Class KFGame.KFLaserSightAttachment
// 0x005C (0x00BC - 0x0060)
class UKFLaserSightAttachment : public UObject {
   public:
    float LaserDotLerpStartDistance;  // 0x0060 (0x0004) [0x0000000000000000]
    float LaserDotLerpEndDistance;    // 0x0064 (0x0004) [0x0000000000000000]
    float LaserDotMaxScale;           // 0x0068 (0x0004) [0x0000000000000000]
    float LaserDotDepthBias;          // 0x006C (0x0004) [0x0000000000000000]
    class UStaticMesh* LaserDotMesh;  // 0x0070 (0x0008) [0x0000000000000000]
    class UStaticMeshComponent*
        LaserDotMeshComp;  // 0x0078 (0x0008) [0x0000000000000000]
    class USkeletalMesh*
        LaserSightMesh;  // 0x0080 (0x0008) [0x0000000000000000]
    class UKFSkeletalMeshComponent*
        LaserSightMeshComp;              // 0x0088 (0x0008) [0x0000000000000000]
    class USkeletalMesh* LaserBeamMesh;  // 0x0090 (0x0008) [0x0000000000000000]
    class UKFSkeletalMeshComponent*
        LaserBeamMeshComp;              // 0x0098 (0x0008) [0x0000000000000000]
    struct FName LaserSightSocketName;  // 0x00A0 (0x0008) [0x0000000000000000]
    float LaserSightRange;              // 0x00A8 (0x0004) [0x0000000000000000]
    float AnimWeight;                   // 0x00AC (0x0004) [0x0000000000000000]
    float AnimBlendRate;                // 0x00B0 (0x0004) [0x0000000000000000]
    float LaserSightAimStrength;        // 0x00B4 (0x0004) [0x0000000000000000]
    float DesiredAimStrength;           // 0x00B8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3489];

        return pClassPointer;
    };

    void GetFOVAdjustedLaserSocket();
    void AimAt();
    void UpdateFirstPersonAImStrength();
    void Update();
    void eventChangeVisibility();
    void SetMeshLightingChannels();
    void SetMeshFOV();
    void AttachLaserSight();
};

UClass* UKFLaserSightAttachment::pClassPointer = NULL;

// Class KFGame.KFLightPool
// 0x001C (0x0260 - 0x0244)
class AKFLightPool : public AActor {
   public:
    TArray<struct FLightPoolInfo>
        ActiveComponents;       // 0x0244 (0x0010) [0x0000000000000000]
    int MaxOnScreenLights;      // 0x0254 (0x0004) [0x0000000000000000]
    int CurrentOnScreenLights;  // 0x0258 (0x0004) [0x0000000000000000]
    int CurrentLowestPriority;  // 0x025C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3491];

        return pClassPointer;
    };

    void RegisterPointLight();
    void eventPreBeginPlay();
};

UClass* AKFLightPool::pClassPointer = NULL;

// Class KFGame.KFMuzzleFlash
// 0x00AC (0x010C - 0x0060)
class UKFMuzzleFlash : public UObject {
   public:
    class AActor* Owner;  // 0x0060 (0x0008) [0x0000000000000000]
    struct FMuzzleEffectInfo
        MuzzleFlash;  // 0x0068 (0x0040) [0x0000000000000000]
    DWORD bEnableSecondaryMuzzleFlash : 1;  // 0x00A8 (0x0004)
                                            // [0x0000000000000000] [0x00000001]
    DWORD bLastWasPrimary : 1;          // 0x00A8 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bAutoActivateShellEject : 1;  // 0x00A8 (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    struct FMuzzleEffectInfo
        MuzzleFlashAlt;  // 0x00AC (0x0040) [0x0000000000000000]
    unsigned char
        FireModeAlternateBothEffects;  // 0x00EC (0x0001) [0x0000000000000000]
    unsigned char
        FireModeFireBothEffects;  // 0x00ED (0x0001) [0x0000000000000000]
    class UParticleSystem*
        ShellEjectPSCTemplate;          // 0x00F0 (0x0008) [0x0000000000000000]
    struct FName ShellEjectSocketName;  // 0x00F8 (0x0008) [0x0000000000000000]
    class UKFParticleSystemComponent*
        ShellEjectPSC;         // 0x0100 (0x0008) [0x0000000000000000]
    float ShellEjectLifetime;  // 0x0108 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3493];

        return pClassPointer;
    };

    void SetShellEjectLife();
    void CauseShellEject();
    void GetAltSocketName();
    void GetSocketName();
    void DetachMuzzleFlash();
    void eventSetFOV();
    void AttachMuzzleFlash();
    void MuzzleFlashAltTimer();
    void MuzzleFlashTimer();
    void StopMuzzleFlash();
    void CauseMuzzleFlash();
};

UClass* UKFMuzzleFlash::pClassPointer = NULL;

// Class KFGame.KFParticleSystemComponent
// 0x0014 (0x03CC - 0x03B8)
class UKFParticleSystemComponent : public UParticleSystemComponent {
   public:
    float FOV;                    // 0x03B8 (0x0004) [0x0000000000000000]
    DWORD bHasSavedScale3D : 1;   // 0x03BC (0x0004) [0x0000000000000000]
                                  // [0x00000001]
    struct FVector SavedScale3D;  // 0x03C0 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3495];

        return pClassPointer;
    };

    void SetFOV();
};

UClass* UKFParticleSystemComponent::pClassPointer = NULL;

// Class KFGame.KFPersistentBloodActor
// 0x001C (0x0260 - 0x0244)
class AKFPersistentBloodActor : public AActor {
   public:
    float ConeSpreadRadius;      // 0x0244 (0x0004) [0x0000000000000000]
    float MaxConeSpreadDegrees;  // 0x0248 (0x0004) [0x0000000000000000]
    DWORD bEnabled : 1;  // 0x024C (0x0004) [0x0000000000000000] [0x00000001]
    float BloodScale;    // 0x0250 (0x0004) [0x0000000000000000]
    float BloodSpread;   // 0x0254 (0x0004) [0x0000000000000000]
    class UDrawConeComponent*
        PreviewCone;  // 0x0258 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3497];

        return pClassPointer;
    };

    void Reset();
    void eventPreBeginPlay();
    void LeaveBloodSplats();
    void TryAddBloodSplats();
};

UClass* AKFPersistentBloodActor::pClassPointer = NULL;

// Class KFGame.KFReverbVolume
// 0x0044 (0x0308 - 0x02C4)
class AKFReverbVolume : public AReverbVolume {
   public:
    TArray<struct FWWiseEnvironmentSettings>
        ReverbEnvironments;  // 0x02C4 (0x0010) [0x0000000000000000]
    struct FWwiseStateSettings
        StateSettings;                 // 0x02D4 (0x0010) [0x0000000000000000]
    float IntraVolumeOcclusionScalar;  // 0x02E4 (0x0004) [0x0000000000000000]
    TArray<struct FName>
        EnvironmentNames;  // 0x02E8 (0x0010) [0x0000000000000000]
    TArray<float>
        EnvironmentEchoDistances;  // 0x02F8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3499];

        return pClassPointer;
    };

    void CalculateEchoLocationAndDelay();
    void CalculateEchoVolumeAndDistance();
    void GetEnvironmentEchoDistance();
};

UClass* AKFReverbVolume::pClassPointer = NULL;

// Class KFGame.KFSkinTypeEffects
// 0x01F8 (0x0258 - 0x0060)
class UKFSkinTypeEffects : public UObject {
   public:
    struct FSkinEffectInfo
        ImpactFXArray[0xF];  // 0x0060 (0x01E0) [0x0000000000000000]
    TArray<struct FSkinEffectInfo>
        CustomEffects;                   // 0x0240 (0x0010) [0x0000000000000000]
    float ImpactParticleEffectInterval;  // 0x0250 (0x0004) [0x0000000000000000]
    float ImpactSoundInterval;           // 0x0254 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3501];

        return pClassPointer;
    };

    void GetImpactSound();
    void PlayTakeHitSound();
    void GetImpactParticleEffect();
    void DefaultSpawnEffect();
    void MeleeSpawnEffect();
    void AttachEffectToHitLocation();
    void AttachEffectToBone();
    void PlayImpactParticleEffect();
};

UClass* UKFSkinTypeEffects::pClassPointer = NULL;

// Class KFGame.KFSprayActor
// 0x03A0 (0x05E4 - 0x0244)
class AKFSprayActor : public AActor {
   public:
    class USkeletalMesh* SkelMesh;  // 0x0244 (0x0008) [0x0000000000000000]
    class UAnimSet* SprayAnimSet;   // 0x024C (0x0008) [0x0000000000000000]
    class UAnimTree*
        SprayAnimTreeTemplate;  // 0x0254 (0x0008) [0x0000000000000000]
    class UKFSkeletalMeshComponent*
        SkeletalSprayMesh;            // 0x025C (0x0008) [0x0000000000000000]
    DWORD bAllowSprayLights : 1;      // 0x0264 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bDoPerBoneSprayFX : 1;      // 0x0264 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bDoFirstPersonFX : 1;       // 0x0264 (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    DWORD bCollideWithTeammates : 1;  // 0x0264 (0x0004) [0x0000000000000000]
                                      // [0x00000008]
    DWORD bVisualOnly : 1;  // 0x0264 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bSprayMeshCollidedThisTick : 1;  // 0x0264 (0x0004)
                                           // [0x0000000000000000] [0x00000020]
    DWORD bSprayMeshCollidedLastTick : 1;  // 0x0264 (0x0004)
                                           // [0x0000000000000000] [0x00000040]
    DWORD bDoCollideComplex : 1;  // 0x0264 (0x0004) [0x0000000000000000]
                                  // [0x00000080]
    DWORD bUseExtentTracing : 1;  // 0x0264 (0x0004) [0x0000000000000000]
                                  // [0x00000100]
    DWORD bWaitingToDestroy : 1;  // 0x0264 (0x0004) [0x0000000000000000]
                                  // [0x00000200]
    DWORD bDetached : 1;  // 0x0264 (0x0004) [0x0000000000000000] [0x00000400]
    DWORD bSkeletonHasBeenUpdated : 1;  // 0x0264 (0x0004) [0x0000000000000000]
                                        // [0x00000800]
    DWORD
        bSplashActive : 1;  // 0x0264 (0x0004) [0x0000000000000000] [0x00001000]
    DWORD bDebugShowBones : 1;         // 0x0264 (0x0004) [0x0000000000000000]
                                       // [0x00002000]
    DWORD bDebugShowCollision : 1;     // 0x0264 (0x0004) [0x0000000000000000]
                                       // [0x00004000]
    DWORD bDebugShowSplashRadius : 1;  // 0x0264 (0x0004) [0x0000000000000000]
                                       // [0x00008000]
    DWORD
        bDebugForceNonPlayerParticles : 1;  // 0x0264 (0x0004)
                                            // [0x0000000000000000] [0x00010000]
    DWORD bDebugShowSeeds : 1;           // 0x0264 (0x0004) [0x0000000000000000]
                                         // [0x00020000]
    DWORD bDebugDirectDamage : 1;        // 0x0264 (0x0004) [0x0000000000000000]
                                         // [0x00040000]
    DWORD bDebugSplashDamage : 1;        // 0x0264 (0x0004) [0x0000000000000000]
                                         // [0x00080000]
    DWORD bDebugSprayLights : 1;         // 0x0264 (0x0004) [0x0000000000000000]
                                         // [0x00100000]
    struct FName SpraySocketName;        // 0x0268 (0x0008) [0x0000000000000000]
    struct FVector2D GravityScaleRange;  // 0x0270 (0x0008) [0x0000000000000000]
    float GravityScaleInTime;            // 0x0278 (0x0004) [0x0000000000000000]
    TArray<struct FSprayBoneInfo>
        BoneChain;                    // 0x027C (0x0010) [0x0000000000000000]
    float PerBoneSprayFXGlobalScale;  // 0x028C (0x0004) [0x0000000000000000]
    class UParticleSystem*
        SplashGlancingEffect;  // 0x0290 (0x0008) [0x0000000000000000]
    class UParticleSystem*
        SplashDirectEffect;  // 0x0298 (0x0008) [0x0000000000000000]
    class UParticleSystem*
        SplashPawnEffect;  // 0x02A0 (0x0008) [0x0000000000000000]
    class UKFImpactEffectInfo*
        ImpactEffects;  // 0x02A8 (0x0008) [0x0000000000000000]
    class UKFParticleSystemComponent*
        CurrentSplashEffect;  // 0x02B0 (0x0008) [0x0000000000000000]
    class UKFParticleSystemComponent*
        SplashGlancingPSC;  // 0x02B8 (0x0008) [0x0000000000000000]
    class UKFParticleSystemComponent*
        SplashDirectPSC;  // 0x02C0 (0x0008) [0x0000000000000000]
    class UKFParticleSystemComponent*
        SplashPawnPSC;  // 0x02C8 (0x0008) [0x0000000000000000]
    class UKFParticleSystemComponent*
        SplashMaterialBasedPSC;         // 0x02D0 (0x0008) [0x0000000000000000]
    class UAkEvent* SplashPawnAKEvent;  // 0x02D8 (0x0008) [0x0000000000000000]
    class UAkEvent*
        SplashDirectAKEvent;  // 0x02E0 (0x0008) [0x0000000000000000]
    class UAkEvent*
        SplashGlancingAKEvent;  // 0x02E8 (0x0008) [0x0000000000000000]
    class UAkEvent*
        SplashPawnStopAKEvent;  // 0x02F0 (0x0008) [0x0000000000000000]
    class UAkEvent*
        SplashDirectStopAKEvent;  // 0x02F8 (0x0008) [0x0000000000000000]
    class UAkEvent*
        SplashGlancingStopAKEvent;  // 0x0300 (0x0008) [0x0000000000000000]
    class UAkEvent*
        CurrentSplashAKEvent;  // 0x0308 (0x0008) [0x0000000000000000]
    class UAkComponent*
        CurrentSplashAKC;          // 0x0310 (0x0008) [0x0000000000000000]
    float SplashGlancingDotLimit;  // 0x0318 (0x0004) [0x0000000000000000]
    int LastBoneChainIndexThatCanSpawnSplashEffects;  // 0x031C (0x0004)
                                                      // [0x0000000000000000]
    float MaxDecalEffectDistance;    // 0x0320 (0x0004) [0x0000000000000000]
    float ImpactProjectileInterval;  // 0x0324 (0x0004) [0x0000000000000000]
    class UClass*
        ImpactProjectileClass;  // 0x0328 (0x0008) [0x0000000000000000]
    struct FSprayFxInfo
        SprayFxInfos[0x14];         // 0x0330 (0x0140) [0x0000000000000000]
    int CurrSprayFxLocIdx;          // 0x0470 (0x0004) [0x0000000000000000]
    float SplashRotInterpSpeed;     // 0x0474 (0x0004) [0x0000000000000000]
    float SplashLocInterpSpeed;     // 0x0478 (0x0004) [0x0000000000000000]
    struct FRotator LastSplashRot;  // 0x047C (0x000C) [0x0000000000000000]
    struct FVector LastSplashLoc;   // 0x0488 (0x000C) [0x0000000000000000]
    TArray<struct FSprayLight>
        SprayLights;  // 0x0494 (0x0010) [0x0000000000000000]
    class UMaterialInstanceConstant*
        MIC_SprayMat0;  // 0x04A4 (0x0008) [0x0000000000000000]
    class UMaterialInstanceConstant*
        MIC_SprayMat1;  // 0x04AC (0x0008) [0x0000000000000000]
    class UMaterialInstanceConstant*
        MIC_SprayMat2;                   // 0x04B4 (0x0008) [0x0000000000000000]
    struct FVector2D MaterialHeatRange;  // 0x04BC (0x0008) [0x0000000000000000]
    float MaterialHeatRampTime;          // 0x04C4 (0x0004) [0x0000000000000000]
    float MatFadePow;                    // 0x04C8 (0x0004) [0x0000000000000000]
    float MaterialFadeOutTime;           // 0x04CC (0x0004) [0x0000000000000000]
    float MaterialCurrentFadeVal;        // 0x04D0 (0x0004) [0x0000000000000000]
    class UParticleSystem*
        SprayStartEffect;  // 0x04D4 (0x0008) [0x0000000000000000]
    class UKFParticleSystemComponent*
        SprayStartPSC;  // 0x04DC (0x0008) [0x0000000000000000]
    class UParticleSystem*
        SprayEndEffect;            // 0x04E4 (0x0008) [0x0000000000000000]
    int AimAdjustYaw;              // 0x04EC (0x0004) [0x0000000000000000]
    float DamageInterval;          // 0x04F0 (0x0004) [0x0000000000000000]
    struct FVector2D SprayDamage;  // 0x04F4 (0x0008) [0x0000000000000000]
    struct FVector2D
        SprayDamageScaleDistRange;      // 0x04FC (0x0008) [0x0000000000000000]
    class UClass* MyDamageType;         // 0x0504 (0x0008) [0x0000000000000000]
    float SplashDamageRadius;           // 0x050C (0x0004) [0x0000000000000000]
    float SplashDamage;                 // 0x0510 (0x0004) [0x0000000000000000]
    float SplashDamageFalloffExponent;  // 0x0514 (0x0004) [0x0000000000000000]
    float SplashDamageInstigatorDamageScale;  // 0x0518 (0x0004)
                                              // [0x0000000000000000]
    float MomentumScale;  // 0x051C (0x0004) [0x0000000000000000]
    TArray<struct FDamagedActorInfo>
        RecentlyDamagedActors;  // 0x0520 (0x0010) [0x0000000000000000]
    struct FSprayMeshContact
        HighestSprayMeshContactThisTick;  // 0x0530 (0x0034)
                                          // [0x0000000000000000]
    float bSprayMeshCollisionDuration;  // 0x0564 (0x0004) [0x0000000000000000]
    class UAnimNodeBlendList*
        AnimBlendNode;  // 0x0568 (0x0008) [0x0000000000000000]
    class UAnimNodeSequence*
        StartSpraySeqNode;  // 0x0570 (0x0008) [0x0000000000000000]
    class UAnimNodeSequence*
        EndSpraySeqNode;  // 0x0578 (0x0008) [0x0000000000000000]
    class UKFSkelControl_SprayScaling*
        ScalingSkelControl;           // 0x0580 (0x0008) [0x0000000000000000]
    TArray<struct FSpraySeed> Seeds;  // 0x0588 (0x0010) [0x0000000000000000]
    float SeedSprayVel;               // 0x0598 (0x0004) [0x0000000000000000]
    float SeedDecel;                  // 0x059C (0x0004) [0x0000000000000000]
    float SeedMaxAge;                 // 0x05A0 (0x0004) [0x0000000000000000]
    float SeedMinChainLength;         // 0x05A4 (0x0004) [0x0000000000000000]
    float SeedSimFreq;                // 0x05A8 (0x0004) [0x0000000000000000]
    float SeedSimTimeRemaining;       // 0x05AC (0x0004) [0x0000000000000000]
    float SeedWarmupTime;             // 0x05B0 (0x0004) [0x0000000000000000]
    float VelocityScaleZ;             // 0x05B4 (0x0004) [0x0000000000000000]
    class AKFPawn* OwningKFPawn;      // 0x05B8 (0x0008) [0x0000000000000000]
    class AActor* DummyFireParent;    // 0x05C0 (0x0008) [0x0000000000000000]
    class AController*
        InstigatorController;      // 0x05C8 (0x0008) [0x0000000000000000]
    float CurrentAge;              // 0x05D0 (0x0004) [0x0000000000000000]
    float RotationSpeed;           // 0x05D4 (0x0004) [0x0000000000000000]
    struct FRotator LastRotation;  // 0x05D8 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3503];

        return pClassPointer;
    };

    void SpawnImpactProjectile();
    void LeaveImpactProjectile();
    void FindOwningKFPawn();
    void DoSprayCollisionDetection();
    void ParticleSystemCleanUp();
    void eventGetImpactEffect();
    void AttachToMesh();
    void TempCreatePSC();
    void SetupPerBoneFireFX();
    void eventOnAnimEnd();
    void CleanupEndFire();
    void DetachAndFinish();
    void Destroyed();
    void BeginSpray();
    void ClearAnimNodes();
    void CacheAnimNodes();
    void SetupFX();
    void SetFOV();
    void eventProcessDirectImpact();
    void PostBeginPlay();
    void eventPreBeginPlay();
    void GetDamage();
    void DebugRenderBones();
    void SetBoneSpawnParticlesActive();
    void DestroyIfAllEmittersFinished();
    void UpdateSplashes();
    void UpdatePerBoneSprayFX();
    void UpdateSeeds();
};

UClass* AKFSprayActor::pClassPointer = NULL;

// Class KFGame.KFVehicleMovementEffect
// 0x0020 (0x0264 - 0x0244)
class AKFVehicleMovementEffect : public AActor {
   public:
    class UStaticMeshComponent*
        AirEffect;                  // 0x0244 (0x0008) [0x0000000000000000]
    float MinVelocityForAirEffect;  // 0x024C (0x0004) [0x0000000000000000]
    float MaxVelocityForAirEffect;  // 0x0250 (0x0004) [0x0000000000000000]
    struct FName AirEffectScalar;   // 0x0254 (0x0008) [0x0000000000000000]
    float AirMaxDelta;              // 0x025C (0x0004) [0x0000000000000000]
    float AirCurrentLevel;          // 0x0260 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3505];

        return pClassPointer;
    };
};

UClass* AKFVehicleMovementEffect::pClassPointer = NULL;

// Class KFGame.KFWireConnector
// 0x001C (0x0274 - 0x0258)
class AKFWireConnector : public AEmitter {
   public:
    struct FVector StartTangent;  // 0x0258 (0x000C) [0x0000000000000000]
    struct FVector EndTangent;    // 0x0264 (0x000C) [0x0000000000000000]
    float TessellationFactor;     // 0x0270 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3507];

        return pClassPointer;
    };

    void Timer();
    void eventPostBeginPlay();
    void ApplyBeamProperties();
};

UClass* AKFWireConnector::pClassPointer = NULL;

// Class KFGame.KFWireStart
// 0x0000 (0x024C - 0x024C)
class AKFWireStart : public AKeypoint {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3509];

        return pClassPointer;
    };
};

UClass* AKFWireStart::pClassPointer = NULL;

// Class KFGame.KFAfflictionBase
// 0x002C (0x008C - 0x0060)
class UKFAfflictionBase : public UObject {
   public:
    float CurrentStrength;     // 0x0060 (0x0004) [0x0000000000000000]
    float DissipationRate;     // 0x0064 (0x0004) [0x0000000000000000]
    class AKFPawn* PawnOwner;  // 0x0068 (0x0008) [0x0000000000000000]
    class AKFPawn_Monster*
        MonsterOwner;           // 0x0070 (0x0008) [0x0000000000000000]
    unsigned char SpecialMove;  // 0x0078 (0x0001) [0x0000000000000000]
    float Cooldown;             // 0x007C (0x0004) [0x0000000000000000]
    float LastActivationTime;   // 0x0080 (0x0004) [0x0000000000000000]
    DWORD bNeedsTick : 1;  // 0x0084 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bDebug : 1;      // 0x0084 (0x0004) [0x0000000000000000] [0x00000002]
    float LastDissipationTime;  // 0x0088 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3511];

        return pClassPointer;
    };

    void GetSpeedModifier();
    void GetDamageModifier();
    void GetStunModifier();
    void GetStumbleModifier();
    void GetKnockdownModifier();
    void eventTick();
    void SetMaterialParameter();
    void ToggleEffects();
    void ShutDown();
    void GetSpecialMoveFlags();
    void Activate();
    void Accrue();
    void Init();
};

UClass* UKFAfflictionBase::pClassPointer = NULL;

// Class KFGame.KFPawn
// 0x052C (0x0B40 - 0x0614)
class AKFPawn : public ABaseAIPawn {
   public:
    class UKFCharacterInfoBase*
        CharacterArch;  // 0x0614 (0x0008) [0x0000000000000000]
    class UKFPawnSoundGroup*
        SoundGroupArch;            // 0x061C (0x0008) [0x0000000000000000]
    class UClass* VoiceGroupArch;  // 0x0624 (0x0008) [0x0000000000000000]
    class UKFPawnAnimInfo*
        PawnAnimInfo;              // 0x062C (0x0008) [0x0000000000000000]
    struct FName LocalizationKey;  // 0x0634 (0x0008) [0x0000000000000000]
    class UTexture2D*
        CharacterPortrait;  // 0x063C (0x0008) [0x0000000000000000]
    struct FLightingChannelContainer
        PawnLightingChannel;  // 0x0644 (0x0004) [0x0000000000000000]
    class USkeletalMeshComponent*
        ThirdPersonHeadMeshComponent;  // 0x0648 (0x0008) [0x0000000000000000]
    int ThirdPersonAttachmentBitMask;  // 0x0650 (0x0004) [0x0000000000000000]
    struct FName ThirdPersonAttachmentSocketNames[0x3];  // 0x0654 (0x0018)
                                                         // [0x0000000000000000]
    class UMeshComponent*
        ThirdPersonAttachments[0x3];  // 0x066C (0x0018) [0x0000000000000000]
    TArray<class UMaterialInstanceConstant*>
        CharacterMICs;                // 0x0684 (0x0010) [0x0000000000000000]
    DWORD bAllowAlwaysOnPhysics : 1;  // 0x0694 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bIsGoreMesh : 1;  // 0x0694 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bTakingRadiusDamage : 1;    // 0x0694 (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    DWORD bNeedsProcessHitFx : 1;     // 0x0694 (0x0004) [0x0000000000000000]
                                      // [0x00000008]
    DWORD bHasBrokenConstraints : 1;  // 0x0694 (0x0004) [0x0000000000000000]
                                      // [0x00000010]
    DWORD bAllowRagdollAndGoreOnDeadBodies : 1;  // 0x0694 (0x0004)
                                                 // [0x0000000000000000]
                                                 // [0x00000020]
    DWORD bReinitPhysAssetOnDeath : 1;  // 0x0694 (0x0004) [0x0000000000000000]
                                        // [0x00000040]
    DWORD
        bAllowDeathSM : 1;  // 0x0694 (0x0004) [0x0000000000000000] [0x00000080]
    DWORD bEmpDisrupted : 1;  // 0x0694 (0x0004) [0x0000000000330000]
                              // [0x00000100] ( CPF_Travel | CPF_EditConst )
    DWORD bEmpPanicked : 1;   // 0x0694 (0x0004) [0x0000000000340000]
                              // [0x00000200] ( CPF_GlobalConfig )
    DWORD bFirePanicked : 1;  // 0x0694 (0x0004) [0x0000000000350000]
                              // [0x00000400] ( CPF_Travel | CPF_GlobalConfig )
    DWORD bCanPlayPhysicsHitReactions : 1;  // 0x0694 (0x0004)
                                            // [0x0000000000000000] [0x00000800]
    DWORD
        bIsSprinting : 1;  // 0x0694 (0x0004) [0x0000000000360000] [0x00001000]
                           // ( CPF_EditConst | CPF_GlobalConfig )
    DWORD bAllowSprinting : 1;  // 0x0694 (0x0004) [0x000000000037008E]
                                // [0x00002000] ( CPF_Const | CPF_Input |
                                // CPF_ExportObject | CPF_Parm | CPF_Travel |
                                // CPF_EditConst | CPF_GlobalConfig )
    DWORD bIgnoreTeamCollision : 1;  // 0x0694 (0x0004) [0x00000000003800A7]
                                     // [0x00004000] ( CPF_Edit | CPF_Const |
                                     // CPF_Input | CPF_Net | CPF_Parm |
                                     // CPF_Component )
    DWORD bUnaffectedByZedTime : 1;  // 0x0694 (0x0004) [0x0000000000390000]
                                     // [0x00008000] ( CPF_Travel |
                                     // CPF_Component )
    DWORD bMovesFastInZedTime : 1;   // 0x0694 (0x0004) [0x00000000003A0000]
                                     // [0x00010000] ( CPF_EditConst |
                                     // CPF_Component )
    DWORD bJumping : 1;  // 0x0694 (0x0004) [0x00000000003B008E] [0x00020000] (
                         // CPF_Const | CPF_Input | CPF_ExportObject | CPF_Parm
                         // | CPF_Travel | CPF_EditConst | CPF_Component )
    DWORD bWeaponBob : 1;  // 0x0694 (0x0004) [0x0000000000000000] [0x00040000]
    DWORD bUpdateEyeheight : 1;  // 0x0694 (0x0004) [0x0000000000000000]
                                 // [0x00080000]
    DWORD bJustLanded : 1;  // 0x0694 (0x0004) [0x0000000000000000] [0x00100000]
    DWORD
        bLandRecovery : 1;  // 0x0694 (0x0004) [0x0000000000000000] [0x00200000]
    DWORD bWeaponAttachmentVisible : 1;  // 0x0694 (0x0004) [0x0000000000000000]
                                         // [0x00400000]
    DWORD bNeedsCrosshair : 1;           // 0x0694 (0x0004) [0x0000000000000000]
                                         // [0x00800000]
    DWORD bEnableAimOffset : 1;          // 0x0694 (0x0004) [0x0000000000000000]
                                         // [0x01000000]
    DWORD bDisableTurnInPlace : 1;       // 0x0694 (0x0004) [0x0000000000000000]
                                         // [0x02000000]
    DWORD
        bCanHeadTrack : 1;  // 0x0694 (0x0004) [0x0000000000000000] [0x04000000]
    DWORD bIsHeadTrackingActive : 1;  // 0x0694 (0x0004) [0x0000000000000000]
                                      // [0x08000000]
    DWORD
        bWeakZedGrab : 1;  // 0x0694 (0x0004) [0x0000000000000000] [0x10000000]
    DWORD bDoFloorConformBlend : 1;  // 0x0694 (0x0004) [0x0000000000000000]
                                     // [0x20000000]
    DWORD bUseQuadrupedFloorConform : 1;  // 0x0694 (0x0004)
                                          // [0x0000000000000000] [0x40000000]
    DWORD bDisableMeshSmoothing : 1;  // 0x0694 (0x0004) [0x0000000000000000]
                                      // [0x80000000]
    DWORD
        bDisableMeshRotationSmoothing : 1;  // 0x0698 (0x0004)
                                            // [0x0000000000000000] [0x00000001]
    DWORD bAllowFootstepSounds : 1;  // 0x0698 (0x0004) [0x0000000000000000]
                                     // [0x00000002]
    DWORD bUseHiddenSpeed : 1;       // 0x0698 (0x0004) [0x0000000000000000]
                                     // [0x00000004]
    DWORD bCanUseHiddenSpeed : 1;    // 0x0698 (0x0004) [0x0000000000000000]
                                     // [0x00000008]
    DWORD bAllowAccelSmoothing : 1;  // 0x0698 (0x0004) [0x0000000000000000]
                                     // [0x00000010]
    DWORD bAIZedsIgnoreMe : 1;       // 0x0698 (0x0004) [0x0000000000000000]
                                     // [0x00000020]
    DWORD bCanCloak : 1;    // 0x0698 (0x0004) [0x0000000000000000] [0x00000040]
    DWORD bIsCloaking : 1;  // 0x0698 (0x0004) [0x00000000003C0123] [0x00000080]
                            // ( CPF_Edit | CPF_Const | CPF_Net | CPF_OutParm |
                            // CPF_GlobalConfig | CPF_Component )
    DWORD bLogTakeDamage : 1;         // 0x0698 (0x0004) [0x0000000000000000]
                                      // [0x00000100]
    DWORD bLogPhysicsBodyImpact : 1;  // 0x0698 (0x0004) [0x0000000000000000]
                                      // [0x00000200]
    DWORD bLogSpecialMove : 1;        // 0x0698 (0x0004) [0x0000000000000000]
                                      // [0x00000400]
    DWORD bLogCustomAnim : 1;         // 0x0698 (0x0004) [0x0000000000000000]
                                      // [0x00000800]
    float LastHeadShotReceivedTime;   // 0x069C (0x0004) [0x0000000000000000]
    TArray<struct FHitZoneInfo>
        HitZones;                 // 0x06A0 (0x0010) [0x0000000000000000]
    float TimeOfDeath;            // 0x06B0 (0x0004) [0x0000000000000000]
    float PenetrationResistance;  // 0x06B4 (0x0004) [0x0000000000000000]
    TArray<struct FDamageOverTimeInfo>
        DamageOverTimeArray;  // 0x06B8 (0x0010) [0x0000000000000000]
    TArray<struct FExplosiveStackInfo>
        RecentExplosiveStacks;     // 0x06C8 (0x0010) [0x0000000000000000]
    float LastTimeDamageHappened;  // 0x06D8 (0x0004) [0x0000000000000000]
    float CrushScale;              // 0x06DC (0x0004) [0x0000000000000000]
    float VolumeDamageScale;       // 0x06E0 (0x0004) [0x0000000000000000]
    TArray<struct FDamageInfo>
        DamageHistory;              // 0x06E4 (0x0010) [0x0000000000000000]
    struct FKFHitFxInfo HitFxInfo;  // 0x06F4 (0x0028) [0x00000000003D000A] (
                                    // CPF_Const | CPF_ExportObject | CPF_Travel
                                    // | CPF_GlobalConfig | CPF_Component )
    struct FKFRadialHitFxInfo
        HitFxRadialInfo;  // 0x071C (0x0010) [0x00000000003E000A]              (
                          // CPF_Const | CPF_ExportObject | CPF_EditConst |
                          // CPF_GlobalConfig | CPF_Component )
    class APawn*
        HitFxInstigator;  // 0x072C (0x0008) [0x00000000003F000A]              (
                          // CPF_Const | CPF_ExportObject | CPF_Travel |
                          // CPF_EditConst | CPF_GlobalConfig | CPF_Component )
    struct FVector
        HitFxAddedRelativeLocs[0x7];  // 0x0734 (0x0054) [0x000000000040000A] (
                                      // CPF_Const | CPF_ExportObject |
                                      // CPF_NeedCtorLink )
    unsigned char
        HitFxAddedHitCount;  // 0x0788 (0x0001) [0x000000000047000A] ( CPF_Const
                             // | CPF_ExportObject | CPF_Travel | CPF_EditConst
                             // | CPF_GlobalConfig | CPF_NeedCtorLink )
    unsigned char
        LastRadiusDamageScale;  // 0x0789 (0x0001) [0x0000000000000000]
    unsigned char
        DeathFireStackedPower;  // 0x078A (0x0001) [0x0000000000480075] (
                                // CPF_Edit | CPF_Input | CPF_OptionalParm |
                                // CPF_Net | CPF_EditConstArray | CPF_Component
                                // | CPF_NeedCtorLink )
    unsigned char
        RepFireBurnedAmount;  // 0x078B (0x0001) [0x0000000000490000] (
                              // CPF_Travel | CPF_Component | CPF_NeedCtorLink )
    unsigned char RagdollWarningLevel;  // 0x078C (0x0001) [0x0000000000000000]
    unsigned char SpecialMove;          // 0x078D (0x0001) [0x0000000000000000]
    unsigned char SpecialMoveFlags;     // 0x078E (0x0001) [0x0000000000000000]
    unsigned char CurrDialogPriority;   // 0x078F (0x0001) [0x0000000000000000]
    float LastTakeHitTimeout;           // 0x0790 (0x0004) [0x0000000000000000]
    struct FVector
        LastRadiusHurtOrigin;  // 0x0794 (0x000C) [0x0000000000000000]
    TArray<class UMaterialInstance*>
        BloodSplatterDecalMaterials;  // 0x07A0 (0x0010) [0x0000000000000000]
    TArray<class UMaterialInstance*>
        BloodPoolDecalMaterials;        // 0x07B0 (0x0010) [0x0000000000000000]
    struct FName BattleBloodParamName;  // 0x07C0 (0x0008) [0x0000000000000000]
    float MinBattleBloodValue;          // 0x07C8 (0x0004) [0x0000000000000000]
    float BattleBloodRangeSq;           // 0x07CC (0x0004) [0x0000000000000000]
    float BattleBloodParamValue;        // 0x07D0 (0x0004) [0x0000000000000000]
    struct FName LeftFootBoneName;      // 0x07D4 (0x0008) [0x0000000000000000]
    struct FName RightFootBoneName;     // 0x07DC (0x0008) [0x0000000000000000]
    struct FName LeftHandBoneName;      // 0x07E4 (0x0008) [0x0000000000000000]
    struct FName RightHandBoneName;     // 0x07EC (0x0008) [0x0000000000000000]
    struct FName HeadBoneName;          // 0x07F4 (0x0008) [0x0000000000000000]
    struct FName TorsoBoneName;         // 0x07FC (0x0008) [0x0000000000000000]
    struct FName PelvisBoneName;        // 0x0804 (0x0008) [0x0000000000000000]
    float LastGibCollisionTime;         // 0x080C (0x0004) [0x0000000000000000]
    float IntendedBodyScale;  // 0x0810 (0x0004) [0x00000000004A0000] (
                              // CPF_EditConst | CPF_Component |
                              // CPF_NeedCtorLink )
    float CurrentBodyScale;          // 0x0814 (0x0004) [0x0000000000000000]
    float BodyScaleChangePerSecond;  // 0x0818 (0x0004) [0x0000000000000000]
    float IntendedHeadScale;         // 0x081C (0x0004) [0x00000000004B0000] (
                              // CPF_Travel | CPF_EditConst | CPF_Component |
                              // CPF_NeedCtorLink )
    float CurrentHeadScale;  // 0x0820 (0x0004) [0x0000000000000000]
    class UKFAfflictionManager*
        AfflictionHandler;  // 0x0824 (0x0008) [0x0000000000000000]
    TArray<struct FIncapSettingsInfo>
        IncapSettings;    // 0x082C (0x0010) [0x0000000000000000]
    int InjuredHitZones;  // 0x083C (0x0004) [0x00000000004C0000]              (
                          // CPF_GlobalConfig | CPF_Component | CPF_NeedCtorLink
                          // )
    float LastImpactParticleEffectTime;  // 0x0840 (0x0004) [0x0000000000000000]
    float LastImpactSoundTime;           // 0x0844 (0x0004) [0x0000000000000000]
    struct FKnockdownImpulseInfo
        KnockdownImpulse;  // 0x0848 (0x0038) [0x00000000004D0000] ( CPF_Travel
                           // | CPF_GlobalConfig | CPF_Component |
                           // CPF_NeedCtorLink )
    struct FReplicatedRootPosInfo
        ReplicatedRootBodyPos;  // 0x0880 (0x0010) [0x00000000004E0042] (
                                // CPF_Const | CPF_EditConstArray |
                                // CPF_EditConst | CPF_GlobalConfig |
                                // CPF_Component | CPF_NeedCtorLink )
    float
        PhysicsHitReactionImpulseScale;  // 0x0890 (0x0004) [0x0000000000000000]
    TArray<struct FName>
        PhysicsBodyImpactBoneList;  // 0x0894 (0x0010) [0x0000000000000000]
    TArray<struct FName>
        PhysicsImpactSpringList;       // 0x08A4 (0x0010) [0x0000000000000000]
    float PhysicsImpactBlendOutTime;   // 0x08B4 (0x0004) [0x0000000000000000]
    float PhysicsImpactBlendTimeToGo;  // 0x08B8 (0x0004) [0x0000000000000000]
    float PhysRagdollImpulseScale;     // 0x08BC (0x0004) [0x0000000000000000]
    float KnockdownImpulseScale;       // 0x08C0 (0x0004) [0x0000000000000000]
    float NextRagdollFailsafeTime;     // 0x08C4 (0x0004) [0x0000000000000000]
    struct FVector
        LastRootRigidBodyTestLoc;  // 0x08C8 (0x000C) [0x0000000000000000]
    float SprintSpeed;  // 0x08D4 (0x0004) [0x00000000004F008E]              (
                        // CPF_Const | CPF_Input | CPF_ExportObject | CPF_Parm |
                        // CPF_Travel | CPF_EditConst | CPF_GlobalConfig |
                        // CPF_Component | CPF_NeedCtorLink )
    float SprintStrafeSpeed;         // 0x08D8 (0x0004) [0x0000000000000000]
    struct FVector ReplicatedFloor;  // 0x08DC (0x000C) [0x0000000000500064] (
                                     // CPF_Input | CPF_Net | CPF_EditConstArray
                                     // | CPF_NeedCtorLink )
    float
        TeammateCollisionRadiusPercent;  // 0x08E8 (0x0004) [0x0000000000000000]
    float ZedTimeSpeedScale;             // 0x08EC (0x0004) [0x0000000000000000]
    float
        AfflictionSpeedModifier;  // 0x08F0 (0x0004) [0x000000000051008E] (
                                  // CPF_Const | CPF_Input | CPF_ExportObject |
                                  // CPF_Parm | CPF_Travel | CPF_NeedCtorLink )
    int NumJumpsAllowed;  // 0x08F4 (0x0004) [0x000000000052008E]              (
                          // CPF_Const | CPF_Input | CPF_ExportObject | CPF_Parm
                          // | CPF_EditConst | CPF_NeedCtorLink )
    int NumJumpsRemaining;      // 0x08F8 (0x0004) [0x0000000000000000]
    float BaseCrouchEyeHeight;  // 0x08FC (0x0004) [0x0000000000000000]
    float Bob;                  // 0x0900 (0x0004) [0x0000000000000000]
    float OldZ;                 // 0x0904 (0x0004) [0x0000000000000000]
    float LandBob;              // 0x0908 (0x0004) [0x0000000000000000]
    float JumpBob;              // 0x090C (0x0004) [0x0000000000000000]
    float AppliedBob;           // 0x0910 (0x0004) [0x0000000000000000]
    float BobTime;              // 0x0914 (0x0004) [0x0000000000000000]
    struct FVector WalkBob;     // 0x0918 (0x000C) [0x0000000000000000]
    TArray<class UClass*>
        DefaultInventory;  // 0x0924 (0x0010) [0x0000000000000000]
    TArray<class AInventory*>
        DefaultInventoryArchetypes;  // 0x0934 (0x0010) [0x0000000000000000]
    class AKFWeaponAttachment*
        WeaponAttachmentTemplate;  // 0x0944 (0x0008) [0x0000000000530000] (
                                   // CPF_Travel | CPF_EditConst |
                                   // CPF_NeedCtorLink )
    class AKFWeaponAttachment*
        WeaponAttachment;  // 0x094C (0x0008) [0x0000000000000000]
    class UKFSkeletalMeshComponent*
        ArmsMesh;  // 0x0954 (0x0008) [0x0000000000000000]
    struct FName
        WeaponAttachmentSocket;   // 0x095C (0x0008) [0x0000000000000000]
    class AKFWeapon* MyKFWeapon;  // 0x0964 (0x0008) [0x0000000000000000]
    float LastWeaponFireTime;     // 0x096C (0x0004) [0x0000000000000000]
    TArray<class UAnimNodeAimOffset*>
        AimOffsetNodes;  // 0x0970 (0x0010) [0x0000000000000000]
    TArray<class UAnimNodeSlot*>
        BodyStanceNodes;  // 0x0980 (0x0010) [0x0000000000000000]
    TArray<struct FName>
        ArmPhysicsBoneList;         // 0x0990 (0x0010) [0x0000000000000000]
    struct FVector2D AimOffsetPct;  // 0x09A0 (0x0008) [0x0000000000000000]
    struct FRotator
        ReplicatedAimOffsetPct;  // 0x09A8 (0x000C) [0x00000000005400F9] (
                                 // CPF_Edit | CPF_ExportObject |
                                 // CPF_OptionalParm | CPF_Net |
                                 // CPF_EditConstArray | CPF_Parm |
                                 // CPF_GlobalConfig | CPF_NeedCtorLink )
    float TurnInPlaceAnimRate;  // 0x09B4 (0x0004) [0x0000000000000000]
    float
        NextHitReactionAnim_ActorTime;  // 0x09B8 (0x0004) [0x0000000000000000]
    float LastMeleeNotify_ActorTime;    // 0x09BC (0x0004) [0x0000000000000000]
    TArray<class UGameSkelCtrl_Recoil*>
        RecoilNodes;  // 0x09C0 (0x0010) [0x0000000000000000]
    class USkelControlLookAt*
        IK_Look_Head;  // 0x09D0 (0x0008) [0x0000000000000000]
    class USkelControlLookAt*
        IK_Look_Spine;  // 0x09D8 (0x0008) [0x0000000000000000]
    class USkelControlSingleBone*
        HeadScaleControl;             // 0x09E0 (0x0008) [0x0000000000000000]
    struct FLookAtInfo MyLookAtInfo;  // 0x09E8 (0x0030) [0x0000000000000000]
    class UKFSkelControl_FootPlacement*
        IKFootLeft;  // 0x0A18 (0x0008) [0x0000000000000000]
    class UKFSkelControl_FootPlacement*
        IKFootRight;                 // 0x0A20 (0x0008) [0x0000000000000000]
    class AKFPawn* InteractionPawn;  // 0x0A28 (0x0008) [0x0000000000000000]
    TArray<class UKFSpecialMove*>
        SpecialMoves;  // 0x0A30 (0x0010) [0x0000000000000000]
    struct FKFSpecialMoveStruct
        ReplicatedSpecialMove;  // 0x0A40 (0x0010) [0x0000000000550000] (
                                // CPF_Travel | CPF_GlobalConfig |
                                // CPF_NeedCtorLink )
    class UKFSpecialMoveHandler*
        SpecialMoveHandler;       // 0x0A50 (0x0008) [0x0000000000000000]
    float WeakZedGrabCooldown;    // 0x0A58 (0x0004) [0x0000000000000000]
    float BaseTranslationOffset;  // 0x0A5C (0x0004) [0x0000000000000000]
    struct FVector
        MTO_PhysSmoothOffset;  // 0x0A60 (0x000C) [0x0000000000000000]
    struct FVector
        MTO_SpecialMoveOffset;  // 0x0A6C (0x000C) [0x0000000000000000]
    struct FVector
        MTO_SpecialMoveInterp;          // 0x0A78 (0x000C) [0x0000000000000000]
    float MTO_SpecialMoveSpeed;         // 0x0A84 (0x0004) [0x0000000000000000]
    struct FVector MTO_IKFloorConform;  // 0x0A88 (0x000C) [0x0000000000000000]
    struct FVector
        MeshFloorConformNormal;  // 0x0A94 (0x000C) [0x0000000000000000]
    struct FRotator
        FloorConformLastPawnRotation;   // 0x0AA0 (0x000C) [0x0000000000000000]
    int FloorConformMeshRotationYaw;    // 0x0AAC (0x0004) [0x0000000000000000]
    float LastPhysSmoothDeltaZ;         // 0x0AB0 (0x0004) [0x0000000000000000]
    float MeshYawOffset;                // 0x0AB4 (0x0004) [0x0000000000000000]
    float MeshRotSmoothingInterpSpeed;  // 0x0AB8 (0x0004) [0x0000000000000000]
    class UAkEvent*
        AmbientSound;  // 0x0ABC (0x0008) [0x0000000000560000]              (
                       // CPF_EditConst | CPF_GlobalConfig | CPF_NeedCtorLink )
    class UAkComponent*
        AmbientAkComponent;  // 0x0AC4 (0x0008) [0x0000000000000000]
    class UAkEvent*
        WeaponAmbientSound;  // 0x0ACC (0x0008) [0x00000000005700CF] ( CPF_Edit
                             // | CPF_Const | CPF_Input | CPF_ExportObject |
                             // CPF_EditConstArray | CPF_Parm | CPF_Travel |
                             // CPF_EditConst | CPF_GlobalConfig |
                             // CPF_NeedCtorLink )
    class UAkComponent*
        WeaponAkComponent;  // 0x0AD4 (0x0008) [0x0000000000000000]
    class UKFWeaponAmbientEchoHandler*
        WeaponAmbientEchoHandler;  // 0x0ADC (0x0008) [0x0000000000000000]
    class UAkComponent*
        FootstepAkComponent;  // 0x0AE4 (0x0008) [0x0000000000000000]
    class UAkComponent*
        DialogAkComponent;               // 0x0AEC (0x0008) [0x0000000000000000]
    float LastReplicateTime;             // 0x0AF4 (0x0004) [0x0000000000000000]
    class AKFAIController* MyKFAIC;      // 0x0AF8 (0x0008) [0x0000000000000000]
    float ExtraCostForPath;              // 0x0B00 (0x0004) [0x0000000000000000]
    float MaxTurningRadius;              // 0x0B04 (0x0004) [0x0000000000000000]
    float CurrentTurningRadius;          // 0x0B08 (0x0004) [0x0000000000000000]
    float AccelConvergeFalloffDistance;  // 0x0B0C (0x0004) [0x0000000000000000]
    struct FVector OldAcceleration;      // 0x0B10 (0x000C) [0x0000000000000000]
    float DamageRecoveryTimeHeavy;       // 0x0B1C (0x0004) [0x0000000000000000]
    float DamageRecoveryTimeMedium;      // 0x0B20 (0x0004) [0x0000000000000000]
    float HiddenGroundSpeed;             // 0x0B24 (0x0004) [0x0000000000000000]
    class AController*
        ExclusiveTargetingController;  // 0x0B28 (0x0008) [0x0000000000000000]
    float AIIgnoreEndTime;             // 0x0B30 (0x0004) [0x0000000000000000]
    int CurrDialogEventID;             // 0x0B34 (0x0004) [0x0000000000000000]
    class UTexture2D*
        DebugRadarTexture;  // 0x0B38 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3513];

        return pClassPointer;
    };

    void DetachEmitter();
    void GetLocalizedName();
    void ShouldCorpseCollideWithLivingAfterSleep();
    void ShouldCorpseCollideWithDeadAfterSleep();
    void ShouldCorpseCollideWithLiving();
    void ShouldCorpseCollideWithDead();
    void DisplayDebug();
    void eventKFMessagePlayer();
    void CanAITargetThisPawn();
    void ShouldBeWandering();
    void CausePanicWander();
    void SetWeakGrabCoolDown();
    void CanBeGrabbed();
    void eventIsMovementDisabledDuringSpecialMove();
    void NotifySpecialMoveEnded();
    void eventCanDoSpecialMove();
    void eventEndSpecialMove();
    void ServerDoSpecialMove();
    void eventDoSpecialMove();
    void IsDoingSpecialMove();
    void EndOfDialogTimer();
    void GetVoiceGroupEventDataClass();
    void HasValidVoiceEventData();
    void HandleDialogResponse();
    void PlayDialogEvent();
    void IsPlayingDialogEvent();
    void IsSpeaking();
    void StopDialog();
    void PlayDialog();
    void OnStackingAfflictionChanged();
    void ProcessAdditionalHitFx();
    void ProcessHitFx();
    void eventTick();
    void SetWeaponComponentRTPCValue();
    void SetWeaponAmbientSound();
    void SetPawnAmbientSound();
    void GetMaterialBelowFeet();
    void eventPlayFootStepSound();
    void eventLanded();
    void ReplicateSound();
    void GetAKRotation();
    void SetHeadScale();
    void OnAnimNotifyParticleSystemSpawned();
    void SetEnableFleXCollision();
    void UpdateMeshForFleXCollision();
    void GetSpecialMoveTag();
    void SetDefaultAimOffsetNodesProfile();
    void SetAimOffsetNodesProfile();
    void StopAllAnimations();
    void eventOnAnimEnd();
    void eventPostInitAnimTree();
    void eventCacheAnimNodes();
    void ClearHeadTrackTarget();
    void SetHeadTrackTarget();
    void UpdateMeshTranslationOffset();
    void StopBodyAnim();
    void PlayBodyAnim();
    void AnimInterruptNotifyTimer();
    void GetCurrentBattlePhase();
    void TickDamageOverTime();
    void GetPerkDoTScaler();
    void ApplyDamageOverTime();
    void AdjustAffliction();
    void GetHitZoneSkinTypeEffects();
    void Knockdown();
    void SetRagdollWarningLevel();
    void eventOnRigidBodyRefusedToSleep();
    void eventOnRigidBodyLinearConstraintViolated();
    void RagdollArm();
    void GetRBBoneFromBoneName();
    void ApplyRagdollImpulse();
    void PlayDamageInstigatorHitEffects();
    void PitchAudio();
    void eventUpdateBodyScale();
    void PlayHealEffects();
    void PlayTakeHitEffects();
    void HasInjuredHitZones();
    void CanInjureHitZone();
    void TakeHitZoneDamage();
    void PlayHeal();
    void PlayHit();
    void IsLargeZed();
    void DecodeUnitVector();
    void EncodeUnitVector();
    void NotifyMeleeTakeHit();
    void HitZoneInjured();
    void InitPartialKinematics();
    void GetImpactPhysicsImpulse();
    void StopPhysicsBodyImpact();
    void StartPhysicsBodyImpact();
    void PlayPhysicsBodyImpact();
    void DamagedHitZones();
    void CalcQuadRegion();
    void CalcOctagonRegion();
    void TerminateEffectsOnDeath();
    void IsHeadless();
    void IsIncapacitated();
    void IsImpaired();
    void IsCombatCapable();
    void NotifyAttackParried();
    void CrushedBy();
    void eventEncroachedBy();
    void Died();
    void PlayDyingSound();
    void eventHideMeshOnDeath();
    void PlayRagdollDeath();
    void ShouldRagdollOnDeath();
    void PlayDying();
    void PrepareRagdoll();
    void GetExposureTo();
    void GetBestAggroEnemy();
    void GetUsedWeaponPerk();
    void NotifyFriendlyAIDamageTaken();
    void UpdateDamageHistoryValues();
    void GetDamageHistory();
    void UpdateDamageHistory();
    void AddTakenDamage();
    void RecentDamageFrom();
    void GetMostRecentDamageHistoryIndexFor();
    void WeeklyShouldExplodeOnDeath();
    void CanCountHeadshots();
    void AdjustRadiusDamage();
    void UpdateLastTimeDamageHappened();
    void AdjustDamage();
    void eventTakeDamage();
    void TakeRadiusDamage();
    void TakeFallingDamage();
    void eventHealDamage();
    void HandleMomentum();
    void GetHealthPercentage();
    void IsResistantTo();
    void IsVulnerableTo();
    void SetThirdPersonAttachmentVisibility();
    void HideHead();
    void SetMeshLightingChannels();
    void SetMeshVisibility();
    void PostTeleport();
    void RestoreAirControlTimer();
    void JumpOffPawn();
    void CanBeBaseForPawn();
    void eventTouch();
    void CannotJumpNow();
    void DoJump();
    void SetSprinting();
    void eventUpdateSprinting();
    void IsSurrounded();
    void IsPawnMovingTowardMe();
    void IsPawnMovingAwayFromMe();
    void IsUsingSuperSpeed();
    void SetCloaked();
    void GetAutoLookAtLocation();
    void GetAutoTargetBones();
    void GetAdjustedAimFor();
    void eventGetBaseAimRotation();
    void ANIMNOTIFY_SpawnedKActor();
    void ANIMNOTIFY_ShellEject();
    void SetNightVisionLight();
    void StopPartialZedTime();
    void ShouldPlaySpecialMeleeAnims();
    void ShouldPlayHeadlessMeleeAnims();
    void ThrowActiveWeapon();
    void CanReloadWeapon();
    void WeaponBob();
    void GetWeaponAttachmentAnimRateByte();
    void WeaponStoppedFiring();
    void WeaponFired();
    void WeaponAttachmentChanged();
    void SetFirstPersonVisibility();
    void AddDefaultInventory();
    void PlayWeaponSwitch();
    void NotifyInventoryWeightChanged();
    void ToggleEquipment();
    void SetAfflictionSpeedModifier();
    void UpdateGroundSpeed();
    void WeaponStateChanged();
    void MeleeImpactNotify();
    void IsDoingMeleeAttack();
    void SetWeaponAttachmentVisibility();
    void eventStartCrouch();
    void eventEndCrouch();
    void eventEndViewTarget();
    void eventBecomeViewTarget();
    void GetEyeHeight();
    void GetPawnViewLocation();
    void UpdateWalkBob();
    void SmoothEyeHeight();
    void eventUpdateEyeHeight();
    void SetBaseEyeheight();
    void eventBaseChange();
    void CalcCamera();
    void eventUsePlayerControlledZedSkin();
    void UpdateGameplayMICParams();
    void SetCharacterAnimationInfo();
    void ProcessViewRotation();
    void SetCharacterArch();
    void OnCharacterMeshChanged();
    void InitRBSettings();
    void eventIsSameTeam();
    void UnPossessed();
    void PossessedBy();
    void eventReplicatedEvent();
    void eventDestroyed();
    void Reset();
    void eventPostBeginPlay();
    void eventPreBeginPlay();
    void ForceUnCrouch();
    void ClearBloodDecals();
    void AllowFirstPersonPreshadows();
    void GetPerk();
    void GetCharacterInfo();
    void ForceOpenActorChannel();
    void FitCollision();
};

UClass* AKFPawn::pClassPointer = NULL;

// Class KFGame.KFAfflictionManager
// 0x003C (0x009C - 0x0060)
class UKFAfflictionManager : public UObject {
   public:
    TArray<class UClass*>
        AfflictionClasses;  // 0x0060 (0x0010) [0x0000000000000000]
    TArray<class UKFAfflictionBase*>
        Afflictions;  // 0x0070 (0x0010) [0x0000000000000000]
    TArray<class UKFAfflictionBase*>
        AfflictionTickArray;  // 0x0080 (0x0010) [0x0000000000000000]
    DWORD bDebugLog : 1;  // 0x0090 (0x0004) [0x0000000000000000] [0x00000001]
    float FireFullyCharredDuration;   // 0x0094 (0x0004) [0x0000000000000000]
    float FireCharPercentThreshhold;  // 0x0098 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3515];

        return pClassPointer;
    };

    void UpdateMaterialParameter();
    void ToggleEffects();
    void ShutDown();
    void GetAfflictionSpeedModifier();
    void GetAfflictionDamageModifier();
    void GetAfflictionStunModifier();
    void GetAfflictionStumbleModifier();
    void GetAfflictionKnockdownModifier();
    void GetAfflictionDuration();
    void VerifyAfflictionInstance();
    void GetAfflictionVulnerability();
    void AccrueAffliction();
    void ProcessEffectBasedAfflictions();
    void ProcessHitReactionAfflictions();
    void ProcessSpecialMoveAfflictions();
    void GetPredictedHitReaction();
    void NotifyTakeHit();
};

UClass* UKFAfflictionManager::pClassPointer = NULL;

// Class KFGame.KFCharacterAttachment
// 0x0070 (0x00D0 - 0x0060)
class UKFCharacterAttachment : public UObject {
   public:
    class UTexture* UITexture;        // 0x0060 (0x0008) [0x0000000000000000]
    DWORD bIsSkeletalAttachment : 1;  // 0x0068 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    struct FString MeshName;          // 0x006C (0x0010) [0x0000000000000000]
    struct FName SocketName;          // 0x007C (0x0008) [0x0000000000000000]
    float MaxDrawDistance;            // 0x0084 (0x0004) [0x0000000000000000]
    int SkinMaterialID;               // 0x0088 (0x0004) [0x0000000000000000]
    TArray<struct FSkinVariant>
        SkinVariations;  // 0x008C (0x0010) [0x0000000000000000]
    struct FAttachmentOverrideList
        OverrideList;  // 0x009C (0x0014) [0x0000000000000000]
    TArray<unsigned char>
        SpecialOverrideIds;  // 0x00B0 (0x0010) [0x0000000000000000]
    TArray<class UKFCharacterAttachment*>
        DefaultSpecialOverrideAttachments;  // 0x00C0 (0x0010)
                                            // [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3517];

        return pClassPointer;
    };
};

UClass* UKFCharacterAttachment::pClassPointer = NULL;

// Class KFGame.KFCharacterInfoBase
// 0x0078 (0x00D8 - 0x0060)
class UKFCharacterInfoBase : public UObject {
   public:
    float DefaultMeshScale;             // 0x0060 (0x0004) [0x0000000000000000]
    class UAnimTree* AnimTreeTemplate;  // 0x0064 (0x0008) [0x0000000000000000]
    TArray<class UAnimSet*> AnimSets;   // 0x006C (0x0010) [0x0000000000000000]
    class UKFPawnAnimInfo*
        AnimArchetype;               // 0x007C (0x0008) [0x0000000000000000]
    class UPhysicsAsset* PhysAsset;  // 0x0084 (0x0008) [0x0000000000000000]
    class UKFPawnSoundGroup*
        SoundGroupArch;                 // 0x008C (0x0008) [0x0000000000000000]
    struct FString VoiceGroupArchName;  // 0x0094 (0x0010) [0x0000000000000000]
    TArray<class UKFSkinTypeEffects*>
        ImpactSkins;  // 0x00A4 (0x0010) [0x0000000000000000]
    struct FName
        BloodPoolOriginBoneName;  // 0x00B4 (0x0008) [0x0000000000000000]
    int GoreFXMICIdx;             // 0x00BC (0x0004) [0x0000000000000000]
    class UTexture*
        DefaultHeadPortrait;  // 0x00C0 (0x0008) [0x0000000000000000]
    TArray<class UTexture*>
        DefaultTeamHeadPortrait;  // 0x00C8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3519];

        return pClassPointer;
    };

    void SetCharacterAnimFromArch();
    void GetWeaponAnimSetIdx();
    void SetFirstPersonArmsFromArch();
    void SetBodySkin();
    void SetBodyMesh();
    void SetCharacterMeshFromArch();
    void SetCharacterFromArch();
    void GetCharPortrait();
};

UClass* UKFCharacterInfoBase::pClassPointer = NULL;

// Class KFGame.KFCharacterInfo_Human
// 0x0100 (0x01D8 - 0x00D8)
class UKFCharacterInfo_Human : public UKFCharacterInfoBase {
   public:
    int UnlockAssetID;    // 0x00D8 (0x0004) [0x0000000000000000]
    DWORD bIsFemale : 1;  // 0x00DC (0x0004) [0x0000000000000000] [0x00000001]
    int HeadMaterialID;   // 0x00E0 (0x0004) [0x0000000000000000]
    int BodyMaterialID;   // 0x00E4 (0x0004) [0x0000000000000000]
    TArray<struct FOutfitVariants>
        BodyVariants;  // 0x00E8 (0x0010) [0x0000000000000000]
    TArray<struct FOutfitVariants>
        HeadVariants;  // 0x00F8 (0x0010) [0x0000000000000000]
    TArray<struct FAttachmentVariants>
        CosmeticVariants;  // 0x0108 (0x0010) [0x0000000000000000]
    TArray<struct FFirstPersonArmVariants>
        CharacterArmVariants;           // 0x0118 (0x0010) [0x0000000000000000]
    struct FString ArmMeshPackageName;  // 0x0128 (0x0010) [0x0000000000000000]
    class USkeletalMesh* ArmMesh;       // 0x0138 (0x0008) [0x0000000000000000]
    struct FString ArmSkinPackageName;  // 0x0140 (0x0010) [0x0000000000000000]
    struct FName
        FavoriteWeaponClassNames[0x8];  // 0x0150 (0x0040) [0x0000000000000000]
    class UClass*
        FavoriteWeaponClassDefs[0x8];  // 0x0190 (0x0040) [0x0000000000000000]
    class UAnimSet* EmoteAnimset;      // 0x01D0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3521];

        return pClassPointer;
    };

    void SetCharacterAnimFromArch();
    void GetWeaponAnimSetIdx();
    void SetArmsMeshAndSkin();
    void SetFirstPersonArmsFromArch();
    void DetachAttachment();
    void RemoveAttachmentMeshAndSkin();
    void GetAttachmentSlotIndex();
    void GetOverrideCase();
    void DetachConflictingAttachments();
    void SetAttachmentMeshAndSkin();
    void SetAttachmentSkinMaterial();
    void IsAttachmentAvailable();
    void SetHeadMeshAndSkin();
    void SetHeadSkinMaterial();
    void SetBodySkinMaterial();
    void SetBodyMeshAndSkin();
    void InitCharacterMICs();
    void SetCharacterMeshFromArch();
    void SetCharacterFromArch();
    void GetFavoriteWeaponIndexOf();
    void GetFirstPersonArms();
    void GetMeshByIndex();
    void GetMesh();
    void GetAssetId();
};

UClass* UKFCharacterInfo_Human::pClassPointer = NULL;

// Class KFGame.KFCharacterInfo_Monster
// 0x0110 (0x01E8 - 0x00D8)
class UKFCharacterInfo_Monster : public UKFCharacterInfoBase {
   public:
    class USkeletalMesh* CharacterMesh;  // 0x00D8 (0x0008) [0x0000000000000000]
    TArray<class UMaterialInterface*>
        Skins;  // 0x00E0 (0x0010) [0x0000000000000000]
    TArray<class UMaterialInterface*>
        PlayerControlledSkins;        // 0x00F0 (0x0010) [0x0000000000000000]
    class USkeletalMesh* ServerMesh;  // 0x0100 (0x0008) [0x0000000000000000]
    TArray<int> ExtraMICIndices;      // 0x0108 (0x0010) [0x0000000000000000]
    TArray<class USkeletalMesh*>
        PACMeshList;  // 0x0118 (0x0010) [0x0000000000000000]
    TArray<struct FZedColorMod>
        RandomizedColors;              // 0x0128 (0x0010) [0x0000000000000000]
    struct FDoorSoundFx DoorHitSound;  // 0x0138 (0x0010) [0x0000000000000000]
    class UMaterialInstance*
        BloodSplatterDecalMaterial;  // 0x0148 (0x0008) [0x0000000000000000]
    class USkeletalMesh* GoreMesh;   // 0x0150 (0x0008) [0x0000000000000000]
    TArray<class UMaterialInterface*>
        GoreSkins;  // 0x0158 (0x0010) [0x0000000000000000]
    TArray<class UMaterialInterface*>
        PlayerControlledGoreSkins;  // 0x0168 (0x0010) [0x0000000000000000]
    TArray<class UKFGoreJointInfo*>
        GoreJointSettings;  // 0x0178 (0x0010) [0x0000000000000000]
    TArray<class UKFGoreChunkAttachmentInfo*>
        GoreChunkAttachments;  // 0x0188 (0x0010) [0x0000000000000000]
    TArray<class UKFGibletInfo*>
        GibletSettings;  // 0x0198 (0x0010) [0x0000000000000000]
    struct FMeleeSpecialDismembermentInfo
        SpecialMeleeDismemberment;  // 0x01A8 (0x0020) [0x0000000000000000]
    class UParticleSystem*
        ExplosionEffectTemplate;  // 0x01C8 (0x0008) [0x0000000000000000]
    class UParticleSystem*
        ObliterationEffectTemplate;  // 0x01D0 (0x0008) [0x0000000000000000]
    class UParticleSystem*
        DazedEffectTemplate;      // 0x01D8 (0x0008) [0x0000000000000000]
    float ExplosionGibScale;      // 0x01E0 (0x0004) [0x0000000000000000]
    float ExplosionImpulseScale;  // 0x01E4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3523];

        return pClassPointer;
    };

    void SetCharacterMeshFromArch();
};

UClass* UKFCharacterInfo_Monster::pClassPointer = NULL;

// Class KFGame.KFPawn_Human
// 0x013C (0x0C7C - 0x0B40)
class AKFPawn_Human : public AKFPawn {
   public:
    float LowHealthSpeedPenalty;       // 0x0B40 (0x0004) [0x0000000000000000]
    unsigned char CurrentWeaponState;  // 0x0B44 (0x0001) [0x0000000000580023]
                                       // ( CPF_Edit | CPF_Const | CPF_Net |
                                       // CPF_Component | CPF_NeedCtorLink )
    unsigned char
        WeaponAttachmentAnimRateByte;    // 0x0B45 (0x0001) [0x0000000000590023]
                                         // ( CPF_Edit | CPF_Const | CPF_Net |
                                         // CPF_Travel | CPF_Component |
                                         // CPF_NeedCtorLink )
    unsigned char ActivePerkMessageIdx;  // 0x0B46 (0x0001) [0x0000000000000000]
    unsigned char HealthToRegen;         // 0x0B47 (0x0001) [0x0000000000000000]
    unsigned char
        MaxArmor;         // 0x0B48 (0x0001) [0x00000000005A0000]              (
                          // CPF_EditConst | CPF_Component | CPF_NeedCtorLink )
    unsigned char Armor;  // 0x0B49 (0x0001) [0x00000000005B0000]              (
                          // CPF_Travel | CPF_EditConst | CPF_Component |
                          // CPF_NeedCtorLink )
    unsigned char IntegrityLevel_High;  // 0x0B4A (0x0001) [0x0000000000000000]
    unsigned char
        IntegrityLevel_Medium;         // 0x0B4B (0x0001) [0x0000000000000000]
    unsigned char IntegrityLevel_Low;  // 0x0B4C (0x0001) [0x0000000000000000]
    unsigned char
        MinEnemiesToTriggerSurrounded;  // 0x0B4D (0x0001) [0x0000000000000000]
    unsigned char HealingSpeedBoost;  // 0x0B4E (0x0001) [0x00000000005C0000] (
                                      // CPF_GlobalConfig | CPF_Component |
                                      // CPF_NeedCtorLink )
    unsigned char HealingDamageBoost;  // 0x0B4F (0x0001) [0x00000000005D0000]
                                       // ( CPF_Travel | CPF_GlobalConfig |
                                       // CPF_Component | CPF_NeedCtorLink )
    unsigned char HealingShield;       // 0x0B50 (0x0001) [0x00000000005E0000] (
                                  // CPF_EditConst | CPF_GlobalConfig |
                                  // CPF_Component | CPF_NeedCtorLink )
    int WeaponSkinItemId;  // 0x0B54 (0x0004) [0x00000000005F0000] ( CPF_Travel
                           // | CPF_EditConst | CPF_GlobalConfig | CPF_Component
                           // | CPF_NeedCtorLink )
    TArray<struct FName>
        DeathFaceAnims;             // 0x0B58 (0x0010) [0x0000000000000000]
    float BloodPoolDelay;           // 0x0B68 (0x0004) [0x0000000000000000]
    float PainSoundChanceOnHit;     // 0x0B6C (0x0004) [0x0000000000000000]
    float PainSoundCoolDown;        // 0x0B70 (0x0004) [0x0000000000000000]
    float PainSoundLastPlayedTime;  // 0x0B74 (0x0004) [0x0000000000000000]
    struct FString
        PerkFXEmitterPoolClassPath;  // 0x0B78 (0x0010) [0x0000000000000000]
    class AEmitterPool*
        PerkFXEmitterPool;  // 0x0B88 (0x0008) [0x0000000000000000]
    struct FName DefaultDeathMaterialEffectParamName;  // 0x0B90 (0x0008)
                                                       // [0x0000000000000000]
    float DefaultDeathMaterialEffectDuration;          // 0x0B98 (0x0004)
                                                       // [0x0000000000000000]
    float DeathMaterialEffectDuration;  // 0x0B9C (0x0004) [0x0000000000000000]
    float DeathMaterialEffectTimeRemaining;  // 0x0BA0 (0x0004)
                                             // [0x0000000000000000]
    struct FName
        DeathMaterialEffectParamName;  // 0x0BA4 (0x0008) [0x0000000000000000]
    class UKFFlashlightAttachment*
        FlashLight;  // 0x0BAC (0x0008) [0x0000000000000000]
    class UKFFlashlightAttachment*
        FlashLightTemplate;   // 0x0BB4 (0x0008) [0x0000000000000000]
    DWORD bFlashlightOn : 1;  // 0x0BBC (0x0004) [0x0000000000600023]
                              // [0x00000001] ( CPF_Edit | CPF_Const | CPF_Net |
                              // CPF_NeedCtorLink )
    DWORD
        bObjectivePlayer : 1;  // 0x0BBC (0x0004) [0x0000000000610000]
                               // [0x00000002] ( CPF_Travel | CPF_NeedCtorLink )
    DWORD bDisableTraderDialog : 1;  // 0x0BBC (0x0004) [0x000000000062000A]
                                     // [0x00000004] ( CPF_Const |
                                     // CPF_ExportObject | CPF_EditConst |
                                     // CPF_NeedCtorLink )
    float BatteryDrainRate;          // 0x0BC0 (0x0004) [0x0000000000000000]
    float BatteryRechargeRate;       // 0x0BC4 (0x0004) [0x0000000000000000]
    float BatteryCharge;             // 0x0BC8 (0x0004) [0x0000000000000000]
    float NVGBatteryDrainRate;       // 0x0BCC (0x0004) [0x0000000000000000]
    class UPointLightComponent*
        NightVisionLightTemplate;  // 0x0BD0 (0x0008) [0x0000000000000000]
    class UPointLightComponent*
        NightVisionLight;  // 0x0BD8 (0x0008) [0x0000000000000000]
    class UKFGFxMoviePlayer_PlayerInfo*
        PlayerPartyInfo;               // 0x0BE0 (0x0008) [0x0000000000000000]
    float HealthRegenRate;             // 0x0BE8 (0x0004) [0x0000000000000000]
    float HealerRewardScaler;          // 0x0BEC (0x0004) [0x0000000000000000]
    float ArmorAbsorbModifier_High;    // 0x0BF0 (0x0004) [0x0000000000000000]
    float ArmorAbsorbModifier_Medium;  // 0x0BF4 (0x0004) [0x0000000000000000]
    float ArmorAbsorbModifier_Low;     // 0x0BF8 (0x0004) [0x0000000000000000]
    float MinHealthPctToTriggerSurrounded;  // 0x0BFC (0x0004)
                                            // [0x0000000000000000]
    TArray<struct FString>
        ActiveSkillIconPaths;  // 0x0C00 (0x0010) [0x0000000000000000]
    class AKFExplosion_AirborneAgent*
        AAExplosionActor;      // 0x0C10 (0x0008) [0x0000000000000000]
    int DoshCaughtStreakAmt;   // 0x0C18 (0x0004) [0x0000000000000000]
    float LastDoshCaughtTime;  // 0x0C1C (0x0004) [0x0000000000000000]
    class APlayerReplicationInfo*
        LastDoshCaughtGiver;   // 0x0C20 (0x0008) [0x0000000000000000]
    int ZedsKilledStreakAmt;   // 0x0C28 (0x0004) [0x0000000000000000]
    float LastZedKilledTime;   // 0x0C2C (0x0004) [0x0000000000000000]
    int DamageTakenStreakAmt;  // 0x0C30 (0x0004) [0x0000000000000000]
    float
        LastDamageTakenStreakStartTime;  // 0x0C34 (0x0004) [0x0000000000000000]
    float InitialContinousDamageTime;    // 0x0C38 (0x0004) [0x0000000000000000]
    float IdleStartTime;                 // 0x0C3C (0x0004) [0x0000000000000000]
    int EnvironmentDialogEventID;        // 0x0C40 (0x0004) [0x0000000000000000]
    float SprintTowardZedStartTime;      // 0x0C44 (0x0004) [0x0000000000000000]
    float SprintStartTime;               // 0x0C48 (0x0004) [0x0000000000000000]
    class UAkComponent*
        TraderDialogAkComponent;  // 0x0C4C (0x0008) [0x0000000000000000]
    struct FDialogResponseInfo
        DlgRespInfo;  // 0x0C54 (0x0018) [0x0000000000000000]
    struct FScriptDelegate
        __OnFinishedDialog__Delegate;  // 0x0C6C (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x0C70 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3525];

        return pClassPointer;
    };

    void DisplayDebug();
    void DrawPerkHUD();
    void DrawHUD();
    void DrawDoors();
    void SetMeshLightingChannels();
    void SetFirstPersonVisibility();
    void eventNotifyOutOfBattery();
    void ServerSetFlashlight();
    void SetFlashlight();
    void ToggleEquipment();
    void Timer_CheckSurrounded();
    void eventBump();
    void DoJump();
    void SetSprinting();
    void StopTraderDialog();
    void PlayTraderDialog();
    void TimeSpentIdling();
    void ResetIdleStartTime();
    void UpdateContinuousDamage();
    void UpdateDamageTakenStreak();
    void UpdateKillStreak();
    void CaughtDoshDialogTimer();
    void UpdateDoshCaught();
    void SetDialogResponseDelegate();
    void HandleDialogResponse();
    void OnFinishedDialog();
    void GetUpdatedSkillIndicators();
    void GetPerkDoTScaler();
    void HasExplosiveResistance();
    void ResetHealingShield();
    void UpdateHealingShield();
    void GetHealingShieldModifier();
    void ResetHealingDamageBoost();
    void UpdateHealingDamageBoost();
    void GetHealingDamageBoostModifier();
    void ResetHealingSpeedBoost();
    void UpdateHealingSpeedBoost();
    void StartAirBorneAgentEvent();
    void SacrificeExplode();
    void UpdateDeathMaterialEffect();
    void PlayDeathMaterialEffects();
    void eventTakeDamage();
    void AdjustDamage();
    void Died();
    void PlayDying();
    void TerminateEffectsOnDeath();
    void SetNightVisionLight();
    void AddBattleBlood();
    void PlayDamageInstigatorHitEffects();
    void eventRigidBodyCollision();
    void PlayTakeHitEffects();
    void LeaveBloodPool();
    void ShieldAbsorb();
    void GetMaxArmor();
    void GiveMaxArmor();
    void AddArmor();
    void GiveHealthOverTime();
    void eventHealDamage();
    void CheckAndEndActiveEMoteSpecialMove();
    void StopAllAnimations();
    void eventPostInitAnimTree();
    void GetWeaponAttachmentAnimRateByte();
    void SetWeaponAttachmentAnimRateByte();
    void WeaponStateChanged();
    void GetHealthMod();
    void UpdateGroundSpeed();
    void eventEndCrouch();
    void eventStartCrouch();
    void PlayWeaponSwitch();
    void AddDefaultInventory();
    void OnCharacterMeshChanged();
    void SetCharacterArch();
    void eventDestroyed();
    void eventReplicatedEvent();
    void NotifyTeamChanged();
    void PossessedBy();
    void eventPreBeginPlay();
    void eventTick();
};

UClass* AKFPawn_Human::pClassPointer = NULL;

// Class KFGame.KFPawn_Customization
// 0x002C (0x0CA8 - 0x0C7C)
class AKFPawn_Customization : public AKFPawn_Human {
   public:
    struct FsReplicatedMovementData
        ReplicatedMovementData;  // 0x0C7C (0x0018) [0x0000000000630000] (
                                 // CPF_Travel | CPF_EditConst |
                                 // CPF_NeedCtorLink )
    DWORD
        bServerHidden : 1;  // 0x0C94 (0x0004) [0x0000000000640000] [0x00000001]
                            // ( CPF_GlobalConfig | CPF_NeedCtorLink )
    DWORD
        bLocalHidden : 1;  // 0x0C94 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bUsingCustomizationPoint : 1;  // 0x0C94 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    class UAnimSet*
        MaleCustomizationAnimSet;  // 0x0C98 (0x0008) [0x0000000000000000]
    class UAnimSet*
        FemaleCustomizationAnimSet;  // 0x0CA0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3527];

        return pClassPointer;
    };

    void Reset();
    void InitializeCustomizationPawn();
    void eventTakeDamage();
    void MoveToCustomizationPoint();
    void NotifyTeamChanged();
    void eventOnAnimEnd();
    void PlayEmoteAnimation();
    void PlayRandomIdleAnimation();
    void AttachWeaponByItemDefinition();
    void SetCharacterAnimationInfo();
    void eventPostInitAnimTree();
    void FaceRotation();
    void ClientSetRotation();
    void SetServerHidden();
    void OnMovementDataUpdated();
    void SetUpdatedMovementData();
    void eventReplicatedEvent();
    void UpdateCustomizationPawnVisibility();
};

UClass* AKFPawn_Customization::pClassPointer = NULL;

// Class KFGame.KFPawn_Monster
// 0x0274 (0x0DB4 - 0x0B40)
class AKFPawn_Monster : public AKFPawn {
   public:
    DWORD bLargeZed : 1;   // 0x0B40 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bVersusZed : 1;  // 0x0B40 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bCanGrabAttack : 1;   // 0x0B40 (0x0004) [0x0000000000000000]
                                // [0x00000004]
    DWORD bCanMeleeAttack : 1;  // 0x0B40 (0x0004) [0x0000000000000000]
                                // [0x00000008]
    DWORD bHasExtraSprintJumpVelocity : 1;  // 0x0B40 (0x0004)
                                            // [0x0000000000000000] [0x00000010]
    DWORD bIsHeadless : 1;  // 0x0B40 (0x0004) [0x0000000000580000] [0x00000020]
                            // ( CPF_Component | CPF_NeedCtorLink )
    DWORD bHasReducedMeleeDamage : 1;  // 0x0B40 (0x0004) [0x0000000000000000]
                                       // [0x00000040]
    DWORD bShowHealth : 1;  // 0x0B40 (0x0004) [0x0000000000000000] [0x00000080]
    DWORD bCheckingExtraHeadDamage : 1;  // 0x0B40 (0x0004) [0x0000000000000000]
                                         // [0x00000100]
    DWORD bJumped : 1;      // 0x0B40 (0x0004) [0x0000000000000000] [0x00000200]
    DWORD bIsPoisoned : 1;  // 0x0B40 (0x0004) [0x0000000000590000] [0x00000400]
                            // ( CPF_Travel | CPF_Component | CPF_NeedCtorLink )
    DWORD bMicrowavePanicked : 1;      // 0x0B40 (0x0004) [0x0000000000000000]
                                       // [0x00000800]
    DWORD bKnockdownWhenJumpedOn : 1;  // 0x0B40 (0x0004) [0x0000000000000000]
                                       // [0x00001000]
    DWORD
        bDisableGoreMeshWhileAlive : 1;  // 0x0B40 (0x0004) [0x00000000005A0000]
                                         // [0x00002000] ( CPF_EditConst |
                                         // CPF_Component | CPF_NeedCtorLink )
    DWORD bUseExplosiveDeath : 1;        // 0x0B40 (0x0004) [0x00000000005B0000]
                                   // [0x00004000] ( CPF_Travel | CPF_EditConst
                                   // | CPF_Component | CPF_NeedCtorLink )
    DWORD bUseDamageInflation : 1;  // 0x0B40 (0x0004) [0x00000000005C0000]
                                    // [0x00008000] ( CPF_GlobalConfig |
                                    // CPF_Component | CPF_NeedCtorLink )
    DWORD bPlayPanicked : 1;        // 0x0B40 (0x0004) [0x00000000005D0000]
                              // [0x00010000] ( CPF_Travel | CPF_GlobalConfig |
                              // CPF_Component | CPF_NeedCtorLink )
    DWORD
        bPlayShambling : 1;  // 0x0B40 (0x0004) [0x00000000005E0000]
                             // [0x00020000] ( CPF_EditConst | CPF_GlobalConfig
                             // | CPF_Component | CPF_NeedCtorLink )
    DWORD bIsBlocking : 1;  // 0x0B40 (0x0004) [0x0000000000000000] [0x00040000]
    DWORD bCloakOnMeleeEnd : 1;          // 0x0B40 (0x0004) [0x0000000000000000]
                                         // [0x00080000]
    DWORD bIsCloakingSpottedByLP : 1;    // 0x0B40 (0x0004) [0x0000000000000000]
                                         // [0x00100000]
    DWORD bIsCloakingSpottedByTeam : 1;  // 0x0B40 (0x0004) [0x00000000005F000A]
                                         // [0x00200000] ( CPF_Const |
                                         // CPF_ExportObject | CPF_Travel |
                                         // CPF_EditConst | CPF_GlobalConfig |
                                         // CPF_Component | CPF_NeedCtorLink )
    DWORD bCanRage : 1;  // 0x0B40 (0x0004) [0x0000000000000000] [0x00400000]
    DWORD
        bIsEnraged : 1;  // 0x0B40 (0x0004) [0x0000000000600023] [0x00800000] (
                         // CPF_Edit | CPF_Const | CPF_Net | CPF_NeedCtorLink )
    DWORD bIsStalkerClass : 1;     // 0x0B40 (0x0004) [0x0000000000000000]
                                   // [0x01000000]
    DWORD bIsCrawlerClass : 1;     // 0x0B40 (0x0004) [0x0000000000000000]
                                   // [0x02000000]
    DWORD bIsFleshpoundClass : 1;  // 0x0B40 (0x0004) [0x0000000000000000]
                                   // [0x04000000]
    DWORD
        bIsClotClass : 1;  // 0x0B40 (0x0004) [0x0000000000000000] [0x08000000]
    DWORD
        bIsBloatClass : 1;  // 0x0B40 (0x0004) [0x0000000000000000] [0x10000000]
    DWORD bMatchEnemySpeed : 1;         // 0x0B40 (0x0004) [0x0000000000000000]
                                        // [0x20000000]
    DWORD bRestoreCollisionOnLand : 1;  // 0x0B40 (0x0004) [0x0000000000000000]
                                        // [0x40000000]
    DWORD bPlayedExplosionEffect : 1;   // 0x0B40 (0x0004) [0x0000000000000000]
                                        // [0x80000000]
    DWORD bCouldTurnIntoShrapnel : 1;   // 0x0B44 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD
        bDisableHeadless : 1;  // 0x0B44 (0x0004) [0x0000000000610000]
                               // [0x00000002] ( CPF_Travel | CPF_NeedCtorLink )
    DWORD bDebug_DrawOverheadInfo : 1;  // 0x0B44 (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    DWORD bDebug_DrawSprintingOverheadInfo : 1;  // 0x0B44 (0x0004)
                                                 // [0x0000000000000000]
                                                 // [0x00000008]
    DWORD bDebug_UseIconForShowingSprintingOverheadInfo : 1;  // 0x0B44 (0x0004)
                                                              // [0x0000000000000000]
                                                              // [0x00000010]
    DWORD
        bReducedZedOnZedPinchPointCollisionStateActive : 1;  // 0x0B44 (0x0004)
                                                             // [0x0000000000000000]
                                                             // [0x00000020]
    DWORD bOnDeathAchivementbDisabled : 1;  // 0x0B44 (0x0004)
                                            // [0x0000000000000000] [0x00000040]
    DWORD bOverrideAsBoss : 1;  // 0x0B44 (0x0004) [0x0000000000620000]
                                // [0x00000080] ( CPF_EditConst |
                                // CPF_NeedCtorLink )
    DWORD bUseAnimatedTheatricCamera : 1;  // 0x0B44 (0x0004)
                                           // [0x0000000000000000] [0x00000100]
    struct FString MonsterArchPath;  // 0x0B48 (0x0010) [0x0000000000000000]
    class UKFCharacterInfo_Monster*
        CharacterMonsterArch;      // 0x0B58 (0x0008) [0x0000000000000000]
    class UClass* ElitePawnClass;  // 0x0B60 (0x0008) [0x0000000000000000]
    struct FViewOffsetData
        ThirdPersonViewOffset;   // 0x0B68 (0x0024) [0x0000000000000000]
    int RandomColorIdx;          // 0x0B8C (0x0004) [0x0000000000000000]
    float SprintChance;          // 0x0B90 (0x0004) [0x0000000000000000]
    float GrabAttackFrequency;   // 0x0B94 (0x0004) [0x0000000000000000]
    float DifficultyDamageMod;   // 0x0B98 (0x0004) [0x0000000000000000]
    float GameResistancePct;     // 0x0B9C (0x0004) [0x0000000000000000]
    float HeadlessBleedOutTime;  // 0x0BA0 (0x0004) [0x0000000000000000]
    unsigned char
        MaxHeadChunkGoreWhileAlive;  // 0x0BA4 (0x0001) [0x0000000000630000] (
                                     // CPF_Travel | CPF_EditConst |
                                     // CPF_NeedCtorLink )
    unsigned char ParryResistance;  // 0x0BA5 (0x0001) [0x0000000000000000]
    unsigned char
        RepInflateMatParam;  // 0x0BA6 (0x0001) [0x0000000000640000] (
                             // CPF_GlobalConfig | CPF_NeedCtorLink )
    unsigned char
        RepDamageInflateParam;  // 0x0BA7 (0x0001) [0x0000000000650000] (
                                // CPF_Travel | CPF_GlobalConfig |
                                // CPF_NeedCtorLink )
    unsigned char
        RepBleedInflateMatParam;  // 0x0BA8 (0x0001) [0x0000000000660000] (
                                  // CPF_EditConst | CPF_GlobalConfig |
                                  // CPF_NeedCtorLink )
    unsigned char
        MinSpawnSquadSizeType;  // 0x0BA9 (0x0001) [0x0000000000000000]
    class UKFMeleeHelperAI*
        MeleeAttackHelper;  // 0x0BAC (0x0008) [0x0000000000000000]
    int DoshValue;          // 0x0BB4 (0x0004) [0x0000000000000000]
    float XPValues[0x4];    // 0x0BB8 (0x0010) [0x0000000000000000]
    TArray<struct FName>
        WeakSpotSocketNames;  // 0x0BC8 (0x0010) [0x0000000000000000]
    TArray<struct FDamageModifierInfo>
        DamageTypeModifiers;  // 0x0BD8 (0x0010) [0x0000000000000000]
    TArray<struct FDamageModifierInfo>
        LiveDamageTypeModifiers;       // 0x0BE8 (0x0010) [0x0000000000000000]
    float ZedBumpDamageScale;          // 0x0BF8 (0x0004) [0x0000000000000000]
    float HumanBaseMeleeDamage;        // 0x0BFC (0x0004) [0x0000000000000000]
    class UClass* DifficultySettings;  // 0x0C00 (0x0008) [0x0000000000000000]
    TArray<unsigned char>
        MoveListGamepadScheme;  // 0x0C08 (0x0010) [0x0000000000000000]
    TArray<struct FSpecialMoveCooldownInfo>
        SpecialMoveCooldowns;          // 0x0C18 (0x0010) [0x0000000000000000]
    float LastAttackHumanWarningTime;  // 0x0C28 (0x0004) [0x0000000000000000]
    int OldHealth;                     // 0x0C2C (0x0004) [0x0000000000000000]
    float ZeroHealthInflation;         // 0x0C30 (0x0004) [0x0000000000000000]
    float DamageInflationRate;         // 0x0C34 (0x0004) [0x0000000000000000]
    float DamageDeflationRate;         // 0x0C38 (0x0004) [0x0000000000000000]
    float
        IntendedDamageInflationPercent;  // 0x0C3C (0x0004) [0x0000000000000000]
    float DamageInflationPercent;        // 0x0C40 (0x0004) [0x0000000000000000]
    float InflateDeathGravity;  // 0x0C44 (0x0004) [0x0000000000670000] (
                                // CPF_Travel | CPF_EditConst | CPF_GlobalConfig
                                // | CPF_NeedCtorLink )
    float InflationExplosionTimer;  // 0x0C48 (0x0004) [0x0000000000680000] (
                                    // CPF_Component | CPF_NeedCtorLink )
    class UKFAnim_RandomScripted*
        WalkBlendList;  // 0x0C4C (0x0008) [0x0000000000000000]
    struct FsBlockInfo
        DifficultyBlockSettings;       // 0x0C54 (0x0024) [0x0000000000000000]
    float MinBlockFOV;                 // 0x0C78 (0x0004) [0x0000000000000000]
    float BlockSprintSpeedModifier;    // 0x0C7C (0x0004) [0x0000000000000000]
    float LastBlockTime;               // 0x0C80 (0x0004) [0x0000000000000000]
    float KnockedDownBySonicWaveOdds;  // 0x0C84 (0x0004) [0x0000000000000000]
    float LastSpottedStatusUpdate;     // 0x0C88 (0x0004) [0x0000000000000000]
    class AKFPlayerController*
        LastStoredCC;  // 0x0C8C (0x0008) [0x0000000000000000]
    class UParticleSystemComponent*
        RallyPSC;  // 0x0C94 (0x0008) [0x0000000000000000]
    class UParticleSystemComponent*
        RallyHandPSCs[0x2];  // 0x0C9C (0x0010) [0x0000000000000000]
    struct FsRallyInfo
        DifficultyRallySettings;       // 0x0CAC (0x0010) [0x0000000000000000]
    float NormalGroundSpeed;           // 0x0CBC (0x0004) [0x0000000000000000]
    float NormalSprintSpeed;           // 0x0CC0 (0x0004) [0x0000000000000000]
    float InitialGroundSpeedModifier;  // 0x0CC4 (0x0004) [0x0000000000000000]
    float LastAISpeedCheckTime;        // 0x0CC8 (0x0004) [0x0000000000000000]
    float LastLOSOrRelevantTime;       // 0x0CCC (0x0004) [0x0000000000000000]
    float MatchEnemySpeedAtDistance;   // 0x0CD0 (0x0004) [0x0000000000000000]
    float MinimumEnemySpeedToMatch;    // 0x0CD4 (0x0004) [0x0000000000000000]
    float PursuitSpeedScale;           // 0x0CD8 (0x0004) [0x0000000000000000]
    float ReachedEnemyThresholdScale;  // 0x0CDC (0x0004) [0x0000000000000000]
    float ReachedGoalThresh_Walking;   // 0x0CE0 (0x0004) [0x0000000000000000]
    float ReachedGoalThresh_Spider;    // 0x0CE4 (0x0004) [0x0000000000000000]
    float LastBumpTime;                // 0x0CE8 (0x0004) [0x0000000000000000]
    float BumpFrequency;               // 0x0CEC (0x0004) [0x0000000000000000]
    class UClass* BumpDamageType;      // 0x0CF0 (0x0008) [0x0000000000000000]
    class UClass* JumpBumpDamageType;  // 0x0CF8 (0x0008) [0x0000000000000000]
    float
        FootstepCameraShakeInnerRadius;  // 0x0D00 (0x0004) [0x0000000000000000]
    float
        FootstepCameraShakeOuterRadius;  // 0x0D04 (0x0004) [0x0000000000000000]
    class UCameraShake*
        FootstepCameraShake;           // 0x0D08 (0x0008) [0x0000000000000000]
    float DesiredAdjustedGroundSpeed;  // 0x0D10 (0x0004) [0x0000000000000000]
    float DesiredAdjustedSprintSpeed;  // 0x0D14 (0x0004) [0x0000000000000000]
    float SpeedAdjustTransitionRate;   // 0x0D18 (0x0004) [0x0000000000000000]
    TArray<struct FAttachedGoreChunkInfo>
        AttachedGoreChunks;    // 0x0D1C (0x0010) [0x0000000000000000]
    int NumHeadChunksRemoved;  // 0x0D2C (0x0004) [0x0000000000000000]
    TArray<struct FName>
        BrokenHeadBones;              // 0x0D30 (0x0010) [0x0000000000000000]
    float LastNapalmInfectCheckTime;  // 0x0D40 (0x0004) [0x0000000000000000]
    int DeadHorseHitStreakAmt;        // 0x0D44 (0x0004) [0x0000000000000000]
    float LastDeadHorseHitTime;       // 0x0D48 (0x0004) [0x0000000000000000]
    float DefaultCollisionRadius;     // 0x0D4C (0x0004) [0x0000000000000000]
    class AKFTrigger_ChokePoint*
        CurrentChokePointTrigger;  // 0x0D50 (0x0008) [0x0000000000000000]
    float
        CollisionRadiusForReducedZedOnZedPinchPointCollisionState;  // 0x0D58
                                                                    // (0x0004)
                                                                    // [0x0000000000000000]
    int OnDeathAchievementID;  // 0x0D5C (0x0004) [0x0000000000000000]
    struct FString BossName;   // 0x0D60 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        BossCaptionStrings;  // 0x0D70 (0x0010) [0x0000000000000000]
    struct FName
        TheatricCameraSocketName;  // 0x0D80 (0x0008) [0x0000000000000000]
    struct FVector
        TheatricCameraAnimOffset;  // 0x0D88 (0x000C) [0x0000000000000000]
    struct FScriptDelegate
        __GoreChunkAttachmentCriteria__Delegate;  // 0x0D94 (0x0010)
                                                  // [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x0D98 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __GoreChunkDetachmentCriteria__Delegate;  // 0x0DA4 (0x0010)
                                                  // [0x0000000000000000]
    unsigned char UnknownData01[0x4];  // 0x0DA8 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3529];

        return pClassPointer;
    };

    void DisablebOnDeathAchivement();
    void GetZedOnDeathAchievement();
    void ShouldGrandOnDeathAchievement();
    void GetLocalizedName();
    void MotivatePlayerToAttack();
    void PlayLandedDialog();
    void PlayLeapedDialog();
    void GetTraderAdviceID();
    void UpdateDeadHorseStreak();
    void GetSpotterDialogID();
    void GetKillerDialogID();
    void GetOverheadDebugText();
    void DrawDebugOverheadSprintingText();
    void DrawDebugOverheadText();
    void eventPostRenderFor();
    void SetDebugTextRendering();
    void GetPerkDoTScaler();
    void IsBloatClass();
    void IsClotClass();
    void IsFleshpoundClass();
    void IsCrawlerClass();
    void IsStalkerClass();
    void eventUpdateSpottedStatus();
    void IsABoss();
    void IsLargeZed();
    void HandleDamageInflation();
    void GetCurrentInflation();
    void eventSetDamageInflation();
    void ChokePointTimer();
    void NotifyMeleeAttackFinished();
    void ForceBreakAllConstraints();
    void eventHasMouth();
    void ShouldPlayHeadlessMeleeAnims();
    void GetHeadHealthPercent();
    void TakeHitZoneDamage();
    void PlayDismemberment();
    void PlayHeadAsplode();
    void HitZoneInjured();
    void ApplyHeadChunkGore();
    void ApplyTakeHitFxGore();
    void ApplyObliterationFxGore();
    void ApplyRadialFxGore();
    void HandlePartialGoreAndGibs();
    void ApplyBloodDecals();
    void TryPlayHitReactionAnim();
    void HandleGoreChunkAttachments();
    void ShouldDetachSkullChunk();
    void ShouldAttachSkullChunk();
    void UpdateGoreChunkData();
    void ShouldAllowHeadBoneToBreak();
    void AddBrokenHeadBone();
    void HeadBoneAlreadyBroken();
    void PlayHitZoneGoreSounds();
    void PlayDyingSound();
    void PlayLivingHitEffects();
    void HandleRagdollImpulseEffects();
    void PlayDeadHitEffects();
    void PlayTakeHitEffects();
    void eventRigidBodyCollision();
    void GetClosestHitBones();
    void eventNotifyGoreMeshActive();
    void SwitchToGoreMesh();
    void StopLookingAtPawn();
    void LookAtPawn();
    void GetPawnToLookAt();
    void GetStepBackInCombatOdds();
    void GetCircleStrafeDuration();
    void msg();
    void NotifyAnimInterrupt();
    void ANIMNOTIFY_Knockdown();
    void MeleeSpecialMoveEnded();
    void CallOutCloaking();
    void SetCloaked();
    void NotifyAttackParried();
    void UpdateGameplayMICParams();
    void IsImpaired();
    void IsHeadless();
    void ShouldBeWandering();
    void EndPanicWander();
    void CausePanicWander();
    void OnStackingAfflictionChanged();
    void CauseHeadTrauma();
    void ShrapnelExplode();
    void InfectWithNapalm();
    void CanNapalmInfect();
    void IsNapalmInfected();
    void CanShowHealth();
    void ResetHealthVisibilty();
    void eventOnRigidBodyLinearConstraintViolated();
    void eventDestroyed();
    void Died();
    void GetRallyBoostResistance();
    void GetRallyBoostDamage();
    void GetDifficultyRallyInfo();
    void SetRallySettings();
    void Timer_EndRallyBoost();
    void Rally();
    void BleedOutTimer();
    void NotifyMeleeTakeHit();
    void PlayHit();
    void NotifyTakeHit();
    void HasReducedMeleeDamage();
    void eventHealDamage();
    void ApplyBlockingDamageModifier();
    void AppendLiveDamageTypeModifiers();
    void GetDamageTypeModifier();
    void AdjustDamage();
    void eventTakeDamage();
    void CanCountHeadshots();
    void InflationExplode();
    void PlayExplosiveDeath();
    void PlayInflationDeath();
    void PlayDying();
    void ShouldDrawBossIcon();
    void eventIsActiveBoss();
    void AdjustAffliction();
    void GetMinBlockFOV();
    void GetBlockSettings();
    void SetBlockSettings();
    void CanBlock();
    void UseAdjustedControllerSensitivity();
    void PutAllMovesOnCooldown();
    void GetSpecialMoveCooldowns();
    void GetSpecialMoveCooldownTimeRemaining();
    void GetSpecialMoveCooldownPercent();
    void NotifySpecialMoveEnded();
    void StopPlayerZedMove();
    void StartPlayerZedMove();
    void eventIsInAnyAttackTagRange();
    void eventIsInAttackTagRange();
    void NotifyMeleeDamageDealt();
    void MeleeImpactNotify();
    void NotifyFriendlyAIDamageTaken();
    void eventIsEnraged();
    void SetEnraged();
    void IsLocationValidForCombat();
    void GetEnemy();
    void InAnyAttackTagRange();
    void InAttackTagRange();
    void InMeleeRange();
    void InChargeRange();
    void IsValidEnemyTargetFor();
    void SetZedTimeSpeedScale();
    void CrushedBy();
    void SetMovementPhysics();
    void eventLanded();
    void TakeFallingDamage();
    void GetBumpAttackDamageType();
    void GetDirectionalJumpScale();
    void GetSprintJumpVelocity();
    void GetJumpZ();
    void DoJump();
    void eventStuckOnPawn();
    void SetSprinting();
    void eventTouch();
    void HandleDestructibleBump();
    void NotifyCollideWithActor();
    void HandleAIDoorBump();
    void eventHitWall();
    void HandleMonsterBump();
    void eventBump();
    void eventSpiderBumpLevel();
    void eventPlayFootStepSound();
    void AdjustMovementSpeed();
    void GetBlockingSprintSpeedModifier();
    void eventUsePlayerControlledZedSkin();
    void GetCharacterMonsterInfo();
    void CanTakeOver();
    void ApplySpecialZoneHealthMod();
    void eventPostInitAnimTree();
    void eventBaseChange();
    void eventFellOutOfWorld();
    void PossessedBy();
    void NotifyTeamChanged();
    void eventPostBeginPlay();
    void eventCheckShouldAlwaysBeRelevant();
    void eventPreBeginPlay();
    void LastChanceLoad();
    void PreloadContent();
    void eventGetAIPawnClassToSpawn();
    void GetXPValue();
    void GetDoshValue();
    void eventReplicatedEvent();
    void CheckEncroachingWorldGeometry();
    void SetChokePointCollision();
    void SpiderPhysicsWallAdjust();
    void GoreChunkDetachmentCriteria();
    void GoreChunkAttachmentCriteria();
};

UClass* AKFPawn_Monster::pClassPointer = NULL;

// Class KFGame.KFPawn_MonsterBoss
// 0x00AC (0x0E60 - 0x0DB4)
class AKFPawn_MonsterBoss : public AKFPawn_Monster {
   public:
    class AKFPlayerController* KFPC;  // 0x0DB4 (0x0008) [0x0000000000000000]
    struct FBossMinionWaveInfo
        SummonWaves[0x4];                // 0x0DBC (0x0080) [0x0000000000000000]
    struct FVector2D NumMinionsToSpawn;  // 0x0E3C (0x0008) [0x0000000000000000]
    int CurrentBattlePhase;  // 0x0E44 (0x0004) [0x0000000000690000] (
                             // CPF_Travel | CPF_Component | CPF_NeedCtorLink )
    float LastPlayerAliveAttackRangeScale;  // 0x0E48 (0x0004)
                                            // [0x0000000000000000]
    float LastPlayerAliveStartTime;   // 0x0E4C (0x0004) [0x0000000000000000]
    float TimeUntilSpeedIncrease;     // 0x0E50 (0x0004) [0x0000000000000000]
    float SpeedLimitScalar;           // 0x0E54 (0x0004) [0x0000000000000000]
    float SpeedPctIncreasePerMinute;  // 0x0E58 (0x0004) [0x0000000000000000]
    float ActualSprintSpeed;          // 0x0E5C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3531];

        return pClassPointer;
    };

    void PlayGrabKilledDialog();
    void PlayGrabbedPlayerDialog();
    void PlayLandedDialog();
    void PlayLeapedDialog();
    void PlayHealDialog();
    void PlayGrabDialog();
    void PlayMonologue();
    void PlayHeadAsplode();
    void CauseHeadTrauma();
    void PlayBossMusic();
    void Died();
    void IsABoss();
    void eventIsActiveBoss();
    void LocalIsOnePlayerLeftInTeamGame();
    void IsOnePlayerLeftInTeamGame();
    void GetAttackRangeScale();
    void CanObliterateDoors();
    void eventHitWall();
    void TryDestroyDoor();
    void HandleAIDoorBump();
    void UpdateBattlePhaseOnLocalPlayerUI();
    void OnBattlePhaseChanged();
    void GetCurrentBattlePhase();
    void UpdateGameplayMICParams();
    void TerminateEffectsOnDeath();
    void PlayDyingSound();
    void PlayDying();
    void CanAITargetThisPawn();
    void NotifyTakeHit();
    void GetNumMinionsToSpawn();
    void Timer_IncreaseSpeed();
    void PossessedBy();
    void eventPostBeginPlay();
    void eventPreBeginPlay();
    void eventReplicatedEvent();
};

UClass* AKFPawn_MonsterBoss::pClassPointer = NULL;

// Class KFGame.KFPawnBlockingVolume
// 0x0004 (0x0288 - 0x0284)
class AKFPawnBlockingVolume : public ABlockingVolume {
   public:
    DWORD
        bBlockPlayers : 1;  // 0x0284 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bBlockZedPlayers : 1;  // 0x0284 (0x0004) [0x0000000000000000]
                                 // [0x00000002]
    DWORD bBlockMonsters : 1;    // 0x0284 (0x0004) [0x0000000000000000]
                                 // [0x00000004]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3533];

        return pClassPointer;
    };
};

UClass* AKFPawnBlockingVolume::pClassPointer = NULL;

// Class KFGame.KFGameReplicationInfo
// 0x0F8C (0x1238 - 0x02AC)
class AKFGameReplicationInfo : public AGameReplicationInfo {
   public:
    struct FPreGameServerAdInfo
        ServerAdInfo;  // 0x02AC (0x0040) [0x0000000000210014]              (
                       // CPF_Input | CPF_OptionalParm | CPF_Travel )
    int PrimaryXPAccumulator;            // 0x02EC (0x0004) [0x0000000000000000]
    int SecondaryXPAccumulator;          // 0x02F0 (0x0004) [0x0000000000000000]
    class AKFTraderTrigger* NextTrader;  // 0x02F4 (0x0008) [0x0000000000220000]
                                         // ( CPF_EditConst )
    class AKFTraderTrigger*
        OpenedTrader;             // 0x02FC (0x0008) [0x0000000000000000]
    class AVolume* TraderVolume;  // 0x0304 (0x0008) [0x0000000000230000] (
                                  // CPF_Travel | CPF_EditConst )
    unsigned char
        TraderVolumeCheckType;  // 0x030C (0x0001) [0x0000000000240000] (
                                // CPF_GlobalConfig )
    unsigned char MusicTrackRepCount;  // 0x030D (0x0001) [0x0000000000250000]
                                       // ( CPF_Travel | CPF_GlobalConfig )
    unsigned char
        RepKickVotes;  // 0x030E (0x0001) [0x0000000000260070]              (
                       // CPF_OptionalParm | CPF_Net | CPF_EditConstArray |
                       // CPF_EditConst | CPF_GlobalConfig )
    unsigned char WaveMax;  // 0x030F (0x0001) [0x000000000027000A] ( CPF_Const
                            // | CPF_ExportObject | CPF_Travel | CPF_EditConst |
                            // CPF_GlobalConfig )
    unsigned char WaveNum;  // 0x0310 (0x0001) [0x0000000000280000] (
                            // CPF_Component )
    unsigned char GameLength;  // 0x0311 (0x0001) [0x000000000029000A] (
                               // CPF_Const | CPF_ExportObject | CPF_Travel |
                               // CPF_Component )
    unsigned char GameDifficulty;  // 0x0312 (0x0001) [0x00000000002A000A] (
                                   // CPF_Const | CPF_ExportObject |
                                   // CPF_EditConst | CPF_Component )
    unsigned char MaxPerkLevel;  // 0x0313 (0x0001) [0x00000000002B000A] (
                                 // CPF_Const | CPF_ExportObject | CPF_Travel |
                                 // CPF_EditConst | CPF_Component )
    unsigned char GameSharedUnlocks;  // 0x0314 (0x0001) [0x00000000002C0000] (
                                      // CPF_GlobalConfig | CPF_Component )
    unsigned char
        CurrentGameConductorStatus;  // 0x0315 (0x0001) [0x00000000002D00AA] (
                                     // CPF_Const | CPF_ExportObject | CPF_Net |
                                     // CPF_Parm | CPF_Travel | CPF_GlobalConfig
                                     // | CPF_Component )
    unsigned char
        MusicIntensity;  // 0x0316 (0x0001) [0x00000000002E0000]              (
                         // CPF_EditConst | CPF_GlobalConfig | CPF_Component )
    int DebugingNextTraderIndex;  // 0x0318 (0x0004) [0x0000000000000000]
    class UKFGFxObject_TraderItems*
        TraderItems;  // 0x031C (0x0008) [0x00000000002F000A]              (
                      // CPF_Const | CPF_ExportObject | CPF_Travel |
                      // CPF_EditConst | CPF_GlobalConfig | CPF_Component )
    DWORD bAllowGrenadePurchase : 1;  // 0x0324 (0x0004) [0x000000000030000A]
                                      // [0x00000001] ( CPF_Const |
                                      // CPF_ExportObject )
    DWORD bTraderIsOpen : 1;          // 0x0324 (0x0004) [0x0000000000310000]
                                      // [0x00000002] ( CPF_Travel )
    DWORD bWaveIsActive : 1;          // 0x0324 (0x0004) [0x0000000000320000]
                                      // [0x00000004] ( CPF_EditConst )
    DWORD bIsUnrankedGame : 1;        // 0x0324 (0x0004) [0x0000000000330000]
                                // [0x00000008] ( CPF_Travel | CPF_EditConst )
    DWORD
        bMatchVictory : 1;  // 0x0324 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bTradersEnabled : 1;  // 0x0324 (0x0004) [0x000000000034000A]
                                // [0x00000020] ( CPF_Const | CPF_ExportObject |
                                // CPF_GlobalConfig )
    DWORD bCustom : 1;  // 0x0324 (0x0004) [0x000000000035000A] [0x00000040] (
                        // CPF_Const | CPF_ExportObject | CPF_Travel |
                        // CPF_GlobalConfig )
    DWORD
        bCurrentSMFinishedSpawning : 1;  // 0x0324 (0x0004) [0x0000000000360034]
                                         // [0x00000080] ( CPF_Input |
                                         // CPF_OptionalParm | CPF_Net |
                                         // CPF_EditConst | CPF_GlobalConfig )
    DWORD bDebugSpawnManager : 1;        // 0x0324 (0x0004) [0x0000000000000000]
                                         // [0x00000100]
    DWORD bTrackingMapEnabled : 1;       // 0x0324 (0x0004) [0x000000000037004D]
                                    // [0x00000200] ( CPF_Edit | CPF_Input |
                                    // CPF_ExportObject | CPF_EditConstArray |
                                    // CPF_Travel | CPF_EditConst |
                                    // CPF_GlobalConfig )
    DWORD bHidePawnIcons : 1;  // 0x0324 (0x0004) [0x0000000000380000]
                               // [0x00000400] ( CPF_Component )
    DWORD
        bGameConductorGraphingEnabled : 1;  // 0x0324 (0x0004)
                                            // [0x00000000003900A0] [0x00000800]
                                            // ( CPF_Net | CPF_Parm | CPF_Travel
                                            // | CPF_Component )
    DWORD bVersusGame : 1;  // 0x0324 (0x0004) [0x00000000003A000A] [0x00001000]
                            // ( CPF_Const | CPF_ExportObject | CPF_EditConst |
                            // CPF_Component )
    DWORD bAllowSwitchTeam : 1;  // 0x0324 (0x0004) [0x0000000000000000]
                                 // [0x00002000]
    class AKFTraderDialogManager*
        TraderDialogManager;  // 0x0328 (0x0008) [0x0000000000000000]
    class UClass*
        TraderDialogManagerClass;  // 0x0330 (0x0008) [0x0000000000000000]
    class UClass*
        TraderVoiceGroupClass;  // 0x0338 (0x0008) [0x0000000000000000]
    int AIRemaining;  // 0x0340 (0x0004) [0x00000000003B0000]              (
                      // CPF_Travel | CPF_EditConst | CPF_Component )
    int WaveTotalAICount;  // 0x0344 (0x0004) [0x00000000003C0000] (
                           // CPF_GlobalConfig | CPF_Component )
    struct FString
        ConsoleGameSessionGuid;  // 0x0348 (0x0010) [0x00000000003D0000] (
                                 // CPF_Travel | CPF_GlobalConfig |
                                 // CPF_Component )
    struct FUniqueNetId
        ConsoleGameSessionHost;  // 0x0358 (0x0008) [0x0000000000000000]
    TArray<struct FUniqueNetId>
        ConsoleGameSessionPendingPlayers;  // 0x0360 (0x0010)
                                           // [0x0000000000000000]
    float GameAmmoCostScale;  // 0x0370 (0x0004) [0x00000000003E000A] (
                              // CPF_Const | CPF_ExportObject | CPF_EditConst |
                              // CPF_GlobalConfig | CPF_Component )
    float CurrentSineMod;  // 0x0374 (0x0004) [0x00000000003F0034] ( CPF_Input |
                           // CPF_OptionalParm | CPF_Net | CPF_Travel |
                           // CPF_EditConst | CPF_GlobalConfig | CPF_Component )
    float CurrentNextSpawnTime;  // 0x0378 (0x0004) [0x0000000000400034] (
                                 // CPF_Input | CPF_OptionalParm | CPF_Net |
                                 // CPF_NeedCtorLink )
    float CurrentSineWavFreq;  // 0x037C (0x0004) [0x0000000000410034] (
                               // CPF_Input | CPF_OptionalParm | CPF_Net |
                               // CPF_Travel | CPF_NeedCtorLink )
    float CurrentNextSpawnTimeMod;  // 0x0380 (0x0004) [0x0000000000420034] (
                                    // CPF_Input | CPF_OptionalParm | CPF_Net |
                                    // CPF_EditConst | CPF_NeedCtorLink )
    int CurrentAIAliveCount;  // 0x0384 (0x0004) [0x0000000000430034] (
                              // CPF_Input | CPF_OptionalParm | CPF_Net |
                              // CPF_Travel | CPF_EditConst | CPF_NeedCtorLink )
    int CurrentMaxMonsters;  // 0x0388 (0x0004) [0x0000000000440034] ( CPF_Input
                             // | CPF_OptionalParm | CPF_Net | CPF_GlobalConfig
                             // | CPF_NeedCtorLink )
    float CurrentTimeTilNextSpawn;  // 0x038C (0x0004) [0x0000000000450034] (
                                    // CPF_Input | CPF_OptionalParm | CPF_Net |
                                    // CPF_Travel | CPF_GlobalConfig |
                                    // CPF_NeedCtorLink )
    float CurrentTotalWavesActiveTime;  // 0x0390 (0x0004) [0x0000000000460034]
                                        // ( CPF_Input | CPF_OptionalParm |
                                        // CPF_Net | CPF_EditConst |
                                        // CPF_GlobalConfig | CPF_NeedCtorLink )
    class UKFVoteCollector*
        VoteCollector;                 // 0x0394 (0x0008) [0x0000000000000000]
    class UClass* VoteCollectorClass;  // 0x039C (0x0008) [0x0000000000000000]
    struct FSpawnVolumeInfo
        SpawnVolumeInfos[0x10];  // 0x03A4 (0x0180) [0x0000000000470057] (
                                 // CPF_Edit | CPF_Const | CPF_Input |
                                 // CPF_OptionalParm | CPF_EditConstArray |
                                 // CPF_Travel | CPF_EditConst |
                                 // CPF_GlobalConfig | CPF_NeedCtorLink )
    int LastSpawnVolumeIndex;  // 0x0524 (0x0004) [0x0000000000000000]
    struct FSpawnVolumeInfo
        FailedSpawnInfos[0x8];  // 0x0528 (0x00C0) [0x0000000000570057] (
                                // CPF_Edit | CPF_Const | CPF_Input |
                                // CPF_OptionalParm | CPF_EditConstArray |
                                // CPF_Travel | CPF_EditConst | CPF_GlobalConfig
                                // | CPF_NeedCtorLink )
    int LastFailedSpawnIndex;  // 0x05E8 (0x0004) [0x0000000000000000]
    struct FZedInfo
        ZedInfos[0x20];  // 0x05EC (0x0800) [0x00000000005F0057]              (
                         // CPF_Edit | CPF_Const | CPF_Input | CPF_OptionalParm
                         // | CPF_EditConstArray | CPF_Travel | CPF_EditConst |
                         // CPF_GlobalConfig | CPF_Component | CPF_NeedCtorLink
                         // )
    float UpdateZedInfoInterval;  // 0x0DEC (0x0004) [0x0000000000000000]
    struct FHumanInfo
        HumanInfos[0x6];  // 0x0DF0 (0x00A8) [0x00000000007F0057]              (
                          // CPF_Edit | CPF_Const | CPF_Input | CPF_OptionalParm
                          // | CPF_EditConstArray | CPF_Travel | CPF_EditConst |
                          // CPF_GlobalConfig | CPF_Component | CPF_NeedCtorLink
                          // )
    float UpdateHumanInfoInterval;  // 0x0E98 (0x0004) [0x0000000000000000]
    struct FPickupInfo
        PickupInfos[0x14];  // 0x0E9C (0x0140) [0x0000000000850057] ( CPF_Edit |
                            // CPF_Const | CPF_Input | CPF_OptionalParm |
                            // CPF_EditConstArray | CPF_Travel |
                            // CPF_GlobalConfig | CPF_NoExport )
    float UpdatePickupInfoInterval;    // 0x0FDC (0x0004) [0x0000000000000000]
    float PlayerAccuracyTracker[0xA];  // 0x0FE0 (0x0028) [0x00000000009900AA]
                                       // ( CPF_Const | CPF_ExportObject |
                                       // CPF_Net | CPF_Parm | CPF_Travel |
                                       // CPF_Component | CPF_NoExport )
    float PlayerHeadshotAccuracyTracker
        [0xA];  // 0x1008 (0x0028) [0x0000000000A300AA]              ( CPF_Const
                // | CPF_ExportObject | CPF_Net | CPF_Parm | CPF_Travel |
                // CPF_EditConst | CPF_NoExport )
    float AggregatePlayerSkillTracker
        [0xA];  // 0x1030 (0x0028) [0x0000000000AD00AA]              ( CPF_Const
                // | CPF_ExportObject | CPF_Net | CPF_Parm | CPF_Travel |
                // CPF_GlobalConfig | CPF_Component | CPF_NoExport )
    float TotalZedLifeSpanAverageTracker
        [0xA];  // 0x1058 (0x0028) [0x0000000000B700AA]              ( CPF_Const
                // | CPF_ExportObject | CPF_Net | CPF_Parm | CPF_Travel |
                // CPF_EditConst | CPF_GlobalConfig | CPF_NoExport )
    float CurrentWaveZedLifeSpanAverageTracker
        [0xA];  // 0x1080 (0x0028) [0x0000000000C100AA]              ( CPF_Const
                // | CPF_ExportObject | CPF_Net | CPF_Parm | CPF_Travel |
                // CPF_NeedCtorLink | CPF_NoExport )
    float RecentZedLifeSpanAverageTracker
        [0xA];  // 0x10A8 (0x0028) [0x0000000000CB00AA]              ( CPF_Const
                // | CPF_ExportObject | CPF_Net | CPF_Parm | CPF_Travel |
                // CPF_EditConst | CPF_Component | CPF_NeedCtorLink |
                // CPF_NoExport )
    float PlayersHealthStatusTracker
        [0xA];  // 0x10D0 (0x0028) [0x0000000000D500AA]              ( CPF_Const
                // | CPF_ExportObject | CPF_Net | CPF_Parm | CPF_Travel |
                // CPF_GlobalConfig | CPF_NeedCtorLink | CPF_NoExport )
    float PlayersAmmoStatusTracker
        [0xA];  // 0x10F8 (0x0028) [0x0000000000DF00AA]              ( CPF_Const
                // | CPF_ExportObject | CPF_Net | CPF_Parm | CPF_Travel |
                // CPF_EditConst | CPF_GlobalConfig | CPF_Component |
                // CPF_NeedCtorLink | CPF_NoExport )
    float AggregatePlayersStatusTracker
        [0xA];  // 0x1120 (0x0028) [0x0000000000E900AA]              ( CPF_Const
                // | CPF_ExportObject | CPF_Net | CPF_Parm | CPF_Travel |
                // CPF_Component | CPF_NeedCtorLink | CPF_NoExport )
    float CurrentParZedLifeSpan;  // 0x1148 (0x0004) [0x0000000000F300AA] (
                                  // CPF_Const | CPF_ExportObject | CPF_Net |
                                  // CPF_Parm | CPF_Travel | CPF_EditConst |
                                  // CPF_NeedCtorLink | CPF_NoExport )
    float OverallRankAndSkillModifierTracker
        [0xA];  // 0x114C (0x0028) [0x0000000000F400AA]              ( CPF_Const
                // | CPF_ExportObject | CPF_Net | CPF_Parm | CPF_GlobalConfig |
                // CPF_NeedCtorLink | CPF_NoExport )
    float ZedMovementSpeedModifierTracker
        [0xA];  // 0x1174 (0x0028) [0x0000000000FE00AA]              ( CPF_Const
                // | CPF_ExportObject | CPF_Net | CPF_Parm | CPF_EditConst |
                // CPF_GlobalConfig | CPF_Component | CPF_NeedCtorLink |
                // CPF_NoExport )
    float ZedSpawnRateModifierTracker
        [0xA];  // 0x119C (0x0028) [0x00000000010800AA]              ( CPF_Const
                // | CPF_ExportObject | CPF_Net | CPF_Parm | CPF_Component )
    float ZedSpawnRateTracker[0xA];  // 0x11C4 (0x0028) [0x00000000011200AA] (
                                     // CPF_Const | CPF_ExportObject | CPF_Net |
                                     // CPF_Parm | CPF_EditConst )
    float VersusZedHealthMod;  // 0x11EC (0x0004) [0x00000000011C00C3] (
                               // CPF_Edit | CPF_Const | CPF_EditConstArray |
                               // CPF_Parm | CPF_GlobalConfig | CPF_Component )
    float
        VersusZedDamageMod;  // 0x11F0 (0x0004) [0x00000000011D00C3] ( CPF_Edit
                             // | CPF_Const | CPF_EditConstArray | CPF_Parm |
                             // CPF_Travel | CPF_GlobalConfig | CPF_Component )
    TArray<class AKFDoorActor*>
        DoorList;  // 0x11F4 (0x0010) [0x0000000000000000]
    class AActor*
        CurrentObjective;  // 0x1204 (0x0008) [0x00000000011E0000] (
                           // CPF_EditConst | CPF_GlobalConfig | CPF_Component )
    class UKFInterface_MapObjective*
        ObjectiveInterface;            // 0x120C (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x8];  // 0x1214 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UAkComponent* MusicComp;     // 0x121C (0x0008) [0x0000000000000000]
    class UKFMusicTrackInfo*
        CurrentMusicTrackInfo;  // 0x1224 (0x0008) [0x0000000000000000]
    class UKFMusicTrackInfo*
        ReplicatedMusicTrackInfo;  // 0x122C (0x0008) [0x00000000011F0000] (
                                   // CPF_Travel | CPF_EditConst |
                                   // CPF_GlobalConfig | CPF_Component )
    float SteamHeartbeatAccumulator;  // 0x1234 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3535];

        return pClassPointer;
    };

    void DeactivateObjective();
    void ActivateObjective();
    void AttemptObjectiveActivation();
    void StartNextRandomObjective();
    void StartNextPresetObjective();
    void StartNextObjective();
    void eventIsStatsSessionValid();
    void AreTeamsOutOfBalanced();
    void GetCurrentRoundNumber();
    void eventNotifyGameUnranked();
    void ReceiveVoteMap();
    void RecieveVoteKick();
    void ServerStartVoteKick();
    void ForceNewMusicTrack();
    void PlayNewMusicTrack();
    void UpdateMusicTrack();
    void UpdateHumanList();
    void UpdateZedList();
    void UpdateSpawnVolumes();
    void UpdatePickupList();
    void eventTick();
    void AddFailedSpawn();
    void AddRecentSpawnVolume();
    void AnyPlayersAlive();
    void GetNumPlayersAlive();
    void DisplayDebug();
    void eventCanChangePerks();
    void RemovePRI();
    void eventTimer();
    void IsFinalWave();
    void SetWaveActive();
    void GetNextMapTimeRemaining();
    void eventSendPlayfabGameTimeUpdate();
    void ProcessChanceDrop();
    void OnOpenAfterActionReport();
    void GetHeartbeatAccumulatorAmount();
    void TriggerClientWaveStartEvents();
    void GetTraderTimeRemaining();
    void CloseTrader();
    void OpenTraderNext();
    void OpenTrader();
    void StartScavengeTime();
    void FadeOutLingeringExplosions();
    void GetKFPRIArray();
    void ShowPreGameServerWelcomeScreen();
    void EndGame();
    void NotifyWaveEnded();
    void UpdateHUDWaveCount();
    void ReceivedGameClass();
    void eventPostBeginPlay();
    void eventReplicatedEvent();
    void EndOfWave();
    void SendSteamRequestItemDrop();
    void SendSteamHeartbeat();
};

UClass* AKFGameReplicationInfo::pClassPointer = NULL;

// Class KFGame.KFPlayerReplicationInfo
// 0x0078 (0x039C - 0x0324)
class AKFPlayerReplicationInfo : public APlayerReplicationInfo {
   public:
    float LastQuitTime;                 // 0x0324 (0x0004) [0x0000000000000000]
    unsigned char NumTimesReconnected;  // 0x0328 (0x0001) [0x0000000000000000]
    unsigned char VOIPStatus;  // 0x0329 (0x0001) [0x000000000028000A] (
                               // CPF_Const | CPF_ExportObject | CPF_Component )
    unsigned char NetPerkIndex;  // 0x032A (0x0001) [0x0000000000290000] (
                                 // CPF_Travel | CPF_Component )
    unsigned char ActivePerkLevel;  // 0x032B (0x0001) [0x00000000002A0000] (
                                    // CPF_EditConst | CPF_Component )
    unsigned char PlayerHealth;  // 0x032C (0x0001) [0x00000000002B0000] (
                                 // CPF_Travel | CPF_EditConst | CPF_Component )
    unsigned char PlayerHealthPercent;  // 0x032D (0x0001) [0x00000000002C0000]
                                        // ( CPF_GlobalConfig | CPF_Component )
    unsigned char
        PerkSupplyLevel;  // 0x032E (0x0001) [0x00000000002D0000]              (
                          // CPF_Travel | CPF_GlobalConfig | CPF_Component )
    unsigned char
        SharedUnlocks;  // 0x032F (0x0001) [0x00000000002E000A]              (
                        // CPF_Const | CPF_ExportObject | CPF_EditConst |
                        // CPF_GlobalConfig | CPF_Component )
    DWORD bHasSpawnedIn : 1;  // 0x0330 (0x0004) [0x00000000002F0000]
                              // [0x00000001] ( CPF_Travel | CPF_EditConst |
                              // CPF_GlobalConfig | CPF_Component )
    DWORD bVOIPRegisteredWithOSS : 1;  // 0x0330 (0x0004) [0x0000000000300000]
                                       // [0x00000002]
    DWORD bExtraFireRange : 1;         // 0x0330 (0x0004) [0x0000000000310000]
                                       // [0x00000004] ( CPF_Travel )
    DWORD bSplashActive : 1;           // 0x0330 (0x0004) [0x0000000000320000]
                                       // [0x00000008] ( CPF_EditConst )
    DWORD bNukeActive : 1;  // 0x0330 (0x0004) [0x0000000000330000] [0x00000010]
                            // ( CPF_Travel | CPF_EditConst )
    DWORD bConcussiveActive : 1;         // 0x0330 (0x0004) [0x0000000000340000]
                                         // [0x00000020] ( CPF_GlobalConfig )
    DWORD bPerkPrimarySupplyUsed : 1;    // 0x0330 (0x0004) [0x0000000000000000]
                                         // [0x00000040]
    DWORD bPerkSecondarySupplyUsed : 1;  // 0x0330 (0x0004) [0x0000000000000000]
                                         // [0x00000080]
    DWORD
        bObjectivePlayer : 1;  // 0x0330 (0x0004) [0x0000000000350000]
                               // [0x00000100] ( CPF_Travel | CPF_GlobalConfig )
    DWORD bShowNonRelevantPlayers : 1;  // 0x0330 (0x0004) [0x0000000000000000]
                                        // [0x00000200]
    struct FString
        LastCrateGiftTimestamp;  // 0x0334 (0x0010) [0x0000000000000000]
    int SecondsOfGameplay;       // 0x0344 (0x0004) [0x0000000000000000]
    TArray<class UKFCharacterInfo_Human*>
        CharacterArchetypes;  // 0x0348 (0x0010) [0x0000000000000000]
    struct FCustomizationInfo
        RepCustomizationInfo;  // 0x0358 (0x000C) [0x0000000000360000] (
                               // CPF_EditConst | CPF_GlobalConfig )
    class UTexture*
        CharPortrait;  // 0x0364 (0x0008) [0x0000000000370000]              (
                       // CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
    int DamageDealtOnTeam;  // 0x036C (0x0004) [0x0000000000380000] (
                            // CPF_Component )
    class UClass* CurrentPerkClass;  // 0x0370 (0x0008) [0x0000000000390000] (
                                     // CPF_Travel | CPF_Component )
    int Assists;  // 0x0378 (0x0004) [0x00000000003A0000]              (
                  // CPF_EditConst | CPF_Component )
    struct FVector
        PawnLocationCompressed;  // 0x037C (0x000C) [0x00000000003B0034] (
                                 // CPF_Input | CPF_OptionalParm | CPF_Net |
                                 // CPF_Travel | CPF_EditConst | CPF_Component )
    struct FVector
        LastReplicatedSmoothedLocation;  // 0x0388 (0x000C) [0x0000000000000000]
    class AKFPlayerController*
        KFPlayerOwner;  // 0x0394 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3537];

        return pClassPointer;
    };

    void HasHadInitialSpawn();
    void NotifyWaveEnded();
    void ResetSupplierUsed();
    void MarkSupplierUsed();
    void MarkSupplierOwnerUsed();
    void IncrementDeaths();
    void NotifyHUDofPRIDestroyed();
    void eventDestroyed();
    void UpdateTraderDosh();
    void AddDosh();
    void ServerSetPlayerReady();
    void SetPlayerReady();
    void GetSmoothedPawnIconLocation();
    void SetSmoothedPawnIconLocation();
    void UpdateReplicatedPlayerHealth();
    void UpdatePawnLocation();
    void UpdateReplicatedVariables();
    void SetPlayerTeam();
    void Duplicate();
    void eventServerAnnounceNewSharedContent();
    void eventCharacterCustomizationChanged();
    void eventGetCharacterConfigSection();
    void GetAnyAvailableCharacter();
    void eventSelectCharacter();
    void ClientInitialize();
    void ClearCharacterAttachment();
    void RetryCharacterOwnership();
    void LoadCharacterConfig();
    void SaveCharacterConfig();
    void eventServerSetCharacterCustomization();
    void eventServerSetSharedUnlocks();
    void RecieveTopMaps();
    void RecieveAARMapOption();
    void ServerCastMapVote();
    void CastMapVote();
    void ServerCastKickVote();
    void CastKickVote();
    void ServerStartKickVote();
    void HideKickVote();
    void ShowKickVote();
    void UnregisterPlayerFromSession();
    void OnTalkerRegistered();
    void VOIPStatusChanged();
    void ServerNotifyStopVOIP();
    void ServerStartSpectatorVoiceChat();
    void ServerNotifyStartTeamVoip();
    void ServerNotifyStartVoip();
    void GetActivePerkLevel();
    void ClientRecieveNewTeam();
    void ServerSwitchTeam();
    void eventPostBeginPlay();
    void eventReplicatedEvent();
};

UClass* AKFPlayerReplicationInfo::pClassPointer = NULL;

// Class KFGame.KFPlayerReplicationInfoVersus
// 0x0024 (0x03C0 - 0x039C)
class AKFPlayerReplicationInfoVersus : public AKFPlayerReplicationInfo {
   public:
    int KillsAsZed;           // 0x039C (0x0004) [0x0000000000000000]
    int AssistsAsZed;         // 0x03A0 (0x0004) [0x0000000000000000]
    int DamageDealtAsZed;     // 0x03A4 (0x0004) [0x0000000000000000]
    int ZedGrabs;             // 0x03A8 (0x0004) [0x0000000000000000]
    int IndirectDamageDealt;  // 0x03AC (0x0004) [0x0000000000000000]
    TArray<int> WaveKills;    // 0x03B0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3539];

        return pClassPointer;
    };

    void Reset();
    void IncrementDeaths();
    void RecordEndGameInfo();
    void VOIPStatusChanged();
    void ClientRecieveNewTeam();
    void ClientRefusedTeamSwitch();
    void WillMaintainTeamBalance();
    void ServerSwitchTeam();
    void SetPlayerTeam();
    void GetOwnerPawn();
};

UClass* AKFPlayerReplicationInfoVersus::pClassPointer = NULL;

// Class KFGame.KFSeqAct_MovePawnsNotInVolume
// 0x0018 (0x0168 - 0x0150)
class UKFSeqAct_MovePawnsNotInVolume : public USequenceAction {
   public:
    DWORD bOnlyLivingPlayers : 1;     // 0x0150 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bRandomizeDestination : 1;  // 0x0150 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD
        bCheckOverlap : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD
        bSetRotation : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bFadeIn : 1;     // 0x0150 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bFadeAudio : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000020]
    struct FColor FadeColor;     // 0x0154 (0x0004) [0x0000000000000000]
    float EndFadeOpacity;        // 0x0158 (0x0004) [0x0000000000000000]
    float FadeTime;              // 0x015C (0x0004) [0x0000000000000000]
    struct FVector2D FadeAlpha;  // 0x0160 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3541];

        return pClassPointer;
    };
};

UClass* UKFSeqAct_MovePawnsNotInVolume::pClassPointer = NULL;

// Class KFGame.KFSeqAct_ToggleEx
// 0x0004 (0x0154 - 0x0150)
class UKFSeqAct_ToggleEx : public USeqAct_Toggle {
   public:
    DWORD bUseDynamicActorIterator : 1;  // 0x0150 (0x0004) [0x0000000000000000]
                                         // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3543];

        return pClassPointer;
    };
};

UClass* UKFSeqAct_ToggleEx::pClassPointer = NULL;

// Class KFGame.KFSpecialMove
// 0x008C (0x0134 - 0x00A8)
class UKFSpecialMove : public UGameSpecialMove {
   public:
    class AKFPawn* KFPOwner;             // 0x00A8 (0x0008) [0x0000000000000000]
    class AKFPlayerController* PCOwner;  // 0x00B0 (0x0008) [0x0000000000000000]
    class AKFAIController* AIOwner;      // 0x00B8 (0x0008) [0x0000000000000000]
    class UObject* AISpecialOwner;       // 0x00C0 (0x0008) [0x0000000000000000]
    unsigned char SMIndex;               // 0x00C8 (0x0001) [0x0000000000000000]
    unsigned char SMRootMotionMode;      // 0x00C9 (0x0001) [0x0000000000000000]
    class UAnimNodeSlot*
        ActiveSlotNode;  // 0x00CC (0x0008) [0x0000000000000000]
    DWORD bOverridePawnSpeedModifier : 1;  // 0x00D4 (0x0004)
                                           // [0x0000000000000000] [0x00000001]
    DWORD bAllowHitReactions : 1;   // 0x00D4 (0x0004) [0x0000000000000000]
                                    // [0x00000002]
    DWORD bAllowMomentumPush : 1;   // 0x00D4 (0x0004) [0x0000000000000000]
                                    // [0x00000004]
    DWORD bCanOnlyWanderAtEnd : 1;  // 0x00D4 (0x0004) [0x0000000000000000]
                                    // [0x00000008]
    DWORD
        bAllowThirdPersonWeaponAnims : 1;  // 0x00D4 (0x0004)
                                           // [0x0000000000000000] [0x00000010]
    DWORD bUseCustomRotationRate : 1;  // 0x00D4 (0x0004) [0x0000000000000000]
                                       // [0x00000020]
    DWORD bUseHigherMeshSmoothingThreshold : 1;  // 0x00D4 (0x0004)
                                                 // [0x0000000000000000]
                                                 // [0x00000040]
    DWORD bDisablesWeaponFiring : 1;  // 0x00D4 (0x0004) [0x0000000000000000]
                                      // [0x00000080]
    DWORD bOnlyInteractionPawnCanDamageMe : 1;  // 0x00D4 (0x0004)
                                                // [0x0000000000000000]
                                                // [0x00000100]
    DWORD bCanModifyInteractionPawn : 1;        // 0x00D4 (0x0004)
                                          // [0x0000000000000000] [0x00000200]
    DWORD bPendingStopFire : 1;  // 0x00D4 (0x0004) [0x0000000000000000]
                                 // [0x00000400]
    DWORD bUseCustomThirdPersonViewOffset : 1;  // 0x00D4 (0x0004)
                                                // [0x0000000000000000]
                                                // [0x00000800]
    DWORD bRestoredCameraDefaults : 1;  // 0x00D4 (0x0004) [0x0000000000000000]
                                        // [0x00001000]
    DWORD bDisableHeadTracking : 1;     // 0x00D4 (0x0004) [0x0000000000000000]
                                        // [0x00002000]
    DWORD bDisableAI : 1;  // 0x00D4 (0x0004) [0x0000000000000000] [0x00004000]
    DWORD bDisableMovement : 1;     // 0x00D4 (0x0004) [0x0000000000000000]
                                    // [0x00008000]
    DWORD bMovementDisabled : 1;    // 0x00D4 (0x0004) [0x0000000000000000]
                                    // [0x00010000]
    DWORD bLockPawnRotation : 1;    // 0x00D4 (0x0004) [0x0000000000000000]
                                    // [0x00020000]
    DWORD bPawnRotationLocked : 1;  // 0x00D4 (0x0004) [0x0000000000000000]
                                    // [0x00040000]
    DWORD
        bDisableLook : 1;  // 0x00D4 (0x0004) [0x0000000000000000] [0x00080000]
    DWORD bDisableWeaponInteraction : 1;    // 0x00D4 (0x0004)
                                            // [0x0000000000000000] [0x00100000]
    DWORD bDisableAIAttackRangeChecks : 1;  // 0x00D4 (0x0004)
                                            // [0x0000000000000000] [0x00200000]
    DWORD bDisableSteering : 1;          // 0x00D4 (0x0004) [0x0000000000000000]
                                         // [0x00400000]
    DWORD bDisableTurnInPlace : 1;       // 0x00D4 (0x0004) [0x0000000000000000]
                                         // [0x00800000]
    DWORD bDisablePhysics : 1;           // 0x00D4 (0x0004) [0x0000000000000000]
                                         // [0x01000000]
    DWORD bServerOnlyPhysics : 1;        // 0x00D4 (0x0004) [0x0000000000000000]
                                         // [0x02000000]
    DWORD bAllowFireAnims : 1;           // 0x00D4 (0x0004) [0x0000000000000000]
                                         // [0x04000000]
    DWORD bShouldDeferToPostTick : 1;    // 0x00D4 (0x0004) [0x0000000000000000]
                                         // [0x08000000]
    struct FRotator CustomRotationRate;  // 0x00D8 (0x000C) [0x0000000000000000]
    struct FName DeferredSeqName;        // 0x00E4 (0x0008) [0x0000000000000000]
    struct FViewOffsetData
        CustomThirdPersonViewOffset;  // 0x00EC (0x0024) [0x0000000000000000]
    float ViewOffsetInterpTime;       // 0x0110 (0x0004) [0x0000000000000000]
    float CustomCameraFOV;            // 0x0114 (0x0004) [0x0000000000000000]
    float CameraFOVTransitionTime;    // 0x0118 (0x0004) [0x0000000000000000]
    float AITimeout;                  // 0x011C (0x0004) [0x0000000000000000]
    float CustomTurnInPlaceAnimRate;  // 0x0120 (0x0004) [0x0000000000000000]
    class UAICommand_PushedBySM*
        AICommand;  // 0x0124 (0x0008) [0x0000000000000000]
    class UClass*
        DefaultAICommandClass;  // 0x012C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3545];

        return pClassPointer;
    };

    void GetSMAimRotation();
    void CanDrawCrosshair();
    void eventModifyInteractionPawn();
    void OnEMPDisrupted();
    void OnGoreMeshSwap();
    void CanInterruptWithParry();
    void NotifyHitReactionInterrupt();
    void NotifyOwnerTakeHit();
    void AbortedByAICommand();
    void OnAnimNotifyParticleSystemSpawned();
    void DeferOnAnimEnd();
    void AnimEndNotify();
    void AbortSpecialMove();
    void PlaySpecialMoveAnim();
    void PlayCameraAnim();
    void ProcessViewRotation();
    void SetLockPawnRotation();
    void Tick();
    void DisableRootMotion();
    void EnableRootMotion();
    void GetSprintSpeedModifier();
    void SetMovementLock();
    void RestoreCameraDefaults();
    void SpecialMoveEnded();
    void SpecialMoveStarted();
    void InitSpecialMove();
    void InternalCanDoSpecialMove();
    void SpecialMoveButtonReleased();
    void SpecialMoveButtonRetriggered();
    void InteractionPawnUpdated();
    void NotifyBump();
    void PackFlagsBase();
    void IsPawnPathClear();
};

UClass* UKFSpecialMove::pClassPointer = NULL;

// Class KFGame.KFSM_InteractionPawnLeader
// 0x0038 (0x016C - 0x0134)
class UKFSM_InteractionPawnLeader : public UKFSpecialMove {
   public:
    class UCameraAnimInst*
        ExecutionCameraAnimInst_Leader;  // 0x0134 (0x0008) [0x0000000000000000]
    class UCameraAnimInst*
        ExecutionCameraAnimInst_Follower;  // 0x013C (0x0008)
                                           // [0x0000000000000000]
    class AKFPawn* Follower;            // 0x0144 (0x0008) [0x0000000000000000]
    unsigned char FollowerSpecialMove;  // 0x014C (0x0001) [0x0000000000000000]
    float InteractionStartTimeOut;      // 0x0150 (0x0004) [0x0000000000000000]
    DWORD bAlignPawns : 1;  // 0x0154 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bAlignLeaderLocation : 1;  // 0x0154 (0x0004) [0x0000000000000000]
                                     // [0x00000002]
    DWORD bAlignFollowerZ : 1;       // 0x0154 (0x0004) [0x0000000000000000]
                                     // [0x00000004]
    DWORD
        bAlignFollowerLookSameDirAsMe : 1;  // 0x0154 (0x0004)
                                            // [0x0000000000000000] [0x00000008]
    DWORD bAlignLeaderRotation : 1;    // 0x0154 (0x0004) [0x0000000000000000]
                                       // [0x00000010]
    DWORD bAlignFollowerRotation : 1;  // 0x0154 (0x0004) [0x0000000000000000]
                                       // [0x00000020]
    DWORD bStopAlignFollowerRotationAtGoal : 1;       // 0x0154 (0x0004)
                                                      // [0x0000000000000000]
                                                      // [0x00000040]
    DWORD bAlignHumanFollowerControllerRotation : 1;  // 0x0154 (0x0004)
                                                      // [0x0000000000000000]
                                                      // [0x00000080]
    DWORD bRetryCollisionCheck : 1;  // 0x0154 (0x0004) [0x0000000000000000]
                                     // [0x00000100]
    float AlignDistance;             // 0x0158 (0x0004) [0x0000000000000000]
    float AlignDistanceThreshold;    // 0x015C (0x0004) [0x0000000000000000]
    float AlignFollowerInterpSpeed;  // 0x0160 (0x0004) [0x0000000000000000]
    int LeaderRelativeYawOffset;     // 0x0164 (0x0004) [0x0000000000000000]
    float AlignSpeedModifier;        // 0x0168 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3547];

        return pClassPointer;
    };

    void CanInteractWithPawn();
    void DetachPawnHelper();
    void DetachPawn();
    void AttachFollowerToLeader();
    void PlayExecutionCameraAnim();
    void DebugSocketRelativeLocation();
    void OnFollowerLeavingSpecialMove();
    void MessageEvent();
    void IsFollowerReachable();
    void RetryCollisionTimer();
    void StartInteraction();
    void IsReadyToStartInteraction();
    void CheckReadyToStartInteraction();
    void InteractionStartTimedOut();
    void SpecialMoveEnded();
    void SpecialMoveStarted();
    void GetClipSafeMeshTranslation();
};

UClass* UKFSM_InteractionPawnLeader::pClassPointer = NULL;

// Class KFGame.KFSM_GrappleCombined
// 0x0030 (0x019C - 0x016C)
class UKFSM_GrappleCombined : public UKFSM_InteractionPawnLeader {
   public:
    TArray<struct FName> GrappleAnims;  // 0x016C (0x0010) [0x0000000000000000]
    DWORD bStopFullBodyWhenMoveEnds : 1;  // 0x017C (0x0004)
                                          // [0x0000000000000000] [0x00000001]
    DWORD
        bCanBeBlocked : 1;  // 0x017C (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bCanBeInterrupted : 1;     // 0x017C (0x0004) [0x0000000000000000]
                                     // [0x00000004]
    DWORD bUseRootMotion : 1;        // 0x017C (0x0004) [0x0000000000000000]
                                     // [0x00000008]
    unsigned char LastVariant;       // 0x0180 (0x0001) [0x0000000000000000]
    float MaxGrabDistance;           // 0x0184 (0x0004) [0x0000000000000000]
    float MaxVictimZOffset;          // 0x0188 (0x0004) [0x0000000000000000]
    struct FName GrabStartAnimName;  // 0x018C (0x0008) [0x0000000000000000]
    float GrabCheckTime;             // 0x0194 (0x0004) [0x0000000000000000]
    float MinPlayerGrabTime;         // 0x0198 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3549];

        return pClassPointer;
    };

    void CheckIfPlayerReleasedGrapple();
    void SpecialMoveButtonReleased();
    void SpecialMoveButtonRetriggered();
    void NotifyHitReactionInterrupt();
    void NotifyOwnerTakeHit();
    void SpecialMoveEnded();
    void OnFollowerLeavingSpecialMove();
    void PlayGrappleLoopAnim();
    void SpecialMoveFlagsUpdated();
    void AnimEndNotify();
    void StartInteraction();
    void BeginGrapple();
    void CanInteractWithPawn();
    void FindPlayerGrabTarget();
    void CheckGrapple();
    void PlayGrabAnim();
    void SpecialMoveStarted();
    void PackFlagsBase();
    void CanInterruptWithParry();
    void CanOverrideMoveWith();
    void InternalCanDoSpecialMove();
};

UClass* UKFSM_GrappleCombined::pClassPointer = NULL;

// Class KFGame.KFSM_Patriarch_Grapple
// 0x0058 (0x01F4 - 0x019C)
class UKFSM_Patriarch_Grapple : public UKFSM_GrappleCombined {
   public:
    float TentacleStartTime;  // 0x019C (0x0004) [0x0000000000000000]
    float MaxRange;           // 0x01A0 (0x0004) [0x0000000000000000]
    float MaxClawReach;       // 0x01A4 (0x0004) [0x0000000000000000]
    float DetachDistance;     // 0x01A8 (0x0004) [0x0000000000000000]
    DWORD bGrabMissed : 1;  // 0x01AC (0x0004) [0x0000000000000000] [0x00000001]
    DWORD
        bGrabbedPawn : 1;  // 0x01AC (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bTentacleCtrlStarted : 1;  // 0x01AC (0x0004) [0x0000000000000000]
                                     // [0x00000004]
    float CurveExponent;             // 0x01B0 (0x0004) [0x0000000000000000]
    float TentacleEndBoneOffset;     // 0x01B4 (0x0004) [0x0000000000000000]
    float TentacleBlendOutTime;      // 0x01B8 (0x0004) [0x0000000000000000]
    struct FName TentacleEndBone;    // 0x01BC (0x0008) [0x0000000000000000]
    struct FName TentacleStartBone;  // 0x01C4 (0x0008) [0x0000000000000000]
    float RetractAirSpeed;           // 0x01CC (0x0004) [0x0000000000000000]
    TArray<class USkelControlSingleBone*>
        TentacleControls;  // 0x01D0 (0x0010) [0x0000000000000000]
    class USkelControlSingleBone*
        TentacleStartCtrl;          // 0x01E0 (0x0008) [0x0000000000000000]
    int TentacleDamage;             // 0x01E8 (0x0004) [0x0000000000000000]
    class UClass* TentacleDmgType;  // 0x01EC (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3551];

        return pClassPointer;
    };

    void PlayerReleasedGrapple();
    void SpecialMoveButtonReleased();
    void SpecialMoveButtonRetriggered();
    void SpecialMoveEnded();
    void ResetFollowerPhysics();
    void OnFollowerLeavingSpecialMove();
    void NotifyOwnerTakeHit();
    void AnimEndNotify();
    void eventDetachGrabbedPawn();
    void SetSkelControlsActive();
    void InitializeSkelControls();
    void SpecialMoveFlagsUpdated();
    void eventOnGrabMissed();
    void StartInteraction();
    void BeginGrapple();
    void DamageFollower();
    void CheckGrapple();
    void BeginTentacleControls();
    void SpecialMoveStarted();
};

UClass* UKFSM_Patriarch_Grapple::pClassPointer = NULL;

// Class KFGame.KFSM_PlaySingleAnim
// 0x001C (0x0150 - 0x0134)
class UKFSM_PlaySingleAnim : public UKFSpecialMove {
   public:
    struct FName AnimName;     // 0x0134 (0x0008) [0x0000000000000000]
    unsigned char AnimStance;  // 0x013C (0x0001) [0x0000000000000000]
    DWORD bLoopAnim : 1;  // 0x0140 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bUseRootMotion : 1;     // 0x0140 (0x0004) [0x0000000000000000]
                                  // [0x00000002]
    DWORD bCanBeInterrupted : 1;  // 0x0140 (0x0004) [0x0000000000000000]
                                  // [0x00000004]
    float BlendInTime;            // 0x0144 (0x0004) [0x0000000000000000]
    float BlendOutTime;           // 0x0148 (0x0004) [0x0000000000000000]
    float AbortBlendOutTime;      // 0x014C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3553];

        return pClassPointer;
    };

    void NotifyHitReactionInterrupt();
    void AnimEndNotify();
    void PlayAnimation();
    void SpecialMoveEnded();
    void SpecialMoveStarted();
};

UClass* UKFSM_PlaySingleAnim::pClassPointer = NULL;

// Class KFGame.KFSM_MeleeAttack
// 0x0004 (0x0154 - 0x0150)
class UKFSM_MeleeAttack : public UKFSM_PlaySingleAnim {
   public:
    DWORD bCannotBeParried : 1;  // 0x0150 (0x0004) [0x0000000000000000]
                                 // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3555];

        return pClassPointer;
    };

    void CanInterruptWithParry();
    void InterruptCheckTimer();
    void AbortedByAICommand();
    void NotifyHitReactionInterrupt();
    void PlayAnimation();
    void SpecialMoveEnded();
    void SpecialMoveStarted();
    void CanOverrideMoveWith();
    void UnpackSpecialMoveFlags();
    void PackFlagsBase();
};

UClass* UKFSM_MeleeAttack::pClassPointer = NULL;

// Class KFGame.KFSM_DoorMeleeAttack
// 0x0000 (0x0154 - 0x0154)
class UKFSM_DoorMeleeAttack : public UKFSM_MeleeAttack {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3557];

        return pClassPointer;
    };

    void InternalCanDoSpecialMove();
    void UnpackSpecialMoveFlags();
    void PackSMFlags();
    void SpecialMoveStarted();
};

UClass* UKFSM_DoorMeleeAttack::pClassPointer = NULL;

// Class KFGame.KFSM_RecoverFromRagdoll
// 0x0034 (0x0168 - 0x0134)
class UKFSM_RecoverFromRagdoll : public UKFSpecialMove {
   public:
    struct FName GetUpFrontAnim;  // 0x0134 (0x0008) [0x0000000000000000]
    struct FName GetUpBackAnim;   // 0x013C (0x0008) [0x0000000000000000]
    DWORD
        bBlendToGetUp : 1;  // 0x0144 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bInvertUpDownBoneAxis : 1;   // 0x0144 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD bIgnorePawnsOnRecover : 1;   // 0x0144 (0x0004) [0x0000000000000000]
                                       // [0x00000004]
    DWORD bDebugSpecialMove : 1;       // 0x0144 (0x0004) [0x0000000000000000]
                                       // [0x00000008]
    float GetUpBlendStartTime;         // 0x0148 (0x0004) [0x0000000000000000]
    float GetUpBlendTime;              // 0x014C (0x0004) [0x0000000000000000]
    struct FName UpDownBoneName;       // 0x0150 (0x0008) [0x0000000000000000]
    unsigned char UpDownAxis;          // 0x0158 (0x0001) [0x0000000000000000]
    unsigned char OrientationAxis;     // 0x0159 (0x0001) [0x0000000000000000]
    struct FName OrientationBoneName;  // 0x015C (0x0008) [0x0000000000000000]
    int GetUpFromBackYawOffset;        // 0x0164 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3559];

        return pClassPointer;
    };

    void SpecialMoveEnded();
    void eventFinishedBlendToGetUp();
    void GetRecoveryAnim();
    void PlayRecoveryAnim();
    void MoveOffGeometry();
    void TraceNoPawns();
    void SpecialMoveStarted();
    void InternalCanDoSpecialMove();
};

UClass* UKFSM_RecoverFromRagdoll::pClassPointer = NULL;

// Class KFGame.KFAutoPurchaseHelper
// 0x0154 (0x01B4 - 0x0060)
class UKFAutoPurchaseHelper : public UObject {
   public:
    class AKFPlayerReplicationInfo*
        MyKFPRI;                        // 0x0060 (0x0008) [0x0000000000000000]
    class AKFInventoryManager* MyKFIM;  // 0x0068 (0x0008) [0x0000000000000000]
    class UKFGFxObject_TraderItems*
        TraderItems;  // 0x0070 (0x0008) [0x0000000000000000]
    TArray<struct FSItemInformation>
        OwnedItemList;  // 0x0078 (0x0010) [0x0000000000000000]
    struct FSItemInformation
        GrenadeItem;                     // 0x0088 (0x0088) [0x0000000000000000]
    struct FSItemInformation ArmorItem;  // 0x0110 (0x0088) [0x0000000000000000]
    int TotalDosh;                       // 0x0198 (0x0004) [0x0000000000000000]
    DWORD bPendingDoshUpdate : 1;        // 0x019C (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    int TotalBlocks;                     // 0x01A0 (0x0004) [0x0000000000000000]
    unsigned char MaxBlocks;             // 0x01A4 (0x0001) [0x0000000000000000]
    int PrevArmor;                       // 0x01A8 (0x0004) [0x0000000000000000]
    int CostPerAutofillCycle;            // 0x01AC (0x0004) [0x0000000000000000]
    int DoshBuffer;                      // 0x01B0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3561];

        return pClassPointer;
    };

    void AddTransactionAmmo();
    void GetTraderItems();
    void AddBlocks();
    void AddItemByPriority();
    void MergeSingleIntoDual();
    void RemoveWeaponFromOwnedItemList();
    void AddWeaponToOwnedItemList();
    void SetWeaponInfo();
    void SetWeaponInformation();
    void BoughtAmmo();
    void UpdateCurrentDosh();
    void NotifyDoshChanged();
    void AddDosh();
    void IsInOwnedItemList();
    void GetAdjustedBuyPriceFor();
    void IsSellable();
    void InitializeOwnedItemList();
    void GetAutoFillCost();
    void StartAutoFill();
    void AutoFillOwnedItems();
    void ClearAutoFillDosh();
    void RePoolAutoFillDosh();
    void AttemptAutoFillOnItem();
    void GetFillAmmoCost();
    void FillAmmo();
    void BuyItemMagazine();
    void BuyMagazine();
    void BuySecondaryAmmoMag();
    void BuyGrenade();
    void GetFillGrenadeCost();
    void AttemptBuyArmorChunk();
    void FillArmor();
    void GetFillArmorCost();
    void SellWeapon();
    void PurchaseWeapon();
    void CanCarry();
    void GetCanAfford();
    void bCanPurchase();
    void GetPotentialDosh();
    void DoIOwnThisWeapon();
    void SellOffPerkWeapons();
    void SellOnPerkWeapons();
    void GetHighValuedWeapon();
    void GetHighValuedOnPerkWeapon();
    void GetLastAffordableItemIndex();
    void AttemptUpgrade();
    void GetTopTierWeapon();
    void AttemptToPurchaseNextLowerTier();
    void DoAutoPurchase();
    void Initialize();
};

UClass* UKFAutoPurchaseHelper::pClassPointer = NULL;

// Class KFGame.KFDataStore_OnlineGameSearch
// 0x0000 (0x00D0 - 0x00D0)
class UKFDataStore_OnlineGameSearch : public UUIDataStore_OnlineGameSearch {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3563];

        return pClassPointer;
    };

    void GetCurrentKFGameSearch();
    void GetActiveKFGameSearch();
    void CancelFindServerPlayerList();
    void FindServerPlayerList();
    void OnSearchComplete();
};

UClass* UKFDataStore_OnlineGameSearch::pClassPointer = NULL;

// Class KFGame.KFGameViewportClient
// 0x00C4 (0x0264 - 0x01A0)
class UKFGameViewportClient : public UGameViewportClient {
   public:
    TArray<struct FString>
        TripWireOfficialMaps;  // 0x01A0 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        CommunityOfficialMaps;  // 0x01B0 (0x0010) [0x0000000000000000]
    struct FLinearColor
        BackgroundColor;          // 0x01C0 (0x0010) [0x0000000000000000]
    struct FString ErrorTitle;    // 0x01D0 (0x0010) [0x0000000000000000]
    struct FString ErrorMessage;  // 0x01E0 (0x0010) [0x0000000000000000]
    struct FString
        LastConnectionAttemptAddress;  // 0x01F0 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        RandomLoadingStrings;  // 0x0200 (0x0010) [0x0000000000000000]
    struct FString
        OfficialCommunityString;  // 0x0210 (0x0010) [0x0000000000000000]
    struct FString
        TripWireOfficialString;  // 0x0220 (0x0010) [0x0000000000000000]
    struct FString
        CommunityCustomString;  // 0x0230 (0x0010) [0x0000000000000000]
    class UFont* MessageFont;   // 0x0240 (0x0008) [0x0000000000000000]
    float FontScale;            // 0x0248 (0x0004) [0x0000000000000000]
    DWORD bSeenIIS : 1;  // 0x024C (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bNeedDisconnectMessage : 1;    // 0x024C (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bNeedSignoutMessage : 1;       // 0x024C (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD bHandlePlayTogether : 1;       // 0x024C (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    DWORD bDownloadingContent : 1;       // 0x024C (0x0004) [0x0000000000000000]
                                         // [0x00000010]
    struct FString CurrentDownloadName;  // 0x0250 (0x0010) [0x0000000000000000]
    int CurrentDownloadProgress;         // 0x0260 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3565];

        return pClassPointer;
    };

    void GetAssociationIdentifier();
    void DrawMapInfo();
    void DrawCancelString();
    void DrawDownloadingString();
    void DrawTransitionMessage();
    void HandleInputKey();
    void GetRandomLoadingMessage();
    void DrawTransition();
    void GetErrorMessage();
    void eventPreBrowse();
    void eventClearDownloadInfo();
    void eventNotifyDownloadProgress();
    void NotifyConnectionError();
};

UClass* UKFGameViewportClient::pClassPointer = NULL;

// Class KFGame.KFGFxObject_Container
// 0x0008 (0x00A8 - 0x00A0)
class UKFGFxObject_Container : public UGFxObject {
   public:
    class UKFGFxObject_Menu*
        ParentMenu;  // 0x00A0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3567];

        return pClassPointer;
    };

    void SetChatWindowMessage();
    void SetComponentInactive();
    void SetMainComponent();
    void ConsoleLocalize();
    void OneSecondLoop();
    void Initialize();
};

UClass* UKFGFxObject_Container::pClassPointer = NULL;

// Class KFGame.KFGFxServerBrowser_Filters
// 0x0144 (0x01EC - 0x00A8)
class UKFGFxServerBrowser_Filters : public UKFGFxObject_Container {
   public:
    class UKFGFxMenu_ServerBrowser*
        ServerMenu;                   // 0x00A8 (0x0008) [0x0000000000000000]
    struct FString NoPasswordString;  // 0x00B0 (0x0010) [0x0000000000000000]
    struct FString NoMutatorsString;  // 0x00C0 (0x0010) [0x0000000000000000]
    struct FString NotFullString;     // 0x00D0 (0x0010) [0x0000000000000000]
    struct FString NotEmptyString;    // 0x00E0 (0x0010) [0x0000000000000000]
    struct FString
        NoRankedStandardString;  // 0x00F0 (0x0010) [0x0000000000000000]
    struct FString
        NoRankedCustomString;            // 0x0100 (0x0010) [0x0000000000000000]
    struct FString NoUnrankedString;     // 0x0110 (0x0010) [0x0000000000000000]
    struct FString DedicatedString;      // 0x0120 (0x0010) [0x0000000000000000]
    struct FString VACSecureString;      // 0x0130 (0x0010) [0x0000000000000000]
    struct FString InLobbyString;        // 0x0140 (0x0010) [0x0000000000000000]
    struct FString InProgressString;     // 0x0150 (0x0010) [0x0000000000000000]
    struct FString OnlyStockMapsString;  // 0x0160 (0x0010) [0x0000000000000000]
    struct FString
        OnlyCustomMapsString;  // 0x0170 (0x0010) [0x0000000000000000]
    struct FString
        LimitServerResultsString;  // 0x0180 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        FilterStrings;      // 0x0190 (0x0010) [0x0000000000000000]
    DWORD bNoPassword : 1;  // 0x01A0 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bNoMutators : 1;  // 0x01A0 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bNotFull : 1;     // 0x01A0 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bNotEmpty : 1;    // 0x01A0 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bUsesStats : 1;   // 0x01A0 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bCustom : 1;      // 0x01A0 (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bDedicated : 1;   // 0x01A0 (0x0004) [0x0000000000000000] [0x00000040]
    DWORD bVAC_Secure : 1;  // 0x01A0 (0x0004) [0x0000000000000000] [0x00000080]
    DWORD bInLobby : 1;     // 0x01A0 (0x0004) [0x0000000000000000] [0x00000100]
    DWORD bInProgress : 1;  // 0x01A0 (0x0004) [0x0000000000000000] [0x00000200]
    DWORD bOnlyStockMaps : 1;          // 0x01A0 (0x0004) [0x0000000000000000]
                                       // [0x00000400]
    DWORD bOnlyCustomMaps : 1;         // 0x01A0 (0x0004) [0x0000000000000000]
                                       // [0x00000800]
    DWORD bLimitServerResults : 1;     // 0x01A0 (0x0004) [0x0000000000000000]
                                       // [0x00001000]
    DWORD bNoPasswordPending : 1;      // 0x01A0 (0x0004) [0x0000000000000000]
                                       // [0x00002000]
    DWORD bNoMutatorsPending : 1;      // 0x01A0 (0x0004) [0x0000000000000000]
                                       // [0x00004000]
    DWORD bNotFullPending : 1;         // 0x01A0 (0x0004) [0x0000000000000000]
                                       // [0x00008000]
    DWORD bNotEmptyPending : 1;        // 0x01A0 (0x0004) [0x0000000000000000]
                                       // [0x00010000]
    DWORD bUsesStatsPending : 1;       // 0x01A0 (0x0004) [0x0000000000000000]
                                       // [0x00020000]
    DWORD bCustomPending : 1;          // 0x01A0 (0x0004) [0x0000000000000000]
                                       // [0x00040000]
    DWORD bDedicatedPending : 1;       // 0x01A0 (0x0004) [0x0000000000000000]
                                       // [0x00080000]
    DWORD bVAC_SecurePending : 1;      // 0x01A0 (0x0004) [0x0000000000000000]
                                       // [0x00100000]
    DWORD bInLobbyPending : 1;         // 0x01A0 (0x0004) [0x0000000000000000]
                                       // [0x00200000]
    DWORD bInProgressPending : 1;      // 0x01A0 (0x0004) [0x0000000000000000]
                                       // [0x00400000]
    DWORD bOnlyStockMapsPending : 1;   // 0x01A0 (0x0004) [0x0000000000000000]
                                       // [0x00800000]
    DWORD bOnlyCustomMapsPending : 1;  // 0x01A0 (0x0004) [0x0000000000000000]
                                       // [0x01000000]
    DWORD bLimitServerResultsPending : 1;  // 0x01A0 (0x0004)
                                           // [0x0000000000000000] [0x02000000]
    unsigned char SavedGameModeIndex;    // 0x01A4 (0x0001) [0x0000000000000000]
    unsigned char SavedMapIndex;         // 0x01A5 (0x0001) [0x0000000000000000]
    unsigned char SavedDifficultyIndex;  // 0x01A6 (0x0001) [0x0000000000000000]
    unsigned char SavedLengthIndex;      // 0x01A7 (0x0001) [0x0000000000000000]
    unsigned char SavedPingIndex;        // 0x01A8 (0x0001) [0x0000000000000000]
    unsigned char
        SavedGameModeIndexPending;       // 0x01A9 (0x0001) [0x0000000000000000]
    unsigned char SavedMapIndexPending;  // 0x01AA (0x0001) [0x0000000000000000]
    unsigned char
        SavedDifficultyIndexPending;  // 0x01AB (0x0001) [0x0000000000000000]
    unsigned char
        SavedLengthIndexPending;  // 0x01AC (0x0001) [0x0000000000000000]
    unsigned char
        SavedPingIndexPending;       // 0x01AD (0x0001) [0x0000000000000000]
    struct FString CachedMapName;    // 0x01B0 (0x0010) [0x0000000000000000]
    struct FString CachedModeName;   // 0x01C0 (0x0010) [0x0000000000000000]
    int CachedDifficulty;            // 0x01D0 (0x0004) [0x0000000000000000]
    int CachedLength;                // 0x01D4 (0x0004) [0x0000000000000000]
    TArray<struct FString> MapList;  // 0x01D8 (0x0010) [0x0000000000000000]
    int NumDifficultyStrings;        // 0x01E8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3569];

        return pClassPointer;
    };

    void GetBoolByEFilter_Key();
    void SetBoolByEFilter_Key();
    void ResetFilters();
    void ClearPendingValues();
    void ApplyFilters();
    void PingChanged();
    void LengthChanged();
    void DifficultyChanged();
    void MapChanged();
    void ModeChanged();
    void CreateList();
    void SetModeMenus();
    void LocalizeCheckBoxes();
    void LocalizeText();
    void InitFiltersArray();
    void GetSelectedGameLength();
    void GetSelectedDifficulty();
    void GetSelectedMap();
    void AdjustSavedFiltersToMode();
    void GetUsableGameMode();
    void Initialize();
};

UClass* UKFGFxServerBrowser_Filters::pClassPointer = NULL;

// Class KFGame.KFGFxServerBrowser_ServerList
// 0x00A2 (0x014A - 0x00A8)
class UKFGFxServerBrowser_ServerList : public UKFGFxObject_Container {
   public:
    class UKFDataStore_OnlineGameSearch*
        SearchDataStore;                // 0x00A8 (0x0008) [0x0000000000000000]
    struct FString ServerPassword;      // 0x00B0 (0x0010) [0x0000000000000000]
    DWORD bJoinAsSpectator : 1;         // 0x00C0 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bQueryDialogShowing : 1;      // 0x00C0 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bIssuedInitialQuery : 1;      // 0x00C0 (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    struct FName SearchDSName;          // 0x00C4 (0x0008) [0x0000000000000000]
    class UOnlineSubsystem* OnlineSub;  // 0x00CC (0x0008) [0x0000000000000000]
    class UOnlineGameInterface*
        GameInterface;                 // 0x00D4 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x8];  // 0x00DC (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    TArray<class UGFxObject*>
        GFxServerObjects;            // 0x00E4 (0x0010) [0x0000000000000000]
    class UGFxObject* DataProvider;  // 0x00F4 (0x0008) [0x0000000000000000]
    int FakePlayerIndex;             // 0x00FC (0x0004) [0x0000000000000000]
    int SelectedServerIndex;         // 0x0100 (0x0004) [0x0000000000000000]
    struct FString
        LeaveServerBrowserString;   // 0x0104 (0x0010) [0x0000000000000000]
    struct FString DetailsString;   // 0x0114 (0x0010) [0x0000000000000000]
    struct FString SpectateString;  // 0x0124 (0x0010) [0x0000000000000000]
    class UKFGFxMenu_ServerBrowser*
        ServerMenu;        // 0x0134 (0x0008) [0x0000000000000000]
    int FilteredCount;     // 0x013C (0x0004) [0x0000000000000000]
    int MaxSearchResults;  // 0x0140 (0x0004) [0x0000000000000000]
    int lastServerCount;   // 0x0144 (0x0004) [0x0000000000000000]
    unsigned char
        QueryCompletionAction;        // 0x0148 (0x0001) [0x0000000000000000]
    unsigned char ECurrentSearchTab;  // 0x0149 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3571];

        return pClassPointer;
    };

    void SetSelectedServerFavorited();
    void IsSelectedServerFavorited();
    void UpdateListDataProvider();
    void OnServerSelected();
    void SetRefreshingIndicator();
    void GetServerDetails();
    void ClearSearchResults();
    void OnRefreshServerDetails();
    void BuildJoinFiltersRequestURL();
    void BuildJoinURL();
    void JoinGameURL();
    void ServerConnect();
    void OnHandshakeComplete();
    void OnQueryAdditionalServerInfoComplete();
    void OnJoinGameComplete();
    void ProcessJoin();
    void JoinServer();
    void DelayedRefresh();
    void OnCancelSearchComplete();
    void CancelQuery();
    void OnFindOnlineGamesComplete();
    void OnGetPlayerListComplete();
    void OnClose();
    void OnFindOnlineGamesCompleteDelegate();
    void FilterEntry();
    void SubmitServerListQuery();
    void BuildServerFilters();
    void RefreshServerList();
    void ClearGFXServerList();
    void OnRefeshClick();
    void LocalizeText();
    void ChangeSearchType();
    void ValidateServerType();
    void SortServerResultsRequest();
    void OnViewActivated();
    void Initialize();
};

UClass* UKFGFxServerBrowser_ServerList::pClassPointer = NULL;

// Class KFGame.KFGFxStartGameContainer_Options
// 0x01B4 (0x025C - 0x00A8)
class UKFGFxStartGameContainer_Options : public UKFGFxObject_Container {
   public:
    int ModeFilter;                   // 0x00A8 (0x0004) [0x0000000000000000]
    int DifficultyFilter;             // 0x00AC (0x0004) [0x0000000000000000]
    int LengthFilter;                 // 0x00B0 (0x0004) [0x0000000000000000]
    int ServerTypeFilter;             // 0x00B4 (0x0004) [0x0000000000000000]
    int InProgressFilter;             // 0x00B8 (0x0004) [0x0000000000000000]
    int PermissionsFilter;            // 0x00BC (0x0004) [0x0000000000000000]
    DWORD bModeFilterSet : 1;         // 0x00C0 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bLengthFilterSet : 1;       // 0x00C0 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bServerTypeFilterSet : 1;   // 0x00C0 (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    DWORD bInProgressFilterSet : 1;   // 0x00C0 (0x0004) [0x0000000000000000]
                                      // [0x00000008]
    DWORD bPermissionsFilterSet : 1;  // 0x00C0 (0x0004) [0x0000000000000000]
                                      // [0x00000010]
    DWORD bShowLengthNoPref : 1;      // 0x00C0 (0x0004) [0x0000000000000000]
                                      // [0x00000020]
    DWORD bShowServerTypeNoPref : 1;  // 0x00C0 (0x0004) [0x0000000000000000]
                                      // [0x00000040]
    DWORD bIsSoloGame : 1;  // 0x00C0 (0x0004) [0x0000000000000000] [0x00000080]
    int InitialMapIndex;    // 0x00C4 (0x0004) [0x0000000000000000]
    unsigned char SavedSoloModeIndex;  // 0x00C8 (0x0001) [0x0000000000000000]
    unsigned char
        SavedSoloDifficultyIndex;        // 0x00C9 (0x0001) [0x0000000000000000]
    unsigned char SavedSoloLengthIndex;  // 0x00CA (0x0001) [0x0000000000000000]
    unsigned char SavedModeIndex;        // 0x00CB (0x0001) [0x0000000000000000]
    unsigned char SavedDifficultyIndex;  // 0x00CC (0x0001) [0x0000000000000000]
    unsigned char SavedLengthIndex;      // 0x00CD (0x0001) [0x0000000000000000]
    unsigned char SavedPrivacyIndex;     // 0x00CE (0x0001) [0x0000000000000000]
    unsigned char SavedServerTypeIndex;  // 0x00CF (0x0001) [0x0000000000000000]
    unsigned char SavedInProgressIndex;  // 0x00D0 (0x0001) [0x0000000000000000]
    unsigned char RegionIndex;           // 0x00D1 (0x0001) [0x0000000000000000]
    struct FString SavedSoloMapString;   // 0x00D4 (0x0010) [0x0000000000000000]
    struct FString SavedMapString;       // 0x00E4 (0x0010) [0x0000000000000000]
    class UKFGFxMenu_StartGame*
        StartMenu;                    // 0x00F4 (0x0008) [0x0000000000000000]
    struct FString BackString;        // 0x00FC (0x0010) [0x0000000000000000]
    struct FString StartGameString;   // 0x010C (0x0010) [0x0000000000000000]
    struct FString LaunchGameString;  // 0x011C (0x0010) [0x0000000000000000]
    struct FString ServerTypeString;  // 0x012C (0x0010) [0x0000000000000000]
    struct FString InProgressString;  // 0x013C (0x0010) [0x0000000000000000]
    struct FString SoloGameString;    // 0x014C (0x0010) [0x0000000000000000]
    struct FString
        LeaveMatchMakingString;  // 0x015C (0x0010) [0x0000000000000000]
    struct FString
        MultiplayerLaunchString;     // 0x016C (0x0010) [0x0000000000000000]
    struct FString SearchingString;  // 0x017C (0x0010) [0x0000000000000000]
    struct FString
        CancelSearchingString;  // 0x018C (0x0010) [0x0000000000000000]
    struct FString
        StandardServerString;  // 0x019C (0x0010) [0x0000000000000000]
    struct FString
        UnrankedServerString;           // 0x01AC (0x0010) [0x0000000000000000]
    struct FString CustomServerString;  // 0x01BC (0x0010) [0x0000000000000000]
    struct FString
        AllowInProgressString;        // 0x01CC (0x0010) [0x0000000000000000]
    struct FString NotStartedString;  // 0x01DC (0x0010) [0x0000000000000000]
    TArray<struct FString>
        ServerTypeStrings;  // 0x01EC (0x0010) [0x0000000000000000]
    TArray<struct FString>
        InProgessOptionStrings;          // 0x01FC (0x0010) [0x0000000000000000]
    TArray<struct FString> GameTypes;    // 0x020C (0x0010) [0x0000000000000000]
    struct FString PreviousMapName;      // 0x021C (0x0010) [0x0000000000000000]
    class UGFxObject* ServerTypeButton;  // 0x022C (0x0008) [0x0000000000000000]
    class UGFxObject* InProgressButton;  // 0x0234 (0x0008) [0x0000000000000000]
    class UGFxObject* PrivacyButton;     // 0x023C (0x0008) [0x0000000000000000]
    class UGFxObject* LengthButton;      // 0x0244 (0x0008) [0x0000000000000000]
    class UGFxObject* DifficultyButton;  // 0x024C (0x0008) [0x0000000000000000]
    class UGFxObject* MapButton;         // 0x0254 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3573];

        return pClassPointer;
    };

    void DoesFilterMatchGameSettings();
    void GetServerTypeIndex();
    void eventGetPartyPrivacy();
    void GetMapName();
    void GetPrivacyIndex();
    void GetDifficulty();
    void GetLengthIndex();
    void GetDifficultyIndex();
    void GetModeIndex();
    void HandleNoPref();
    void GetAllowInProgress();
    void GetMakeNewServer();
    void eventGetGameLength();
    void UpdateFilters();
    void InProgressChanged();
    void ServerTypeChanged();
    void CheckAndUpdateBasedOnPrivacy();
    void PrivacyChanged();
    void MapChanged();
    void DifficultyChanged();
    void LengthChanged();
    void ModeChanged();
    void SetSearching();
    void SetOptions();
    void CreateList();
    void LocalizeArrays();
    void InitializeGameOptions();
    void SetModeMenus();
    void SetHelpText();
    void UpdateButtonsEnabled();
    void ClampSavedFiltersToMode();
    void GetButtons();
    void Initialize();
};

UClass* UKFGFxStartGameContainer_Options::pClassPointer = NULL;

// Class KFGame.KFGFxObject_Menu
// 0x0040 (0x00E0 - 0x00A0)
class UKFGFxObject_Menu : public UGFxObject {
   public:
    class UKFGFxMoviePlayer_Manager*
        Manager;                        // 0x00A0 (0x0008) [0x0000000000000000]
    class UTWOnlineLobby* OnlineLobby;  // 0x00A8 (0x0008) [0x0000000000000000]
    struct FString
        LeavePartyTitleString;  // 0x00B0 (0x0010) [0x0000000000000000]
    struct FString
        LeavePartyDescriptionString;  // 0x00C0 (0x0010) [0x0000000000000000]
    struct FString LeaveString;       // 0x00D0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3575];

        return pClassPointer;
    };

    void Callback_MouseMoved();
    void SetControlScheme();
    void eventFilterButtonInput();
    void Callback_ChatFocusOut();
    void Callback_ChatFocusIn();
    void Callback_BroadcastChatMessage();
    void PlayCloseAnimation();
    void PlayOpenAnimation();
    void Callback_InviteFriend();
    void Callback_OpenPlayerList();
    void Callback_LeaveParty();
    void Callback_CreateParty();
    void Callback_ProfileOption();
    void Callback_PerkChanged();
    void Callback_PlayerClicked();
    void Callback_ReadyClicked();
    void Callback_RequestTeamSwitch();
    void Callback_MenuBarTabChanged();
    void Callback_MenusFinishedClosing();
    void Callback_Quit();
    void Callback_ControllerCloseMenu();
    void ConsoleLocalize();
    void CancelLeaveParty();
    void ConfirmLeaveParty();
    void ShowLeavePartyPopUp();
    void OnLobbyStatusChanged();
    void eventOnClose();
    void OnRoundOver();
    void eventOnTraderTimeStart();
    void eventOnAxisModified();
    void OneSecondLoop();
    void OnInputTypeChanged();
    void OnR3Pressed();
    void InitOnlineLobby();
    void OnOpen();
    void InitializeMenu();
};

UClass* UKFGFxObject_Menu::pClassPointer = NULL;

// Class KFGame.KFGFxMenu_Gear
// 0x01A4 (0x0284 - 0x00E0)
class UKFGFxMenu_Gear : public UKFGFxObject_Menu {
   public:
    class UKFGFxObject_Container*
        CustomizationComponent;  // 0x00E0 (0x0008) [0x0000000000000000]
    class AKFPlayerReplicationInfo*
        MyKFPRI;  // 0x00E8 (0x0008) [0x0000000000000000]
    class UKFGFxGearContainer_PerksSelection*
        PerkSelectionContainer;        // 0x00F0 (0x0008) [0x0000000000000000]
    struct FString HeadMeshKey;        // 0x00F8 (0x0010) [0x0000000000000000]
    struct FString HeadSkinKey;        // 0x0108 (0x0010) [0x0000000000000000]
    struct FString HeadFunctionKey;    // 0x0118 (0x0010) [0x0000000000000000]
    struct FString BodyMeshKey;        // 0x0128 (0x0010) [0x0000000000000000]
    struct FString BodySkinKey;        // 0x0138 (0x0010) [0x0000000000000000]
    struct FString BodyFunctionKey;    // 0x0148 (0x0010) [0x0000000000000000]
    struct FString AttachmentKey;      // 0x0158 (0x0010) [0x0000000000000000]
    struct FString AttachmentSkinKey;  // 0x0168 (0x0010) [0x0000000000000000]
    struct FString
        AttachmentFunctionKey;  // 0x0178 (0x0010) [0x0000000000000000]
    struct FString
        KFCharacterInfoString;         // 0x0188 (0x0010) [0x0000000000000000]
    struct FString KFEmoteInfoString;  // 0x0198 (0x0010) [0x0000000000000000]
    class UKFCharacterInfo_Human*
        CurrentCharInfo;               // 0x01A8 (0x0008) [0x0000000000000000]
    struct FString CharInfoPath;       // 0x01B0 (0x0010) [0x0000000000000000]
    struct FString GearHeaderString;   // 0x01C0 (0x0010) [0x0000000000000000]
    struct FString CharacterString;    // 0x01D0 (0x0010) [0x0000000000000000]
    struct FString BioString;          // 0x01E0 (0x0010) [0x0000000000000000]
    struct FString HeadString;         // 0x01F0 (0x0010) [0x0000000000000000]
    struct FString BodyString;         // 0x0200 (0x0010) [0x0000000000000000]
    struct FString AttachmentsString;  // 0x0210 (0x0010) [0x0000000000000000]
    struct FString SkinsString;        // 0x0220 (0x0010) [0x0000000000000000]
    struct FString BackString;         // 0x0230 (0x0010) [0x0000000000000000]
    struct FString NoneString;         // 0x0240 (0x0010) [0x0000000000000000]
    class UKFGFxObject_TraderItems*
        TraderItems;                    // 0x0250 (0x0008) [0x0000000000000000]
    int ControllerRotationRate;         // 0x0258 (0x0004) [0x0000000000000000]
    float ControllerRotationThreshold;  // 0x025C (0x0004) [0x0000000000000000]
    int CurrentPerkIndex;               // 0x0260 (0x0004) [0x0000000000000000]
    struct FString ClearImagePath;      // 0x0264 (0x0010) [0x0000000000000000]
    TArray<struct FEmote> EmoteList;    // 0x0274 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3577];

        return pClassPointer;
    };

    void SelectCustomizationOption();
    void SelectCharacter();
    void RelayFromCheatManager();
    void Callback_Attachment();
    void Callback_Body();
    void Callback_Head();
    void Callback_Character();
    void Callback_Emote();
    void Callback_HeadCamera();
    void Callback_BodyCamera();
    void Callback_EndRotateCamera();
    void Callback_RotateCamera();
    void eventOnAxisModified();
    void eventOnClose();
    void SetAttachmentButtons();
    void SetGearButtons();
    void SetEmoteButton();
    void SetCurrentCharacterButtons();
    void UpdateOutfitVariants();
    void UpdateCosmeticVariants();
    void UpdateAttachmentsList();
    void UpdateMeshList();
    void ReInitMenu();
    void UpdateGear();
    void UpdateCharacterList();
    void UpdateEmoteList();
    void LocalizeText();
    void SaveChanges();
    void CheckForCustomizationPawn();
    void OnOpen();
    void eventWidgetInitialized();
    void InitializeMenu();
};

UClass* UKFGFxMenu_Gear::pClassPointer = NULL;

// Class KFGame.KFGFxMenu_IIS
// 0x0034 (0x0114 - 0x00E0)
class UKFGFxMenu_IIS : public UKFGFxObject_Menu {
   public:
    struct FScriptDelegate
        AutoLoginCompleteDelegate;     // 0x00E0 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x00E4 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    DWORD bLoggingIn : 1;  // 0x00F0 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bForceConnectionAtLogin : 1;  // 0x00F0 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bStatsRead : 1;  // 0x00F0 (0x0004) [0x0000000000000000] [0x00000004]
    class UOnlineSubsystem* OnlineSub;  // 0x00F4 (0x0008) [0x0000000000000000]
    class UPlayfabInterface*
        PlayfabInter;  // 0x00FC (0x0008) [0x0000000000000000]
    struct FScriptDelegate
        __OnAutoLoginComplete__Delegate;  // 0x0104 (0x0010)
                                          // [0x0000000000000000]
    unsigned char UnknownData01[0x4];  // 0x0108 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3579];

        return pClassPointer;
    };

    void NotifyLoginFailed();
    void DelayedOpenGammaPopup();
    void OnPS4StatsRead();
    void ProceedToMainMenu();
    void OnLoginToGameComplete();
    void OnStatsRead();
    void OnReadProfileSettingsComplete();
    void LoginToGame();
    void OnLoginStatusChanged();
    void OnConfirmPlayOffline();
    void OnLoginCancelled();
    void ShowLoginUI();
    void ValidateActiveAccount();
    void eventFilterButtonInput();
    void UnRegisterDelegates();
    void eventOnClose();
    void OnOpen();
    void eventAttemptAutoLogin();
    void OnAutoLoginComplete();
};

UClass* UKFGFxMenu_IIS::pClassPointer = NULL;

// Class KFGame.KFGFxMenu_StartGame
// 0x02B0 (0x0390 - 0x00E0)
class UKFGFxMenu_StartGame : public UKFGFxObject_Menu {
   public:
    DWORD bIsLeader : 1;   // 0x00E0 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bIsInParty : 1;  // 0x00E0 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bSearchingForGame : 1;       // 0x00E0 (0x0004) [0x0000000000000000]
                                       // [0x00000004]
    DWORD bLeaderInServerBrowser : 1;  // 0x00E0 (0x0004) [0x0000000000000000]
                                       // [0x00000008]
    DWORD bLeaderWasInServerBrowser : 1;  // 0x00E0 (0x0004)
                                          // [0x0000000000000000] [0x00000010]
    DWORD AttemptingJoin : 1;           // 0x00E0 (0x0004) [0x0000000000000000]
                                        // [0x00000020]
    DWORD bAttemptingServerCreate : 1;  // 0x00E0 (0x0004) [0x0000000000000000]
                                        // [0x00000040]
    DWORD bHarrassedPlayerAboutSharedContent : 1;  // 0x00E0 (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00000080]
    DWORD AttemptServerTakeovers : 1;  // 0x00E0 (0x0004) [0x0000000000000000]
                                       // [0x00000100]
    DWORD bPauseTryingServers : 1;     // 0x00E0 (0x0004) [0x0000000000000000]
                                       // [0x00000200]
    DWORD bLogSearchInfo : 1;          // 0x00E0 (0x0004) [0x0000000000000000]
                                       // [0x00000400]
    DWORD SearchFinished : 1;          // 0x00E0 (0x0004) [0x0000000000000000]
                                       // [0x00000800]
    DWORD
        bIsPlayGoRun : 1;  // 0x00E0 (0x0004) [0x0000000000000000] [0x00001000]
    int CurrentSearchIndex;         // 0x00E4 (0x0004) [0x0000000000000000]
    struct FString ModeKey;         // 0x00E8 (0x0010) [0x0000000000000000]
    struct FString DifficultyKey;   // 0x00F8 (0x0010) [0x0000000000000000]
    struct FString MapKey;          // 0x0108 (0x0010) [0x0000000000000000]
    struct FString WhitelistedKey;  // 0x0118 (0x0010) [0x0000000000000000]
    struct FString InProgressKey;   // 0x0128 (0x0010) [0x0000000000000000]
    struct FString PermissionsKey;  // 0x0138 (0x0010) [0x0000000000000000]
    struct FString ServerTypeKey;   // 0x0148 (0x0010) [0x0000000000000000]
    struct FString GameLengthKey;   // 0x0158 (0x0010) [0x0000000000000000]
    class UKFGFxStartGameContainer_FindGame*
        FindGameContainer;  // 0x0168 (0x0008) [0x0000000000000000]
    class UKFGFxStartGameContainer_Options*
        OptionsComponent;  // 0x0170 (0x0008) [0x0000000000000000]
    class UKFGFxStartContainer_InGameOverview*
        OverviewContainer;  // 0x0178 (0x0008) [0x0000000000000000]
    class UKFGFxStartContainer_ServerBrowserOverview*
        ServerBrowserOverviewContainer;  // 0x0180 (0x0008) [0x0000000000000000]
    class UKFGFxMissionObjectivesContainer*
        MissionObjectiveContainer;  // 0x0188 (0x0008) [0x0000000000000000]
    class UGFxObject*
        MatchMakingButton;  // 0x0190 (0x0008) [0x0000000000000000]
    class UGFxObject*
        ServerBrowserButton;             // 0x0198 (0x0008) [0x0000000000000000]
    struct FString FindGameString;       // 0x01A0 (0x0010) [0x0000000000000000]
    struct FString HostOptionsString;    // 0x01B0 (0x0010) [0x0000000000000000]
    struct FString OverviewString;       // 0x01C0 (0x0010) [0x0000000000000000]
    struct FString MatchmakingString;    // 0x01D0 (0x0010) [0x0000000000000000]
    struct FString ServerBrowserString;  // 0x01E0 (0x0010) [0x0000000000000000]
    struct FString GameModeTitle;        // 0x01F0 (0x0010) [0x0000000000000000]
    struct FString DifficultyTitle;      // 0x0200 (0x0010) [0x0000000000000000]
    struct FString LengthTitle;          // 0x0210 (0x0010) [0x0000000000000000]
    struct FString MapTitle;             // 0x0220 (0x0010) [0x0000000000000000]
    struct FString MutatorTitle;         // 0x0230 (0x0010) [0x0000000000000000]
    struct FString PermissionsTitle;     // 0x0240 (0x0010) [0x0000000000000000]
    struct FString ServerTypeString;     // 0x0250 (0x0010) [0x0000000000000000]
    struct FString WhiteListedTitle;     // 0x0260 (0x0010) [0x0000000000000000]
    struct FString InfoTitle;            // 0x0270 (0x0010) [0x0000000000000000]
    struct FString InProgressString;     // 0x0280 (0x0010) [0x0000000000000000]
    struct FString LeaveMenuString;      // 0x0290 (0x0010) [0x0000000000000000]
    struct FString
        CouldNotFindGameTitleString;  // 0x02A0 (0x0010) [0x0000000000000000]
    struct FString CouldNotFindGameDescriptionStringPC;  // 0x02B0 (0x0010)
                                                         // [0x0000000000000000]
    struct FString
        CouldNotFindGameDescriptionStringOrbis;  // 0x02C0 (0x0010)
                                                 // [0x0000000000000000]
    TArray<struct FString>
        WhiteListedStrings;     // 0x02D0 (0x0010) [0x0000000000000000]
    struct FName SearchDSName;  // 0x02E0 (0x0008) [0x0000000000000000]
    class UKFDataStore_OnlineGameSearch*
        SearchDataStore;  // 0x02E8 (0x0008) [0x0000000000000000]
    class UOnlineGameInterface*
        GameInterface;                 // 0x02F0 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x8];  // 0x02F8 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    TArray<struct FString>
        MapStringList;              // 0x0300 (0x0010) [0x0000000000000000]
    struct FString MapTakeoverURL;  // 0x0310 (0x0010) [0x0000000000000000]
    struct FString
        PendingResolvedAddress;  // 0x0320 (0x0010) [0x0000000000000000]
    struct FString
        CurrentPartyLeaderName;         // 0x0330 (0x0010) [0x0000000000000000]
    float InitialSearchPause;           // 0x0340 (0x0004) [0x0000000000000000]
    int MaxResultsToTry;                // 0x0344 (0x0004) [0x0000000000000000]
    int ServerConnectTimeout;           // 0x0348 (0x0004) [0x0000000000000000]
    int ServerTakeoverTimeout;          // 0x034C (0x0004) [0x0000000000000000]
    TArray<struct FString> StockMaps;   // 0x0350 (0x0010) [0x0000000000000000]
    struct FString LobbyOwnerPassword;  // 0x0360 (0x0010) [0x0000000000000000]
    struct FString
        TestLobbyOwnerPassword;        // 0x0370 (0x0010) [0x0000000000000000]
    struct FString CurrentConnectMap;  // 0x0380 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3581];

        return pClassPointer;
    };

    void ShowOverview();
    void OnCancelSearchComplete();
    void eventCancelGameSearch();
    void UnpauseTryingServers();
    void OnBuyGamePressed();
    void Callback_StartOnlineGame();
    void GenerateRandomPassword();
    void OnSetTakoverServerPassword();
    void ShowServerTakeoverPasswordPrompt();
    void eventStartOnlineGame();
    void Callback_StartOfflineGame();
    void Callback_StartGame();
    void ShouldUseLengthFilter();
    void ShouldUseDifficultyFilter();
    void BuildServerFilters();
    void AddLobbyFilter();
    void eventOnClose();
    void OnHandshakeComplete();
    void OnOpen();
    void ServerConnectGiveUp();
    void eventAddJoinGameCompleteDelegate();
    void eventSetServerConnectGiveUpTimer();
    void ConnectToPlayfabServer();
    void OnJoinGameComplete();
    void SecureTakeover();
    void BuildTakeoverURL();
    void BuildJoinFiltersRequestURL();
    void RandomizeSearchResults();
    void SortServers();
    void SortLastEntry();
    void MapGood();
    void SpaceAvailable();
    void OnFindGameServerComplete();
    void eventGetLobbySize();
    void eventOpenNotFoundPopup();
    void HandleSearchOver();
    void TryNextServer();
    void GetSearchComplete();
    void MakeMapURL();
    void SetLobbyData();
    void Callback_InProgress();
    void Callback_ServerType();
    void Callback_MapSelection();
    void Callback_Privacy();
    void Callback_Difficulty();
    void Callback_Length();
    void Callback_Mode();
    void Callback_StartMenuChange();
    void Callback_StartMenuRequestReinit();
    void OnCanPlayOnlineCheckComplete();
    void Callback_OpenServerBrowser();
    void ProceedToMatchMaking();
    void Callback_OpenMatchMaking();
    void Callback_InGamePermissionChange();
    void Callback_OptionListOpened();
    void Callback_RequestLeaveMatchmaking();
    void Callback_CancelSearch();
    void Callback_OnWebLinkClicked();
    void Callback_StartTutorial();
    void Callback_OnWhatsNewClicked();
    void UpdateStartMenuState();
    void OpenMultiplayerMenu();
    void CancelLeaveMenu();
    void GoToServerBrowser();
    void ApproveMatchMakingLeave();
    void ReceiveLeaderOptions();
    void SendLeaderOptions();
    void UpdateMenu();
    void SendToOverviewOnChange();
    void HandleSteamLobbyLeaderTakeOver();
    void GetMapSource();
    void GetStartMenuState();
    void OneSecondLoop();
    void OnPlayerReadiedUp();
    void SetOverview();
    void ReloadSounds();
    void CheckGameFullyInstalled();
    void GetCouldNotFindGameDescription();
    void eventWidgetInitialized();
    void GetSpecialEventClass();
    void SetSeasonalEventClass();
    void InitializeMenu();
    void GetMapList();
};

UClass* UKFGFxMenu_StartGame::pClassPointer = NULL;

// Class KFGame.KFGFxMenu_Store
// 0x0048 (0x0128 - 0x00E0)
class UKFGFxMenu_Store : public UKFGFxObject_Menu {
   public:
    struct FString ExitKF2;             // 0x00E0 (0x0010) [0x0000000000000000]
    class UOnlineSubsystem* OnlineSub;  // 0x00F0 (0x0008) [0x0000000000000000]
    class UKFGFxStoreContainer_Main*
        MainContainer;  // 0x00F8 (0x0008) [0x0000000000000000]
    class UKFGFxStoreContainer_Details*
        DetailsContainer;  // 0x0100 (0x0008) [0x0000000000000000]
    class UKFGFxStoreContainer_Cart*
        CartContainer;                // 0x0108 (0x0008) [0x0000000000000000]
    class UGFxObject* AddCartButton;  // 0x0110 (0x0008) [0x0000000000000000]
    struct FString StoreString;       // 0x0118 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3583];

        return pClassPointer;
    };

    void CheckForEmptyStore();
    void CreateStoreItem();
    void CallBack_ItemDetailsClicked();
    void Callback_AddToCartClicked();
    void Callback_StoreSectionChanged();
    void eventWidgetInitialized();
    void LocalizeText();
    void RefreshItemList();
    void OnReadPlayfabInventoryComplete();
    void OnInventoryReadComplete();
    void OnClose();
    void OnOpen();
    void InitializeMenu();
    void HideSystemStoreIcon();
    void ShowSystemStoreIcon();
};

UClass* UKFGFxMenu_Store::pClassPointer = NULL;

// Class KFGame.KFGFxMenu_Trader
// 0x017C (0x025C - 0x00E0)
class UKFGFxMenu_Trader : public UKFGFxObject_Menu {
   public:
    class AKFPlayerController* MyKFPC;  // 0x00E0 (0x0008) [0x0000000000000000]
    class AKFPlayerReplicationInfo*
        MyKFPRI;                        // 0x00E8 (0x0008) [0x0000000000000000]
    class AKFInventoryManager* MyKFIM;  // 0x00F0 (0x0008) [0x0000000000000000]
    class UKFGFxTraderContainer_GameInfo*
        GameInfoContainer;  // 0x00F8 (0x0008) [0x0000000000000000]
    class UKFGFxTraderContainer_Filter*
        FilterContainer;  // 0x0100 (0x0008) [0x0000000000000000]
    class UKFGFxTraderContainer_Store*
        ShopContainer;  // 0x0108 (0x0008) [0x0000000000000000]
    class UKFGFxTraderContainer_PlayerInventory*
        PlayerInventoryContainer;  // 0x0110 (0x0008) [0x0000000000000000]
    class UKFGFxTraderContainer_PlayerInfo*
        PlayerInfoContainer;  // 0x0118 (0x0008) [0x0000000000000000]
    class UKFGFxTraderContainer_ItemDetails*
        ItemDetails;                 // 0x0120 (0x0008) [0x0000000000000000]
    DWORD bGenericItemSelected : 1;  // 0x0128 (0x0004) [0x0000000000000000]
                                     // [0x00000001]
    DWORD bCanBuyOrSellItem : 1;     // 0x0128 (0x0004) [0x0000000000000000]
                                     // [0x00000002]
    struct FSTraderItem
        LastDefaultItemInfo;  // 0x012C (0x0064) [0x0000000000000000]
    struct FSItemInformation
        LastItemInfo;                 // 0x0190 (0x0088) [0x0000000000000000]
    struct FString ExitMenuString;    // 0x0218 (0x0010) [0x0000000000000000]
    int PrevArmor;                    // 0x0228 (0x0004) [0x0000000000000000]
    unsigned char CurrentTab;         // 0x022C (0x0001) [0x0000000000000000]
    unsigned char SelectedList;       // 0x022D (0x0001) [0x0000000000000000]
    unsigned char SelectedItemIndex;  // 0x022E (0x0001) [0x0000000000000000]
    int CurrentFilterIndex;           // 0x0230 (0x0004) [0x0000000000000000]
    TArray<struct FName>
        FavoritedItems;            // 0x0234 (0x0010) [0x0000000000000000]
    class AKFPerk* LastPerkClass;  // 0x0244 (0x0008) [0x0000000000000000]
    TArray<struct FSItemInformation>
        OwnedItemList;  // 0x024C (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3585];

        return pClassPointer;
    };

    void Callback_Close();
    void Callback_PerkChanged();
    void Callback_GrenadeItemSelected();
    void Callback_ArmorItemSelected();
    void Callback_PlayerItemSelected();
    void Callback_ShopItemSelected();
    void Callback_AutoFill();
    void Callback_BuyMagazine();
    void Callback_FillAmmo();
    void Callback_FillArmor();
    void Callback_FillGrenades();
    void Callback_BuyGrenade();
    void Callback_TabChanged();
    void Callback_FilterChanged();
    void Callback_FavoriteItem();
    void Callback_BuyOrSellItem();
    void GetDisplayedBlocksRequiredFor();
    void ToggleFavorite();
    void GetIsFavorite();
    void RefreshShopItemList();
    void RefreshItemComponents();
    void OnPerkChanged();
    void SetNewSelectedIndex();
    void SetGenericItemDetails();
    void SetPlayerItemDetails();
    void SetTraderItemDetails();
    void GiveExternalWeapon();
    void UpdatePlayerInfo();
    void OneSecondLoop();
    void eventOnClose();
    void GetPerkIndex();
    void eventWidgetInitialized();
    void OnOpen();
    void LocalizeText();
    void OnR3Pressed();
    void InitializeMenu();
};

UClass* UKFGFxMenu_Trader::pClassPointer = NULL;

// Class KFGame.KFGFxOptionsMenu_Graphics
// 0x0930 (0x0A10 - 0x00E0)
class UKFGFxOptionsMenu_Graphics : public UKFGFxObject_Menu {
   public:
    DWORD bIsRevertCoundownActive : 1;  // 0x00E0 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD UnsavedPendingRestart : 1;    // 0x00E0 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    unsigned char TimeCount;            // 0x00E4 (0x0001) [0x0000000000000000]
    unsigned char ExpireTime;           // 0x00E5 (0x0001) [0x0000000000000000]
    struct FString FlexPopUpString;     // 0x00E8 (0x0010) [0x0000000000000000]
    struct FString
        KeepSettingsPromptString;        // 0x00F8 (0x0010) [0x0000000000000000]
    struct FString WarningPromptString;  // 0x0108 (0x0010) [0x0000000000000000]
    struct FString WillExpireString;     // 0x0118 (0x0010) [0x0000000000000000]
    struct FString
        PerformanceDescString[0x2];      // 0x0128 (0x0020) [0x0000000000000000]
    struct FString RestartDescString;    // 0x0148 (0x0010) [0x0000000000000000]
    struct FString SingleWarningString;  // 0x0158 (0x0010) [0x0000000000000000]
    struct FString DoubleWarningString;  // 0x0168 (0x0010) [0x0000000000000000]
    struct FString
        UnsavedChangesString;          // 0x0178 (0x0010) [0x0000000000000000]
    struct FString ContinueString;     // 0x0188 (0x0010) [0x0000000000000000]
    struct FString SaveChangesString;  // 0x0198 (0x0010) [0x0000000000000000]
    struct FString
        AdjustGammaDescription;        // 0x01A8 (0x0010) [0x0000000000000000]
    struct FString ResetGammaString;   // 0x01B8 (0x0010) [0x0000000000000000]
    struct FString SetGammaString;     // 0x01C8 (0x0010) [0x0000000000000000]
    struct FString GraphicsString;     // 0x01D8 (0x0010) [0x0000000000000000]
    struct FString BasicString;        // 0x01E8 (0x0010) [0x0000000000000000]
    struct FString AdvancedString;     // 0x01F8 (0x0010) [0x0000000000000000]
    struct FString EffectsString;      // 0x0208 (0x0010) [0x0000000000000000]
    struct FString AspectRatioString;  // 0x0218 (0x0010) [0x0000000000000000]
    struct FString ResolutionString;   // 0x0228 (0x0010) [0x0000000000000000]
    struct FString
        GraphicsQualityString;        // 0x0238 (0x0010) [0x0000000000000000]
    struct FString VSyncString;       // 0x0248 (0x0010) [0x0000000000000000]
    struct FString FullscreenString;  // 0x0258 (0x0010) [0x0000000000000000]
    struct FString
        VariableFrameRateString;       // 0x0268 (0x0010) [0x0000000000000000]
    struct FString AdjustGammaString;  // 0x0278 (0x0010) [0x0000000000000000]
    struct FString FilmGrainString;    // 0x0288 (0x0010) [0x0000000000000000]
    struct FString
        EnvironmentDetailsString;  // 0x0298 (0x0010) [0x0000000000000000]
    struct FString
        CharacterDetailString;  // 0x02A8 (0x0010) [0x0000000000000000]
    struct FString FXString;    // 0x02B8 (0x0010) [0x0000000000000000]
    struct FString
        TextureResolutionString;  // 0x02C8 (0x0010) [0x0000000000000000]
    struct FString
        TextureFilteringString;    // 0x02D8 (0x0010) [0x0000000000000000]
    struct FString ShadowsString;  // 0x02E8 (0x0010) [0x0000000000000000]
    struct FString
        RealtimeReflectionsString;      // 0x02F8 (0x0010) [0x0000000000000000]
    struct FString AntiAliasingString;  // 0x0308 (0x0010) [0x0000000000000000]
    struct FString BloomString;         // 0x0318 (0x0010) [0x0000000000000000]
    struct FString MotionBlurString;    // 0x0328 (0x0010) [0x0000000000000000]
    struct FString
        AmbientOcclusionString;         // 0x0338 (0x0010) [0x0000000000000000]
    struct FString DepthOfFieldString;  // 0x0348 (0x0010) [0x0000000000000000]
    struct FString
        VolumetricLightingString;       // 0x0358 (0x0010) [0x0000000000000000]
    struct FString lensFlaresString;    // 0x0368 (0x0010) [0x0000000000000000]
    struct FString LightShaftsString;   // 0x0378 (0x0010) [0x0000000000000000]
    struct FString CustomString;        // 0x0388 (0x0010) [0x0000000000000000]
    struct FString IniOverrideString;   // 0x0398 (0x0010) [0x0000000000000000]
    struct FString OKString;            // 0x03A8 (0x0010) [0x0000000000000000]
    struct FString ApplyString;         // 0x03B8 (0x0010) [0x0000000000000000]
    struct FString CancelString;        // 0x03C8 (0x0010) [0x0000000000000000]
    struct FString DefaultString;       // 0x03D8 (0x0010) [0x0000000000000000]
    struct FString PhysicsLevelString;  // 0x03E8 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        PhysicsLevelOptionStrings;  // 0x03F8 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        PhysicsLevelSuggestionStrings;  // 0x0408 (0x0010) [0x0000000000000000]
    struct FString
        AspectRatioString_All;  // 0x0418 (0x0010) [0x0000000000000000]
    struct FString
        StandardAspectRatioString_4;  // 0x0428 (0x0010) [0x0000000000000000]
    struct FString
        StandardAspectRatioString_5;  // 0x0438 (0x0010) [0x0000000000000000]
    struct FString
        StandardAspectRatioString_3;  // 0x0448 (0x0010) [0x0000000000000000]
    struct FString
        WideAspectRatioString_16;  // 0x0458 (0x0010) [0x0000000000000000]
    struct FString
        WideAspectRatioString_1601;  // 0x0468 (0x0010) [0x0000000000000000]
    struct FString
        ExtraWideAspectRatioString_2;  // 0x0478 (0x0010) [0x0000000000000000]
    struct FString
        ExtraWideAspectRatioString_21;  // 0x0488 (0x0010) [0x0000000000000000]
    struct FString
        MultiMonitorAspectRatioString;  // 0x0498 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        FullScreenStringOptions;  // 0x04A8 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        GraphicsQualityStringOptions;  // 0x04B8 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        VSyncStringOptions;  // 0x04C8 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        EnvironmentDetailsStringOptions;  // 0x04D8 (0x0010)
                                          // [0x0000000000000000]
    TArray<struct FString>
        CharacterDetailStringOptions;  // 0x04E8 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        FXStringOptions;  // 0x04F8 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        TextureResolutionStringOptions;  // 0x0508 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        TextureFilteringStringOptions;  // 0x0518 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        ShadowsStringOptions;  // 0x0528 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        RealtimeReflectionsStringOptions;  // 0x0538 (0x0010)
                                           // [0x0000000000000000]
    TArray<struct FString>
        AntiAliasingStringOptions;  // 0x0548 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        BloomStringOptions;  // 0x0558 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        MotionBlurStringOptions;  // 0x0568 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        AmbientOcclusionStringOptions;  // 0x0578 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        DepthOfFieldStringOptions;  // 0x0588 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        OffOnStringOptions;  // 0x0598 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        SupportedResolutionList;  // 0x05A8 (0x0010) [0x0000000000000000]
    struct FString
        RevertPopupDescriptionString;  // 0x05B8 (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        AvailableAspectRatioList;  // 0x05C8 (0x0010) [0x0000000000000000]
    TArray<struct FGraphicsQualitySetting>
        GraphicsQualityPresets;  // 0x05D8 (0x0010) [0x0000000000000000]
    TArray<struct FDisplaySetting>
        DisplayPresets;  // 0x05E8 (0x0010) [0x0000000000000000]
    TArray<struct FVSyncSetting>
        VSyncPresets;  // 0x05F8 (0x0010) [0x0000000000000000]
    TArray<struct FVariableFramerateSetting>
        VariableFrameratePresets;  // 0x0608 (0x0010) [0x0000000000000000]
    TArray<struct FFilmGrainSetting>
        FilmGrainMinMaxPreset;  // 0x0618 (0x0010) [0x0000000000000000]
    TArray<struct FFlexSetting>
        FlexPresets;  // 0x0628 (0x0010) [0x0000000000000000]
    TArray<struct FEnvironmentDetailSetting>
        EnvironmentDetailPresets;  // 0x0638 (0x0010) [0x0000000000000000]
    TArray<struct FShadowQualitySetting>
        ShadowQualityPresets;  // 0x0648 (0x0010) [0x0000000000000000]
    TArray<struct FFXQualitySetting>
        FXQualityPresets;  // 0x0658 (0x0010) [0x0000000000000000]
    TArray<struct FRealtimeReflectionsSetting>
        RealtimeReflectionsPresets;  // 0x0668 (0x0010) [0x0000000000000000]
    TArray<struct FCharacterDetailSetting>
        CharacterDetailPresets;  // 0x0678 (0x0010) [0x0000000000000000]
    TArray<struct FLightShaftsSetting>
        LightShaftsPresets;  // 0x0688 (0x0010) [0x0000000000000000]
    TArray<struct FVolumetricLightingSetting>
        VolumetricLightingPresets;  // 0x0698 (0x0010) [0x0000000000000000]
    TArray<struct FLensFlareSetting>
        LensFlarePresets;  // 0x06A8 (0x0010) [0x0000000000000000]
    TArray<struct FTextureResolutionSetting>
        TextureResolutionPresets;  // 0x06B8 (0x0010) [0x0000000000000000]
    TArray<struct FTextureFilterSetting>
        TextureFilterPresets;  // 0x06C8 (0x0010) [0x0000000000000000]
    TArray<struct FBloomSetting>
        BloomPresets;  // 0x06D8 (0x0010) [0x0000000000000000]
    TArray<struct FMotionBlurSetting>
        MotionBlurPresets;  // 0x06E8 (0x0010) [0x0000000000000000]
    TArray<struct FAntiAliasingSetting>
        AntiAliasingPresets;  // 0x06F8 (0x0010) [0x0000000000000000]
    TArray<struct FAmbientOcclusionSetting>
        AmbientOcclusionPresets;  // 0x0708 (0x0010) [0x0000000000000000]
    TArray<struct FDOFSetting>
        DOFPresets;  // 0x0718 (0x0010) [0x0000000000000000]
    struct FGFXSettings
        CurrentGFXSettings;  // 0x0728 (0x00F8) [0x0000000000000000]
    struct FGFXSettings
        RevertedGFXSettings;  // 0x0820 (0x00F8) [0x0000000000000000]
    struct FGFXSettings
        UnsavedGFXSettings;  // 0x0918 (0x00F8) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3587];

        return pClassPointer;
    };

    void Callback_OpenGamma();
    void Callback_ResetDefaultVideo();
    void Callback_CancelVideo();
    void Callback_ApplyVideo();
    void Callback_FleXOptionChange();
    void Callback_CloseMenu();
    void OnSaveCancel();
    void OnSaveConfirm();
    void OnSettingsRevert();
    void OnRestartConfirm();
    void OnSettingsConfirm();
    void OnFlexSettingChanged();
    void OnLightShaftsSettingChanged();
    void OnLensFlareSettingChanged();
    void OnVolumetricLightingSettingChanged();
    void OnDOFSettingChanged();
    void OnAmbientOcclusionSettingChanged();
    void OnMotionBlurSettingChanged();
    void OnBloomSettingChanged();
    void OnAntiAliasingSettingChanged();
    void OnReflectionSettingChanged();
    void OnShadowQualitySettingChanged();
    void OnTextureFilteringSettingChanged();
    void OnTextureResolutionSettingChanged();
    void OnFXQualitySettingChanged();
    void OnCharacterDetailSettingChanged();
    void OnEnvironmentDetailSettingChanged();
    void OnFilmGrainSettingChanged();
    void OnVariableFramerateSettingChanged();
    void OnDisplaySettingChanged();
    void OnVsyncSettingChanged();
    void OnResolutionSettingChanged();
    void OnAdvancedOptionChanged();
    void OnAspectRatioSet();
    void UpdateResolutionList();
    void OnGraphicsQualitySet();
    void ShowRevertPopUp();
    void RevertSettings();
    void ResetValues();
    void Apply();
    void OneSecondLoop();
    void UpdateAdvancedSettingsUI();
    void CheckForChangedSettings();
    void InitializeResolution();
    void GetModifiedGFXSettings();
    void SetGFXSettings();
    void GetCurrentGFXSettings();
    void InitValues();
    void eventSetGraphicsQuality();
    void eventSetCompatibilityLevel();
    void GetGraphicsQualityFromCompat();
    void MakeDataProvider();
    void LocalizeText();
    void SetPhysicsLevelOptions();
    void SetLightShaftOptions();
    void SetLensFlareOptions();
    void SetVolumetricLightingOptions();
    void SetDepthOfFieldOptions();
    void SetAmbientOcclusionOptions();
    void SetMotionBlurOptions();
    void SetBloomOptions();
    void SetAntiAliasingOptions();
    void SetRealtimeReflectionsOptions();
    void SetShadowOptions();
    void SetTextureFilteringOptions();
    void SetTextureResolutionOptions();
    void SetFXOptions();
    void SetCharacterDetailOptions();
    void SetEnvironmentDetailOptions();
    void SetVSyncOptions();
    void SetGraphicsQualityOptions();
    void SetFullScreenOptions();
    void SetAspectRatioOptions();
    void SetFleXOptionEnabled();
    void InitializeMenu();
    void SetScriptFlexSettings();
    void GetScriptFlexSettings();
    void FindFlexSettingIndex();
    void SetScriptDOFSettings();
    void GetScriptDOFSettings();
    void FindDOFSettingIndex();
    void SetScriptAmbientOcclusionSettings();
    void GetScriptAmbientOcclusionSettings();
    void FindAmbientOcclusionSettingIndex();
    void SetScriptAntiAliasingSettings();
    void GetScriptAntiAliasingSettings();
    void FindAntiAliasingSettingIndex();
    void SetScriptMotionBlurSettings();
    void GetScriptMotionBlurSettings();
    void FindMotionBlurSettingIndex();
    void SetScriptBloomSettings();
    void GetScriptBloomSettings();
    void FindBloomSettingIndex();
    void SetScriptTextureFilterSettings();
    void GetScriptTextureFilterSettings();
    void FindTextureFilterSettingIndex();
    void SetScriptTextureResolutionSettings();
    void GetScriptTextureResolutionSettings();
    void FindTextureResolutionSettingIndex();
    void SetScriptLensFlareSettings();
    void GetScriptLensFlareSettings();
    void FindLensFlareSettingIndex();
    void SetScriptVolumetricLightingSettings();
    void GetScriptVolumetricLightingSettings();
    void FindVolumetricLightingSettingIndex();
    void SetScriptLightShaftsSettings();
    void GetScriptLightShaftsSettings();
    void FindLightShaftsSettingIndex();
    void SetScriptCharacterDetailSettings();
    void GetScriptCharacterDetailSettings();
    void FindCharacterDetailIndex();
    void SetScriptReflectionSettings();
    void GetScriptReflectionSettings();
    void FindReflectionsSettingIndex();
    void SetScriptFXQualitySettings();
    void GetScriptFXQualitySettings();
    void FindFXQualityIndex();
    void SetScriptShadowQualitySettings();
    void GetScriptShadowQualitySettings();
    void FindShadowQualityIndex();
    void SetScriptEnvironmentDetailSettings();
    void GetScriptEnvironmentDetailSettings();
    void FindEnvironmentDetailIndex();
    void NotEqual_FilmGrainSettingFilmGrainSetting();
    void EqualEqual_FilmGrainSettingFilmGrainSetting();
    void SetScriptFilmGrainSettings();
    void GetScriptFilmGrainSettings();
    void GetFilmGrainSettingValue();
    void GetFilmGrainSliderValue();
    void SetScriptVariableFramerateSettings();
    void GetScriptVariableFramerateSettings();
    void FindVariableFPSSettingIndex();
    void SetScriptVSyncSettings();
    void GetScriptVSyncSettings();
    void FindVSyncSettingIndex();
    void SetScriptDisplaySettings();
    void GetScriptDisplaySettings();
    void FindDisplaySettingIndex();
    void FindGraphicsQualitySettingIndex();
    void SetScriptSettings();
    void GetCurrentScriptSettings();
    void eventGetAspectRatio();
    void UpdateGSA();
    void IsFleXSupported();
    void RefreshSupportedResolutions();
    void IsAspectRatioAvailable();
    void GetCompatLevel();
    void SetNativeSettings();
    void GetCurrentNativeSettings();
    void FlushGSA();
    void UpdateGSAResolution();
    void UpdateGSASetting();
};

UClass* UKFGFxOptionsMenu_Graphics::pClassPointer = NULL;

// Class KFGame.KFGFxObject_TraderItems
// 0x0044 (0x00A4 - 0x0060)
class UKFGFxObject_TraderItems : public UObject {
   public:
    DWORD bBuildItemInfo : 1;  // 0x0060 (0x0004) [0x0000000000000000]
                               // [0x00000001]
    TArray<struct FSTraderItem>
        SaleItems;           // 0x0064 (0x0010) [0x0000000000000000]
    int ArmorPrice;          // 0x0074 (0x0004) [0x0000000000000000]
    int GrenadePrice;        // 0x0078 (0x0004) [0x0000000000000000]
    class UClass* ArmorDef;  // 0x007C (0x0008) [0x0000000000000000]
    TArray<struct FSTraderItemWeaponStats>
        KnifeStats;                  // 0x0084 (0x0010) [0x0000000000000000]
    struct FString OffPerkIconPath;  // 0x0094 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3589];

        return pClassPointer;
    };

    void GetItemIndicesFromArche();
    void SetItemsInfo();
};

UClass* UKFGFxObject_TraderItems::pClassPointer = NULL;

// Class KFGame.KFHUDBase
// 0x010C (0x0670 - 0x0564)
class AKFHUDBase : public AHUD {
   public:
    class AKFPlayerController*
        KFPlayerOwner;  // 0x0564 (0x0008) [0x0000000000000000]
    class AKFGameReplicationInfo*
        KFGRI;                          // 0x056C (0x0008) [0x0000000000000000]
    class UTexture2D* IconHudTexture;   // 0x0574 (0x0008) [0x0000000000000000]
    struct FColor BlackColor;           // 0x057C (0x0004) [0x0000000000000000]
    struct FColor GoldColor;            // 0x0580 (0x0004) [0x0000000000000000]
    struct FColor LightGoldColor;       // 0x0584 (0x0004) [0x0000000000000000]
    struct FColor LightGreenColor;      // 0x0588 (0x0004) [0x0000000000000000]
    struct FColor ArmorColor;           // 0x058C (0x0004) [0x0000000000000000]
    struct FColor HealthColor;          // 0x0590 (0x0004) [0x0000000000000000]
    struct FColor PlayerBarBGColor;     // 0x0594 (0x0004) [0x0000000000000000]
    struct FColor PlayerBarTextColor;   // 0x0598 (0x0004) [0x0000000000000000]
    struct FColor PlayerBarIconColor;   // 0x059C (0x0004) [0x0000000000000000]
    struct FColor SupplierActiveColor;  // 0x05A0 (0x0004) [0x0000000000000000]
    struct FColor SupplierUsableColor;  // 0x05A4 (0x0004) [0x0000000000000000]
    struct FColor
        SupplierHalfUsableColor;  // 0x05A8 (0x0004) [0x0000000000000000]
    struct FColor ZedIconColor;   // 0x05AC (0x0004) [0x0000000000000000]
    float ResolutionScale;        // 0x05B0 (0x0004) [0x0000000000000000]
    float ResolutionScaleX;       // 0x05B4 (0x0004) [0x0000000000000000]
    float FriendlyHudScale;       // 0x05B8 (0x0004) [0x0000000000000000]
    class UFont* GlowFonts[0x2];  // 0x05BC (0x0010) [0x0000000000000000]
    struct FFontRenderInfo
        TextRenderInfo;              // 0x05CC (0x0028) [0x0000000000000000]
    float PulseDuration;             // 0x05F4 (0x0004) [0x0000000000000000]
    float PulseSplit;                // 0x05F8 (0x0004) [0x0000000000000000]
    float PulseMultiplier;           // 0x05FC (0x0004) [0x0000000000000000]
    DWORD bCachedShowOverlays : 1;   // 0x0600 (0x0004) [0x0000000000000000]
                                     // [0x00000001]
    DWORD bDrawCrosshair : 1;        // 0x0600 (0x0004) [0x0000000000000000]
                                     // [0x00000002]
    DWORD bForceDrawCrosshair : 1;   // 0x0600 (0x0004) [0x0000000000000000]
                                     // [0x00000004]
    DWORD bCrosshairOnFriendly : 1;  // 0x0600 (0x0004) [0x0000000000000000]
                                     // [0x00000008]
    DWORD bGreenCrosshair : 1;       // 0x0600 (0x0004) [0x0000000000000000]
                                     // [0x00000010]
    struct FFontRenderInfo
        Text_NoClipShadowed;    // 0x0604 (0x0028) [0x0000000000000000]
    float TargetCrossHairMod;   // 0x062C (0x0004) [0x0000000000000000]
    float CurrentCrossHairMod;  // 0x0630 (0x0004) [0x0000000000000000]
    float BaseCrosshairSize;    // 0x0634 (0x0004) [0x0000000000000000]
    struct FInterpCurveFloat
        CrosshairAccuracyScale;  // 0x0638 (0x0014) [0x0000000000000000]
    class UTexture2D*
        PlayerStatusBarBGTexture;     // 0x064C (0x0008) [0x0000000000000000]
    float PlayerStatusBarLengthMax;   // 0x0654 (0x0004) [0x0000000000000000]
    float PlayerStatusIconSize;       // 0x0658 (0x0004) [0x0000000000000000]
    float HumanPlayerIconInterpMult;  // 0x065C (0x0004) [0x0000000000000000]
    class UTexture2D*
        GenericHumanIconTexture;  // 0x0660 (0x0008) [0x0000000000000000]
    class UTexture2D*
        GenericZedIconTexture;  // 0x0668 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3591];

        return pClassPointer;
    };

    void SetPostRenderingFor();
    void eventOnLostFocusPause();
    void DrawZedIcon();
    void CheckAndDrawRemainingZedIcons();
    void DrawHiddenHumanPlayerIcon();
    void CheckAndDrawHiddenPlayerIcons();
    void DrawKFBar();
    void DrawObjectiveHUD();
    void DrawFriendlyHumanPlayerInfo();
    void DrawHUD();
    void DrawShadowedRotatedTile();
    void DrawShadowedStretchedTile();
    void DrawShadowedTile();
    void CheckCrosshairOnFriendly();
    void DrawToolTip();
    void SetShowLeaderboard();
    void ToggleLeaderboard();
    void SetShowScores();
    void GetLocalPlayerOwnerIndex();
    void ReleaseShowScores();
    void CompletePauseMenuClose();
    void TogglePauseMenu();
    void CloseOtherMenus();
    void SetVisible();
    void RemoveMovies();
    void OnOpenAnimComplete();
    void OnCloseAnimComplete();
    void DrawCrosshair();
    void SetShowOverlays();
    void ResolutionChanged();
    void PreCalcValues();
    void PostBeginPlay();
    void DrawGlowText();
};

UClass* AKFHUDBase::pClassPointer = NULL;

// Class KFGame.KFDebugCameraHUD
// 0x0018 (0x0688 - 0x0670)
class AKFDebugCameraHUD : public AKFHUDBase {
   public:
    DWORD bDrawDebugText : 1;         // 0x0670 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bDrawAimBasedText : 1;      // 0x0670 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bFocusOnSelectedActor : 1;  // 0x0670 (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    DWORD
        bDisplayHelp : 1;  // 0x0670 (0x0004) [0x0000000000000000] [0x00000008]
    class AKFPawn* SelectedKFPawn;  // 0x0674 (0x0008) [0x0000000000000000]
    class ACamera* PlayerCamera;    // 0x067C (0x0008) [0x0000000000000000]
    float DebugTextMaxLen;          // 0x0684 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3593];

        return pClassPointer;
    };

    void DrawCrosshair();
    void eventPostRender();
    void DisplayHelp();
    void ToggleHelpDisplay();
    void DrawDebugHUDText();
};

UClass* AKFDebugCameraHUD::pClassPointer = NULL;

// Class KFGame.KFMission_LocalizedStrings
// 0x00F8 (0x0158 - 0x0060)
class UKFMission_LocalizedStrings : public UObject {
   public:
    struct FString GrantedWeeklyString;  // 0x0060 (0x0010) [0x0000000000000000]
    struct FString WeeklyString;         // 0x0070 (0x0010) [0x0000000000000000]
    struct FString
        CurrentWeeklySettingsString;    // 0x0080 (0x0010) [0x0000000000000000]
    struct FString SpecialEventString;  // 0x0090 (0x0010) [0x0000000000000000]
    struct FString
        SpecialEventChanceDropString;  // 0x00A0 (0x0010) [0x0000000000000000]
    struct FString
        GrantedSpecialEventString;     // 0x00B0 (0x0010) [0x0000000000000000]
    struct FString RewardsString;      // 0x00C0 (0x0010) [0x0000000000000000]
    struct FString WeeklyOverview;     // 0x00D0 (0x0010) [0x0000000000000000]
    struct FString ShortWeeklyString;  // 0x00E0 (0x0010) [0x0000000000000000]
    struct FString ObjectivesString;   // 0x00F0 (0x0010) [0x0000000000000000]
    struct FString SeasonalString;     // 0x0100 (0x0010) [0x0000000000000000]
    struct FMap_Mirror
        WeeklyOutbreakInfo;  // 0x0110 (0x0048) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3595];

        return pClassPointer;
    };

    void GetCurrentSpecialEventString();
    void GetWeeklyOutbreakInfoByIndex();
    void GetCurrentWeeklyOutbreakInfo();
};

UClass* UKFMission_LocalizedStrings::pClassPointer = NULL;

// Class KFGame.KFUIDataProvider_SearchResult
// 0x0000 (0x009C - 0x009C)
class UKFUIDataProvider_SearchResult : public UUIDataProvider_Settings {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3597];

        return pClassPointer;
    };
};

UClass* UKFUIDataProvider_SearchResult::pClassPointer = NULL;

// Class KFGame.KFWeeklyOutbreakInformation
// 0x0064 (0x00C4 - 0x0060)
class UKFWeeklyOutbreakInformation : public UObject {
   public:
    TArray<int> RewardIDs;    // 0x0060 (0x0010) [0x0000000000000000]
    int Index;                // 0x0070 (0x0004) [0x0000000000000000]
    struct FString IconPath;  // 0x0074 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        ModifierIconPaths;        // 0x0084 (0x0010) [0x0000000000000000]
    struct FString FriendlyName;  // 0x0094 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        DescriptionStrings;  // 0x00A4 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        ModifierDescriptions;  // 0x00B4 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3599];

        return pClassPointer;
    };
};

UClass* UKFWeeklyOutbreakInformation::pClassPointer = NULL;

// Class KFGame.KFUIDataStore_GameResource
// 0x0000 (0x00F0 - 0x00F0)
class UKFUIDataStore_GameResource : public UUIDataStore_GameResource {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[3601];

        return pClassPointer;
    };

    void InitializeProviders();
    void InitializeProvidersInternal();
    void GetMapNameUsingProviderIndex();
    void FindProviderIndexByMapName();
    void GetMapSummaryFromMapName();
};

UClass* UKFUIDataStore_GameResource::pClassPointer = NULL;

// Class KFGame.KFAnimNotify_ReloadAmmo
// 0x0000 (0x0064 - 0x0064)
class UKFAnimNotify_ReloadAmmo : public UAnimNotify {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[48555];

        return pClassPointer;
    };
};

UClass* UKFAnimNotify_ReloadAmmo::pClassPointer = NULL;

// Class KFGame.KFAnimNotify_Interrupt
// 0x0000 (0x0064 - 0x0064)
class UKFAnimNotify_Interrupt : public UAnimNotify {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[48556];

        return pClassPointer;
    };
};

UClass* UKFAnimNotify_Interrupt::pClassPointer = NULL;

// Class KFGame.KFDamageType
// 0x00D4 (0x0164 - 0x0090)
class UKFDamageType : public UDamageType {
   public:
    class UClass* WeaponDef;             // 0x0090 (0x0008) [0x0000000000000000]
    DWORD bNoInstigatorDamage : 1;       // 0x0098 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bConsideredIndirectOrAoE : 1;  // 0x0098 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bAllowAIDoorDestruction : 1;   // 0x0098 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD bAnyPerk : 1;  // 0x0098 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bShouldSpawnBloodSplat : 1;  // 0x0098 (0x0004) [0x0000000000000000]
                                       // [0x00000010]
    DWORD bShouldSpawnPersistentBlood : 1;  // 0x0098 (0x0004)
                                            // [0x0000000000000000] [0x00000020]
    DWORD bCanGib : 1;  // 0x0098 (0x0004) [0x0000000000000000] [0x00000040]
    DWORD bCanObliterate : 1;  // 0x0098 (0x0004) [0x0000000000000000]
                               // [0x00000080]
    DWORD
        bUseHitLocationForGibImpulses : 1;  // 0x0098 (0x0004)
                                            // [0x0000000000000000] [0x00000100]
    DWORD bPointImpulseTowardsOrigin : 1;   // 0x0098 (0x0004)
                                            // [0x0000000000000000] [0x00000200]
    DWORD bNoPain : 1;  // 0x0098 (0x0004) [0x0000000000000000] [0x00000400]
    DWORD bIgnoreSelfInflictedScale : 1;  // 0x0098 (0x0004)
                                          // [0x0000000000000000] [0x00000800]
    DWORD bIgnoreZedOnZedScaling : 1;  // 0x0098 (0x0004) [0x0000000000000000]
                                       // [0x00001000]
    float HeadDestructionDamageScale;  // 0x009C (0x0004) [0x0000000000000000]
    float HeadDestructionImpulseForceScale;  // 0x00A0 (0x0004)
                                             // [0x0000000000000000]
    unsigned char DoT_Type;         // 0x00A4 (0x0001) [0x0000000000000000]
    unsigned char EffectGroup;      // 0x00A5 (0x0001) [0x0000000000000000]
    unsigned char GoreDamageGroup;  // 0x00A6 (0x0001) [0x0000000000000000]
    float DoT_Duration;             // 0x00A8 (0x0004) [0x0000000000000000]
    float DoT_Interval;             // 0x00AC (0x0004) [0x0000000000000000]
    float DoT_DamageScale;          // 0x00B0 (0x0004) [0x0000000000000000]
    float StunPower;                // 0x00B4 (0x0004) [0x0000000000000000]
    float KnockdownPower;           // 0x00B8 (0x0004) [0x0000000000000000]
    float StumblePower;             // 0x00BC (0x0004) [0x0000000000000000]
    float LegStumblePower;          // 0x00C0 (0x0004) [0x0000000000000000]
    float GunHitPower;              // 0x00C4 (0x0004) [0x0000000000000000]
    float MeleeHitPower;            // 0x00C8 (0x0004) [0x0000000000000000]
    float BurnPower;                // 0x00CC (0x0004) [0x0000000000000000]
    float EMPPower;                 // 0x00D0 (0x0004) [0x0000000000000000]
    float PoisonPower;              // 0x00D4 (0x0004) [0x0000000000000000]
    float MicrowavePower;           // 0x00D8 (0x0004) [0x0000000000000000]
    float FreezePower;              // 0x00DC (0x0004) [0x0000000000000000]
    float SnarePower;               // 0x00E0 (0x0004) [0x0000000000000000]
    float BleedPower;               // 0x00E4 (0x0004) [0x0000000000000000]
    TArray<class UClass*>
        ModifierPerkList;  // 0x00E8 (0x0010) [0x0000000000000000]
    TArray<class UMaterialInstance*>
        BodyWoundDecalMaterials;      // 0x00F8 (0x0010) [0x0000000000000000]
    float BodyWoundDecalWidth;        // 0x0108 (0x0004) [0x0000000000000000]
    float BodyWoundDecalHeight;       // 0x010C (0x0004) [0x0000000000000000]
    struct FName ScreenMaterialName;  // 0x0110 (0x0008) [0x0000000000000000]
    class UClass*
        CameraLensEffectTemplate;  // 0x0118 (0x0008) [0x0000000000000000]
    class UClass*
        AltCameraLensEffectTemplate;  // 0x0120 (0x0008) [0x0000000000000000]
    int ObliterationHealthThreshold;  // 0x0128 (0x0004) [0x0000000000000000]
    int ObliterationDamageThreshold;  // 0x012C (0x0004) [0x0000000000000000]
    float MaxObliterationGibs;        // 0x0130 (0x0004) [0x0000000000000000]
    float GibImpulseScale;            // 0x0134 (0x0004) [0x0000000000000000]
    float ImpulseOriginScale;         // 0x0138 (0x0004) [0x0000000000000000]
    float ImpulseOriginLift;          // 0x013C (0x0004) [0x0000000000000000]
    float BloodSpread;                // 0x0140 (0x0004) [0x0000000000000000]
    float BloodScale;                 // 0x0144 (0x0004) [0x0000000000000000]
    struct FName
        DeathMaterialEffectParamName;   // 0x0148 (0x0008) [0x0000000000000000]
    float DeathMaterialEffectDuration;  // 0x0150 (0x0004) [0x0000000000000000]
    class UParticleSystem*
        OverrideImpactEffect;  // 0x0154 (0x0008) [0x0000000000000000]
    class UAkEvent*
        OverrideImpactSound;  // 0x015C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[48668];

        return pClassPointer;
    };

    void AlwaysPoisons();
    void CheckObliterate();
    void IsNotPerkBound();
    void PlayImpactHitEffects();
    void CanApplyDamageOverTime();
    void GetDamageeDialogID();
    void GetDamagerDialogID();
    void GetKillerDialogID();
    void GetPinProjectileClass();
    void ModifyDismembermentHitImpulse();
    void GetBoneToDismember();
    void CanDismemberHitZone();
    void GetOnDeathGoreScale();
    void GetGoreDamageScale();
    void GetBloodScale();
    void AddBloodSpread();
};

UClass* UKFDamageType::pClassPointer = NULL;

// Class KFGame.KFAfflictionAdvanced
// 0x0010 (0x009C - 0x008C)
class UKFAfflictionAdvanced : public UKFAfflictionBase {
   public:
    float Duration;       // 0x008C (0x0004) [0x0000000000000000]
    DWORD bIsActive : 1;  // 0x0090 (0x0004) [0x0000000000000000] [0x00000001]
    struct FName EffectSocketName;  // 0x0094 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[48712];

        return pClassPointer;
    };

    void ShutDown();
    void DeActivate();
    void Activate();
    void Init();
};

UClass* UKFAfflictionAdvanced::pClassPointer = NULL;

// Class KFGame.KFAffliction_EMP
// 0x0038 (0x00D4 - 0x009C)
class UKFAffliction_EMP : public UKFAfflictionAdvanced {
   public:
    class UParticleSystem*
        EmpPanicTemplate;  // 0x009C (0x0008) [0x0000000000000000]
    class UParticleSystemComponent*
        EMPPanicEffect;  // 0x00A4 (0x0008) [0x0000000000000000]
    class UParticleSystem*
        EmpDisruptTemplate;  // 0x00AC (0x0008) [0x0000000000000000]
    class UParticleSystemComponent*
        EMPDisruptEffect;               // 0x00B4 (0x0008) [0x0000000000000000]
    struct FName EMPDisruptSocketName;  // 0x00BC (0x0008) [0x0000000000000000]
    class UAkEvent* OnEMPSound;         // 0x00C4 (0x0008) [0x0000000000000000]
    class UAkEvent* OnEMPEndSound;      // 0x00CC (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[48711];

        return pClassPointer;
    };

    void SetEMPMatParam();
    void ToggleEffects();
    void SetEMPPanicked();
    void ShutDown();
    void DeActivate();
    void Activate();
};

UClass* UKFAffliction_EMP::pClassPointer = NULL;

// Class KFGame.KFAffliction_Fire
// 0x0030 (0x00CC - 0x009C)
class UKFAffliction_Fire : public UKFAfflictionAdvanced {
   public:
    float FireBurnedAmount;           // 0x009C (0x0004) [0x0000000000000000]
    float FireFullyCharredDuration;   // 0x00A0 (0x0004) [0x0000000000000000]
    float FireCharPercentThreshhold;  // 0x00A4 (0x0004) [0x0000000000000000]
    class UParticleSystem*
        BurningTemplate;  // 0x00A8 (0x0008) [0x0000000000000000]
    class UParticleSystemComponent*
        BurningEffect;               // 0x00B0 (0x0008) [0x0000000000000000]
    float MicrowaveParamValue;       // 0x00B8 (0x0004) [0x0000000000000000]
    class UAkEvent* OnFireSound;     // 0x00BC (0x0008) [0x0000000000000000]
    class UAkEvent* OnFireEndSound;  // 0x00C4 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[48713];

        return pClassPointer;
    };

    void ShutDown();
    void UpdateBurnedMatParam();
    void ToggleEffects();
    void SetMaterialParameter();
    void SetFirePanicked();
    void eventTick();
    void DeActivate();
    void Activate();
    void Init();
};

UClass* UKFAffliction_Fire::pClassPointer = NULL;

// Class KFGame.KFAffliction_HeavyRecovery
// 0x0000 (0x008C - 0x008C)
class UKFAffliction_HeavyRecovery : public UKFAfflictionBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[48714];

        return pClassPointer;
    };

    void Activate();
};

UClass* UKFAffliction_HeavyRecovery::pClassPointer = NULL;

// Class KFGame.KFAffliction_MediumRecovery
// 0x0000 (0x008C - 0x008C)
class UKFAffliction_MediumRecovery : public UKFAfflictionBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[48715];

        return pClassPointer;
    };

    void Activate();
};

UClass* UKFAffliction_MediumRecovery::pClassPointer = NULL;

// Class KFGame.KFAffliction_Stumble
// 0x0000 (0x008C - 0x008C)
class UKFAffliction_Stumble : public UKFAfflictionBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[48716];

        return pClassPointer;
    };

    void GetSpecialMoveFlags();
};

UClass* UKFAffliction_Stumble::pClassPointer = NULL;

// Class KFGame.KFAffliction_Stun
// 0x0000 (0x008C - 0x008C)
class UKFAffliction_Stun : public UKFAfflictionBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[48717];

        return pClassPointer;
    };
};

UClass* UKFAffliction_Stun::pClassPointer = NULL;

// Class KFGame.KFAffliction_Poison
// 0x0000 (0x009C - 0x009C)
class UKFAffliction_Poison : public UKFAfflictionAdvanced {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[48718];

        return pClassPointer;
    };

    void ToggleEffects();
    void SetPoisoned();
    void DeActivate();
    void Activate();
};

UClass* UKFAffliction_Poison::pClassPointer = NULL;

// Class KFGame.KFAffliction_Snare
// 0x0000 (0x009C - 0x009C)
class UKFAffliction_Snare : public UKFAfflictionAdvanced {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[48719];

        return pClassPointer;
    };

    void GetSpeedModifier();
    void DeActivate();
    void Activate();
};

UClass* UKFAffliction_Snare::pClassPointer = NULL;

// Class KFGame.KFAffliction_Knockdown
// 0x0000 (0x008C - 0x008C)
class UKFAffliction_Knockdown : public UKFAfflictionBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[48720];

        return pClassPointer;
    };

    void ActivateKnockdown();
    void Activate();
};

UClass* UKFAffliction_Knockdown::pClassPointer = NULL;

// Class KFGame.KFAffliction_Freeze
// 0x0000 (0x008C - 0x008C)
class UKFAffliction_Freeze : public UKFAfflictionBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[48721];

        return pClassPointer;
    };
};

UClass* UKFAffliction_Freeze::pClassPointer = NULL;

// Class KFGame.KFAffliction_Microwave
// 0x0044 (0x00E0 - 0x009C)
class UKFAffliction_Microwave : public UKFAfflictionAdvanced {
   public:
    float MicrowavedAmount;       // 0x009C (0x0004) [0x0000000000000000]
    float UsedMicrowavedAmount;   // 0x00A0 (0x0004) [0x0000000000000000]
    float MicrowaveBurnedAmount;  // 0x00A4 (0x0004) [0x0000000000000000]
    struct FInterpCurveFloat
        MicroWaveCharCurve;  // 0x00A8 (0x0014) [0x0000000000000000]
    class UParticleSystem*
        SteamingTemplate;  // 0x00BC (0x0008) [0x0000000000000000]
    class UParticleSystemComponent*
        SteamingEffect;               // 0x00C4 (0x0008) [0x0000000000000000]
    DWORD bSteamEffectActive : 1;     // 0x00CC (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    class UAkEvent* OnSteamSound;     // 0x00D0 (0x0008) [0x0000000000000000]
    class UAkEvent* OnSteamEndSound;  // 0x00D8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[48722];

        return pClassPointer;
    };

    void ShutDown();
    void SetMicrowaveSteamEffects();
    void SetMaterialParameter();
    void UpdateBurnedMatParam();
    void UpdateMicrowaveMatParam();
    void eventTick();
    void SetMicrowavePanicked();
    void DeActivate();
    void Activate();
};

UClass* UKFAffliction_Microwave::pClassPointer = NULL;

// Class KFGame.KFAffliction_Bleed
// 0x0024 (0x00C0 - 0x009C)
class UKFAffliction_Bleed : public UKFAfflictionAdvanced {
   public:
    float DeflateThreshold;             // 0x009C (0x0004) [0x0000000000000000]
    float IncapModifier;                // 0x00A0 (0x0004) [0x0000000000000000]
    float DamageModifier;               // 0x00A4 (0x0004) [0x0000000000000000]
    float SpeedModifier;                // 0x00A8 (0x0004) [0x0000000000000000]
    float PrevStrength;                 // 0x00AC (0x0004) [0x0000000000000000]
    float MaxDeflate;                   // 0x00B0 (0x0004) [0x0000000000000000]
    float CurDeflate;                   // 0x00B4 (0x0004) [0x0000000000000000]
    unsigned char CurrentDeflateState;  // 0x00B8 (0x0001) [0x0000000000000000]
    float DeflateChangeRate;            // 0x00BC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[48723];

        return pClassPointer;
    };

    void SetMaterialParameter();
    void CalcDeflate();
    void CalcInflate();
    void CheckStateChange();
    void UpdateDeflateMaterialParam();
    void Tick();
    void Accrue();
    void GetSpeedModifier();
    void GetDamageModifier();
    void GetStunModifier();
    void GetStumbleModifier();
    void GetKnockdownModifier();
};

UClass* UKFAffliction_Bleed::pClassPointer = NULL;

// Class KFGame.KFPawnSoundGroup
// 0x0118 (0x0178 - 0x0060)
class UKFPawnSoundGroup : public UObject {
   public:
    TArray<struct FFootstepSoundInfo>
        FootstepSounds;  // 0x0060 (0x0010) [0x0000000000000000]
    class UAkBaseSoundObject*
        DefaultFootstepSound;  // 0x0070 (0x0008) [0x0000000000000000]
    TArray<struct FFootstepSoundInfo>
        SprintingFootstepSounds;  // 0x0078 (0x0010) [0x0000000000000000]
    class UAkBaseSoundObject*
        DefaultSprintingFootstepSound;  // 0x0088 (0x0008) [0x0000000000000000]
    TArray<struct FFootstepSoundInfo>
        HandstepSounds;  // 0x0090 (0x0010) [0x0000000000000000]
    class UAkBaseSoundObject*
        DefaultHandstepSound;  // 0x00A0 (0x0008) [0x0000000000000000]
    struct FVector2D
        MaxFootstepSoundRanges;  // 0x00A8 (0x0008) [0x0000000000000000]
    TArray<struct FFootstepSoundInfo>
        JumpingSounds;  // 0x00B0 (0x0010) [0x0000000000000000]
    class UAkBaseSoundObject*
        DefaultJumpingSound;  // 0x00C0 (0x0008) [0x0000000000000000]
    TArray<struct FFootstepSoundInfo>
        LandingSounds;  // 0x00C8 (0x0010) [0x0000000000000000]
    class UAkBaseSoundObject*
        DefaultLandingSound;  // 0x00D8 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        FallingDamageLandSound;  // 0x00E0 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        PainSound;  // 0x00E8 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        DyingSound;  // 0x00F0 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        MouthlessDyingSound;  // 0x00F8 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        BleedoutDyingSound;              // 0x0100 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject* GibSound;  // 0x0108 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        GaspSound;  // 0x0110 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        EntranceSound;  // 0x0118 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        DismembermentSound;  // 0x0120 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        BloodSpraySound;  // 0x0128 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        DismemberedPartImpactSound;  // 0x0130 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        VisceraImpactSound;  // 0x0138 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        HeadPopSound;  // 0x0140 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        RagdollImpactSound;  // 0x0148 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        CleaveSound;  // 0x0150 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        ObliterationSound;             // 0x0158 (0x0008) [0x0000000000000000]
    class UAkEvent* OnDeathStopEvent;  // 0x0160 (0x0008) [0x0000000000000000]
    TArray<struct FImpactSoundCoolDownInfo>
        ImpactSoundCoolDowns;  // 0x0168 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[48724];

        return pClassPointer;
    };

    void PlayBloodSpraySound();
    void PlayObliterationSound();
    void ShouldPlayCleaveSound();
    void PlayCleaveSound();
    void PlayHeadPopSounds();
    void PlayGibletCollisionSound();
    void PlayRigidBodyCollisionSound();
    void PlayDismembermentSounds();
    void GetLandSound();
    void GetJumpSound();
    void GetSprintingFootstepSound();
    void GetFootstepSound();
    void PlayEntranceSound();
    void PlayGaspSound();
    void PlayGibSound();
    void PlayBleedoutDyingSound();
    void PlayMouthlessDyingSound();
    void PlayDyingSound();
    void PlayPainSound();
    void PlayFallingDamageLandSound();
    void PlayLandSound();
    void PlayJumpSound();
};

UClass* UKFPawnSoundGroup::pClassPointer = NULL;

// Class KFGame.KFGiblet
// 0x0014 (0x0258 - 0x0244)
class AKFGiblet : public AActor {
   public:
    class UMeshComponent* GibMeshComp;  // 0x0244 (0x0008) [0x0000000000000000]
    class UKFPawnSoundGroup*
        SoundGroup;           // 0x024C (0x0008) [0x0000000000000000]
    float LastCollisionTime;  // 0x0254 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[48831];

        return pClassPointer;
    };

    void eventRigidBodyCollision();
    void SetMesh();
    void LifespanTimer();
};

UClass* AKFGiblet::pClassPointer = NULL;

// Class KFGame.KFPawnAnimInfo
// 0x01AC (0x020C - 0x0060)
class UKFPawnAnimInfo : public UObject {
   public:
    TArray<struct FAttackAnimInfo>
        Attacks;                         // 0x0060 (0x0010) [0x0000000000000000]
    TArray<struct FName> DoorAttacks;    // 0x0070 (0x0010) [0x0000000000000000]
    DWORD bEnableDifficultyScaling : 1;  // 0x0080 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bDebugLog : 1;  // 0x0080 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bCanPlayAnimHitReactions : 1;  // 0x0080 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD bCanPlayPhysicsHitReactions : 1;  // 0x0080 (0x0004)
                                            // [0x0000000000000000] [0x00000008]
    DWORD bCanPlayDeathAnimations : 1;  // 0x0080 (0x0004) [0x0000000000000000]
                                        // [0x00000010]
    float WeakAttackChance;             // 0x0084 (0x0004) [0x0000000000000000]
    float MediumAttackChance;           // 0x0088 (0x0004) [0x0000000000000000]
    float HardAttackChance;             // 0x008C (0x0004) [0x0000000000000000]
    TArray<struct FAnimVariants>
        LightHitAnims;  // 0x0090 (0x0010) [0x0000000000000000]
    TArray<struct FAnimVariants>
        MediumHitAnims;  // 0x00A0 (0x0010) [0x0000000000000000]
    TArray<struct FAnimVariants>
        HeavyHitAnims;  // 0x00B0 (0x0010) [0x0000000000000000]
    TArray<struct FName>
        DmgOverTimeHitAnims;  // 0x00C0 (0x0010) [0x0000000000000000]
    TArray<struct FAnimVariants>
        StumbleAnims;  // 0x00D0 (0x0010) [0x0000000000000000]
    struct FDeathAnimInfo
        DefaultDeathAnims;  // 0x00E0 (0x0060) [0x0000000000000000]
    struct FDeathAnimInfo
        ExplosiveDeathAnims;  // 0x0140 (0x0060) [0x0000000000000000]
    TArray<struct FDeathAnimInfo>
        BodyPartDeathAnims;            // 0x01A0 (0x0010) [0x0000000000000000]
    unsigned char LastDeathAnimIndex;  // 0x01B0 (0x0001) [0x0000000000000000]
    struct FVector2D
        DeathPhysMotorStrength;       // 0x01B4 (0x0008) [0x0000000000000000]
    TArray<struct FName> TauntAnims;  // 0x01BC (0x0010) [0x0000000000000000]
    TArray<struct FName>
        TauntKillAnims;  // 0x01CC (0x0010) [0x0000000000000000]
    TArray<struct FName>
        TauntEnragedAnims;  // 0x01DC (0x0010) [0x0000000000000000]
    TArray<struct FsTheatricAnimInfo>
        TheatricBossEntranceAnimInfos;  // 0x01EC (0x0010) [0x0000000000000000]
    TArray<struct FsTheatricAnimInfo>
        TheatricBossVictoryAnimInfos;  // 0x01FC (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[48861];

        return pClassPointer;
    };

    void PlayHitReactionAnim();
    void EvaulateDeathAnimList();
    void ChooseDeathAnimation();
    void AllowAttackByDifficulty();
    void AllowAttackByMovement();
    void SetDifficultyValues();
    void GetAttackRangeExtent();
    void GetAttackRangeByName();
    void IsAttackOnCooldown();
    void CanDoAttackAnim();
    void CheckForValidCooldown();
    void GetStrikeFlags();
    void GetAttackAnimName();
    void GetAttackIndexByTag();
    void GetMedianStrikeRange();
    void GetAttackRange();
    void UpdateAttackCooldown();
    void ChooseNextStrike();
    void ChooseAttackByName();
    void InitMeleeSpecialMove();
};

UClass* UKFPawnAnimInfo::pClassPointer = NULL;

// Class KFGame.KFDT_Explosive
// 0x0000 (0x0164 - 0x0164)
class UKFDT_Explosive : public UKFDamageType {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[48994];

        return pClassPointer;
    };

    void GetBoneToDismember();
    void GetKillerDialogID();
    void AddBloodSpread();
    void GetBloodScale();
};

UClass* UKFDT_Explosive::pClassPointer = NULL;

// Class KFGame.KFGameDifficultyInfo
// 0x01A4 (0x0204 - 0x0060)
class UKFGameDifficultyInfo : public UObject {
   public:
    struct FNumPlayerMods
        NumPlayers_WaveSize;  // 0x0060 (0x001C) [0x0000000000000000]
    struct FNumPlayerMods
        NumPlayers_AIHiddenSpeed;  // 0x007C (0x001C) [0x0000000000000000]
    struct FNumPlayerMods
        NumPlayers_WeaponPickupRespawnTime;  // 0x0098 (0x001C)
                                             // [0x0000000000000000]
    struct FNumPlayerMods
        NumPlayers_AmmoPickupRespawnTime;  // 0x00B4 (0x001C)
                                           // [0x0000000000000000]
    struct FNumPlayerMods
        NumPlayers_ZedDamageResistance;  // 0x00D0 (0x001C) [0x0000000000000000]
    struct FDifficultySettings Normal;   // 0x00EC (0x0038) [0x0000000000000000]
    struct FDifficultySettings Hard;     // 0x0124 (0x0038) [0x0000000000000000]
    struct FDifficultySettings
        Suicidal;  // 0x015C (0x0038) [0x0000000000000000]
    struct FDifficultySettings
        HellOnEarth;  // 0x0194 (0x0038) [0x0000000000000000]
    struct FDifficultySettings
        CurrentSettings;  // 0x01CC (0x0038) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[49012];

        return pClassPointer;
    };

    void GetDifficultyIndex();
    void GetDifficultyValue();
    void GetDamageResistanceModifier();
    void GetWeaponPickupInterval();
    void GetAmmoPickupInterval();
    void GetPlayerNumMaxAIModifier();
    void GetAIHiddenSpeedModifier();
    void GetNumPlayersModifier();
    void GetSpawnRateModifier();
    void GetSelfInflictedDamageMod();
    void GetHardAttackChance();
    void GetMediumAttackChance();
    void GetWeakAttackChance();
    void GetAmmoPickupModifier();
    void GetItemPickupModifier();
    void GetAdjustedRespawnCash();
    void GetAdjustedStartingCash();
    void GetKillCashModifier();
    void GetDifficultyMaxAIModifier();
    void GetAIGroundSpeedMod();
    void GetAISpeedMod();
    void GetAIDamageModifier();
    void GetTraderTimeByDifficulty();
    void GetCharSprintWhenDamagedChanceByDifficulty();
    void GetCharSprintChanceByDifficulty();
    void GetCharHeadHealthModDifficulty();
    void GetCharHealthModDifficulty();
    void GetGlobalHealthMod();
    void GetNumPlayersHealthMod();
    void GetVersusHealthModifier();
    void GetAIHealthModifier();
    void SetDifficultySettings();
};

UClass* UKFGameDifficultyInfo::pClassPointer = NULL;

// Class KFGame.KFSpecialMoveHandler
// 0x0020 (0x0080 - 0x0060)
class UKFSpecialMoveHandler : public UObject {
   public:
    TArray<class UClass*>
        SpecialMoveClasses;  // 0x0060 (0x0010) [0x0000000000000000]
    struct FKFSpecialMoveStruct
        PendingSpecialMoveStruct;  // 0x0070 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[49092];

        return pClassPointer;
    };

    void EndSpecialMove();
    void ClearPendingSpecialMove();
    void VerifySpecialMoveInstance();
    void SpecialMoveEnded();
    void SpecialMoveStarted();
    void CanChainSpecialMove();
    void eventCanDoSpecialMove();
    void ReplicateSpecialMove();
    void ReassignSpecialMove();
    void DoPendingSpecialMove();
    void CanOverrideSpecialMove();
    void eventDoSpecialMove();
};

UClass* UKFSpecialMoveHandler::pClassPointer = NULL;

// Class KFGame.KFWeaponAmbientEchoHandler
// 0x0010 (0x0070 - 0x0060)
class UKFWeaponAmbientEchoHandler : public UObject {
   public:
    TArray<struct FEchoSet> EchoSets;  // 0x0060 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[49163];

        return pClassPointer;
    };

    void StopEcho();
    void StartEcho();
    void TickEchoes();
    void StopAllEchoes();
    void StopEchoSet();
    void DelayedStartEcho();
    void StartEchoSet();
    void HandleEchoes();
};

UClass* UKFWeaponAmbientEchoHandler::pClassPointer = NULL;

// Class KFGame.KFPawnVoiceGroup
// 0x0028 (0x0088 - 0x0060)
class UKFPawnVoiceGroup : public UObject {
   public:
    class UClass* EventDataClass;  // 0x0060 (0x0008) [0x0000000000000000]
    TArray<struct FDialogEventLineInfo>
        DialogEvents;  // 0x0068 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        DialogEventNames;  // 0x0078 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[49963];

        return pClassPointer;
    };

    void GetDialogEventInfo();
    void GetDialogAkEvent();
    void GetEventName();
};

UClass* UKFPawnVoiceGroup::pClassPointer = NULL;

// Class KFGame.KFPawnVoiceGroupEventData
// 0x0010 (0x0070 - 0x0060)
class UKFPawnVoiceGroupEventData : public UObject {
   public:
    TArray<struct FDialogEventInfo>
        Events;  // 0x0060 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[49965];

        return pClassPointer;
    };
};

UClass* UKFPawnVoiceGroupEventData::pClassPointer = NULL;

// Class KFGame.KFPhysicalMaterialProperty
// 0x0003 (0x0064 - 0x0061)
class UKFPhysicalMaterialProperty : public UPhysicalMaterialPropertyBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[49982];

        return pClassPointer;
    };
};

UClass* UKFPhysicalMaterialProperty::pClassPointer = NULL;

// Class KFGame.EphemeralMatchStats
// 0x00D4 (0x0134 - 0x0060)
class UEphemeralMatchStats : public UObject {
   public:
    DWORD bShowMatchStatsLogging : 1;  // 0x0060 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bKilledBoss : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000002]
    TArray<struct FAARAward>
        TeamAwardList;  // 0x0064 (0x0010) [0x0000000000000000]
    TArray<struct FAARAward>
        PersonalBestList;  // 0x0074 (0x0010) [0x0000000000000000]
    struct FTopWeaponReplicationInfo
        TWRI;                      // 0x0084 (0x003C) [0x0000000000000000]
    int ZedsKilledLastWave;        // 0x00C0 (0x0004) [0x0000000000000000]
    unsigned char DeathStreak;     // 0x00C4 (0x0001) [0x0000000000000000]
    unsigned char SurvivedStreak;  // 0x00C5 (0x0001) [0x0000000000000000]
    int TotalHeadShots;            // 0x00C8 (0x0004) [0x0000000000000000]
    int TotalDoshEarned;           // 0x00CC (0x0004) [0x0000000000000000]
    int TotalDamageDealt;          // 0x00D0 (0x0004) [0x0000000000000000]
    int TotalDamageTaken;          // 0x00D4 (0x0004) [0x0000000000000000]
    int TotalAmountHealGiven;      // 0x00D8 (0x0004) [0x0000000000000000]
    int TotalAmountHealReceived;   // 0x00DC (0x0004) [0x0000000000000000]
    int TotalLargeZedKills;        // 0x00E0 (0x0004) [0x0000000000000000]
    TArray<struct FPerkXPGain>
        PerkXPList;  // 0x00E4 (0x0010) [0x0000000000000000]
    TArray<struct FWeaponDamage>
        WeaponDamageList;  // 0x00F4 (0x0010) [0x0000000000000000]
    TArray<struct FZedKillType>
        ZedKillsArray;  // 0x0104 (0x0010) [0x0000000000000000]
    struct FScriptDelegate
        __SortXP__Delegate;            // 0x0114 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x0118 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __SortWeapons__Delegate;       // 0x0124 (0x0010) [0x0000000000000000]
    unsigned char UnknownData01[0x4];  // 0x0128 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[50052];

        return pClassPointer;
    };

    void ReceiveAwardInfo();
    void Give_Dominator();
    void Give_HeadPopper();
    void Give_MoneyBags();
    void Give_GiantSlayer();
    void Give_Destroyer();
    void Give_Enforcer();
    void Give_ZedSlayer();
    void Give_MedicineMaster();
    void Give_Closer();
    void Give_Combo();
    void Give_Carnage();
    void Give_BestSupportingZed();
    void Give_Grabby();
    void Give_Zednnihilation();
    void GetTeamAward();
    void GivePersonalBestDoorWelding();
    void GivePersonalBestAssists();
    void GivePersonalBestKills();
    void GivePersonalBestDoshEarned();
    void GivePersonalBestLargeZedKills();
    void GivePersonalBestHealing();
    void GivePersonalBestHeadShots();
    void GivePersonalBestPistolKills();
    void GivePersonalBestKnifeKills();
    void GetKnifeKills();
    void GetPistolKills();
    void GetPersonalBests();
    void SendMapOptionsAndOpenAARMenu();
    void ProcessPostGameStats();
    void SortWeapons();
    void SortXP();
    void GetTopWeapons();
    void AddUnpackedWeaponToDamageList();
    void ProcessTopWeaponsStats();
    void UnpackTopWeapons();
    void PackTopWeapons();
    void InternalRecordWeaponDamage();
    void RecordWeaponKill();
    void RecordWeaponDamage();
    void RecordWeaponHeadShot();
    void RecordZedKill();
    void RecordSecondaryXPGain();
    void RecordPerkXPGain();
    void ResetLastWaveInfo();
    void RecordWaveInfo();
    void GetHealGivenInWave();
    void IncrementHealGivenInWave();
    void GetHealReceivedInWave();
    void IncrementHealReceivedInWave();
    void GetDamageTakenInWave();
    void IncrementDamageTakenInWave();
    void GetDamageDealtInWave();
    void IncrementDamageDealtInWave();
    void GetDoshEarnedInWave();
    void IncrementDoshEarnedInWave();
    void GetHeadShotsInWave();
    void IncrementHeadShotsInWave();
    void RecordIntStat();
};

UClass* UEphemeralMatchStats::pClassPointer = NULL;

// Class KFGame.KFSM_Stumble
// 0x0000 (0x0150 - 0x0150)
class UKFSM_Stumble : public UKFSM_PlaySingleAnim {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[50058];

        return pClassPointer;
    };

    void SpecialMoveFlagsUpdated();
    void EnableInterrupt();
    void PlayAnimation();
    void InternalCanDoSpecialMove();
    void GetStumbleTypeFromRegion();
    void GetRandomVariant();
    void PackRandomSMFlags();
    void PackParrySMFlags();
    void PackLegHitSMFlags();
    void PackBodyHitSMFlags();
    void ShouldDoLegStumble();
};

UClass* UKFSM_Stumble::pClassPointer = NULL;

// Class KFGame.KFSM_DeathAnim
// 0x000C (0x0140 - 0x0134)
class UKFSM_DeathAnim : public UKFSpecialMove {
   public:
    float NextDeathAnim_ActorTime;       // 0x0134 (0x0004) [0x0000000000000000]
    unsigned char NumChainedDeathAnims;  // 0x0138 (0x0001) [0x0000000000000000]
    unsigned char MaxChainedDeathAnims;  // 0x0139 (0x0001) [0x0000000000000000]
    DWORD bHasDeathMotorsActive : 1;     // 0x013C (0x0004) [0x0000000000000000]
                                         // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[50064];

        return pClassPointer;
    };

    void NotifyOwnerTakeHit();
    void OnRigidBodySpringOverextension();
    void SetSpringForBone();
    void StopDeathAnimMotors();
    void StartDeathAnimMotors();
    void SpecialMoveEnded();
    void AnimEndNotify();
    void GetDeathAnimation();
    void PlayDeathAnimation();
    void InternalCanDoSpecialMove();
    void PackSMFlags();
};

UClass* UKFSM_DeathAnim::pClassPointer = NULL;

// Class KFGame.KFDT_Falling
// 0x0000 (0x0164 - 0x0164)
class UKFDT_Falling : public UKFDamageType {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[50108];

        return pClassPointer;
    };
};

UClass* UKFDT_Falling::pClassPointer = NULL;

// Class KFGame.KFSeqEvent_PawnTeleported
// 0x0000 (0x0170 - 0x0170)
class UKFSeqEvent_PawnTeleported : public USequenceEvent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[50111];

        return pClassPointer;
    };
};

UClass* UKFSeqEvent_PawnTeleported::pClassPointer = NULL;

// Class KFGame.KFImpactEffectInfo
// 0x0068 (0x00C8 - 0x0060)
class UKFImpactEffectInfo : public UObject {
   public:
    TArray<struct FMaterialImpactEffect>
        ImpactEffects;  // 0x0060 (0x0010) [0x0000000000000000]
    struct FMaterialImpactEffect
        DefaultImpactEffect;        // 0x0070 (0x0044) [0x0000000000000000]
    class UAkEvent* BulletWhipSnd;  // 0x00B4 (0x0008) [0x0000000000000000]
    DWORD bMakeSplash : 1;  // 0x00BC (0x0004) [0x0000000000000000] [0x00000001]
    class UParticleSystem*
        SplashEffectTemplate;  // 0x00C0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[50137];

        return pClassPointer;
    };
};

UClass* UKFImpactEffectInfo::pClassPointer = NULL;

// Class KFGame.AICommand_Attack_Grab
// 0x0000 (0x0110 - 0x0110)
class UAICommand_Attack_Grab : public UAICommand_SM_Attack {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[50551];

        return pClassPointer;
    };

    void UpdateLastMeleeTime();
    void NotifyEnemyChanged();
    void Popped();
    void Paused();
    void Resumed();
    void Pushed();
    void eventGetDumpString();
    void Grab();
};

UClass* UAICommand_Attack_Grab::pClassPointer = NULL;

// Class KFGame.AICommand_Attack_Kick
// 0x0004 (0x0114 - 0x0110)
class UAICommand_Attack_Kick : public UAICommand_SM_Attack {
   public:
    DWORD bForce : 1;  // 0x0110 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[50591];

        return pClassPointer;
    };

    void Popped();
    void Pushed();
    void Kick();
};

UClass* UAICommand_Attack_Kick::pClassPointer = NULL;

// Class KFGame.AICommand_TauntEnemy
// 0x0014 (0x0108 - 0x00F4)
class UAICommand_TauntEnemy : public UAICommand_SpecialMove {
   public:
    class APawn* TauntTarget;  // 0x00F4 (0x0008) [0x0000000000000000]
    unsigned char TauntType;   // 0x00FC (0x0001) [0x0000000000000000]
    class UClass* TauntClass;  // 0x0100 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[50685];

        return pClassPointer;
    };

    void Popped();
    void Pushed();
    void Taunt();
};

UClass* UAICommand_TauntEnemy::pClassPointer = NULL;

// Class KFGame.AICommand_Base_Boss
// 0x0000 (0x00E8 - 0x00E8)
class UAICommand_Base_Boss : public UAICommand_Base_Zed {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[50772];

        return pClassPointer;
    };
};

UClass* UAICommand_Base_Boss::pClassPointer = NULL;

// Class KFGame.AICommand_Base_Crawler
// 0x002C (0x0114 - 0x00E8)
class UAICommand_Base_Crawler : public UAICommand_Base_Zed {
   public:
    class AKFWallPathNode* LeapTarget;  // 0x00E8 (0x0008) [0x0000000000000000]
    DWORD bJumpingToWall : 1;           // 0x00F0 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    struct FVector TempDest;            // 0x00F4 (0x000C) [0x0000000000000000]
    struct FVector OriginalTrans;       // 0x0100 (0x000C) [0x0000000000000000]
    class AActor* TempMoveGoal;         // 0x010C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[50774];

        return pClassPointer;
    };

    void SetTempDest();
    void CheckWalls();
    void Resumed();
    void SightCheck();
    void BeginMoveToWall();
    void Paused();
    void Pushed();
};

UClass* UAICommand_Base_Crawler::pClassPointer = NULL;

// Class KFGame.AICommand_Base_Hans
// 0x0000 (0x00E8 - 0x00E8)
class UAICommand_Base_Hans : public UAICommand_Base_Boss {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[50825];

        return pClassPointer;
    };
};

UClass* UAICommand_Base_Hans::pClassPointer = NULL;

// Class KFGame.KFPawn_ZedHansBase
// 0x00AC (0x0F0C - 0x0E60)
class AKFPawn_ZedHansBase : public AKFPawn_MonsterBoss {
   public:
    class AKFAIController_Hans*
        MyHansController;     // 0x0E60 (0x0008) [0x0000000000000000]
    DWORD bGunsEquipped : 1;  // 0x0E68 (0x0004) [0x00000000006A0000]
                              // [0x00000001] ( CPF_EditConst | CPF_Component |
                              // CPF_NeedCtorLink )
    DWORD bHealedThisPhase : 1;    // 0x0E68 (0x0004) [0x0000000000000000]
                                   // [0x00000002]
    DWORD bInHuntAndHealMode : 1;  // 0x0E68 (0x0004) [0x00000000006B0000]
                                   // [0x00000004] ( CPF_Travel | CPF_EditConst
                                   // | CPF_Component | CPF_NeedCtorLink )
    DWORD bPendingSmokeGrenadeBarrage : 1;  // 0x0E68 (0x0004)
                                            // [0x0000000000000000] [0x00000008]
    DWORD
        bDoingBarrage : 1;  // 0x0E68 (0x0004) [0x0000000000000000] [0x00000010]
    TArray<struct FHansBattlePhaseInfo>
        BattlePhases;             // 0x0E6C (0x0010) [0x0000000000000000]
    float AmountHealedThisPhase;  // 0x0E7C (0x0004) [0x0000000000000000]
    float
        HuntAndHealModeDamageReduction;  // 0x0E80 (0x0004) [0x0000000000000000]
    float IncapPowerScaleWhenHealing;    // 0x0E84 (0x0004) [0x0000000000000000]
    float ShieldHealth;                  // 0x0E88 (0x0004) [0x0000000000000000]
    float ShieldHealthMax;               // 0x0E8C (0x0004) [0x0000000000000000]
    unsigned char ShieldHealthPctByte;   // 0x0E90 (0x0001) [0x00000000006C0000]
                                         // ( CPF_GlobalConfig | CPF_Component |
                                         // CPF_NeedCtorLink )
    int NumHuntAndHealEnemyBumps;        // 0x0E94 (0x0004) [0x0000000000000000]
    float LastHuntAndHealEnemyBumpTime;  // 0x0E98 (0x0004) [0x0000000000000000]
    class UClass* ActiveGrenadeClass;    // 0x0E9C (0x0008) [0x0000000000000000]
    class UClass*
        ExplosiveGrenadeClass;           // 0x0EA4 (0x0008) [0x0000000000000000]
    class UClass* NerveGasGrenadeClass;  // 0x0EAC (0x0008) [0x0000000000000000]
    class UClass* SmokeGrenadeClass;     // 0x0EB4 (0x0008) [0x0000000000000000]
    struct FName RightHandSocketName;    // 0x0EBC (0x0008) [0x0000000000000000]
    struct FName LeftHandSocketName;     // 0x0EC4 (0x0008) [0x0000000000000000]
    struct FVector GrenadeTossSpread;    // 0x0ECC (0x000C) [0x0000000000000000]
    int BarrageTossCount;                // 0x0ED8 (0x0004) [0x0000000000000000]
    float GlobalOffensiveNadeCooldown;   // 0x0EDC (0x0004) [0x0000000000000000]
    float LastOffensiveNadeTime;         // 0x0EE0 (0x0004) [0x0000000000000000]
    float HENadeTossCooldown;            // 0x0EE4 (0x0004) [0x0000000000000000]
    float LastHENadeTossTime;            // 0x0EE8 (0x0004) [0x0000000000000000]
    float HENadeBarrageCooldown;         // 0x0EEC (0x0004) [0x0000000000000000]
    float LastHENadeBarrageTime;         // 0x0EF0 (0x0004) [0x0000000000000000]
    float NerveGasTossCooldown;          // 0x0EF4 (0x0004) [0x0000000000000000]
    float LastNerveGasTossTime;          // 0x0EF8 (0x0004) [0x0000000000000000]
    float NerveGasBarrageCooldown;       // 0x0EFC (0x0004) [0x0000000000000000]
    float LastNerveGasBarrageTime;       // 0x0F00 (0x0004) [0x0000000000000000]
    float SmokeTossCooldown;             // 0x0F04 (0x0004) [0x0000000000000000]
    float LastSmokeTossTime;             // 0x0F08 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[50833];

        return pClassPointer;
    };

    void DetachShieldFX();
    void UpdateShieldColor();
    void ApplyBloodDecals();
    void ANIMNOTIFY_AoENerveGas();
    void NeedToTurnEx();
    void HuntAndHealBump();
    void eventBump();
    void ClearDOTs();
    void SummonMinions();
    void GetHealAmountForThisPhase();
    void Timer_ResetShieldHealthPct();
    void SetHuntAndHealMode();
    void PlayGrenadeDialog();
    void PlayDrawGunsDialog();
    void CanMoveWhileThrowingGrenades();
    void SetActiveGrenadeClassNerveGas();
    void SetActiveGrenadeClassSmoke();
    void SetActiveGrenadeClassGrenade();
    void CacheGrenadeThrowLocation();
    void IsThrowingGrenade();
    void CanSmokeTossInThisPhase();
    void CanGrenadeBarrageInThisPhase();
    void CanTossGrenadeInThisPhase();
    void CanUseGunsInThisPhase();
    void CanBarrageNerveGasInThisPhase();
    void CanTossNerveGasInThisPhase();
    void OffensiveGrenadeCooldownComplete();
    void CanBlock();
    void ShouldPlaySpecialMeleeAnims();
    void DesireSprintingInThisPhase();
    void CanFrenzyInThisPhase();
    void BreakShield();
    void UpdateShieldHealth();
    void AdjustAffliction();
    void AdjustDamage();
    void SetPhaseCooldowns();
    void IncrementBattlePhase();
    void PossessedBy();
    void eventReplicatedEvent();
};

UClass* AKFPawn_ZedHansBase::pClassPointer = NULL;

// Class KFGame.AICommand_BossTheatrics
// 0x0008 (0x00FC - 0x00F4)
class UAICommand_BossTheatrics : public UAICommand_SpecialMove {
   public:
    unsigned char TheatricType;  // 0x00F4 (0x0001) [0x0000000000000000]
    int TheatricDuration;        // 0x00F8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[50843];

        return pClassPointer;
    };

    void Popped();
    void Pushed();
    void DoTheatrics();
};

UClass* UAICommand_BossTheatrics::pClassPointer = NULL;

// Class KFGame.KFSM_Zed_Boss_Theatrics
// 0x001C (0x016C - 0x0150)
class UKFSM_Zed_Boss_Theatrics : public UKFSM_PlaySingleAnim {
   public:
    unsigned char CurrentTheatricType;  // 0x0150 (0x0001) [0x0000000000000000]
    class UCameraAnim* CameraAnim;      // 0x0154 (0x0008) [0x0000000000000000]
    struct FColor FadeInColor;          // 0x015C (0x0004) [0x0000000000000000]
    struct FColor FadeOutColor;         // 0x0160 (0x0004) [0x0000000000000000]
    float FadeInTime;                   // 0x0164 (0x0004) [0x0000000000000000]
    float FadeOutTime;                  // 0x0168 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[50862];

        return pClassPointer;
    };

    void GetALocalKFPlayerController();
    void SpecialMoveEnded();
    void PlayAnimation();
    void SpecialMoveStarted();
    void PackSMFlags();
    void InternalCanDoSpecialMove();
};

UClass* UKFSM_Zed_Boss_Theatrics::pClassPointer = NULL;

// Class KFGame.AICommand_Crawler_LeapToWall
// 0x001C (0x00D4 - 0x00B8)
class UAICommand_Crawler_LeapToWall : public UAICommand {
   public:
    class AKFWallPathNode* WallNode;  // 0x00B8 (0x0008) [0x0000000000000000]
    class ANavigationPoint*
        StartLeapNode;  // 0x00C0 (0x0008) [0x0000000000000000]
    class ANavigationPoint*
        EndLeapNode;  // 0x00C8 (0x0008) [0x0000000000000000]
    float JumpTime;   // 0x00D0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[50866];

        return pClassPointer;
    };

    void NotifyHitWall();
    void NotifyFallingHitWall();
    void NotifyLanded();
    void CanChangeEnemy();
    void Popped();
    void Pushed();
    void LeapToWall();
};

UClass* UAICommand_Crawler_LeapToWall::pClassPointer = NULL;

// Class KFGame.AICommand_Crawler_MoveToGoal
// 0x0000 (0x01D4 - 0x01D4)
class UAICommand_Crawler_MoveToGoal : public UAICommand_MoveToGoal {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[51123];

        return pClassPointer;
    };

    void NotifyLanded();
    void CrawlerMoveToGoal();
};

UClass* UAICommand_Crawler_MoveToGoal::pClassPointer = NULL;

// Class KFGame.AICommand_PushedBySM
// 0x0004 (0x00F8 - 0x00F4)
class UAICommand_PushedBySM : public UAICommand_SpecialMove {
   public:
    DWORD bAllowMeleeCombatDecisions : 1;  // 0x00F4 (0x0004)
                                           // [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[51162];

        return pClassPointer;
    };

    void SpecialMoveTimeout();
    void Popped();
    void Pushed();
    void AllowTransitionTo();
    void eventGetDumpString();
    void PushSpecialMoveCommand();
};

UClass* UAICommand_PushedBySM::pClassPointer = NULL;

// Class KFGame.AICommand_CrawlerEmerge
// 0x0000 (0x00F8 - 0x00F8)
class UAICommand_CrawlerEmerge : public UAICommand_PushedBySM {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[51181];

        return pClassPointer;
    };

    void SpecialMoveTimeout();
    void GetUpdatedAnchor();
    void GetStartAnchor();
    void Emerge();
};

UClass* UAICommand_CrawlerEmerge::pClassPointer = NULL;

// Class KFGame.AICommand_Debug
// 0x0038 (0x00F0 - 0x00B8)
class UAICommand_Debug : public UAICommand {
   public:
    DWORD bTestStepAside : 1;  // 0x00B8 (0x0004) [0x0000000000000000]
                               // [0x00000001]
    DWORD bNoFocus : 1;  // 0x00B8 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bOldDebugPostRenderInfo : 1;  // 0x00B8 (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    DWORD bTempDisableHitWall : 1;      // 0x00B8 (0x0004) [0x0000000000000000]
                                        // [0x00000008]
    DWORD bStoppedRotationTowardEnemy : 1;  // 0x00B8 (0x0004)
                                            // [0x0000000000000000] [0x00000010]
    struct FVector DebugMoveLocation;  // 0x00BC (0x000C) [0x0000000000000000]
    class AKFPawn* DebuggingPlayer;    // 0x00C8 (0x0008) [0x0000000000000000]
    float MaxRoamDist;                 // 0x00D0 (0x0004) [0x0000000000000000]
    float RoamStartTime;               // 0x00D4 (0x0004) [0x0000000000000000]
    float RoamEnvelopeOuter;           // 0x00D8 (0x0004) [0x0000000000000000]
    float RoamEnvelopeInner;           // 0x00DC (0x0004) [0x0000000000000000]
    float RoamWaitMin;                 // 0x00E0 (0x0004) [0x0000000000000000]
    float RoamWaitMax;                 // 0x00E4 (0x0004) [0x0000000000000000]
    class AActor* LastDebugGoal;       // 0x00E8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[51197];

        return pClassPointer;
    };

    void DrawDebug();
    void CanSeePawn();
    void ReadyToCharge();
    void EnableNotifyHitWall();
    void NotifyHitWall();
    void CheckVision();
    void EvaluateThreats();
    void Debug_LOS();
    void Debug_CrawlerAttack();
    void Debug_DebugNodes();
    void Debug_Leap();
    void Debug_DebugLines();
    void Debug_Wander();
    void Debug_Steering();
    void Debug_StepAside();
    void Debug_Enemy();
    void Debug_Hide();
    void Debug_Flank();
    void Debug_Vision();
    void Debug_MoveForward();
    void Debug_Charge();
    void NotifyPlayerBecameVisible();
    void Popped();
    void GrabTestTimer();
    void Resumed();
    void Pushed();
    void Debug();
};

UClass* UAICommand_Debug::pClassPointer = NULL;

// Class KFGame.AICommand_Wander
// 0x0030 (0x00E8 - 0x00B8)
class UAICommand_Wander : public UAICommand {
   public:
    struct FVector WanderDestination;  // 0x00B8 (0x000C) [0x0000000000000000]
    float MaxWanderDist;               // 0x00C4 (0x0004) [0x0000000000000000]
    float WanderDuration;              // 0x00C8 (0x0004) [0x0000000000000000]
    float RandomCoef;                  // 0x00CC (0x0004) [0x0000000000000000]
    float WanderEnvelopeInner;         // 0x00D0 (0x0004) [0x0000000000000000]
    float WanderWaitMin;               // 0x00D4 (0x0004) [0x0000000000000000]
    float WanderWaitMax;               // 0x00D8 (0x0004) [0x0000000000000000]
    class AActor* WanderGoal;          // 0x00DC (0x0008) [0x0000000000000000]
    DWORD bWanderAroundGoal : 1;       // 0x00E4 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bCanUsePartialPath : 1;      // 0x00E4 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD
        bWasSprinting : 1;  // 0x00E4 (0x0004) [0x0000000000000000] [0x00000004]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[51382];

        return pClassPointer;
    };

    void CanSeePawn();
    void IsPawnVisibleViaTrace();
    void GetMoveDir();
    void Timer_WanderDurationExpired();
    void Popped();
    void Resumed();
    void Paused();
    void Pushed();
    void BeginWander();
};

UClass* UAICommand_Wander::pClassPointer = NULL;

// Class KFGame.AICommand_DebugTurn
// 0x000C (0x00C4 - 0x00B8)
class UAICommand_DebugTurn : public UAICommand {
   public:
    class AKFPlayerController* Player;  // 0x00B8 (0x0008) [0x0000000000000000]
    DWORD bEnableMeleeWhenInRange : 1;  // 0x00C0 (0x0004) [0x0000000000000000]
                                        // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[51387];

        return pClassPointer;
    };

    void StartMeleeSpecialMove();
    void CheckMeleeRange();
    void Pushed();
    void DebugTurnInPlace();
};

UClass* UAICommand_DebugTurn::pClassPointer = NULL;

// Class KFGame.AICommand_Evade
// 0x001C (0x0110 - 0x00F4)
class UAICommand_Evade : public UAICommand_SpecialMove {
   public:
    unsigned char EvadeDirection;  // 0x00F4 (0x0001) [0x0000000000000000]
    unsigned char SMFlags;         // 0x00F5 (0x0001) [0x0000000000000000]
    float EvadeDelay;              // 0x00F8 (0x0004) [0x0000000000000000]
    DWORD bFrightened : 1;  // 0x00FC (0x0004) [0x0000000000000000] [0x00000001]
    DWORD
        bTurnToThreat : 1;  // 0x00FC (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bLookAtDangerInstigator : 1;  // 0x00FC (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    DWORD bOldHeadTrackingActive : 1;   // 0x00FC (0x0004) [0x0000000000000000]
                                        // [0x00000008]
    float RepeatDistSq;                 // 0x0100 (0x0004) [0x0000000000000000]
    struct FVector LookAtLocation;      // 0x0104 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[51406];

        return pClassPointer;
    };

    void CanEvade();
    void Popped();
    void Pushed();
    void eventGetDumpString();
    void Evade();
};

UClass* UAICommand_Evade::pClassPointer = NULL;

// Class KFGame.KFSM_Evade
// 0x0010 (0x0160 - 0x0150)
class UKFSM_Evade : public UKFSM_PlaySingleAnim {
   public:
    TArray<struct FAnimVariants>
        EvadeAnims;  // 0x0150 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[51445];

        return pClassPointer;
    };

    void PlayAnimation();
    void PackAnimFlag();
};

UClass* UKFSM_Evade::pClassPointer = NULL;

// Class KFGame.AICommand_Flee
// 0x0020 (0x00D8 - 0x00B8)
class UAICommand_Flee : public UAICommand {
   public:
    DWORD bStopAtGoal : 1;  // 0x00B8 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD
        bWasSprinting : 1;  // 0x00B8 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bHaveGoal : 1;    // 0x00B8 (0x0004) [0x0000000000000000] [0x00000004]
    class AActor* FleeTarget;  // 0x00BC (0x0008) [0x0000000000000000]
    float Dot;                 // 0x00C4 (0x0004) [0x0000000000000000]
    int PathAttempts;          // 0x00C8 (0x0004) [0x0000000000000000]
    float FleeDuration;        // 0x00CC (0x0004) [0x0000000000000000]
    float FleeDistance;        // 0x00D0 (0x0004) [0x0000000000000000]
    float GoalOffset;          // 0x00D4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[51449];

        return pClassPointer;
    };

    void Popped();
    void StartFleeing();
    void Timer_FleeDurationExpired();
    void Pushed();
    void FleeFrom();
};

UClass* UAICommand_Flee::pClassPointer = NULL;

// Class KFGame.AICommand_Hans_GunStance
// 0x0001 (0x00F5 - 0x00F4)
class UAICommand_Hans_GunStance : public UAICommand_SpecialMove {
   public:
    unsigned char StanceType;  // 0x00F4 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[51479];

        return pClassPointer;
    };

    void Popped();
    void Pushed();
    void SetGunStance();
};

UClass* UAICommand_Hans_GunStance::pClassPointer = NULL;

// Class KFGame.AICommand_HeadlessWander
// 0x0024 (0x00DC - 0x00B8)
class UAICommand_HeadlessWander : public UAICommand {
   public:
    class AController* EventInstigator;  // 0x00B8 (0x0008) [0x0000000000000000]
    float RandomMoveDist;                // 0x00C0 (0x0004) [0x0000000000000000]
    float DotCheck;                      // 0x00C4 (0x0004) [0x0000000000000000]
    float LastHeadlessAttackTime;        // 0x00C8 (0x0004) [0x0000000000000000]
    DWORD
        bDebugWander : 1;  // 0x00CC (0x0004) [0x0000000000000000] [0x00000001]
    struct FVector Dest;   // 0x00D0 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[51495];

        return pClassPointer;
    };

    void NotifyHearNoise();
    void CalcTurnDirection();
    void ShouldRunSomewhereElse();
    void AllowTransitionTo();
    void Popped();
    void Pushed();
    void HeadlessWander();
};

UClass* UAICommand_HeadlessWander::pClassPointer = NULL;

// Class KFGame.AICommand_MoveToEnemy
// 0x0068 (0x0120 - 0x00B8)
class UAICommand_MoveToEnemy : public UAICommand {
   public:
    class AActor* Path;      // 0x00B8 (0x0008) [0x0000000000000000]
    class AActor* Find;      // 0x00C0 (0x0008) [0x0000000000000000]
    float Radius;            // 0x00C8 (0x0004) [0x0000000000000000]
    int MoveTriesRemaining;  // 0x00CC (0x0004) [0x0000000000000000]
    DWORD
        bCompleteMove : 1;  // 0x00D0 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bAllowedToAttackDuringMove : 1;  // 0x00D0 (0x0004)
                                           // [0x0000000000000000] [0x00000002]
    float GoalDistance;     // 0x00D4 (0x0004) [0x0000000000000000]
    float AbandonDistance;  // 0x00D8 (0x0004) [0x0000000000000000]
    struct FBasedPosition
        LastEnemyLocation;        // 0x00DC (0x0038) [0x0000000000000000]
    float RepathDistance;         // 0x0114 (0x0004) [0x0000000000000000]
    class AActor* OverrideFocus;  // 0x0118 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[51548];

        return pClassPointer;
    };

    void JumpToTarget();
    void eventGetDumpString();
    void DirectMoveTimeout();
    void CheckEnemyMoved();
    void CheckReachedEnemy();
    void SprintTimer();
    void NotifyPlayerBecameVisible();
    void Resumed();
    void Paused();
    void Popped();
    void Pushed();
    void MoveToEnemy();
};

UClass* UAICommand_MoveToEnemy::pClassPointer = NULL;

// Class KFGame.AICommand_PanicWander
// 0x0000 (0x00DC - 0x00DC)
class UAICommand_PanicWander : public UAICommand_HeadlessWander {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[51603];

        return pClassPointer;
    };

    void Popped();
    void EndWander();
    void Resumed();
    void PanicWander();
};

UClass* UAICommand_PanicWander::pClassPointer = NULL;

// Class KFGame.AICommand_Pause
// 0x0008 (0x00C0 - 0x00B8)
class UAICommand_Pause : public UAICommand {
   public:
    float PauseTime;  // 0x00B8 (0x0004) [0x0000000000000000]
    DWORD
        bStopMovement : 1;  // 0x00BC (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bAbortCommands : 1;   // 0x00BC (0x0004) [0x0000000000000000]
                                // [0x00000002]
    DWORD bWaitForLanding : 1;  // 0x00BC (0x0004) [0x0000000000000000]
                                // [0x00000004]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[51616];

        return pClassPointer;
    };

    void CanChangeEnemy();
    void AllowTransitionTo();
    void Paused();
    void Popped();
    void Pushed();
    void Pause();
};

UClass* UAICommand_Pause::pClassPointer = NULL;

// Class KFGame.AICommand_StepAside
// 0x0088 (0x0140 - 0x00B8)
class UAICommand_StepAside : public UAICommand {
   public:
    struct FBasedPosition
        PreStepAsideLocation;  // 0x00B8 (0x0038) [0x0000000000000000]
    struct FBasedPosition
        StepAsideLocation;  // 0x00F0 (0x0038) [0x0000000000000000]
    DWORD bDelayStep : 1;   // 0x0128 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bNoFocus : 1;     // 0x0128 (0x0004) [0x0000000000000000] [0x00000002]
    struct FVector OriginalFocalPoint;  // 0x012C (0x000C) [0x0000000000000000]
    class AActor* OriginalFocus;        // 0x0138 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[51642];

        return pClassPointer;
    };

    void DrawDebug();
    void eventGetDumpString();
    void Popped();
    void Pushed();
    void StepAside();
};

UClass* UAICommand_StepAside::pClassPointer = NULL;

// Class KFGame.AICommand_Stumble
// 0x000D (0x0105 - 0x00F8)
class UAICommand_Stumble : public UAICommand_PushedBySM {
   public:
    struct FVector Momentum;    // 0x00F8 (0x000C) [0x0000000000000000]
    unsigned char HitZoneLimb;  // 0x0104 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[51686];

        return pClassPointer;
    };

    void IsAllowedToAttack();
    void ShouldIgnoreTimeTransitions();
    void Popped();
    void Pushed();
    void Stumble();
};

UClass* UAICommand_Stumble::pClassPointer = NULL;

// Class KFGame.AICommand_SummonZeds
// 0x000C (0x0100 - 0x00F4)
class UAICommand_SummonZeds : public UAICommand_SpecialMove {
   public:
    class UKFAIWaveInfo* SummonWave;  // 0x00F4 (0x0008) [0x0000000000000000]
    int MaxBossMinions;               // 0x00FC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[51702];

        return pClassPointer;
    };

    void Popped();
    void Pushed();
    void Summon();
};

UClass* UAICommand_SummonZeds::pClassPointer = NULL;

// Class KFGame.KFAIWaveInfo
// 0x0038 (0x0098 - 0x0060)
class UKFAIWaveInfo : public UObject {
   public:
    DWORD
        bRecycleWave : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000001]
    TArray<class UKFAISpawnSquad*>
        Squads;  // 0x0064 (0x0010) [0x0000000000000000]
    TArray<class UKFAISpawnSquad*>
        SpecialSquads;  // 0x0074 (0x0010) [0x0000000000000000]
    int MaxAI;          // 0x0084 (0x0004) [0x0000000000000000]
    TArray<class UKFAISpawnSquad*>
        EventSquads;  // 0x0088 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[51718];

        return pClassPointer;
    };

    void GetEventSquadList();
    void GetSpecialSquad();
    void GetNewSquadList();
};

UClass* UKFAIWaveInfo::pClassPointer = NULL;

// Class KFGame.KFSM_Zed_Taunt
// 0x0001 (0x0151 - 0x0150)
class UKFSM_Zed_Taunt : public UKFSM_PlaySingleAnim {
   public:
    unsigned char CurrentTauntType;  // 0x0150 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[51739];

        return pClassPointer;
    };

    void SpecialMoveEnded();
    void PlayAnimation();
    void PackSMFlags();
    void PackFlagsBase();
};

UClass* UKFSM_Zed_Taunt::pClassPointer = NULL;

// Class KFGame.AICommand_ThrowGrenade
// 0x0008 (0x00FC - 0x00F4)
class UAICommand_ThrowGrenade : public UAICommand_SpecialMove {
   public:
    int GrenadeBarrage;  // 0x00F4 (0x0004) [0x0000000000000000]
    DWORD
        bHuntAndHeal : 1;  // 0x00F8 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[51745];

        return pClassPointer;
    };

    void Popped();
    void LockdownAI();
    void Pushed();
    void ThrowGrenade();
};

UClass* UAICommand_ThrowGrenade::pClassPointer = NULL;

// Class KFGame.AIDebugGoal
// 0x0008 (0x024C - 0x0244)
class AAIDebugGoal : public AActor {
   public:
    struct FName GoalName;  // 0x0244 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[51818];

        return pClassPointer;
    };
};

UClass* AAIDebugGoal::pClassPointer = NULL;

// Class KFGame.KFweapDef_Knife_Base
// 0x0001 (0x00A4 - 0x00A3)
class UKFweapDef_Knife_Base : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[52115];

        return pClassPointer;
    };
};

UClass* UKFweapDef_Knife_Base::pClassPointer = NULL;

// Class KFGame.KFWeapDef_9mm
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_9mm : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[52116];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_9mm::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Remington1858
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Remington1858 : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[52117];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Remington1858::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Colt1911
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Colt1911 : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[52118];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Colt1911::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Deagle
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Deagle : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[52119];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Deagle::pClassPointer = NULL;

// Class KFGame.KFWeapDef_SW500
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_SW500 : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[52120];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_SW500::pClassPointer = NULL;

// Class KFGame.KFWeapDef_MedicPistol
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_MedicPistol : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[52121];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_MedicPistol::pClassPointer = NULL;

// Class KFGame.KFVoteCollector
// 0x00A0 (0x0100 - 0x0060)
class UKFVoteCollector : public UObject {
   public:
    unsigned char VoteTime;              // 0x0060 (0x0001) [0x0000000000000000]
    unsigned char ShortenedTime;         // 0x0061 (0x0001) [0x0000000000000000]
    unsigned char YesVotes;              // 0x0062 (0x0001) [0x0000000000000000]
    unsigned char NoVotes;               // 0x0063 (0x0001) [0x0000000000000000]
    unsigned char KickedPlayers;         // 0x0064 (0x0001) [0x0000000000000000]
    unsigned char LastKickVoteValue;     // 0x0065 (0x0001) [0x0000000000000000]
    struct FsKickVoteInfo CurrentVote;   // 0x0068 (0x0020) [0x0000000000000000]
    DWORD bIsVoteInProgress : 1;         // 0x0088 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bIsFailedVoteTimerActive : 1;  // 0x0088 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bAllPlayersVotedOnMap : 1;     // 0x0088 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    int TopResultsToShow;                // 0x008C (0x0004) [0x0000000000000000]
    int ActiveTimeUntilVoteEnabled;      // 0x0090 (0x0004) [0x0000000000000000]
    TArray<class APlayerReplicationInfo*>
        PlayersThatHaveVoted;         // 0x0094 (0x0010) [0x0000000000000000]
    struct FTopVotes TopVotesObject;  // 0x00A4 (0x003C) [0x0000000000000000]
    TArray<struct FMapVote>
        MapVoteList;                 // 0x00E0 (0x0010) [0x0000000000000000]
    TArray<struct FString> MapList;  // 0x00F0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[52123];

        return pClassPointer;
    };

    void MapVoteSort();
    void CheckAllPlayerVoted();
    void CheckMajorityPlayersVotedOnMap();
    void ShortenVoteTime();
    void ReceiveVoteMap();
    void SearchAndClearPreviousVote();
    void GetNextMap();
    void AddMapOption();
    void ClearFailedVoteFlag();
    void ConcludeVoteKick();
    void ShouldConcludeVote();
    void UnPackVotes();
    void ReplicateVotes();
    void RecieveVoteKick();
    void ServerStartVoteKick();
};

UClass* UKFVoteCollector::pClassPointer = NULL;

// Class KFGame.GroundFireEmitterPool
// 0x0000 (0x02BC - 0x02BC)
class AGroundFireEmitterPool : public AEmitterPool {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[52228];

        return pClassPointer;
    };
};

UClass* AGroundFireEmitterPool::pClassPointer = NULL;

// Class KFGame.KFAccessControl
// 0x0014 (0x03BC - 0x03A8)
class AKFAccessControl : public AAccessControl {
   public:
    DWORD bSilentAdminLogin : 1;  // 0x03A8 (0x0004) [0x0000000000000000]
                                  // [0x00000001]
    TArray<struct FUniqueNetId>
        SessionBannedIDs;  // 0x03AC (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[52231];

        return pClassPointer;
    };

    void IsIDBanned();
    void IsSessionBanned();
    void KickBanPlayer();
    void AdminLogout();
    void AdminExited();
    void AdminEntered();
    void ForceKickPlayer();
    void KickSessionBanPlayer();
};

UClass* AKFAccessControl::pClassPointer = NULL;

// Class KFGame.KFLocalMessage
// 0x0224 (0x0298 - 0x0074)
class UKFLocalMessage : public ULocalMessage {
   public:
    struct FString SystemString;  // 0x0074 (0x0010) [0x0000000000000000]
    struct FString AdminString;   // 0x0084 (0x0010) [0x0000000000000000]
    struct FString
        LoggedInAsAdminString;  // 0x0094 (0x0010) [0x0000000000000000]
    struct FString
        LoggedOutAsAdminString;  // 0x00A4 (0x0010) [0x0000000000000000]
    struct FString
        MustLoginToCheatString;          // 0x00B4 (0x0010) [0x0000000000000000]
    struct FString CheatsEnabledString;  // 0x00C4 (0x0010) [0x0000000000000000]
    struct FString
        ServerMaintenanceString;  // 0x00D4 (0x0010) [0x0000000000000000]
    struct FString
        KickVoteStartedString;  // 0x00E4 (0x0010) [0x0000000000000000]
    struct FString
        KickVoteFailedString;  // 0x00F4 (0x0010) [0x0000000000000000]
    struct FString
        KickVoteSucceededString;  // 0x0104 (0x0010) [0x0000000000000000]
    struct FString
        KickVoteRejectedString;  // 0x0114 (0x0010) [0x0000000000000000]
    struct FString
        KickVoteInProgressString;  // 0x0124 (0x0010) [0x0000000000000000]
    struct FString
        KickVoteDisabledString;  // 0x0134 (0x0010) [0x0000000000000000]
    struct FString
        KickVoteYesReceivedString;  // 0x0144 (0x0010) [0x0000000000000000]
    struct FString
        KickVoteNoReceivedString;  // 0x0154 (0x0010) [0x0000000000000000]
    struct FString
        KickVoteKickAdminString;  // 0x0164 (0x0010) [0x0000000000000000]
    struct FString
        KickVoteActiveTimeString;  // 0x0174 (0x0010) [0x0000000000000000]
    struct FString
        KickVoteMatchNotStartedString;  // 0x0184 (0x0010) [0x0000000000000000]
    struct FString
        KickVoteMaxKicksReachedString;  // 0x0194 (0x0010) [0x0000000000000000]
    struct FString
        KickVoteNotEnoughPlayersString;  // 0x01A4 (0x0010) [0x0000000000000000]
    struct FString
        KickVoteNoSpectatorsString;  // 0x01B4 (0x0010) [0x0000000000000000]
    struct FString
        KickedFromServerString;  // 0x01C4 (0x0010) [0x0000000000000000]
    struct FString
        BannedFromServerString;  // 0x01D4 (0x0010) [0x0000000000000000]
    struct FString
        ServerNoLongerAvailableString;  // 0x01E4 (0x0010) [0x0000000000000000]
    int MessageArea;                    // 0x01F4 (0x0004) [0x0000000000000000]
    int AnnouncementPriority;           // 0x01F8 (0x0004) [0x0000000000000000]
    DWORD
        bShowPortrait : 1;  // 0x01FC (0x0004) [0x0000000000000000] [0x00000001]
    float AnnouncementVolume;            // 0x0200 (0x0004) [0x0000000000000000]
    float AnnouncementDelay;             // 0x0204 (0x0004) [0x0000000000000000]
    struct FString SayColor;             // 0x0208 (0x0010) [0x0000000000000000]
    struct FString TeamSayColor;         // 0x0218 (0x0010) [0x0000000000000000]
    struct FString NonAffialiatedColor;  // 0x0228 (0x0010) [0x0000000000000000]
    struct FString EventColor;           // 0x0238 (0x0010) [0x0000000000000000]
    struct FString GameColor;            // 0x0248 (0x0010) [0x0000000000000000]
    struct FString InteractionColor;     // 0x0258 (0x0010) [0x0000000000000000]
    struct FString PriorityColor;        // 0x0268 (0x0010) [0x0000000000000000]
    struct FString DefaultColor;         // 0x0278 (0x0010) [0x0000000000000000]
    struct FString ConnectionColor;      // 0x0288 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[52260];

        return pClassPointer;
    };

    void getLocalized();
    void GetHexColor();
    void KilledByVictoryMessage();
    void GetPos();
    void AnnouncementSound();
    void AnnouncementLevel();
    void GetString();
};

UClass* UKFLocalMessage::pClassPointer = NULL;

// Class KFGame.KFAffliction_EMPDisrupt
// 0x0000 (0x00D4 - 0x00D4)
class UKFAffliction_EMPDisrupt : public UKFAffliction_EMP {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[52369];

        return pClassPointer;
    };

    void SetEMPDisrupted();
    void EMPDisruptTimer();
    void Accrue();
};

UClass* UKFAffliction_EMPDisrupt::pClassPointer = NULL;

// Class KFGame.KFSM_Block
// 0x002C (0x017C - 0x0150)
class UKFSM_Block : public UKFSM_PlaySingleAnim {
   public:
    TArray<struct FAnimVariants>
        BlockAnims;             // 0x0150 (0x0010) [0x0000000000000000]
    class AKFGameInfo* MyKFGI;  // 0x0160 (0x0008) [0x0000000000000000]
    class AKFPawn_Monster*
        MyMonsterPawn;               // 0x0168 (0x0008) [0x0000000000000000]
    int NumBlocks;                   // 0x0170 (0x0004) [0x0000000000000000]
    unsigned char ReactionDir;       // 0x0174 (0x0001) [0x0000000000000000]
    DWORD bPlayedBlockBreak : 1;     // 0x0178 (0x0004) [0x0000000000000000]
                                     // [0x00000001]
    DWORD bUseBlockSprintSpeed : 1;  // 0x0178 (0x0004) [0x0000000000000000]
                                     // [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[54221];

        return pClassPointer;
    };

    void SpecialMoveEnded();
    void NotifyHitReactionInterrupt();
    void Timer_BlockBroken();
    void Timer_BlockDurationExpired();
    void Timer_EnableBlocking();
    void SpecialMoveFlagsUpdated();
    void Timer_ResetSpecialMoveFlags();
    void PlayAnimation();
    void GetSprintSpeedModifier();
    void AdjustSprintSpeed();
    void SpecialMoveStarted();
    void CanChainMove();
    void CanOverrideMoveWith();
    void InternalCanDoSpecialMove();
    void PackBlockSMFLags();
};

UClass* UKFSM_Block::pClassPointer = NULL;

// Class KFGame.KFDummyReplicationInfo
// 0x0000 (0x0324 - 0x0324)
class AKFDummyReplicationInfo : public APlayerReplicationInfo {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[54370];

        return pClassPointer;
    };

    void ShouldBroadCastWelcomeMessage();
};

UClass* AKFDummyReplicationInfo::pClassPointer = NULL;

// Class KFGame.KFCameraShake
// 0x0008 (0x00E8 - 0x00E0)
class UKFCameraShake : public UCameraShake {
   public:
    class UForceFeedbackWaveform*
        FFWaveform;  // 0x00E0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[54383];

        return pClassPointer;
    };
};

UClass* UKFCameraShake::pClassPointer = NULL;

// Class KFGame.KFDT_Slashing
// 0x0000 (0x0164 - 0x0164)
class UKFDT_Slashing : public UKFDamageType {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[54661];

        return pClassPointer;
    };

    void GetKillerDialogID();
    void CanDismemberHitZone();
    void GetBloodScale();
    void AddBloodSpread();
    void GetLastSlashDirection();
};

UClass* UKFDT_Slashing::pClassPointer = NULL;

// Class KFGame.KFLocalMessage_Priority
// 0x0150 (0x03E8 - 0x0298)
class UKFLocalMessage_Priority : public UKFLocalMessage {
   public:
    struct FString WaveStartMessage;    // 0x0298 (0x0010) [0x0000000000000000]
    struct FString WaveEndMessage;      // 0x02A8 (0x0010) [0x0000000000000000]
    struct FString GetToTraderMessage;  // 0x02B8 (0x0010) [0x0000000000000000]
    struct FString ScavengeMessage;     // 0x02C8 (0x0010) [0x0000000000000000]
    struct FString YouLostMessage;      // 0x02D8 (0x0010) [0x0000000000000000]
    struct FString YouWonMessage;       // 0x02E8 (0x0010) [0x0000000000000000]
    struct FString
        SquadWipedOutMessage;  // 0x02F8 (0x0010) [0x0000000000000000]
    struct FString
        SquadSurvivedMessage;  // 0x0308 (0x0010) [0x0000000000000000]
    struct FString
        ObjectiveStartMessage;           // 0x0318 (0x0010) [0x0000000000000000]
    struct FString ObjectiveWonMessage;  // 0x0328 (0x0010) [0x0000000000000000]
    struct FString
        ObjectiveLostMessage;  // 0x0338 (0x0010) [0x0000000000000000]
    struct FString
        ObjectiveEndedMessage;  // 0x0348 (0x0010) [0x0000000000000000]
    struct FString
        ObjNotEnoughPlayersMessage;  // 0x0358 (0x0010) [0x0000000000000000]
    struct FString
        ObjTimeRanOutMessage;          // 0x0368 (0x0010) [0x0000000000000000]
    struct FString HumansLoseMessage;  // 0x0378 (0x0010) [0x0000000000000000]
    struct FString HumansWinMessage;   // 0x0388 (0x0010) [0x0000000000000000]
    struct FString
        AttackHumanPlayersString;  // 0x0398 (0x0010) [0x0000000000000000]
    struct FString
        ZedGroupRegroupingString;  // 0x03A8 (0x0010) [0x0000000000000000]
    struct FString
        NextRoundBeginString;  // 0x03B8 (0x0010) [0x0000000000000000]
    struct FString
        PlayerCanChangePerksString;  // 0x03C8 (0x0010) [0x0000000000000000]
    struct FString
        ZedWaitingForNextRoundString;  // 0x03D8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[55336];

        return pClassPointer;
    };

    void GetMessageLifeTime();
    void OpenPerkMenu();
    void CloseMenus();
    void GetMessageString();
    void ClientReceive();
};

UClass* UKFLocalMessage_Priority::pClassPointer = NULL;

// Class KFGame.KFGoreJointInfo
// 0x007C (0x00DC - 0x0060)
class UKFGoreJointInfo : public UObject {
   public:
    struct FName HitBoneName;      // 0x0060 (0x0008) [0x0000000000000000]
    DWORD bNonBreakableJoint : 1;  // 0x0068 (0x0004) [0x0000000000000000]
                                   // [0x00000001]
    TArray<struct FPartialBreakSettings>
        BoneShrinkGore;  // 0x006C (0x0010) [0x0000000000000000]
    TArray<struct FExplosionBreakSettings>
        HitExplosionGore;  // 0x007C (0x0010) [0x0000000000000000]
    TArray<struct FDependentBreakSettings>
        DependentBreakGore;  // 0x008C (0x0010) [0x0000000000000000]
    TArray<struct FBloodJetSettings>
        BloodJets;  // 0x009C (0x0010) [0x0000000000000000]
    TArray<struct FBloodTrailSettings>
        BloodTrails;  // 0x00AC (0x0010) [0x0000000000000000]
    TArray<struct FName>
        BloodMICParamName;  // 0x00BC (0x0010) [0x0000000000000000]
    TArray<struct FDismembermentEffect>
        DismembermentEffects;  // 0x00CC (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[55353];

        return pClassPointer;
    };
};

UClass* UKFGoreJointInfo::pClassPointer = NULL;

// Class KFGame.KFDT_Ballistic
// 0x0000 (0x0164 - 0x0164)
class UKFDT_Ballistic : public UKFDamageType {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[55360];

        return pClassPointer;
    };

    void GetDamageeDialogID();
    void GetKillerDialogID();
    void CanDismemberHitZone();
};

UClass* UKFDT_Ballistic::pClassPointer = NULL;

// Class KFGame.KFGoreChunkAttachmentInfo
// 0x0020 (0x0080 - 0x0060)
class UKFGoreChunkAttachmentInfo : public UObject {
   public:
    class UStaticMesh* StaticMesh;  // 0x0060 (0x0008) [0x0000000000000000]
    struct FName SocketName;        // 0x0068 (0x0008) [0x0000000000000000]
    TArray<struct FName>
        DismemberedBoneList;  // 0x0070 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[55381];

        return pClassPointer;
    };

    void ShouldDetachGoreChunk();
    void ShouldAttachGoreChunk();
};

UClass* UKFGoreChunkAttachmentInfo::pClassPointer = NULL;

// Class KFGame.KFDT_Bleeding
// 0x0000 (0x0164 - 0x0164)
class UKFDT_Bleeding : public UKFDamageType {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[55389];

        return pClassPointer;
    };
};

UClass* UKFDT_Bleeding::pClassPointer = NULL;

// Class KFGame.KFProj_RicochetBullet
// 0x0010 (0x03B0 - 0x03A0)
class AKFProj_RicochetBullet : public AKFProj_Bullet {
   public:
    int BouncesLeft;      // 0x03A0 (0x0004) [0x0000000000000000]
    float DampingFactor;  // 0x03A4 (0x0004) [0x0000000000000000]
    class UKFImpactEffectInfo*
        RicochetEffects;  // 0x03A8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[55395];

        return pClassPointer;
    };

    void Bounce();
};

UClass* AKFProj_RicochetBullet::pClassPointer = NULL;

// Class KFGame.KFProj_PinningBullet
// 0x000C (0x03BC - 0x03B0)
class AKFProj_PinningBullet : public AKFProj_RicochetBullet {
   public:
    class ARB_ConstraintActor*
        PinConstraint;  // 0x03B0 (0x0008) [0x0000000000000000]
    DWORD bPinned : 1;  // 0x03B8 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bSpawnedForPin : 1;  // 0x03B8 (0x0004) [0x0000000000000000]
                               // [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[55394];

        return pClassPointer;
    };

    void PinVictim();
    void CreatePin();
};

UClass* AKFProj_PinningBullet::pClassPointer = NULL;

// Class KFGame.KFSM_Emerge
// 0x0048 (0x017C - 0x0134)
class UKFSM_Emerge : public UKFSpecialMove {
   public:
    TArray<struct FName> FloorEmerge;    // 0x0134 (0x0010) [0x0000000000000000]
    TArray<struct FName> Wall248Emerge;  // 0x0144 (0x0010) [0x0000000000000000]
    TArray<struct FName>
        WallHighEmerge;                  // 0x0154 (0x0010) [0x0000000000000000]
    TArray<struct FName> CeilingEmerge;  // 0x0164 (0x0010) [0x0000000000000000]
    float BlendOutTime;                  // 0x0174 (0x0004) [0x0000000000000000]
    DWORD
        bDoKnockdown : 1;  // 0x0178 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[55401];

        return pClassPointer;
    };

    void FindAnchorFailsafe();
    void AbortSpecialMove();
    void PushOverlappingHumans();
    void RestoreCollision();
    void AnimEndNotify();
    void Timer_CheckForPortalDestructibles();
    void SpecialMoveEnded();
    void PlayEmerge();
    void SpecialMoveStarted();
    void CanOverrideMoveWith();
    void GetEmergeAnim();
    void GetEmergeAnimNum();
    void PackAnimFlag();
};

UClass* UKFSM_Emerge::pClassPointer = NULL;

// Class KFGame.KFExplosionActor
// 0x004C (0x0318 - 0x02CC)
class AKFExplosionActor : public AGameExplosionActor {
   public:
    struct FMaterialImpactEffect
        MyImpactEffect;            // 0x02CC (0x0044) [0x0000000000000000]
    unsigned char NumPawnsKilled;  // 0x0310 (0x0001) [0x0000000000000000]
    unsigned char
        ExplosionLightPriority;  // 0x0311 (0x0001) [0x0000000000000000]
    float DamageScalePerStack;   // 0x0314 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[55405];

        return pClassPointer;
    };

    void Reset();
    void IsBehindExplosion();
    void CalcStackingDamageScale();
    void DrawDebug();
    void DoExplosionDamage();
    void StumblePawn();
    void KnockdownPawn();
    void SpecialPawnEffectsFor();
    void SpawnExplosionDecal();
    void SpawnExplosionParticleSystem();
    void UpdateExplosionTemplateWithPerMaterialFX();
    void SpawnShards();
    void Explode();
};

UClass* AKFExplosionActor::pClassPointer = NULL;

// Class KFGame.KFExplosionActorReplicated
// 0x000C (0x0324 - 0x0318)
class AKFExplosionActorReplicated : public AKFExplosionActor {
   public:
    class UGameExplosion*
        ExploTemplateRef;  // 0x0318 (0x0008) [0x0000000000160000] (
                           // CPF_EditConst | CPF_GlobalConfig )
    DWORD bIgnoreInstigator : 1;  // 0x0320 (0x0004) [0x0000000000000000]
                                  // [0x00000001]
    DWORD bTraceForHitActorWhenDirectionalExplosion : 1;  // 0x0320 (0x0004)
                                                          // [0x0000000000170000]
                                                          // [0x00000002] (
                                                          // CPF_Travel |
                                                          // CPF_EditConst |
                                                          // CPF_GlobalConfig )
    DWORD bSyncParticlesToMuzzle : 1;  // 0x0320 (0x0004) [0x0000000000180000]
                                       // [0x00000004] ( CPF_Component )

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[55404];

        return pClassPointer;
    };

    void GetMuzzleEffectLocation();
    void SpawnExplosionParticleSystem();
    void Explode();
    void eventReplicatedEvent();
};

UClass* AKFExplosionActorReplicated::pClassPointer = NULL;

// Class KFGame.KFDT_Fire
// 0x0000 (0x0164 - 0x0164)
class UKFDT_Fire : public UKFDamageType {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[55411];

        return pClassPointer;
    };

    void GetDamageeDialogID();
    void GetDamagerDialogID();
    void GetKillerDialogID();
};

UClass* UKFDT_Fire::pClassPointer = NULL;

// Class KFGame.KFDT_Fire_Napalm
// 0x0000 (0x0164 - 0x0164)
class UKFDT_Fire_Napalm : public UKFDT_Fire {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[55410];

        return pClassPointer;
    };
};

UClass* UKFDT_Fire_Napalm::pClassPointer = NULL;

// Class KFGame.KFDT_Bludgeon
// 0x0000 (0x0164 - 0x0164)
class UKFDT_Bludgeon : public UKFDamageType {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[55416];

        return pClassPointer;
    };

    void GetKillerDialogID();
};

UClass* UKFDT_Bludgeon::pClassPointer = NULL;

// Class KFGame.KFDT_Explosive_Sacrifice
// 0x0000 (0x0164 - 0x0164)
class UKFDT_Explosive_Sacrifice : public UKFDT_Explosive {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[55429];

        return pClassPointer;
    };
};

UClass* UKFDT_Explosive_Sacrifice::pClassPointer = NULL;

// Class KFGame.KFVersusNoTakeoverVolume
// 0x0000 (0x0280 - 0x0280)
class AKFVersusNoTakeoverVolume : public AVolume {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[55437];

        return pClassPointer;
    };
};

UClass* AKFVersusNoTakeoverVolume::pClassPointer = NULL;

// Class KFGame.KFMonsterDifficultyInfo
// 0x0220 (0x0280 - 0x0060)
class UKFMonsterDifficultyInfo : public UObject {
   public:
    struct FZedDifficultySettings
        Normal;                          // 0x0060 (0x0064) [0x0000000000000000]
    struct FZedDifficultySettings Hard;  // 0x00C4 (0x0064) [0x0000000000000000]
    struct FZedDifficultySettings
        Suicidal;  // 0x0128 (0x0064) [0x0000000000000000]
    struct FZedDifficultySettings
        HellOnEarth;                   // 0x018C (0x0064) [0x0000000000000000]
    float NumPlayersScale_BodyHealth;  // 0x01F0 (0x0004) [0x0000000000000000]
    float NumPlayersScale_HeadHealth;  // 0x01F4 (0x0004) [0x0000000000000000]
    float NumPlayersScale_BodyHealth_Versus;  // 0x01F8 (0x0004)
                                              // [0x0000000000000000]
    float NumPlayersScale_HeadHealth_Versus;  // 0x01FC (0x0004)
                                              // [0x0000000000000000]
    struct FsEvadeOnDamageInfo
        EvadeOnDamageSettings_Versus;  // 0x0200 (0x0010) [0x0000000000000000]
    struct FsBlockInfo
        BlockSettings_Versus;  // 0x0210 (0x0024) [0x0000000000000000]
    struct FsBlockInfo
        BlockSettings_Player_Versus;  // 0x0234 (0x0024) [0x0000000000000000]
    struct FsRallyInfo
        RallySettings_Versus;  // 0x0258 (0x0010) [0x0000000000000000]
    struct FsRallyInfo
        RallySettings_Player_Versus;  // 0x0268 (0x0010) [0x0000000000000000]
    float ZedTimeSpeedScale_Versus;   // 0x0278 (0x0004) [0x0000000000000000]
    float ZedTimeSpeedScale_Player_Versus;  // 0x027C (0x0004)
                                            // [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[55438];

        return pClassPointer;
    };

    void GetMovementSpeedMod();
    void GetZedTimeSpeedScale();
    void GetBlockSettings();
    void GetRallySettings();
    void GetEvadeOnDamageSettings();
};

UClass* UKFMonsterDifficultyInfo::pClassPointer = NULL;

// Class KFGame.KFDT_NPCBump
// 0x0000 (0x0164 - 0x0164)
class UKFDT_NPCBump : public UKFDT_Bludgeon {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[55458];

        return pClassPointer;
    };
};

UClass* UKFDT_NPCBump::pClassPointer = NULL;

// Class KFGame.KFSM_RagdollKnockdown
// 0x001C (0x0150 - 0x0134)
class UKFSM_RagdollKnockdown : public UKFSpecialMove {
   public:
    float KnockdownMaxZ;               // 0x0134 (0x0004) [0x0000000000000000]
    int MaxKnockdownPawns;             // 0x0138 (0x0004) [0x0000000000000000]
    struct FVector KnockdownStartLoc;  // 0x013C (0x000C) [0x0000000000000000]
    class UParticleSystemComponent*
        DazedPSC;  // 0x0148 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[55462];

        return pClassPointer;
    };

    void RestoreRBCollision();
    void TermKnockdownRagdoll();
    void EndKnockdown();
    void KnockdownTimer();
    void eventKnockdownFailsafe();
    void PlayFallDown();
    void ApplyKnockdownImpulse();
    void DeferApplyKnockdownImpulse();
    void SpecialMoveEnded();
    void SpecialMoveStarted();
    void InternalCanDoSpecialMove();
};

UClass* UKFSM_RagdollKnockdown::pClassPointer = NULL;

// Class KFGame.KFSM_Stunned
// 0x0048 (0x017C - 0x0134)
class UKFSM_Stunned : public UKFSpecialMove {
   public:
    struct FName StunnedAnim;          // 0x0134 (0x0008) [0x0000000000000000]
    TArray<struct FName> WakeupAnims;  // 0x013C (0x0010) [0x0000000000000000]
    float StunDuration;                // 0x014C (0x0004) [0x0000000000000000]
    struct FVector2D
        PlayerStunDurationRange;         // 0x0150 (0x0008) [0x0000000000000000]
    struct FVector2D StunDurationRange;  // 0x0158 (0x0008) [0x0000000000000000]
    struct FName DazedFXSocketName;      // 0x0160 (0x0008) [0x0000000000000000]
    struct FRotator
        DazedFXRelativeRotation;  // 0x0168 (0x000C) [0x0000000000000000]
    class UParticleSystemComponent*
        DazedPSC;  // 0x0174 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[55463];

        return pClassPointer;
    };

    void AttachDazedEffect();
    void SpecialMoveEnded();
    void SpecialMoveFlagsUpdated();
    void PlayWakeupAnimation();
    void DoWakeup();
    void DoStun();
    void SpecialMoveStarted();
};

UClass* UKFSM_Stunned::pClassPointer = NULL;

// Class KFGame.KFSM_Frozen
// 0x0044 (0x0178 - 0x0134)
class UKFSM_Frozen : public UKFSpecialMove {
   public:
    struct FName FrozenAnim;          // 0x0134 (0x0008) [0x0000000000000000]
    TArray<struct FName> ThawAnims;   // 0x013C (0x0010) [0x0000000000000000]
    float FreezeInTime;               // 0x014C (0x0004) [0x0000000000000000]
    float FreezeOutTime;              // 0x0150 (0x0004) [0x0000000000000000]
    struct FVector2D FreezeDuration;  // 0x0154 (0x0008) [0x0000000000000000]
    float BeginFreezePhaseTime;       // 0x015C (0x0004) [0x0000000000000000]
    float FreezeMatParamValue;        // 0x0160 (0x0004) [0x0000000000000000]
    class UParticleSystem*
        FrozenSteamTemplate;  // 0x0164 (0x0008) [0x0000000000000000]
    class UParticleSystemComponent*
        FrozenSteamEffect;  // 0x016C (0x0008) [0x0000000000000000]
    DWORD bIsThawing : 1;   // 0x0174 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[55464];

        return pClassPointer;
    };

    void DelayedShatterTimer();
    void PlayDeathEffects();
    void SetFrozenParameter();
    void OnGoreMeshSwap();
    void SpecialMoveEnded();
    void UpdateFreezeOutParam();
    void UpdateFreezeInParam();
    void SpecialMoveFlagsUpdated();
    void PlayThawAnimation();
    void DoThaw();
    void DoFreeze();
    void SpecialMoveStarted();
};

UClass* UKFSM_Frozen::pClassPointer = NULL;

// Class KFGame.KFSM_Zed_WalkingTaunt
// 0x0004 (0x0154 - 0x0150)
class UKFSM_Zed_WalkingTaunt : public UKFSM_PlaySingleAnim {
   public:
    float WalkingTauntChance;  // 0x0150 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[55465];

        return pClassPointer;
    };

    void PlayAnimation();
    void InternalCanDoSpecialMove();
};

UClass* UKFSM_Zed_WalkingTaunt::pClassPointer = NULL;

// Class KFGame.KFGFxMoviePlayer_HUD
// 0x0124 (0x0308 - 0x01E4)
class UKFGFxMoviePlayer_HUD : public UGFxMoviePlayer {
   public:
    class UKFGFxMoviePlayer_ScoreBoard*
        GfxScoreBoardPlayer;        // 0x01E4 (0x0008) [0x0000000000000000]
    class UClass* ScoreBoardClass;  // 0x01EC (0x0008) [0x0000000000000000]
    class UKFGFxHUD_SpectatorInfo*
        SpectatorInfoWidget;  // 0x01F4 (0x0008) [0x0000000000000000]
    class UKFGFxHUD_PlayerStatus*
        PlayerStatusContainer;  // 0x01FC (0x0008) [0x0000000000000000]
    class UKFGFxHUD_PlayerBackpack*
        PlayerBackpackContainer;  // 0x0204 (0x0008) [0x0000000000000000]
    class UGFxObject*
        PriorityMessageContainer;  // 0x020C (0x0008) [0x0000000000000000]
    class UGFxObject*
        BossNameplateContainer;  // 0x0214 (0x0008) [0x0000000000000000]
    class UGFxObject*
        InteractionMessageContainer;  // 0x021C (0x0008) [0x0000000000000000]
    class UKFGFxHUD_WeaponSelectWidget*
        KeyboardWeaponSelectWidget;  // 0x0224 (0x0008) [0x0000000000000000]
    class UKFGFxHUD_WeaponSelectWidget*
        ControllerWeaponSelectWidget;  // 0x022C (0x0008) [0x0000000000000000]
    class UKFGFxHUD_WeaponSelectWidget*
        WeaponSelectWidget;  // 0x0234 (0x0008) [0x0000000000000000]
    class UKFGFxHUD_TraderCompass*
        TraderCompassWidget;  // 0x023C (0x0008) [0x0000000000000000]
    class UKFGFxHUD_WaveInfo*
        WaveInfoWidget;  // 0x0244 (0x0008) [0x0000000000000000]
    class UKFGFxWidget_VOIPNotification*
        VOIPWidget;  // 0x024C (0x0008) [0x0000000000000000]
    class UKFGFxHUD_ChatBoxWidget*
        HudChatBox;  // 0x0254 (0x0008) [0x0000000000000000]
    class UKFGFxWidget_LevelUpNotification*
        LevelUpNotificationWidget;  // 0x025C (0x0008) [0x0000000000000000]
    class UKFGFxWidget_VoiceComms*
        VoiceCommsWidget;  // 0x0264 (0x0008) [0x0000000000000000]
    class UKFGFxWidget_MusicNotification*
        MusicNotification;  // 0x026C (0x0008) [0x0000000000000000]
    class UKFGFxWidget_KickVote*
        KickVoteWidget;  // 0x0274 (0x0008) [0x0000000000000000]
    class UKFGFxWidget_NonCriticalGameMessage*
        NonCriticalGameMessageWidget;  // 0x027C (0x0008) [0x0000000000000000]
    class UKFGFxWidget_RhythmCounter*
        RhythmCounterWidget;  // 0x0284 (0x0008) [0x0000000000000000]
    class UKFGFxWidget_BossHealthBar*
        bossHealthBar;                 // 0x028C (0x0008) [0x0000000000000000]
    class AKFPlayerController* KFPC;   // 0x0294 (0x0008) [0x0000000000000000]
    float HUDScale;                    // 0x029C (0x0004) [0x0000000000000000]
    class UGFxObject* KFGXHUDManager;  // 0x02A0 (0x0008) [0x0000000000000000]
    DWORD
        bIsSpectating : 1;  // 0x02A8 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bIsVisible : 1;   // 0x02A8 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD
        bUsingGamepad : 1;  // 0x02A8 (0x0004) [0x0000000000000000] [0x00000004]
    int CurrentInteractionIndex;  // 0x02AC (0x0004) [0x0000000000000000]
    struct FString
        ControllerStringPrefix;  // 0x02B0 (0x0010) [0x0000000000000000]
    struct FString
        HoldCommandDelimiter;           // 0x02C0 (0x0010) [0x0000000000000000]
    struct FString ZEDTeamTextColor;    // 0x02D0 (0x0010) [0x0000000000000000]
    struct FString HumanTeamTextColor;  // 0x02E0 (0x0010) [0x0000000000000000]
    float UpdateInterval;               // 0x02F0 (0x0004) [0x0000000000000000]
    float LastUpdateTime;               // 0x02F4 (0x0004) [0x0000000000000000]
    struct FString
        PendingKickPlayerName;  // 0x02F8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[55555];

        return pClassPointer;
    };

    void Callback_VoteKick();
    void Callback_VoiceCommsSelection();
    void Callback_VoiceCommsSay();
    void Callback_WeaponSelectFadedOut();
    void Callback_SelectWeapon();
    void Callback_ChatBoxClosed();
    void Callback_BroadcastChatMessage();
    void ReceivePawn();
    void PawnDied();
    void ClearBuffIcons();
    void NotifyHUDofWeapon();
    void UpdateScale();
    void UpdateKickVoteCount();
    void HideKickVote();
    void ShowKickVote();
    void OpenChatBox();
    void UpdateUsingGamePad();
    void EatMyInput();
    void UpdateRhythmCounterWidget();
    void ShowNonCriticalMessage();
    void HideInteractionMessage();
    void SendInteractionMessageToGFX();
    void GetInteractionMessagePriority();
    void DisplayInteractionMessage();
    void DisplayPriorityMessage();
    void HideBossNamePlate();
    void ShowBossNameplate();
    void ShowKillMessage();
    void NotifyHUDofPRIDestroyed();
    void Cleanup();
    void PlayerOwnerDied();
    void ShowVoiceComms();
    void ShowScoreboard();
    void SetHUDSpectating();
    void UpdateVisibilityState();
    void NotifyVisibilityChange();
    void UpdateWaveCount();
    void TickHud();
    void UpdateWeaponSelect();
    void eventWidgetInitialized();
    void UpdateRatio();
    void ClearScoreboard();
    void CreateScoreboard();
    void Init();
};

UClass* UKFGFxMoviePlayer_HUD::pClassPointer = NULL;

// Class KFGame.KFAISpawnSquad
// 0x0014 (0x0074 - 0x0060)
class UKFAISpawnSquad : public UObject {
   public:
    unsigned char MinVolumeType;  // 0x0060 (0x0001) [0x0000000000000000]
    TArray<struct FAISquadElement>
        MonsterList;  // 0x0064 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[56424];

        return pClassPointer;
    };
};

UClass* UKFAISpawnSquad::pClassPointer = NULL;

// Class KFGame.KFGameConductor
// 0x01D8 (0x0238 - 0x0060)
class UKFGameConductor : public UObject {
   public:
    float PlayersHealthStatus;        // 0x0060 (0x0004) [0x0000000000000000]
    float PlayersAmmoStatus;          // 0x0064 (0x0004) [0x0000000000000000]
    float AggregatePlayersStatus;     // 0x0068 (0x0004) [0x0000000000000000]
    float PlayersLowHealthThreshold;  // 0x006C (0x0004) [0x0000000000000000]
    float ZedVisibleAverageLifespan;  // 0x0070 (0x0004) [0x0000000000000000]
    float TotalZedVisibleLifespan;    // 0x0074 (0x0004) [0x0000000000000000]
    int TotalZedsKilled;              // 0x0078 (0x0004) [0x0000000000000000]
    float CurrentWaveZedVisibleAverageLifeSpan;  // 0x007C (0x0004)
                                                 // [0x0000000000000000]
    float CurrentWaveTotalZedVisibleLifeSpan;    // 0x0080 (0x0004)
                                                 // [0x0000000000000000]
    int CurrentWaveTotalZedsKilled;  // 0x0084 (0x0004) [0x0000000000000000]
    float RecentZedVisibleAverageLifeSpan;  // 0x0088 (0x0004)
                                            // [0x0000000000000000]
    float
        RecentTotalZedVisibleLifeSpan;  // 0x008C (0x0004) [0x0000000000000000]
    int RecentTotalZedsKilled;          // 0x0090 (0x0004) [0x0000000000000000]
    float RecentZedLifeSpanTotalTracker[0xA];  // 0x0094 (0x0028)
                                               // [0x0000000000000000]
    float
        RecentZedKillTotalTracker[0xA];  // 0x00BC (0x0028) [0x0000000000000000]
    float AggregatePlayerSkill;          // 0x00E4 (0x0004) [0x0000000000000000]
    float PlayersAverageAccuracy;        // 0x00E8 (0x0004) [0x0000000000000000]
    float
        PlayersAverageHeadshotAccuracy;  // 0x00EC (0x0004) [0x0000000000000000]
    float ParShotAccuracy;               // 0x00F0 (0x0004) [0x0000000000000000]
    float ParHeadshotAccuracy;           // 0x00F4 (0x0004) [0x0000000000000000]
    float HighlySkilledAccuracyMod;      // 0x00F8 (0x0004) [0x0000000000000000]
    float HighlySkilledAccuracyModMax;   // 0x00FC (0x0004) [0x0000000000000000]
    float LessSkilledAccuracyMod;        // 0x0100 (0x0004) [0x0000000000000000]
    float LessSkilledAccuracyModMin;     // 0x0104 (0x0004) [0x0000000000000000]
    float BaseLinePlayerShootingSkill;   // 0x0108 (0x0004) [0x0000000000000000]
    float ShootingAccuracySkillWeight;   // 0x010C (0x0004) [0x0000000000000000]
    float HeadShootingAccuracySkillWeight;  // 0x0110 (0x0004)
                                            // [0x0000000000000000]
    float ParZedLifeSpan[0x4];      // 0x0114 (0x0010) [0x0000000000000000]
    float ParZedLifeSpanSolo[0x4];  // 0x0124 (0x0010) [0x0000000000000000]
    float ZedLifeSpanHighlySkilledThreshold;     // 0x0134 (0x0004)
                                                 // [0x0000000000000000]
    float ZedLifeSpanHighlySkilledThresholdMin;  // 0x0138 (0x0004)
                                                 // [0x0000000000000000]
    float ZedLifeSpanLessSkilledThreshold;       // 0x013C (0x0004)
                                                 // [0x0000000000000000]
    float ZedLifeSpanLessSkilledThresholdMax;    // 0x0140 (0x0004)
                                                 // [0x0000000000000000]
    float OverallRankAndSkillModifier;  // 0x0144 (0x0004) [0x0000000000000000]
    float
        PerkRankPercentOfOverallSkill;  // 0x0148 (0x0004) [0x0000000000000000]
    float
        AccuracyPercentOfOverallSkill;  // 0x014C (0x0004) [0x0000000000000000]
    float ZedLifeSpanPercentOfOverallSkill;  // 0x0150 (0x0004)
                                             // [0x0000000000000000]
    unsigned char GameConductorStatus;  // 0x0154 (0x0001) [0x0000000000000000]
    float PlayerDeathForceLullLength;   // 0x0158 (0x0004) [0x0000000000000000]
    float PlayerDeathForceLullTime;     // 0x015C (0x0004) [0x0000000000000000]
    float SoloPlayerSurroundedForceLullLength;  // 0x0160 (0x0004)
                                                // [0x0000000000000000]
    float SoloPlayerSurroundedForceLullTime;    // 0x0164 (0x0004)
                                                // [0x0000000000000000]
    float AveragePlayerPerkRank;  // 0x0168 (0x0004) [0x0000000000000000]
    struct FVector2D
        TargetPerkRankRange[0x4];  // 0x016C (0x0020) [0x0000000000000000]
    float CurrentTargetPerkRank;   // 0x018C (0x0004) [0x0000000000000000]
    struct FInterpCurveFloat
        SpawnRateModificationRangeCurve[0x4];  // 0x0190 (0x0050)
                                               // [0x0000000000000000]
    float CurrentSpawnRateModification;  // 0x01E0 (0x0004) [0x0000000000000000]
    struct FVector2D
        AIMovementSpeedModificationRange[0x4];  // 0x01E4 (0x0020)
                                                // [0x0000000000000000]
    float CurrentAIMovementSpeedMod;  // 0x0204 (0x0004) [0x0000000000000000]
    float CurrentVersusZedHealthMod;  // 0x0208 (0x0004) [0x0000000000000000]
    float CurrentVersusZedDamageMod;  // 0x020C (0x0004) [0x0000000000000000]
    int AllowLowIntensityZedModeByDifficulty[0x4];  // 0x0210 (0x0010)
                                                    // [0x0000000000000000]
    TArray<struct FsLullInfo>
        LullSettings;                // 0x0220 (0x0010) [0x0000000000000000]
    float LullCooldownStartTime;     // 0x0230 (0x0004) [0x0000000000000000]
    DWORD bLogGameConductor : 1;     // 0x0234 (0x0004) [0x0000000000000000]
                                     // [0x00000001]
    DWORD bBypassGameConductor : 1;  // 0x0234 (0x0004) [0x0000000000000000]
                                     // [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[56437];

        return pClassPointer;
    };

    void Timer_EndLull();
    void WithinRange();
    void EvaluateAIMovementSpeedModification();
    void EvaluateSpawnRateModification();
    void UpdateOverallAttackCoolDowns();
    void UpdateOverallStatus();
    void GetParZedLifeSpan();
    void UpdateZedLifespanStats();
    void UpdatePlayerAccuracyStats();
    void UpdatePlayersAggregateSkill();
    void UpdatePlayersStatus();
    void TimerUpdate();
    void HandlePlayerChangedTeam();
    void UpdateAveragePerkRank();
    void ResetWaveStats();
    void NotifySoloPlayerSurrounded();
    void NotifyHumanTeamPlayerDeath();
    void HandleZedKill();
    void Initialize();
};

UClass* UKFGameConductor::pClassPointer = NULL;

// Class KFGame.KFAISpawnManager_Long
// 0x0000 (0x01C4 - 0x01C4)
class UKFAISpawnManager_Long : public UKFAISpawnManager {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[56510];

        return pClassPointer;
    };
};

UClass* UKFAISpawnManager_Long::pClassPointer = NULL;

// Class KFGame.KFAISpawnManager_Normal
// 0x0000 (0x01C4 - 0x01C4)
class UKFAISpawnManager_Normal : public UKFAISpawnManager {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[56563];

        return pClassPointer;
    };
};

UClass* UKFAISpawnManager_Normal::pClassPointer = NULL;

// Class KFGame.KFAISpawnManager_Short
// 0x0000 (0x01C4 - 0x01C4)
class UKFAISpawnManager_Short : public UKFAISpawnManager {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[56602];

        return pClassPointer;
    };
};

UClass* UKFAISpawnManager_Short::pClassPointer = NULL;

// Class KFGame.KFInterface_MinigameActor
// 0x0000 (0x0060 - 0x0060)
class UKFInterface_MinigameActor : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[56779];

        return pClassPointer;
    };

    void eventCanPlayAkEvent();
    void Deactivated();
    void Activated();
    void CanBeActivated();
};

UClass* UKFInterface_MinigameActor::pClassPointer = NULL;

// Class KFGame.KFAnimNotify_PlayDialog
// 0x0004 (0x0068 - 0x0064)
class UKFAnimNotify_PlayDialog : public UAnimNotify_Scripted {
   public:
    int DialogID;  // 0x0064 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[56847];

        return pClassPointer;
    };

    void eventNotify();
};

UClass* UKFAnimNotify_PlayDialog::pClassPointer = NULL;

// Class KFGame.KFAnimNotify_SpawnKActor
// 0x0060 (0x00C4 - 0x0064)
class UKFAnimNotify_SpawnKActor : public UAnimNotify_Scripted {
   public:
    class UStaticMesh* RigidBodyMesh;  // 0x0064 (0x0008) [0x0000000000000000]
    struct FVector MinLinearVel;       // 0x006C (0x000C) [0x0000000000000000]
    struct FVector MaxLinearVel;       // 0x0078 (0x000C) [0x0000000000000000]
    struct FVector MinAngularVel;      // 0x0084 (0x000C) [0x0000000000000000]
    struct FVector MaxAngularVel;      // 0x0090 (0x000C) [0x0000000000000000]
    struct FVector MeshTranslation;    // 0x009C (0x000C) [0x0000000000000000]
    struct FRotator MeshRotation;      // 0x00A8 (0x000C) [0x0000000000000000]
    struct FName BoneName;             // 0x00B4 (0x0008) [0x0000000000000000]
    DWORD bShouldHideBone : 1;         // 0x00BC (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bNotifyPawnOwner : 1;        // 0x00BC (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD bClientOnly : 1;  // 0x00BC (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bIgnoreEffectRelevancy : 1;  // 0x00BC (0x0004) [0x0000000000000000]
                                       // [0x00000008]
    float FirstPersonUnhideDelay;      // 0x00C0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[56854];

        return pClassPointer;
    };

    void eventNotify();
};

UClass* UKFAnimNotify_SpawnKActor::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Armor
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Armor : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[56976];

        return pClassPointer;
    };

    void GetItemLocalization();
};

UClass* UKFWeapDef_Armor::pClassPointer = NULL;

// Class KFGame.KFGFxMoviePlayer_Manager
// 0x0208 (0x03EC - 0x01E4)
class UKFGFxMoviePlayer_Manager : public UGFxMoviePlayer {
   public:
    float LastForceCloseTime;  // 0x01E4 (0x0004) [0x0000000000000000]
    float AllowMenusOpenAfterForceCloseTime;  // 0x01E8 (0x0004)
                                              // [0x0000000000000000]
    TArray<struct FSMenuPaths>
        MenuSWFPaths;  // 0x01EC (0x0010) [0x0000000000000000]
    class UKFGFxObject_Menu*
        CurrentMenu;                 // 0x01FC (0x0008) [0x0000000000000000]
    unsigned char CurrentMenuIndex;  // 0x0204 (0x0001) [0x0000000000000000]
    unsigned char StartMenuState;    // 0x0205 (0x0001) [0x0000000000000000]
    unsigned char CurrentPopUpType;  // 0x0206 (0x0001) [0x0000000000000000]
    class UKFGFxMenu_StartGame*
        StartMenu;                      // 0x0208 (0x0008) [0x0000000000000000]
    class UKFGFxMenu_Perks* PerksMenu;  // 0x0210 (0x0008) [0x0000000000000000]
    class UKFGFxMenu_Gear* GearMenu;    // 0x0218 (0x0008) [0x0000000000000000]
    class UKFGFxMenu_Inventory*
        InventoryMenu;                  // 0x0220 (0x0008) [0x0000000000000000]
    class UKFGFxMenu_Store* StoreMenu;  // 0x0228 (0x0008) [0x0000000000000000]
    class UKFGFxOptionsMenu_Controls*
        OptionsControlsMenu;  // 0x0230 (0x0008) [0x0000000000000000]
    class UKFGFxOptionsMenu_Audio*
        OptionsAudioMenu;  // 0x0238 (0x0008) [0x0000000000000000]
    class UKFGFxOptionsMenu_Graphics*
        OptionsGraphicsMenu;  // 0x0240 (0x0008) [0x0000000000000000]
    class UKFGFxOptionsMenu_GameSettings*
        OptionsGameSettingsMenu;  // 0x0248 (0x0008) [0x0000000000000000]
    class UKFGFxOptionsMenu_Selection*
        OptionsSelectionMenu;  // 0x0250 (0x0008) [0x0000000000000000]
    class UKFGFxMenu_PostGameReport*
        PostGameMenu;  // 0x0258 (0x0008) [0x0000000000000000]
    class UKFGFxMenu_Trader*
        TraderMenu;  // 0x0260 (0x0008) [0x0000000000000000]
    class UKFGFxMenu_ServerBrowser*
        ServerBrowserMenu;            // 0x0268 (0x0008) [0x0000000000000000]
    class UKFGFxMenu_Exit* ExitMenu;  // 0x0270 (0x0008) [0x0000000000000000]
    class UKFGFxMenu_IIS* IISMenu;    // 0x0278 (0x0008) [0x0000000000000000]
    class UKFGFxMoviePlayer_ScreenSize*
        ScreenSizeMovie;  // 0x0280 (0x0008) [0x0000000000000000]
    class UKFProfileSettings*
        CachedProfile;               // 0x0288 (0x0008) [0x0000000000000000]
    DWORD bPostGameState : 1;        // 0x0290 (0x0004) [0x0000000000000000]
                                     // [0x00000001]
    DWORD bKickVotePopupActive : 1;  // 0x0290 (0x0004) [0x0000000000000000]
                                     // [0x00000002]
    DWORD
        bUsingGamepad : 1;  // 0x0290 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bAfterLobby : 1;  // 0x0290 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bMenusOpen : 1;   // 0x0290 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD
        bMenusActive : 1;  // 0x0290 (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bSearchingForGame : 1;  // 0x0290 (0x0004) [0x0000000000000000]
                                  // [0x00000040]
    DWORD
        bCanCloseMenu : 1;  // 0x0290 (0x0004) [0x0000000000000000] [0x00000080]
    DWORD bPlayerInLobby : 1;  // 0x0290 (0x0004) [0x0000000000000000]
                               // [0x00000100]
    DWORD bSetGamma : 1;  // 0x0290 (0x0004) [0x0000000000000000] [0x00000200]
    class UClass*
        InGamePartyWidgetClass;  // 0x0294 (0x0008) [0x0000000000000000]
    class UTextureMovie*
        CurrentBackgroundMovie;  // 0x029C (0x0008) [0x0000000000000000]
    TArray<struct FDelayedPopup>
        DelayedPopups;  // 0x02A4 (0x0010) [0x0000000000000000]
    int ActivePopup;    // 0x02B4 (0x0004) [0x0000000000000000]
    class UKFGFxObject_Popup*
        CurrentPopup;  // 0x02B8 (0x0008) [0x0000000000000000]
    TArray<struct FSPopupData>
        PopupData;  // 0x02C0 (0x0010) [0x0000000000000000]
    struct FString
        FailedSearchTitleString;         // 0x02D0 (0x0010) [0x0000000000000000]
    struct FString FailedSearchString;   // 0x02E0 (0x0010) [0x0000000000000000]
    struct FString BrowseServersString;  // 0x02F0 (0x0010) [0x0000000000000000]
    struct FString
        HasInvitedToGameString;     // 0x0300 (0x0010) [0x0000000000000000]
    struct FString JoinGameString;  // 0x0310 (0x0010) [0x0000000000000000]
    class UKFGFxWidget_MenuBar*
        MenuBarWidget;  // 0x0320 (0x0008) [0x0000000000000000]
    class UKFGFxWidget_BaseParty*
        PartyWidget;  // 0x0328 (0x0008) [0x0000000000000000]
    class UKFGFxWidget_ButtonPrompt*
        ButtonPromptWidget;              // 0x0330 (0x0008) [0x0000000000000000]
    TArray<struct FString> WidgetPaths;  // 0x0338 (0x0010) [0x0000000000000000]
    class APlayerReplicationInfo*
        VotePRI;                        // 0x0348 (0x0008) [0x0000000000000000]
    class UTWOnlineLobby* OnlineLobby;  // 0x0350 (0x0008) [0x0000000000000000]
    struct FUniqueNetId
        CurrentInviteLobbyId;          // 0x0358 (0x0008) [0x0000000000000000]
    struct FUniqueNetId ZeroUniqueId;  // 0x0360 (0x0008) [0x0000000000000000]
    class UGFxObject* ManagerObject;   // 0x0368 (0x0008) [0x0000000000000000]
    class AKFHUDBase* HUD;             // 0x0370 (0x0008) [0x0000000000000000]
    TArray<class UTextureMovie*>
        BackgroundMovies;           // 0x0378 (0x0010) [0x0000000000000000]
    class UTextureMovie* IISMovie;  // 0x0388 (0x0008) [0x0000000000000000]
    TArray<struct FString>
        IgnoredCommands;                // 0x0390 (0x0010) [0x0000000000000000]
    struct FName SoundThemeName;        // 0x03A0 (0x0008) [0x0000000000000000]
    int MouseInputChangedThreshold;     // 0x03A8 (0x0004) [0x0000000000000000]
    class UOnlineSubsystem* OnlineSub;  // 0x03AC (0x0008) [0x0000000000000000]
    class UPlayfabInterface*
        PlayfabInter;  // 0x03B4 (0x0008) [0x0000000000000000]
    struct FScriptDelegate
        __PendingRightButtonDelegate__Delegate;  // 0x03BC (0x0010)
                                                 // [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x03C0 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __PendingMiddleButtonDelegate__Delegate;  // 0x03CC (0x0010)
                                                  // [0x0000000000000000]
    unsigned char UnknownData01[0x4];  // 0x03D0 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __PendingLeftButtonDelegate__Delegate;  // 0x03DC (0x0010)
                                                // [0x0000000000000000]
    unsigned char UnknownData02[0x4];  // 0x03E0 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[57323];

        return pClassPointer;
    };

    void currentFocus();
    void UpdateViewportSize();
    void CloseScreenSizeMovie();
    void OpenScreenSizeMovie();
    void CastNoVote();
    void CastYesVote();
    void HideKickVote();
    void ShowKickVote();
    void NotifySpectateStateChanged();
    void RemotePlayerDisconnected();
    void UpdateVOIP();
    void IsFocusIgnoreKey();
    void GetKeyBindName();
    void UpdateDynamicIgnoreKeys();
    void GetUsingGamepad();
    void OnInputTypeChanged();
    void CheckIfUsingGamepad();
    void eventFilterButtonInput();
    void ChangeOverviewState();
    void HandleSteamLobbyLeaderTakeOver();
    void UpdateMenuBar();
    void SetSearchingForMatch();
    void SetStartMenuState();
    void GetStartMenuState();
    void GetMultiplayerMenuActive();
    void IsInLobby();
    void OnLobbyStatusChanged();
    void ClientRecieveNewTeam();
    void CanUnpauseMenuClosed();
    void ConditionalPauseGame();
    void UnloadPopups();
    void LoadPopups();
    void UnloadCurrentPopup();
    void LoadPopup();
    void OpenPopup();
    void InitializePopup();
    void AssignPendingRightButtonDelegate();
    void AssignPendingMiddleButtonDelegate();
    void AssignPendingLeftButtonDelegate();
    void NotifyUnsuccessfulSearch();
    void ShowWelcomeScreen();
    void CloseTraderMenu();
    void OnRoundOver();
    void OnTraderTimeStart();
    void SetHUDVisiblity();
    void SetMenuVisibility();
    void SetWidgetsVisible();
    void eventMenusFinishedClosing();
    void PlayOpeningSound();
    void ToggleMenus();
    void eventOnCleanup();
    void eventOnClose();
    void CloseMenus();
    void ClosePostGameMenu();
    void OnMenuOpen();
    void LoadWidgets();
    void LoadMenu();
    void OpenMenu();
    void SetMenusOpen();
    void OneSecondLoop();
    void OnForceUpdate();
    void ForceUpdateNextFrame();
    void AllowCloseMenu();
    void StatsInitialized();
    void eventWidgetInitialized();
    void CheckSkipLobby();
    void ShowDelayedPopupMessage();
    void DelayedOpenPopup();
    void DelayedShowDisconnectMessage();
    void GetBackgroundMovie();
    void UpdateBackgroundMovie();
    void LaunchMenus();
    void OnProfileSettingsRead();
    void Init();
    void PendingLeftButtonDelegate();
    void PendingMiddleButtonDelegate();
    void PendingRightButtonDelegate();
};

UClass* UKFGFxMoviePlayer_Manager::pClassPointer = NULL;

// Class KFGame.KFCommon_LocalizedStrings
// 0x0260 (0x02C0 - 0x0060)
class UKFCommon_LocalizedStrings : public UObject {
   public:
    TArray<struct FString>
        DifficultyStrings;  // 0x0060 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        LengthStrings;  // 0x0070 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        ServerTypeStrings;  // 0x0080 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        PermissionStrings;  // 0x0090 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        ConsolePermissionStrings;        // 0x00A0 (0x0010) [0x0000000000000000]
    TArray<struct FString> ModeStrings;  // 0x00B0 (0x0010) [0x0000000000000000]
    struct FString TeamSwappedString;    // 0x00C0 (0x0010) [0x0000000000000000]
    struct FString NoPreferenceString;   // 0x00D0 (0x0010) [0x0000000000000000]
    struct FString OKString;             // 0x00E0 (0x0010) [0x0000000000000000]
    struct FString ConfirmString;        // 0x00F0 (0x0010) [0x0000000000000000]
    struct FString CancelString;         // 0x0100 (0x0010) [0x0000000000000000]
    struct FString BackString;           // 0x0110 (0x0010) [0x0000000000000000]
    struct FString
        PerkUpdateNoticeString;         // 0x0120 (0x0010) [0x0000000000000000]
    struct FString NoticeString;        // 0x0130 (0x0010) [0x0000000000000000]
    struct FString AcceptString;        // 0x0140 (0x0010) [0x0000000000000000]
    struct FString DeclineString;       // 0x0150 (0x0010) [0x0000000000000000]
    struct FString YesString;           // 0x0160 (0x0010) [0x0000000000000000]
    struct FString NoString;            // 0x0170 (0x0010) [0x0000000000000000]
    struct FString DisbandPartyString;  // 0x0180 (0x0010) [0x0000000000000000]
    struct FString
        LeaveCurrentMenuString;      // 0x0190 (0x0010) [0x0000000000000000]
    struct FString ZedString;        // 0x01A0 (0x0010) [0x0000000000000000]
    struct FString HumanString;      // 0x01B0 (0x0010) [0x0000000000000000]
    struct FString SpectatorString;  // 0x01C0 (0x0010) [0x0000000000000000]
    struct FString
        UnableToSwitchTeamString;  // 0x01D0 (0x0010) [0x0000000000000000]
    struct FString
        NoSwitchReasonString;      // 0x01E0 (0x0010) [0x0000000000000000]
    struct FString TeamString;     // 0x01F0 (0x0010) [0x0000000000000000]
    struct FString AllString;      // 0x0200 (0x0010) [0x0000000000000000]
    struct FString LoadingString;  // 0x0210 (0x0010) [0x0000000000000000]
    struct FString
        AutoTradeCompleteString;  // 0x0220 (0x0010) [0x0000000000000000]
    struct FString
        AutoFillCompleteString;  // 0x0230 (0x0010) [0x0000000000000000]
    struct FString
        WeaponUpgradeComepleteString;  // 0x0240 (0x0010) [0x0000000000000000]
    struct FString
        SecondaryWeaponPurchasedString;  // 0x0250 (0x0010) [0x0000000000000000]
    struct FString
        NoItemsPurchasedString;  // 0x0260 (0x0010) [0x0000000000000000]
    struct FString
        SetTakeoverServerPasswordTitle;  // 0x0270 (0x0010) [0x0000000000000000]
    struct FString
        FreeConsolePlayOverString;  // 0x0280 (0x0010) [0x0000000000000000]
    struct FString BuyGameString;   // 0x0290 (0x0010) [0x0000000000000000]
    struct FString CustomString;    // 0x02A0 (0x0010) [0x0000000000000000]
    struct FString
        CancelConnectionString;  // 0x02B0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[57360];

        return pClassPointer;
    };

    void GetFriendlyMapName();
    void GetGameModeString();
    void GetGameModeStringsArray();
    void GetPermissionStringsArray();
    void GetPermissionString();
    void GetServerTypeString();
    void GetLengthString();
    void GetLengthStringsArray();
    void GetDifficultyString();
    void GetDifficultyStringsArray();
};

UClass* UKFCommon_LocalizedStrings::pClassPointer = NULL;

// Class KFGame.KFBossCamera
// 0x006C (0x00D8 - 0x006C)
class UKFBossCamera : public UGameCameraBase {
   public:
    struct FCameraOffsets BaseOffsets;  // 0x006C (0x001C) [0x0000000000000000]
    struct FCameraOffsets
        BackupOffsets;                  // 0x0088 (0x001C) [0x0000000000000000]
    struct FCameraOffsets DeadOffsets;  // 0x00A4 (0x001C) [0x0000000000000000]
    class UPointLightComponent*
        PointLightTemplate;  // 0x00C0 (0x0008) [0x0000000000000000]
    class UPointLightComponent*
        PointLight;                     // 0x00C8 (0x0008) [0x0000000000000000]
    class AKFPawn_Monster* ViewedPawn;  // 0x00D0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[57368];

        return pClassPointer;
    };

    void GetOffsets();
    void UpdateCamera();
    void OnBecomeInActive();
    void OnBecomeActive();
};

UClass* UKFBossCamera::pClassPointer = NULL;

// Class KFGame.KFEmit_CameraEffect
// 0x0000 (0x028C - 0x028C)
class AKFEmit_CameraEffect : public AEmitterCameraLensEffectBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[57407];

        return pClassPointer;
    };
};

UClass* AKFEmit_CameraEffect::pClassPointer = NULL;

// Class KFGame.KFCameraLensEmit_BloodBase
// 0x0000 (0x028C - 0x028C)
class AKFCameraLensEmit_BloodBase : public AKFEmit_CameraEffect {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[57410];

        return pClassPointer;
    };
};

UClass* AKFCameraLensEmit_BloodBase::pClassPointer = NULL;

// Class KFGame.KFCameraLensEmit_EMP
// 0x0000 (0x028C - 0x028C)
class AKFCameraLensEmit_EMP : public AKFEmit_CameraEffect {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[57416];

        return pClassPointer;
    };
};

UClass* AKFCameraLensEmit_EMP::pClassPointer = NULL;

// Class KFGame.KFCameraLensEmit_Fire
// 0x0000 (0x028C - 0x028C)
class AKFCameraLensEmit_Fire : public AKFEmit_CameraEffect {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[57420];

        return pClassPointer;
    };

    void NotifyRetriggered();
};

UClass* AKFCameraLensEmit_Fire::pClassPointer = NULL;

// Class KFGame.KFCameraLensEmit_Puke
// 0x0000 (0x028C - 0x028C)
class AKFCameraLensEmit_Puke : public AKFEmit_CameraEffect {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[57425];

        return pClassPointer;
    };
};

UClass* AKFCameraLensEmit_Puke::pClassPointer = NULL;

// Class KFGame.KFCameraLensEmit_Puke_Light
// 0x0000 (0x028C - 0x028C)
class AKFCameraLensEmit_Puke_Light : public AKFEmit_CameraEffect {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[57429];

        return pClassPointer;
    };
};

UClass* AKFCameraLensEmit_Puke_Light::pClassPointer = NULL;

// Class KFGame.KFUnlockableAsset
// 0x0000 (0x0060 - 0x0060)
class UKFUnlockableAsset : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[57741];

        return pClassPointer;
    };

    void GetAssetId();
};

UClass* UKFUnlockableAsset::pClassPointer = NULL;

// Class KFGame.KFGibletInfo
// 0x0034 (0x0094 - 0x0060)
class UKFGibletInfo : public UObject {
   public:
    class UStaticMesh* GibStaticMesh;   // 0x0060 (0x0008) [0x0000000000000000]
    class USkeletalMesh* GibSkelMesh;   // 0x0068 (0x0008) [0x0000000000000000]
    class UPhysicsAsset* GibPhysAsset;  // 0x0070 (0x0008) [0x0000000000000000]
    int CullDistance;                   // 0x0078 (0x0004) [0x0000000000000000]
    float DrawScale;                    // 0x007C (0x0004) [0x0000000000000000]
    int GibletMaxSpeed;                 // 0x0080 (0x0004) [0x0000000000000000]
    TArray<struct FName> GibletBones;   // 0x0084 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[57793];

        return pClassPointer;
    };
};

UClass* UKFGibletInfo::pClassPointer = NULL;

// Class KFGame.KFGameExplosion
// 0x0014 (0x0168 - 0x0154)
class UKFGameExplosion : public UGameExplosion {
   public:
    class UClass* ShardClass;  // 0x0154 (0x0008) [0x0000000000000000]
    int NumShards;             // 0x015C (0x0004) [0x0000000000000000]
    class UKFImpactEffectInfo*
        ExplosionEffects;  // 0x0160 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[59048];

        return pClassPointer;
    };
};

UClass* UKFGameExplosion::pClassPointer = NULL;

// Class KFGame.KFDT_Sonic
// 0x0000 (0x0164 - 0x0164)
class UKFDT_Sonic : public UKFDamageType {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[59066];

        return pClassPointer;
    };

    void GetDamageeDialogID();
};

UClass* UKFDT_Sonic::pClassPointer = NULL;

// Class KFGame.KFDebugFlare
// 0x0008 (0x024C - 0x0244)
class AKFDebugFlare : public AActor {
   public:
    class UPointLightComponent*
        FlareLight;  // 0x0244 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[59089];

        return pClassPointer;
    };
};

UClass* AKFDebugFlare::pClassPointer = NULL;

// Class KFGame.KFWeap_ScopedBase
// 0x0038 (0x08F8 - 0x08C0)
class AKFWeap_ScopedBase : public AKFWeapon {
   public:
    class UTWSceneCapture2DDPGComponent*
        SceneCapture;              // 0x08C0 (0x0008) [0x0000000000000000]
    float ScopeTextureScale;       // 0x08C8 (0x0004) [0x0000000000000000]
    int MaxSceneCaptureSize;       // 0x08CC (0x0004) [0x0000000000000000]
    struct FName InterpParamName;  // 0x08D0 (0x0008) [0x0000000000000000]
    class UTextureRenderTarget2D*
        SniperScopeTextureTarget;  // 0x08D8 (0x0008) [0x0000000000000000]
    class UMaterialInstanceConstant*
        ScopeLenseMICTemplate;  // 0x08E0 (0x0008) [0x0000000000000000]
    class UMaterialInstanceConstant*
        ScopeLenseMIC;            // 0x08E8 (0x0008) [0x0000000000000000]
    int CurrentScopeTextureSize;  // 0x08F0 (0x0004) [0x0000000000000000]
    float ScopedSensitivityMod;   // 0x08F4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[59112];

        return pClassPointer;
    };

    void ZoomOutFastFinished();
    void ZoomOut();
    void ZoomIn();
    void eventOnZoomOutFinished();
    void eventOnZoomInFinished();
    void eventTick();
    void DetachWeapon();
    void AttachWeaponTo();
    void GetModifiedFOVAngle();
    void eventSetPosition();
    void ClientWeaponSet();
    void InitFOV();
    void ProcessInstantHitEx();
    void eventGetTraderFilter();
    void ScopeFOV();
};

UClass* AKFWeap_ScopedBase::pClassPointer = NULL;

// Class KFGame.KFWeapAttach_SprayBase
// 0x0078 (0x0460 - 0x03E8)
class AKFWeapAttach_SprayBase : public AKFWeaponAttachment {
   public:
    DWORD
        bFireSpraying : 1;  // 0x03E8 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD
        bPilotLightOn : 1;  // 0x03E8 (0x0004) [0x0000000000000000] [0x00000002]
    int NextFlamePoolIdx;   // 0x03EC (0x0004) [0x0000000000000000]
    class AKFSprayActor*
        FlamePool[0x2];  // 0x03F0 (0x0010) [0x0000000000000000]
    class AKFSprayActor*
        ActiveFlameSpray;  // 0x0400 (0x0008) [0x0000000000000000]
    class AKFSprayActor*
        FlameSprayArchetype;  // 0x0408 (0x0008) [0x0000000000000000]
    class UAkEvent*
        PilotLightPlayEvent;  // 0x0410 (0x0008) [0x0000000000000000]
    class UAkEvent*
        PilotLightStopEvent;  // 0x0418 (0x0008) [0x0000000000000000]
    class UKFParticleSystemComponent*
        PSC_PilotLight;                 // 0x0420 (0x0008) [0x0000000000000000]
    struct FName PilotLightSocketName;  // 0x0428 (0x0008) [0x0000000000000000]
    class UKFExplosionLight*
        PilotLightTemplate;  // 0x0430 (0x0008) [0x0000000000000000]
    class UKFExplosionLightComponent*
        PilotLightComponent;  // 0x0438 (0x0008) [0x0000000000000000]
    class UParticleSystemComponent*
        PSC_EndSpray;      // 0x0440 (0x0008) [0x0000000000000000]
    float BarrelHeat;      // 0x0448 (0x0004) [0x0000000000000000]
    float LastBarrelHeat;  // 0x044C (0x0004) [0x0000000000000000]
    TArray<struct AKFWeapAttach_SprayBase_FPilotLight>
        PilotLights;  // 0x0450 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[59115];

        return pClassPointer;
    };

    void eventTick();
    void GetFlickerVal();
    void Destroyed();
    void DetachFrom();
    void AttachTo();
    void StopThirdPersonFireEffects();
    void ThirdPersonFireEffects();
    void TurnOffFireSpray();
    void TurnOnFireSpray();
    void SetPilotDynamicLightEnabled();
    void StopPilotSound();
    void StartPilotSound();
    void GetFlameSprayFromPool();
    void TurnOffPilot();
    void GetFlameSocketLocAndRot();
    void TurnOnPilot();
    void eventPreBeginPlay();
    void SetFlameDebugFX();
    void SetFlameDebugDamage();
};

UClass* AKFWeapAttach_SprayBase::pClassPointer = NULL;

// Class KFGame.KFWeap_FlameBase
// 0x006A (0x092A - 0x08C0)
class AKFWeap_FlameBase : public AKFWeapon {
   public:
    DWORD
        bFireSpraying : 1;  // 0x08C0 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD
        bPilotLightOn : 1;  // 0x08C0 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bWarnAIWhenFiring : 1;       // 0x08C0 (0x0004) [0x0000000000000000]
                                       // [0x00000004]
    DWORD bArePilotLightsAllowed : 1;  // 0x08C0 (0x0004) [0x0000000000000000]
                                       // [0x00000008]
    int NextFlamePoolIdx;              // 0x08C4 (0x0004) [0x0000000000000000]
    class AKFSprayActor*
        FlamePool[0x2];  // 0x08C8 (0x0010) [0x0000000000000000]
    class AKFSprayActor*
        ActiveFlameSpray;  // 0x08D8 (0x0008) [0x0000000000000000]
    class AKFSprayActor*
        FlameSprayArchetype;  // 0x08E0 (0x0008) [0x0000000000000000]
    class UAkEvent*
        PilotLightPlayEvent;  // 0x08E8 (0x0008) [0x0000000000000000]
    class UAkEvent*
        PilotLightStopEvent;  // 0x08F0 (0x0008) [0x0000000000000000]
    class UKFParticleSystemComponent*
        PSC_PilotLight;                 // 0x08F8 (0x0008) [0x0000000000000000]
    struct FName PilotLightSocketName;  // 0x0900 (0x0008) [0x0000000000000000]
    float BarrelHeat;                   // 0x0908 (0x0004) [0x0000000000000000]
    float LastBarrelHeat;               // 0x090C (0x0004) [0x0000000000000000]
    TArray<struct AKFWeap_FlameBase_FPilotLight>
        PilotLights;  // 0x0910 (0x0010) [0x0000000000000000]
    class UKFParticleSystemComponent*
        PSC_EndSpray;               // 0x0920 (0x0008) [0x0000000000000000]
    unsigned char MinAmmoConsumed;  // 0x0928 (0x0001) [0x0000000000000000]
    unsigned char AmmoConsumed;     // 0x0929 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[59116];

        return pClassPointer;
    };

    void eventGetTraderFilter();
    void CalculateTraderWeaponStatDamage();
    void eventSetFOV();
    void ChangeVisibility();
    void CustomFire();
    void DetachWeapon();
    void Timer_CheckForAIWarning();
    void TurnOffFireSpray();
    void TurnOnFireSpray();
    void GetFlameSprayFromPool();
    void GetFlickerVal();
    void StopLoopingFireEffects();
    void StartLoopingFireEffects();
    void StopPilotSound();
    void StartPilotSound();
    void SetPilotDynamicLightEnabled();
    void TurnOffPilot();
    void GetFlameSocketLocAndRot();
    void TurnOnPilot();
    void Destroyed();
    void eventTick();
    void SetFlameDebugFX();
    void SetFlameDebugDamage();
    void SetFlameComplex();
};

UClass* AKFWeap_FlameBase::pClassPointer = NULL;

// Class KFGame.KFMapSummary
// 0x0001 (0x00D5 - 0x00D4)
class UKFMapSummary : public UUIMapSummary {
   public:
    unsigned char MapAssociation;  // 0x00D4 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[59206];

        return pClassPointer;
    };
};

UClass* UKFMapSummary::pClassPointer = NULL;

// Class KFGame.KFCustomizationCamera
// 0x0044 (0x00B0 - 0x006C)
class UKFCustomizationCamera : public UGameCameraBase {
   public:
    DWORD bInitialize : 1;  // 0x006C (0x0004) [0x0000000000000000] [0x00000001]
    unsigned char BodyViewIndex;     // 0x0070 (0x0001) [0x0000000000000000]
    unsigned char CurrentViewIndex;  // 0x0071 (0x0001) [0x0000000000000000]
    struct FVector CharacterOffset;  // 0x0074 (0x000C) [0x0000000000000000]
    struct FVector HeadOffset;       // 0x0080 (0x000C) [0x0000000000000000]
    float CharacterDistance;         // 0x008C (0x0004) [0x0000000000000000]
    float HeadDistance;              // 0x0090 (0x0004) [0x0000000000000000]
    int RotationOffset;              // 0x0094 (0x0004) [0x0000000000000000]
    int RotationRate;                // 0x0098 (0x0004) [0x0000000000000000]
    int MaxRotationRate;             // 0x009C (0x0004) [0x0000000000000000]
    int LastRotation;                // 0x00A0 (0x0004) [0x0000000000000000]
    float FadeRotationStartTime;     // 0x00A4 (0x0004) [0x0000000000000000]
    float FadeRotationDuration;      // 0x00A8 (0x0004) [0x0000000000000000]
    float FadeRotationScaler;        // 0x00AC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[59273];

        return pClassPointer;
    };

    void OnBecomeInActive();
    void FadeCameraRotation();
    void StartFadeRotation();
    void UpdateRotation();
    void RotatedCamera();
    void SetCustomizationView();
    void BlendCustomizationPart();
    void SetBodyView();
    void UpdateCamera();
    void OnBecomeActive();
};

UClass* UKFCustomizationCamera::pClassPointer = NULL;

// Class KFGame.KFCustomizationPoint
// 0x0000 (0x037C - 0x037C)
class AKFCustomizationPoint : public ANavigationPoint {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[59323];

        return pClassPointer;
    };

    void eventPreBeginPlay();
};

UClass* AKFCustomizationPoint::pClassPointer = NULL;

// Class KFGame.KFDebugCameraInput
// 0x0000 (0x02C0 - 0x02C0)
class UKFDebugCameraInput : public UPlayerInput {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[59492];

        return pClassPointer;
    };

    void InputKey();
};

UClass* UKFDebugCameraInput::pClassPointer = NULL;

// Class KFGame.KFInterface_MapObjective
// 0x0000 (0x0060 - 0x0060)
class UKFInterface_MapObjective : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[59768];

        return pClassPointer;
    };

    void GetIcon();
    void GetIconLocation();
    void GetProgress();
    void CanActivateObjective();
    void DeactivateObjective();
    void ActivateObjective();
};

UClass* UKFInterface_MapObjective::pClassPointer = NULL;

// Class KFGame.KFGFxObject_Popup
// 0x0038 (0x00D8 - 0x00A0)
class UKFGFxObject_Popup : public UGFxObject {
   public:
    class UKFGFxMoviePlayer_Manager*
        Manager;  // 0x00A0 (0x0008) [0x0000000000000000]
    struct FScriptDelegate
        __LeftButtonPress__Delegate;   // 0x00A8 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x00AC (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __MiddleButtonPress__Delegate;  // 0x00B8 (0x0010) [0x0000000000000000]
    unsigned char UnknownData01[0x4];  // 0x00BC (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __RightButtonPress__Delegate;  // 0x00C8 (0x0010) [0x0000000000000000]
    unsigned char UnknownData02[0x4];  // 0x00CC (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[61339];

        return pClassPointer;
    };

    void InitializePopup();
    void OnClosed();
    void UpdateDescritionText();
    void ClearDelegates();
    void AssignRightButtonDelegate();
    void AssignMiddleButtonDelegate();
    void AssignLeftButtonDelegate();
    void RightButtonPress();
    void MiddleButtonPress();
    void LeftButtonPress();
    void ClosePopUp();
    void Callback_ClosedPopup();
};

UClass* UKFGFxObject_Popup::pClassPointer = NULL;

// Class KFGame.KFGFxPopup_InputPrompt
// 0x0030 (0x0108 - 0x00D8)
class UKFGFxPopup_InputPrompt : public UKFGFxObject_Popup {
   public:
    struct FString ConfirmButtonString;  // 0x00D8 (0x0010) [0x0000000000000000]
    struct FString DeclineButtonString;  // 0x00E8 (0x0010) [0x0000000000000000]
    struct FString PlayerInputString;    // 0x00F8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[61338];

        return pClassPointer;
    };

    void Callback_ClosedPopup();
    void Callback_ClickedConfirm();
    void ClearDelegates();
    void AssignRightButtonDelegate();
    void AssignLeftButtonDelegate();
};

UClass* UKFGFxPopup_InputPrompt::pClassPointer = NULL;

// Class KFGame.KFLocalMessage_VoiceComms
// 0x0010 (0x02A8 - 0x0298)
class UKFLocalMessage_VoiceComms : public UKFLocalMessage {
   public:
    TArray<struct FString>
        VoiceCommsOptionStrings;  // 0x0298 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[61351];

        return pClassPointer;
    };

    void GetHexColor();
    void GetString();
};

UClass* UKFLocalMessage_VoiceComms::pClassPointer = NULL;

// Class KFGame.KFLocalMessage_Interaction
// 0x0150 (0x03E8 - 0x0298)
class UKFLocalMessage_Interaction : public UKFLocalMessage {
   public:
    struct FString UseTraderMessage;    // 0x0298 (0x0010) [0x0000000000000000]
    struct FString UseDoorMessage;      // 0x02A8 (0x0010) [0x0000000000000000]
    struct FString EquipWelderMessage;  // 0x02B8 (0x0010) [0x0000000000000000]
    struct FString RepairDoorMessage;   // 0x02C8 (0x0010) [0x0000000000000000]
    struct FString
        AcceptObjectiveMessage;         // 0x02D8 (0x0010) [0x0000000000000000]
    struct FString ReceiveAmmoMessage;  // 0x02E8 (0x0010) [0x0000000000000000]
    struct FString
        ReceiveGrenadesMessage;      // 0x02F8 (0x0010) [0x0000000000000000]
    struct FString HealSelfWarning;  // 0x0308 (0x0010) [0x0000000000000000]
    struct FString
        HealSelfGamepadWarning;         // 0x0318 (0x0010) [0x0000000000000000]
    struct FString PressToBashWarning;  // 0x0328 (0x0010) [0x0000000000000000]
    struct FString
        GamepadWeaponSelectHint;       // 0x0338 (0x0010) [0x0000000000000000]
    struct FString ZedUseDoorMessage;  // 0x0348 (0x0010) [0x0000000000000000]
    struct FString
        ZedUseDoorWeldedMessage;  // 0x0358 (0x0010) [0x0000000000000000]
    struct FString
        PlayerClotGrabWarningMessage;   // 0x0368 (0x0010) [0x0000000000000000]
    struct FString UseMinigameMessage;  // 0x0378 (0x0010) [0x0000000000000000]
    struct FString
        UseMinigameGeneratorMessage;  // 0x0388 (0x0010) [0x0000000000000000]
    struct FString USE_COMMAND;       // 0x0398 (0x0010) [0x0000000000000000]
    struct FString HEAL_COMMAND;      // 0x03A8 (0x0010) [0x0000000000000000]
    struct FString
        HEAL_COMMAND_CONTROLLER;  // 0x03B8 (0x0010) [0x0000000000000000]
    struct FString BASH_COMMAND;  // 0x03C8 (0x0010) [0x0000000000000000]
    struct FString
        WEAPON_SELECT_CONTROLLER;  // 0x03D8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[61353];

        return pClassPointer;
    };

    void GetHexColor();
    void GetPos();
    void GetString();
    void GetKeyBind();
    void GetMessageDuration();
    void ClientReceive();
};

UClass* UKFLocalMessage_Interaction::pClassPointer = NULL;

// Class KFGame.KFGFxHudWrapper
// 0x0018 (0x0688 - 0x0670)
class AKFGFxHudWrapper : public AKFHUDBase {
   public:
    class UClass* HUDClass;  // 0x0670 (0x0008) [0x0000000000000000]
    class UKFGFxMoviePlayer_HUD*
        HudMovie;                     // 0x0678 (0x0008) [0x0000000000000000]
    class AKFPawn_Monster* BossPawn;  // 0x0680 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[61365];

        return pClassPointer;
    };

    void LocalizedMessage();
    void PlayerOwnerDied();
    void eventDrawHUD();
    void SetShowScores();
    void eventPostRender();
    void ResolutionChanged();
    void SetVisible();
    void GetLocalPlayerOwnerIndex();
    void RemoveMovies();
    void eventDestroyed();
    void CreateHUDMovie();
};

UClass* AKFGFxHudWrapper::pClassPointer = NULL;

// Class KFGame.KFOnlineStatsReadDingo
// 0x0000 (0x00D8 - 0x00D8)
class UKFOnlineStatsReadDingo : public UKFOnlineStatsRead {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[61433];

        return pClassPointer;
    };
};

UClass* UKFOnlineStatsReadDingo::pClassPointer = NULL;

// Class KFGame.KFOnlineStatsWriteDingo
// 0x0000 (0x0234 - 0x0234)
class UKFOnlineStatsWriteDingo : public UKFOnlineStatsWrite {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[61434];

        return pClassPointer;
    };
};

UClass* UKFOnlineStatsWriteDingo::pClassPointer = NULL;

// Class KFGame.KFGFxHUD_WaveInfo
// 0x0050 (0x00F0 - 0x00A0)
class UKFGFxHUD_WaveInfo : public UGFxObject {
   public:
    class AKFGameReplicationInfo*
        KFGRI;                       // 0x00A0 (0x0008) [0x0000000000000000]
    int LastWaveMax;                 // 0x00A8 (0x0004) [0x0000000000000000]
    int LastZEDCount;                // 0x00AC (0x0004) [0x0000000000000000]
    int LastWave;                    // 0x00B0 (0x0004) [0x0000000000000000]
    int LastTraderTimeRemaining;     // 0x00B4 (0x0004) [0x0000000000000000]
    struct FString WaveString;       // 0x00B8 (0x0010) [0x0000000000000000]
    struct FString BossWaveString;   // 0x00C8 (0x0010) [0x0000000000000000]
    struct FString FinalWaveString;  // 0x00D8 (0x0010) [0x0000000000000000]
    class UKFGFxHUD_ObjectiveConatiner*
        ObjectiveContainer;  // 0x00E8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[61444];

        return pClassPointer;
    };

    void UpdateTraderTimeRemaining();
    void UpdateZEDCount();
    void UpdateWaveCount();
    void TickHud();
    void InitializeHUD();
};

UClass* UKFGFxHUD_WaveInfo::pClassPointer = NULL;

// Class KFGame.KFGFxHUD_WeaponSelectWidget
// 0x0065 (0x0105 - 0x00A0)
class UKFGFxHUD_WeaponSelectWidget : public UGFxObject {
   public:
    DWORD bChangingWeapons : 1;         // 0x00A0 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    struct FString PrimaryString;       // 0x00A4 (0x0010) [0x0000000000000000]
    struct FString EquiptmentString;    // 0x00B4 (0x0010) [0x0000000000000000]
    struct FString MeleeString;         // 0x00C4 (0x0010) [0x0000000000000000]
    struct FString SecondaryString;     // 0x00D4 (0x0010) [0x0000000000000000]
    struct FString ThrowString;         // 0x00E4 (0x0010) [0x0000000000000000]
    struct FString ThrowGBA;            // 0x00F4 (0x0010) [0x0000000000000000]
    unsigned char LastRefreshInvCount;  // 0x0104 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[61458];

        return pClassPointer;
    };

    void FadeOut();
    void SetWeaponSwitchStayOpen();
    void RefreshTimer();
    void ShowAllHUDGroups();
    void ShowOnlyHUDGroup();
    void SendWeaponIndex();
    void SetWeaponCategories();
    void Hide();
    void UpdateIndex();
    void GetSelectedWeapon();
    void SetSelectedWeapon();
    void SetWeaponList();
    void SetWeaponGroupList();
    void UpdateWeaponGroupOnHUD();
    void SetThowButton();
    void RefreshWeaponSelect();
    void InitializeObject();
};

UClass* UKFGFxHUD_WeaponSelectWidget::pClassPointer = NULL;

// Class KFGame.KFGFxWidget_VoiceComms
// 0x0038 (0x00D8 - 0x00A0)
class UKFGFxWidget_VoiceComms : public UGFxObject {
   public:
    DWORD bPlayedVoiceComm : 1;  // 0x00A0 (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    DWORD bActive : 1;  // 0x00A0 (0x0004) [0x0000000000000000] [0x00000002]
    struct FVector RawJoyVector;       // 0x00A4 (0x000C) [0x0000000000000000]
    class APlayerController* PC;       // 0x00B0 (0x0008) [0x0000000000000000]
    TArray<struct FString> IconPaths;  // 0x00B8 (0x0010) [0x0000000000000000]
    float MouseDampening;              // 0x00C8 (0x0004) [0x0000000000000000]
    float ControllerDampening;         // 0x00CC (0x0004) [0x0000000000000000]
    int SavedSelectionIndex;           // 0x00D0 (0x0004) [0x0000000000000000]
    float DeselectTime;                // 0x00D4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[61461];

        return pClassPointer;
    };

    void UpdateUICursorPosition();
    void UpdateJoystickDirection();
    void OnAxisModified();
    void SayVoiceCommms();
    void HandleInputChange();
    void UpdateGFxEmoteState();
    void UpdateEmoteState();
    void DisableComm();
    void EnableComm();
    void SaveVoiceCommSelection();
    void SetLocalizedText();
    void InitializeHUD();
};

UClass* UKFGFxWidget_VoiceComms::pClassPointer = NULL;

// Class KFGame.KFGFxWidget_BaseParty
// 0x057C (0x0624 - 0x00A8)
class UKFGFxWidget_BaseParty : public UKFGFxObject_Container {
   public:
    struct FString ReadyString;         // 0x00A8 (0x0010) [0x0000000000000000]
    struct FString LeaveString;         // 0x00B8 (0x0010) [0x0000000000000000]
    struct FString DefaultPlayerName;   // 0x00C8 (0x0010) [0x0000000000000000]
    struct FString SquadString;         // 0x00D8 (0x0010) [0x0000000000000000]
    struct FString SoloString;          // 0x00E8 (0x0010) [0x0000000000000000]
    struct FString CreatePartyString;   // 0x00F8 (0x0010) [0x0000000000000000]
    struct FString WaitingString;       // 0x0108 (0x0010) [0x0000000000000000]
    struct FString DeployingString;     // 0x0118 (0x0010) [0x0000000000000000]
    struct FString PlayerReadyString;   // 0x0128 (0x0010) [0x0000000000000000]
    struct FString PartyLeaderString;   // 0x0138 (0x0010) [0x0000000000000000]
    struct FString MuteString;          // 0x0148 (0x0010) [0x0000000000000000]
    struct FString UnmuteString;        // 0x0158 (0x0010) [0x0000000000000000]
    struct FString AddFriendString;     // 0x0168 (0x0010) [0x0000000000000000]
    struct FString RemoveFriendString;  // 0x0178 (0x0010) [0x0000000000000000]
    struct FString ViewProfileString;   // 0x0188 (0x0010) [0x0000000000000000]
    struct FString VoteKickString;      // 0x0198 (0x0010) [0x0000000000000000]
    struct FString PartyLeaderSearchingForMatchString;  // 0x01A8 (0x0010)
                                                        // [0x0000000000000000]
    struct FString
        PartyLeaderIsUpdatingMatchOptionsString;      // 0x01B8 (0x0010)
                                                      // [0x0000000000000000]
    struct FString PartyLeaderInServerBrowserString;  // 0x01C8 (0x0010)
                                                      // [0x0000000000000000]
    struct FString
        PartyLeaderInOtherMenuString;  // 0x01D8 (0x0010) [0x0000000000000000]
    struct FString
        SearchingForGameString;         // 0x01E8 (0x0010) [0x0000000000000000]
    struct FString PartHostLeftString;  // 0x01F8 (0x0010) [0x0000000000000000]
    struct FString
        PartyLeaderChangedString;       // 0x0208 (0x0010) [0x0000000000000000]
    struct FString DownloadingString;   // 0x0218 (0x0010) [0x0000000000000000]
    struct FString RemainingString;     // 0x0228 (0x0010) [0x0000000000000000]
    struct FString MatchOverString;     // 0x0238 (0x0010) [0x0000000000000000]
    class UOnlineSubsystem* OnlineSub;  // 0x0248 (0x0008) [0x0000000000000000]
    class UTWOnlineLobby* OnlineLobby;  // 0x0250 (0x0008) [0x0000000000000000]
    DWORD bInLobby : 1;  // 0x0258 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bReadyButtonVisible : 1;    // 0x0258 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bCreatePartyVisible : 1;    // 0x0258 (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    class AKFPlayerController* KFPC;  // 0x025C (0x0008) [0x0000000000000000]
    class UKFGFxHUD_ChatBoxWidget*
        PartyChatWidget;               // 0x0264 (0x0008) [0x0000000000000000]
    struct FString PerkPrefix;         // 0x026C (0x0010) [0x0000000000000000]
    struct FString SearchingPrefix;    // 0x027C (0x0010) [0x0000000000000000]
    struct FString ServerBrowserOpen;  // 0x028C (0x0010) [0x0000000000000000]
    struct FString SearchingForGame;   // 0x029C (0x0010) [0x0000000000000000]
    struct FString UpdatingOptions;    // 0x02AC (0x0010) [0x0000000000000000]
    struct FString InOtherMenu;        // 0x02BC (0x0010) [0x0000000000000000]
    struct FString ViewProfileKey;     // 0x02CC (0x0010) [0x0000000000000000]
    struct FString AddFriendKey;       // 0x02DC (0x0010) [0x0000000000000000]
    struct FString KickKey;            // 0x02EC (0x0010) [0x0000000000000000]
    struct FString MuteKey;            // 0x02FC (0x0010) [0x0000000000000000]
    int OccupiedSlots;                 // 0x030C (0x0004) [0x0000000000000000]
    struct FUniqueNetId LastLeaderID;  // 0x0310 (0x0008) [0x0000000000000000]
    class UKFGFxMoviePlayer_Manager*
        Manager;                    // 0x0318 (0x0008) [0x0000000000000000]
    class UGFxObject* ReadyButton;  // 0x0320 (0x0008) [0x0000000000000000]
    class UGFxObject* LeaveButton;  // 0x0328 (0x0008) [0x0000000000000000]
    class UGFxObject*
        CreatePartyButton;             // 0x0330 (0x0008) [0x0000000000000000]
    class UGFxObject* SquadHeader;     // 0x0338 (0x0008) [0x0000000000000000]
    class UGFxObject* Notification;    // 0x0340 (0x0008) [0x0000000000000000]
    int PlayerSlots;                   // 0x0348 (0x0004) [0x0000000000000000]
    struct FUniqueNetId ZeroUniqueId;  // 0x034C (0x0008) [0x0000000000000000]
    struct FSMemberSlot
        MemberSlots[0xC];  // 0x0354 (0x02D0) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[61470];

        return pClassPointer;
    };

    void StopCountdown();
    void StartCountdown();
    void SendSearching();
    void UpdateSearching();
    void UpdatePerks();
    void UpdateLock();
    void ReceiveMessage();
    void SetReadyButtonVisibility();
    void OpenPlayerList();
    void RefreshParty();
    void UpdateVOIP();
    void KickPlayer();
    void RemoveFriend();
    void AddFriend();
    void ViewProfile();
    void ToggelMuteOnPlayer();
    void IsPlayerAFriend();
    void ProfileOptionClicked();
    void UpdateSoloSquadText();
    void UpdateInLobby();
    void AddStringOptionToList();
    void CreatePlayerOptions();
    void isUserYourFriend();
    void InitializeMemberSlot();
    void SetSearchingText();
    void ShowDownLoadNotification();
    void InitNotificationUI();
    void LocalizeText();
    void InitializeWidget();
};

UClass* UKFGFxWidget_BaseParty::pClassPointer = NULL;

// Class KFGame.KFGFxMoviePlayer_ScoreBoard
// 0x0028 (0x020C - 0x01E4)
class UKFGFxMoviePlayer_ScoreBoard : public UGFxMoviePlayer {
   public:
    class UKFGFxHUD_ScoreboardWidget*
        ScoreboardWidget;  // 0x01E4 (0x0008) [0x0000000000000000]
    class UKFGFxHUD_ScoreboardVersusWidget*
        ZEDScoreboardWidget;             // 0x01EC (0x0008) [0x0000000000000000]
    float UpdateInterval;                // 0x01F4 (0x0004) [0x0000000000000000]
    float LastUpdateTime;                // 0x01F8 (0x0004) [0x0000000000000000]
    class USwfMovie* MovieInfoStandard;  // 0x01FC (0x0008) [0x0000000000000000]
    class USwfMovie* MovieInfoVersus;    // 0x0204 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[61483];

        return pClassPointer;
    };

    void UpdateWaveCount();
    void ShowScoreboard();
    void TickHud();
    void eventWidgetInitialized();
    void GetMovieInfo();
    void Init();
};

UClass* UKFGFxMoviePlayer_ScoreBoard::pClassPointer = NULL;

// Class KFGame.KFInterface_Usable
// 0x0000 (0x0060 - 0x0060)
class UKFInterface_Usable : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[61573];

        return pClassPointer;
    };

    void GetInteractionIndex();
    void GetIsUsable();
};

UClass* UKFInterface_Usable::pClassPointer = NULL;

// Class KFGame.KFLocalMessage_Game
// 0x0280 (0x0518 - 0x0298)
class UKFLocalMessage_Game : public UKFLocalMessage {
   public:
    struct FString
        ReceivedAmmoFromMessage;       // 0x0298 (0x0010) [0x0000000000000000]
    struct FString GaveAmmoToMessage;  // 0x02A8 (0x0010) [0x0000000000000000]
    struct FString HealedByMessage;    // 0x02B8 (0x0010) [0x0000000000000000]
    struct FString HealedMessage;      // 0x02C8 (0x0010) [0x0000000000000000]
    struct FString
        PickedupArmorMessage;          // 0x02D8 (0x0010) [0x0000000000000000]
    struct FString FullArmorMessage;   // 0x02E8 (0x0010) [0x0000000000000000]
    struct FString PickupAmmoMessage;  // 0x02F8 (0x0010) [0x0000000000000000]
    struct FString AmmoFullMessage;    // 0x0308 (0x0010) [0x0000000000000000]
    struct FString
        AlreadyCarryingWeaponMessage;  // 0x0318 (0x0010) [0x0000000000000000]
    struct FString
        PickupWeaponAmmoMessage;   // 0x0328 (0x0010) [0x0000000000000000]
    struct FString PickupMessage;  // 0x0338 (0x0010) [0x0000000000000000]
    struct FString
        TooMuchWeightMessage;  // 0x0348 (0x0010) [0x0000000000000000]
    struct FString
        ReceivedGrenadesFromMessage;  // 0x0358 (0x0010) [0x0000000000000000]
    struct FString
        GaveGrenadesToMessage;      // 0x0368 (0x0010) [0x0000000000000000]
    struct FString YourselfString;  // 0x0378 (0x0010) [0x0000000000000000]
    struct FString
        FailedDropInventoryMessage;  // 0x0388 (0x0010) [0x0000000000000000]
    struct FString
        PendingPerkChangesSet;  // 0x0398 (0x0010) [0x0000000000000000]
    struct FString
        PendingPerkChangesApplied;  // 0x03A8 (0x0010) [0x0000000000000000]
    struct FString KilledMessage;   // 0x03B8 (0x0010) [0x0000000000000000]
    struct FString SuicideMessage;  // 0x03C8 (0x0010) [0x0000000000000000]
    struct FString
        KillzedBy_PatriarchString;  // 0x03D8 (0x0010) [0x0000000000000000]
    struct FString
        KillzedBy_HansString;  // 0x03E8 (0x0010) [0x0000000000000000]
    struct FString
        KillzedBy_ZedCrawlerString;  // 0x03F8 (0x0010) [0x0000000000000000]
    struct FString
        KillzedBy_ZedBloatString;  // 0x0408 (0x0010) [0x0000000000000000]
    struct FString
        KillzedBy_ZedFleshpoundString;  // 0x0418 (0x0010) [0x0000000000000000]
    struct FString
        KillzedBy_ZedGorefastString;  // 0x0428 (0x0010) [0x0000000000000000]
    struct FString
        KillzedBy_ZedHuskString;  // 0x0438 (0x0010) [0x0000000000000000]
    struct FString
        KillzedBy_ZedScrakeString;  // 0x0448 (0x0010) [0x0000000000000000]
    struct FString
        KillzedBy_ZedSirenString;  // 0x0458 (0x0010) [0x0000000000000000]
    struct FString
        KillzedBy_ZedStalkerString;  // 0x0468 (0x0010) [0x0000000000000000]
    struct FString
        KillzedBy_ZedClot_CystString;  // 0x0478 (0x0010) [0x0000000000000000]
    struct FString
        KillzedBy_ZedClot_AlphaString;  // 0x0488 (0x0010) [0x0000000000000000]
    struct FString KillzedBy_ZedClot_SlasherString;  // 0x0498 (0x0010)
                                                     // [0x0000000000000000]
    struct FString
        FoundAMapCollectibleMessage;  // 0x04A8 (0x0010) [0x0000000000000000]
    struct FString
        FoundAllMapCollectiblesMessage;  // 0x04B8 (0x0010) [0x0000000000000000]
    struct FString MapCollectibleName;   // 0x04C8 (0x0010) [0x0000000000000000]
    struct FString
        SharingContentString;            // 0x04D8 (0x0010) [0x0000000000000000]
    struct FString HeadShotAddedString;  // 0x04E8 (0x0010) [0x0000000000000000]
    struct FString HeadShotMaxString;    // 0x04F8 (0x0010) [0x0000000000000000]
    struct FString HeadShotResetString;  // 0x0508 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[61576];

        return pClassPointer;
    };

    void GetPos();
    void GetKilledByZedMessage();
    void GetString();
    void GetHexColor();
};

UClass* UKFLocalMessage_Game::pClassPointer = NULL;

// Class KFGame.KFMusicStingerHelper
// 0x0078 (0x00D8 - 0x0060)
class UKFMusicStingerHelper : public UObject {
   public:
    class UAkEvent* RoundWonStinger;   // 0x0060 (0x0008) [0x0000000000000000]
    class UAkEvent* RoundLostStinger;  // 0x0068 (0x0008) [0x0000000000000000]
    class UAkEvent* MatchWonStinger;   // 0x0070 (0x0008) [0x0000000000000000]
    class UAkEvent* MatchLostStinger;  // 0x0078 (0x0008) [0x0000000000000000]
    class UAkEvent* WaveStartStinger;  // 0x0080 (0x0008) [0x0000000000000000]
    class UAkEvent*
        WaveCompletedStinger;  // 0x0088 (0x0008) [0x0000000000000000]
    class UAkEvent*
        ObjectiveWonStinger;  // 0x0090 (0x0008) [0x0000000000000000]
    class UAkEvent*
        ObjectiveLostStinger;           // 0x0098 (0x0008) [0x0000000000000000]
    class UAkEvent* PlayerDiedStinger;  // 0x00A0 (0x0008) [0x0000000000000000]
    class UAkEvent* LevelUpStinger;     // 0x00A8 (0x0008) [0x0000000000000000]
    class UAkEvent*
        TierUnlockedStinger;  // 0x00B0 (0x0008) [0x0000000000000000]
    class UAkEvent*
        TeammateDeathStinger;  // 0x00B8 (0x0008) [0x0000000000000000]
    class UAkEvent*
        ZedKillHumanStinger;  // 0x00C0 (0x0008) [0x0000000000000000]
    class UAkEvent*
        ZedPlayerKilledStinger;  // 0x00C8 (0x0008) [0x0000000000000000]
    class UAkEvent*
        ZedPlayerSuicideStinger;  // 0x00D0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[61580];

        return pClassPointer;
    };

    void PlayPlayerDiedStinger();
    void PlayTierUnlockedStinger();
    void PlayLevelUpStinger();
    void PlayObjectiveLostStinger();
    void PlayObjectiveWonStinger();
    void PlayWaveCompletedStinger();
    void PlayWaveStartStinger();
    void PlayMatchLostStinger();
    void PlayMatchWonStinger();
    void PlayRoundLostStinger();
    void PlayRoundWonStinger();
    void PlayZedPlayerSuicideStinger();
    void PlayZedPlayerKilledStinger();
    void PlayZedKillHumanStinger();
    void PlayTeammateDeathStinger();
};

UClass* UKFMusicStingerHelper::pClassPointer = NULL;

// Class KFGame.KFTeamInfo_Human
// 0x0014 (0x0278 - 0x0264)
class AKFTeamInfo_Human : public ATeamInfo {
   public:
    struct FsTeamScoreData
        TeamScoreDataPacket;  // 0x0264 (0x0014) [0x0000000000180000] (
                              // CPF_Component )

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[61581];

        return pClassPointer;
    };

    void Reset();
    void AddRoundScore();
    void AddScore();
    void GetHumanReadableName();
    void RemoveFromTeam();
    void AddToTeam();
    void Timer_WaitingForGRI();
    void PostBeginPlay();
};

UClass* AKFTeamInfo_Human::pClassPointer = NULL;

// Class KFGame.KFLocalMessage_PlayerKills
// 0x0020 (0x02B8 - 0x0298)
class UKFLocalMessage_PlayerKills : public UKFLocalMessage {
   public:
    struct FString KilledString;  // 0x0298 (0x0010) [0x0000000000000000]
    struct FString ZedString;     // 0x02A8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[61588];

        return pClassPointer;
    };

    void ResolveTeamName();
    void GetString();
    void GetHexColor();
};

UClass* UKFLocalMessage_PlayerKills::pClassPointer = NULL;

// Class KFGame.KFGameWaveforms
// 0x0010 (0x0090 - 0x0080)
class UKFGameWaveforms : public UGameWaveForms {
   public:
    class UForceFeedbackWaveform*
        CameraShakeMediumVeryShort;  // 0x0080 (0x0008) [0x0000000000000000]
    class UForceFeedbackWaveform*
        CameraShakeBigVeryShort;  // 0x0088 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[61604];

        return pClassPointer;
    };
};

UClass* UKFGameWaveforms::pClassPointer = NULL;

// Class KFGame.KFPlayerCamera
// 0x0050 (0x0720 - 0x06D0)
class AKFPlayerCamera : public AGamePlayerCamera {
   public:
    class UKFCustomizationCamera*
        CustomizationCam;  // 0x06D0 (0x0008) [0x0000000000000000]
    class UClass*
        CustomizationCameraClass;   // 0x06D8 (0x0008) [0x0000000000000000]
    class UKFBossCamera* BossCam;   // 0x06E0 (0x0008) [0x0000000000000000]
    class UClass* BossCameraClass;  // 0x06E8 (0x0008) [0x0000000000000000]
    class UKFFirstPersonCamera*
        FirstPersonCam;  // 0x06F0 (0x0008) [0x0000000000000000]
    class UClass*
        FirstPersonCameraClass;      // 0x06F8 (0x0008) [0x0000000000000000]
    class UKFEmoteCamera* EmoteCam;  // 0x0700 (0x0008) [0x0000000000000000]
    class UClass* EmoteCameraClass;  // 0x0708 (0x0008) [0x0000000000000000]
    float TargetFOV;                 // 0x0710 (0x0004) [0x0000000000000000]
    float TransitionStartFOV;        // 0x0714 (0x0004) [0x0000000000000000]
    float TransitionTimeElapsed;     // 0x0718 (0x0004) [0x0000000000000000]
    float TransitionTimeTotal;       // 0x071C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[61607];

        return pClassPointer;
    };

    void Reset();
    void FindBestCameraType();
    void CalcRadialShakeScale();
    void SetFOV();
    void GetOptionsFOVScale();
    void TransitionFOV();
    void UpdateCameraLensEffects();
    void GetActualFOV();
    void UpdateViewTarget();
    void DoUpdateCamera();
    void PostBeginPlay();
};

UClass* AKFPlayerCamera::pClassPointer = NULL;

// Class KFGame.KFGFxMenu_Perks
// 0x0084 (0x0164 - 0x00E0)
class UKFGFxMenu_Perks : public UKFGFxObject_Menu {
   public:
    class UKFGFxPerksContainer_Selection*
        SelectionContainer;  // 0x00E0 (0x0008) [0x0000000000000000]
    class UKFGFxPerksContainer_Header*
        HeaderContainer;  // 0x00E8 (0x0008) [0x0000000000000000]
    class UKFGFxPerksContainer_Details*
        DetailsContainer;  // 0x00F0 (0x0008) [0x0000000000000000]
    class UKFGFxPerksContainer_Skills*
        SkillsContainer;  // 0x00F8 (0x0008) [0x0000000000000000]
    class UKFGFxPerksContainer_SkillsSummary*
        SkillsSummaryContainer;       // 0x0100 (0x0008) [0x0000000000000000]
    class AKFPlayerController* KFPC;  // 0x0108 (0x0008) [0x0000000000000000]
    struct FString LockIconPath;      // 0x0110 (0x0010) [0x0000000000000000]
    unsigned char LastPerkIndex;      // 0x0120 (0x0001) [0x0000000000000000]
    unsigned char LastPerkLevel;      // 0x0121 (0x0001) [0x0000000000000000]
    unsigned char
        SelectedSkillsHolder[0x5];    // 0x0122 (0x0005) [0x0000000000000000]
    class UClass* PreviousPerk;       // 0x0128 (0x0008) [0x0000000000000000]
    struct FString TierUnlockedText;  // 0x0130 (0x0010) [0x0000000000000000]
    struct FString
        TierUnlockedSecondaryText;  // 0x0140 (0x0010) [0x0000000000000000]
    class AKFPlayerReplicationInfo*
        MyKFPRI;                // 0x0150 (0x0008) [0x0000000000000000]
    DWORD bModifiedSkills : 1;  // 0x0158 (0x0004) [0x0000000000000000]
                                // [0x00000001]
    DWORD
        bModifiedPerk : 1;  // 0x0158 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bChangesMadeDuringLobby : 1;  // 0x0158 (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    struct FName PerkLevelupSound;      // 0x015C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[61628];

        return pClassPointer;
    };

    void Callback_SkillSelectionOpened();
    void Callback_SkillSelected();
    void Callback_PerkSelected();
    void Callback_ReadyClicked();
    void SavePerkData();
    void UpdateSkillsHolder();
    void UpdateSkillsUI();
    void UpdateContainers();
    void UpdateLock();
    void OneSecondLoop();
    void PerkChanged();
    void IsMatchStarted();
    void OnRoundOver();
    void eventOnTraderTimeStart();
    void eventOnClose();
    void CheckTiersForPopup();
    void OnOpen();
    void eventWidgetInitialized();
};

UClass* UKFGFxMenu_Perks::pClassPointer = NULL;

// Class KFGame.KFGFxMoviePlayer_PostRoundMenu
// 0x0008 (0x01EC - 0x01E4)
class UKFGFxMoviePlayer_PostRoundMenu : public UGFxMoviePlayer {
   public:
    class UKFGFxHUD_PostRoundMenu*
        PostRoundMenu;  // 0x01E4 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[61743];

        return pClassPointer;
    };

    void Callback_WinnerAnimationComplete();
    void eventWidgetInitialized();
    void Init();
};

UClass* UKFGFxMoviePlayer_PostRoundMenu::pClassPointer = NULL;

// Class KFGame.KFDemoRecSpectator
// 0x0010 (0x0D94 - 0x0D84)
class AKFDemoRecSpectator : public AKFPlayerController {
   public:
    DWORD bFindPlayer : 1;  // 0x0D84 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bLockRotationToViewTarget : 1;  // 0x0D84 (0x0004)
                                          // [0x0000000000000000] [0x00000002]
    DWORD bAutoSwitchPlayers : 1;  // 0x0D84 (0x0004) [0x0000000000000000]
                                   // [0x00000004]
    class APlayerReplicationInfo*
        MyRealViewTarget;            // 0x0D88 (0x0008) [0x0000000000000000]
    float AutoSwitchPlayerInterval;  // 0x0D90 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[61928];

        return pClassPointer;
    };

    void UpdateRotation();
    void eventGetPlayerViewPoint();
    void Pause();
    void SetPause();
    void ClientSetRealViewTarget();
    void ServerViewSelf();
    void SetViewTarget();
    void DemoViewNextPlayer();
    void ViewClass();
    void Slomo();
    void SetGFxHUD();
    void InitPlayerReplicationInfo();
    void eventReceivedPlayer();
    void eventPostBeginPlay();
};

UClass* AKFDemoRecSpectator::pClassPointer = NULL;

// Class KFGame.KFDT_Environment_KActorImpulse
// 0x0000 (0x0164 - 0x0164)
class UKFDT_Environment_KActorImpulse : public UKFDamageType {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[62254];

        return pClassPointer;
    };
};

UClass* UKFDT_Environment_KActorImpulse::pClassPointer = NULL;

// Class KFGame.KFDT_NPCBump_Large
// 0x0000 (0x0164 - 0x0164)
class UKFDT_NPCBump_Large : public UKFDT_NPCBump {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[62255];

        return pClassPointer;
    };
};

UClass* UKFDT_NPCBump_Large::pClassPointer = NULL;

// Class KFGame.KFDialogEnvironmentVolume
// 0x0001 (0x0281 - 0x0280)
class AKFDialogEnvironmentVolume : public AVolume {
   public:
    unsigned char Environment;  // 0x0280 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[62257];

        return pClassPointer;
    };

    void eventUnTouch();
    void eventTouch();
};

UClass* AKFDialogEnvironmentVolume::pClassPointer = NULL;

// Class KFGame.KFDialogManager
// 0x00C4 (0x0308 - 0x0244)
class AKFDialogManager : public AActor {
   public:
    DWORD bEnabled : 1;    // 0x0244 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bLogDialog : 1;  // 0x0244 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD
        bIsTraderTime : 1;  // 0x0244 (0x0004) [0x0000000000000000] [0x00000004]
    TArray<struct FDialogCoolDownInfo>
        Cooldowns;                 // 0x0248 (0x0010) [0x0000000000000000]
    class APawn* NextSpotterPawn;  // 0x0258 (0x0008) [0x0000000000000000]
    float LastSpotUpdateTime;      // 0x0260 (0x0004) [0x0000000000000000]
    TArray<struct FDelayedDialogInfo>
        DelayedDialog;         // 0x0264 (0x0010) [0x0000000000000000]
    float LastIdleUpdateTime;  // 0x0274 (0x0004) [0x0000000000000000]
    unsigned char
        InterruptPriorityThreshold;  // 0x0278 (0x0001) [0x0000000000000000]
    unsigned char InterruptedByAnyPriorityThreshold;  // 0x0279 (0x0001)
                                                      // [0x0000000000000000]
    int WeldAboutToBreakThreshold;      // 0x027C (0x0004) [0x0000000000000000]
    float NeedMoreHealingPctThreshold;  // 0x0280 (0x0004) [0x0000000000000000]
    float
        NeedNoMoreHealingPctThreshold;  // 0x0284 (0x0004) [0x0000000000000000]
    int CaughtSomeDoshAmt;              // 0x0288 (0x0004) [0x0000000000000000]
    int CaughtMuchDoshAmt;              // 0x028C (0x0004) [0x0000000000000000]
    int NumZedsForPressureReload;       // 0x0290 (0x0004) [0x0000000000000000]
    float LowSpareAmmoPctThreshold;     // 0x0294 (0x0004) [0x0000000000000000]
    int NumKillsForOnARoll;             // 0x0298 (0x0004) [0x0000000000000000]
    float CloseCallKillHealthPctThreshold;  // 0x029C (0x0004)
                                            // [0x0000000000000000]
    int NumZedsInAreaForMassacre;       // 0x02A0 (0x0004) [0x0000000000000000]
    float AreaRadiusForMassacre;        // 0x02A4 (0x0004) [0x0000000000000000]
    float TimeLimitForMassacre;         // 0x02A8 (0x0004) [0x0000000000000000]
    int NumHitsForDeadHorse;            // 0x02AC (0x0004) [0x0000000000000000]
    float TimeBetweenHitsForDeadHorse;  // 0x02B0 (0x0004) [0x0000000000000000]
    float TimeForContinuousDamageThreshold;    // 0x02B4 (0x0004)
                                               // [0x0000000000000000]
    float TimeBetweenHitsForContinuousDamage;  // 0x02B8 (0x0004)
                                               // [0x0000000000000000]
    float PlayerHealthPctForNearDeath;  // 0x02BC (0x0004) [0x0000000000000000]
    float
        PlayerTakeDamageStreakInterval;  // 0x02C0 (0x0004) [0x0000000000000000]
    float PlayerTakeDamageStreakPctForScream;  // 0x02C4 (0x0004)
                                               // [0x0000000000000000]
    float IdleTimeforSpottingZed;  // 0x02C8 (0x0004) [0x0000000000000000]
    int SpotLargeHordeNumZeds;     // 0x02CC (0x0004) [0x0000000000000000]
    float ZedAlmostDeadHealthPctThreshold;  // 0x02D0 (0x0004)
                                            // [0x0000000000000000]
    float SprintTowardZedDuration;       // 0x02D4 (0x0004) [0x0000000000000000]
    float IdleTimeForSituationalDialog;  // 0x02D8 (0x0004) [0x0000000000000000]
    int IdleLowDoshThreshold;            // 0x02DC (0x0004) [0x0000000000000000]
    int IdleHighDoshThreshold;           // 0x02E0 (0x0004) [0x0000000000000000]
    int IdleLowAmmoPctThreshold;         // 0x02E4 (0x0004) [0x0000000000000000]
    int IdleHighAmmoPctThreshold;        // 0x02E8 (0x0004) [0x0000000000000000]
    float TimeUntilStartSprintPanting;   // 0x02EC (0x0004) [0x0000000000000000]
    class UAkEvent*
        StopBreathingAkEvent;  // 0x02F0 (0x0008) [0x0000000000000000]
    struct FScriptDelegate
        __OnFinishedDialog__Delegate;  // 0x02F8 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x02FC (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[62272];

        return pClassPointer;
    };

    void PlayPattyWhirlwindDialog();
    void PlayPattyBattlePhaseDialog();
    void PlayPattyKilledDialog();
    void PlayPattyChildKilledDialog();
    void PlayPattyTentaclePullDialog();
    void PlayPattyMinigunAttackDialog();
    void PlayPattyMinigunWarnDialog();
    void PlayPatriarchTickDialog();
    void PlayHansBattlePhaseDialog();
    void PlayHansAOEDialog();
    void PlayHansFrenzyDialog();
    void PlayHansDamagePlayerDialog();
    void PlayHansKilledDialog();
    void PlayHansGasDialog();
    void PlayHansSmokeDialog();
    void PlayHansNadeDialog();
    void PlayHansDrawGunsDialog();
    void PlayHansTickDialog();
    void PlayBossLandedDialog();
    void PlayBossLeapedDialog();
    void PlayBossDeathDialog();
    void PlayBossTakeDamageDialog();
    void PlayBossHealDialog();
    void PlayBossGrabDialog();
    void PlayBossChallengeDialog();
    void PlayBossLoseSightOfDialog();
    void PlayBossMonologue();
    void PlayVoiceCommandDialog();
    void PlaySwitchToFavoriteWeaponDialog();
    void PlayDefendObjDialog();
    void PlayObjectiveDialogOnRandomPlayers();
    void GetHumanPawnsInObj();
    void PlayLoseObjectiveDialog();
    void PlayWinObjectiveDialog();
    void PlayDeclineObjectiveDialog();
    void PlayAcceptObjectiveDialog();
    void PlayEnvironmentalDialog();
    void PlayWaveStartDialog();
    void PlayRandomSituationalResponse();
    void PlayRandomSituationalDialog();
    void PlaySituationalDialog();
    void CheckIdleDialog();
    void PlayBasicSpottedResponse();
    void PlayLoseSightOfBossDialog();
    void PlaySpotRunAwayDialog();
    void PlaySpotZedHealingDialog();
    void PlayBeingShotAtDialog();
    void PlaySpotGrenadeDialog();
    void PlaySpotRocketsDialog();
    void PlaySpotChargeDialog();
    void PlaySpotEnragedDialog();
    void PlaySpotCloakDialog();
    void CheckSpotPickupsDialog();
    void SpotEnemyBehindPlayer();
    void FindBestSpottedMonster();
    void CheckSpottedDialog();
    void CheckSpotMonsterDialog();
    void CheckSpottedDialogPriority();
    void PlayPlayerDeathDialog();
    void PlayPlayerGrabbedByPatriarchDialog();
    void PlayPlayerGrabbedDialog();
    void CheckPlayerDamageGeneric();
    void PlayPlayerDamageDialog();
    void PlayBeatDeadHorseDialog();
    void PlayDamageZedContinuousDialog();
    void PlayDamagedZedDialog();
    void PlayBasicKilledResponse();
    void CheckKilledWithFavoriteWeaponDialog();
    void CheckKillAsLastAliveDialog();
    void CheckCloseCallKillDialog();
    void CheckMassacreDialog();
    void CheckOnARollDialog();
    void PlayKilledZedDialog();
    void PlayLevelUpDialog();
    void StopBreathingDialog();
    void PlaySprintPantingDialog();
    void PlayJumpDialog();
    void PlayIronsightsDialog();
    void PlayMeleeAttackDialog();
    void PlayDropWeaponDialog();
    void PlayAmmoDialog();
    void PlayReloadDialog();
    void PlayDoshTossDialog();
    void PlayDoshCaughtDialog();
    void PlayHealingDialog();
    void PlayHealMissResponse();
    void PlayHealMissDialog();
    void PlayDoorTakeDamageDialog();
    void PlayUnweldDialog();
    void PlayWeldDialog();
    void AddDelayedDialogEvent();
    void AddRandomDialogOption();
    void PlayCustomDialogResponse();
    void FindPlayerResponder();
    void PlayBasicDialogResponse();
    void BasicResponseDelegate();
    void PlayerIsPlayingDialogEvent();
    void PlayDialogEvent();
    void DialogEventCanBePlayed();
    void DialogIsCoolingDown();
    void UpdateDelayedDialog();
    void eventTick();
    void SetTraderTime();
    void PlayerCanSpotEnemy();
    void PawnWithinPawnLOS();
    void ActorWithinPawnRadius();
    void ActorWithinPawnFOV();
    void PawnCanSpotActor();
    void PawnCanSpotPawn();
    void PawnIsValidPlayer();
    void GetEventIsOnlyPlayedLocally();
    void GetEventCoolDownCategory();
    void GetEventCoolDownRadiusSq();
    void GetEventCoolDownRadius();
    void GetEventCoolDownTime();
    void GetEventPriority();
    void GetEventFOV();
    void GetEventRadiusSq();
    void GetEventRadius();
    void OnFinishedDialog();
};

UClass* AKFDialogManager::pClassPointer = NULL;

// Class KFGame.KFDT_Toxic
// 0x0000 (0x0164 - 0x0164)
class UKFDT_Toxic : public UKFDamageType {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63119];

        return pClassPointer;
    };

    void GetDamageeDialogID();
    void GetDamagerDialogID();
    void GetKillerDialogID();
};

UClass* UKFDT_Toxic::pClassPointer = NULL;

// Class KFGame.KFKActorSpawnable_Door
// 0x0000 (0x037C - 0x037C)
class AKFKActorSpawnable_Door : public AKFKActorSpawnable {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63417];

        return pClassPointer;
    };

    void CheckOnFlatGround();
    void HideNonFlatMesh();
    void eventOnSleepRBPhysics();
};

UClass* AKFKActorSpawnable_Door::pClassPointer = NULL;

// Class KFGame.KFDroppedPickup_Cash
// 0x0014 (0x02E8 - 0x02D4)
class AKFDroppedPickup_Cash : public AKFDroppedPickup {
   public:
    int CashAmount;  // 0x02D4 (0x0004) [0x0000000000000000]
    class APlayerReplicationInfo*
        TosserPRI;                // 0x02D8 (0x0008) [0x0000000000000000]
    class UAkEvent* PickupSound;  // 0x02E0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63602];

        return pClassPointer;
    };

    void ServerNotifyMinigameHit();
    void NotifyMinigameHit();
    void eventDestroyed();
    void SetPickupMesh();
    void AddDoshForBenefector();
    void GiveTo();
};

UClass* AKFDroppedPickup_Cash::pClassPointer = NULL;

// Class KFGame.KFInterface_MinigameTarget
// 0x0000 (0x0060 - 0x0060)
class UKFInterface_MinigameTarget : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63623];

        return pClassPointer;
    };

    void IsAlive();
    void InvalidHit();
    void ValidHit();
};

UClass* UKFInterface_MinigameTarget::pClassPointer = NULL;

// Class KFGame.KFDT_Ballistic_Shell
// 0x0000 (0x0164 - 0x0164)
class UKFDT_Ballistic_Shell : public UKFDT_Ballistic {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63638];

        return pClassPointer;
    };

    void CanDismemberHitZone();
};

UClass* UKFDT_Ballistic_Shell::pClassPointer = NULL;

// Class KFGame.KFDT_Toxic_DemoNuke
// 0x0000 (0x0164 - 0x0164)
class UKFDT_Toxic_DemoNuke : public UKFDT_Toxic {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63657];

        return pClassPointer;
    };

    void AlwaysPoisons();
};

UClass* UKFDT_Toxic_DemoNuke::pClassPointer = NULL;

// Class KFGame.KFDT_DemoNuke_Toxic_Lingering
// 0x0000 (0x0164 - 0x0164)
class UKFDT_DemoNuke_Toxic_Lingering : public UKFDT_Toxic_DemoNuke {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63661];

        return pClassPointer;
    };

    void AlwaysPoisons();
};

UClass* UKFDT_DemoNuke_Toxic_Lingering::pClassPointer = NULL;

// Class KFGame.KFDT_DrainHealth
// 0x0000 (0x0164 - 0x0164)
class UKFDT_DrainHealth : public UKFDamageType {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63665];

        return pClassPointer;
    };
};

UClass* UKFDT_DrainHealth::pClassPointer = NULL;

// Class KFGame.KFDT_EMP
// 0x0000 (0x0164 - 0x0164)
class UKFDT_EMP : public UKFDamageType {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63667];

        return pClassPointer;
    };

    void GetDamagerDialogID();
    void GetKillerDialogID();
};

UClass* UKFDT_EMP::pClassPointer = NULL;

// Class KFGame.KFDT_Explosive_DoorTrap
// 0x0000 (0x0164 - 0x0164)
class UKFDT_Explosive_DoorTrap : public UKFDT_Explosive {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63700];

        return pClassPointer;
    };
};

UClass* UKFDT_Explosive_DoorTrap::pClassPointer = NULL;

// Class KFGame.KFDT_Explosive_Shrapnel
// 0x0000 (0x0164 - 0x0164)
class UKFDT_Explosive_Shrapnel : public UKFDT_Explosive {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63703];

        return pClassPointer;
    };
};

UClass* UKFDT_Explosive_Shrapnel::pClassPointer = NULL;

// Class KFGame.KFDT_ExplosiveSubmunition_HX25
// 0x0000 (0x0164 - 0x0164)
class UKFDT_ExplosiveSubmunition_HX25 : public UKFDT_Explosive {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63705];

        return pClassPointer;
    };
};

UClass* UKFDT_ExplosiveSubmunition_HX25::pClassPointer = NULL;

// Class KFGame.KFWeapDef_HX25
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_HX25 : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63707];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_HX25::pClassPointer = NULL;

// Class KFGame.KFDT_Fire_Ground
// 0x0000 (0x0164 - 0x0164)
class UKFDT_Fire_Ground : public UKFDT_Fire {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63716];

        return pClassPointer;
    };

    void GetDamageeDialogID();
    void GetDamagerDialogID();
    void GetKillerDialogID();
};

UClass* UKFDT_Fire_Ground::pClassPointer = NULL;

// Class KFGame.KFDT_Freeze
// 0x0010 (0x0174 - 0x0164)
class UKFDT_Freeze : public UKFDamageType {
   public:
    class UParticleSystem*
        FrozenShatterTemplate;  // 0x0164 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        ShatterSound;  // 0x016C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63725];

        return pClassPointer;
    };

    void PlayShatter();
    void GetDamagerDialogID();
    void GetKillerDialogID();
};

UClass* UKFDT_Freeze::pClassPointer = NULL;

// Class KFGame.KFDT_Healing
// 0x0000 (0x0164 - 0x0164)
class UKFDT_Healing : public UKFDamageType {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63751];

        return pClassPointer;
    };

    void PlayImpactHitEffects();
};

UClass* UKFDT_Healing::pClassPointer = NULL;

// Class KFGame.KFDT_NoGoVolume
// 0x0000 (0x0164 - 0x0164)
class UKFDT_NoGoVolume : public UKFDamageType {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63759];

        return pClassPointer;
    };
};

UClass* UKFDT_NoGoVolume::pClassPointer = NULL;

// Class KFGame.KFDT_Piercing
// 0x0000 (0x0164 - 0x0164)
class UKFDT_Piercing : public UKFDamageType {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63766];

        return pClassPointer;
    };

    void CanDismemberHitZone();
};

UClass* UKFDT_Piercing::pClassPointer = NULL;

// Class KFGame.KFDT_Toxic_AcidicRounds
// 0x0000 (0x0164 - 0x0164)
class UKFDT_Toxic_AcidicRounds : public UKFDT_Toxic {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63809];

        return pClassPointer;
    };

    void AlwaysPoisons();
};

UClass* UKFDT_Toxic_AcidicRounds::pClassPointer = NULL;

// Class KFGame.KFDT_Toxic_MedicGrenade
// 0x0000 (0x0164 - 0x0164)
class UKFDT_Toxic_MedicGrenade : public UKFDT_Toxic {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63813];

        return pClassPointer;
    };
};

UClass* UKFDT_Toxic_MedicGrenade::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Grenade_Medic
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Grenade_Medic : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63815];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Grenade_Medic::pClassPointer = NULL;

// Class KFGame.KFDynamicFogAndDamageVolumeInfo
// 0x0048 (0x02A0 - 0x0258)
class AKFDynamicFogAndDamageVolumeInfo : public AFogVolumeConstantDensityInfo {
   public:
    float DamagePerSec;        // 0x0258 (0x0004) [0x0000000000000000]
    class UClass* DamageType;  // 0x025C (0x0008) [0x0000000000000000]
    DWORD
        bPainCausing : 1;   // 0x0264 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bDamageZeds : 1;  // 0x0264 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bBlendingFogIn : 1;   // 0x0264 (0x0004) [0x0000000000000000]
                                // [0x00000004]
    DWORD bBlendingFogOut : 1;  // 0x0264 (0x0004) [0x0000000000000000]
                                // [0x00000008]
    DWORD bOldEnabled : 1;  // 0x0264 (0x0004) [0x0000000000000000] [0x00000010]
    float PainInterval;     // 0x0268 (0x0004) [0x0000000000000000]
    float FogBlendTime;     // 0x026C (0x0004) [0x0000000000000000]
    float FogBlendTimeRemaining;      // 0x0270 (0x0004) [0x0000000000000000]
    unsigned char FogBlendAmountRep;  // 0x0274 (0x0001) [0x0000000000160000] (
                                      // CPF_EditConst | CPF_GlobalConfig )
    float InitialDensity;              // 0x0278 (0x0004) [0x0000000000000000]
    float CurrentDensity;              // 0x027C (0x0004) [0x0000000000000000]
    struct FString ActivateMessage;    // 0x0280 (0x0010) [0x0000000000000000]
    struct FString DeactivateMessage;  // 0x0290 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63820];

        return pClassPointer;
    };

    void TempMessagePlayers();
    void SetEnabled();
    void StartBlendOut();
    void StartBlendIn();
    void DeActivate();
    void Activate();
    void TimerPop();
    void CausePainTo();
    void eventTouch();
    void eventTick();
    void SetFogDensity();
    void OnToggle();
    void eventReplicatedEvent();
    void eventPostBeginPlay();
};

UClass* AKFDynamicFogAndDamageVolumeInfo::pClassPointer = NULL;

// Class KFGame.KFEmit_Path
// 0x0038 (0x0290 - 0x0258)
class AKFEmit_Path : public AEmitter {
   public:
    int WAYPOINT_HEIGHT;           // 0x0258 (0x0004) [0x0000000000000000]
    int WAYPOINT_HEIGHT_NAV_MESH;  // 0x025C (0x0004) [0x0000000000000000]
    float MinDistanceBetweenWayPointsOnNavMesh;  // 0x0260 (0x0004)
                                                 // [0x0000000000000000]
    class UParticleSystem*
        EmitterTemplate;                // 0x0264 (0x0008) [0x0000000000000000]
    TArray<struct FVector> WayPoints;   // 0x026C (0x0010) [0x0000000000000000]
    int NumPoints;                      // 0x027C (0x0004) [0x0000000000000000]
    int Position;                       // 0x0280 (0x0004) [0x0000000000000000]
    float CURVE_TURNRATE;               // 0x0284 (0x0004) [0x0000000000000000]
    float ACCEL_RATE;                   // 0x0288 (0x0004) [0x0000000000000000]
    DWORD bUseAccelerationPhysics : 1;  // 0x028C (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD
        bHeadedRight : 1;  // 0x028C (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bShowEmitPathDebugArtifacts : 1;  // 0x028C (0x0004)
                                            // [0x0000000000000000] [0x00000004]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63867];

        return pClassPointer;
    };

    void ShouldStopPathing();
    void StartNextPath();
    void eventSetTemplate();
    void eventSetInitialState();
    void SetDestination();
    void PostBeginPlay();
};

UClass* AKFEmit_Path::pClassPointer = NULL;

// Class KFGame.KFEmit_TraderPath
// 0x0000 (0x0290 - 0x0290)
class AKFEmit_TraderPath : public AKFEmit_Path {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63915];

        return pClassPointer;
    };

    void ShouldStopPathing();
};

UClass* AKFEmit_TraderPath::pClassPointer = NULL;

// Class KFGame.KFEmit_ScriptedPath
// 0x0000 (0x0290 - 0x0290)
class AKFEmit_ScriptedPath : public AKFEmit_TraderPath {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63923];

        return pClassPointer;
    };

    void ShouldStopPathing();
};

UClass* AKFEmit_ScriptedPath::pClassPointer = NULL;

// Class KFGame.KFEmitter
// 0x0004 (0x025C - 0x0258)
class AKFEmitter : public AEmitter {
   public:
    DWORD bClientsideKismetToggle : 1;  // 0x0258 (0x0004) [0x0000000000000000]
                                        // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63928];

        return pClassPointer;
    };

    void OnToggle();
};

UClass* AKFEmitter::pClassPointer = NULL;

// Class KFGame.KFThirdPersonCamera
// 0x0004 (0x01D8 - 0x01D4)
class UKFThirdPersonCamera : public UGameThirdPersonCamera {
   public:
    DWORD bInvertY : 1;  // 0x01D4 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63934];

        return pClassPointer;
    };

    void InvertViewOffset();
    void SetViewOffset();
};

UClass* UKFThirdPersonCamera::pClassPointer = NULL;

// Class KFGame.KFThirdPersonCameraMode
// 0x0000 (0x0264 - 0x0264)
class UKFThirdPersonCameraMode : public UGameThirdPersonCameraMode_Default {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63942];

        return pClassPointer;
    };

    void GetDefaultOffset();
    void InvertViewOffset();
};

UClass* UKFThirdPersonCameraMode::pClassPointer = NULL;

// Class KFGame.KFEmoteCamera
// 0x0000 (0x01D8 - 0x01D8)
class UKFEmoteCamera : public UKFThirdPersonCamera {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63944];

        return pClassPointer;
    };
};

UClass* UKFEmoteCamera::pClassPointer = NULL;

// Class KFGame.KFEmoteCameraMode
// 0x0000 (0x0264 - 0x0264)
class UKFEmoteCameraMode : public UKFThirdPersonCameraMode {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[63946];

        return pClassPointer;
    };
};

UClass* UKFEmoteCameraMode::pClassPointer = NULL;

// Class KFGame.KFExplosion_AirborneAgent
// 0x0060 (0x0384 - 0x0324)
class AKFExplosion_AirborneAgent : public AKFExplosionActorReplicated {
   public:
    class UClass* HealingDamageType;   // 0x0324 (0x0008) [0x0000000000000000]
    float HealingAmount;               // 0x032C (0x0004) [0x0000000000000000]
    class UAkEvent* LoopStartEvent;    // 0x0330 (0x0008) [0x0000000000000000]
    class UAkEvent* LoopStopEvent;     // 0x0338 (0x0008) [0x0000000000000000]
    float interval;                    // 0x0340 (0x0004) [0x0000000000000000]
    float maxTime;                     // 0x0344 (0x0004) [0x0000000000000000]
    DWORD bOnlyDamagePawns : 1;        // 0x0348 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bSkipLineCheckForPawns : 1;  // 0x0348 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD
        bDoFullDamage : 1;  // 0x0348 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD
        bWasFadedOut : 1;  // 0x0348 (0x0004) [0x0000000000000000] [0x00000008]
    class AKFPerk*
        CachedInstigatorPerk;  // 0x034C (0x0008) [0x0000000000000000]
    class UParticleSystem*
        LoopingParticleEffect;  // 0x0354 (0x0008) [0x0000000000000000]
    class UParticleSystemComponent*
        LoopingPSC;  // 0x035C (0x0008) [0x0000000000000000]
    struct FString
        AAHealingDamageTypePath;  // 0x0364 (0x0010) [0x0000000000000000]
    class UParticleSystemComponent*
        PSC;              // 0x0374 (0x0008) [0x0000000000000000]
    class APawn* MyPawn;  // 0x037C (0x0008) [0x0000000000190000]              (
                          // CPF_Travel | CPF_Component )

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[64093];

        return pClassPointer;
    };

    void ExplodePawns();
    void DoExplosionDamage();
    void StopLoopingParticleEffect();
    void eventDestroyed();
    void FadeOut();
    void StartLoopingParticleEffect();
    void Explode();
    void SpawnExplosionParticleSystem();
    void AffectsPawn();
    void eventReplicatedEvent();
};

UClass* AKFExplosion_AirborneAgent::pClassPointer = NULL;

// Class KFGame.KFExplosionActorLingering
// 0x002C (0x0344 - 0x0318)
class AKFExplosionActorLingering : public AKFExplosionActor {
   public:
    float interval;                    // 0x0318 (0x0004) [0x0000000000000000]
    float maxTime;                     // 0x031C (0x0004) [0x0000000000000000]
    DWORD bOnlyDamagePawns : 1;        // 0x0320 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bSkipLineCheckForPawns : 1;  // 0x0320 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD
        bDoFullDamage : 1;  // 0x0320 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD
        bWasFadedOut : 1;  // 0x0320 (0x0004) [0x0000000000000000] [0x00000008]
    class UAkEvent* LoopStartEvent;  // 0x0324 (0x0008) [0x0000000000000000]
    class UAkEvent* LoopStopEvent;   // 0x032C (0x0008) [0x0000000000000000]
    class UParticleSystem*
        LoopingParticleEffect;  // 0x0334 (0x0008) [0x0000000000000000]
    class UParticleSystemComponent*
        LoopingPSC;  // 0x033C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[64148];

        return pClassPointer;
    };

    void AffectsPawn();
    void ExplodePawns();
    void DoExplosionDamage();
    void StopLoopingParticleEffect();
    void eventDestroyed();
    void FadeOut();
    void StartLoopingParticleEffect();
    void Explode();
};

UClass* AKFExplosionActorLingering::pClassPointer = NULL;

// Class KFGame.KFExplosion_Nuke
// 0x0004 (0x0348 - 0x0344)
class AKFExplosion_Nuke : public AKFExplosionActorLingering {
   public:
    float NukeEffectRadius;  // 0x0344 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[64185];

        return pClassPointer;
    };

    void GetNukeEffectCheckRadius();
    void ExplodePawns();
    void Explode();
    void AffectsPawn();
};

UClass* AKFExplosion_Nuke::pClassPointer = NULL;

// Class KFGame.KFExplosionActorPlaceable
// 0x0000 (0x0318 - 0x0318)
class AKFExplosionActorPlaceable : public AKFExplosionActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[64211];

        return pClassPointer;
    };
};

UClass* AKFExplosionActorPlaceable::pClassPointer = NULL;

// Class KFGame.KFFirstPersonCamera
// 0x0000 (0x006C - 0x006C)
class UKFFirstPersonCamera : public UGameCameraBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[64233];

        return pClassPointer;
    };

    void PlayerUpdateCamera();
    void UpdateCamera();
};

UClass* UKFFirstPersonCamera::pClassPointer = NULL;

// Class KFGame.KFGameInfo_Entry
// 0x0008 (0x071C - 0x0714)
class AKFGameInfo_Entry : public AKFGameInfo {
   public:
    DWORD
        bInitialized : 1;  // 0x0714 (0x0004) [0x0000000000000000] [0x00000001]
    int LastSystemTimeMinutes;  // 0x0718 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[65504];

        return pClassPointer;
    };

    void FinishCraft();
    void Tick();
    void GetSystemTimeMinutes();
    void eventInitGame();
    void StartMatch();
    void InitTraderList();
    void InitSpawnManager();
    void SpawnDefaultPawnFor();
    void NeedPlayers();
    void PreloadContentClasses();
};

UClass* AKFGameInfo_Entry::pClassPointer = NULL;

// Class KFGame.KFTraderVoiceGroupBase
// 0x10D8 (0x1138 - 0x0060)
class UKFTraderVoiceGroupBase : public UObject {
   public:
    struct FTraderDialogEventInfo
        DialogEvents[0x9A];         // 0x0060 (0x0C08) [0x0000000000000000]
    struct FName EventNames[0x9A];  // 0x0C68 (0x04D0) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[65505];

        return pClassPointer;
    };
};

UClass* UKFTraderVoiceGroupBase::pClassPointer = NULL;

// Class KFGame.KFGameInfoSummary
// 0x0000 (0x00F8 - 0x00F8)
class UKFGameInfoSummary : public UUIGameInfoSummary {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[65555];

        return pClassPointer;
    };
};

UClass* UKFGameInfoSummary::pClassPointer = NULL;

// Class KFGame.KFGameplayPoolManager
// 0x0024 (0x0268 - 0x0244)
class AKFGameplayPoolManager : public AActor {
   public:
    unsigned char MAX_ACTIVE_C4;  // 0x0244 (0x0001) [0x0000000000000000]
    unsigned char
        MAX_ACTIVE_PUKE_MINES;  // 0x0245 (0x0001) [0x0000000000000000]
    TArray<class AKFProjectile*>
        ActiveC4;  // 0x0248 (0x0010) [0x0000000000000000]
    TArray<class AKFProjectile*>
        ActivePukeMines;  // 0x0258 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[65754];

        return pClassPointer;
    };

    void eventReset();
    void RemoveProjectileFromPool_Internal();
    void AddProjectileToPool_Internal();
    void RemoveProjectileFromPool();
    void AddProjectileToPool();
    void GetPoolManager();
};

UClass* AKFGameplayPoolManager::pClassPointer = NULL;

// Class KFGame.KFSeqEvent_WaveStart
// 0x0000 (0x0170 - 0x0170)
class UKFSeqEvent_WaveStart : public USequenceEvent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66013];

        return pClassPointer;
    };

    void SetWaveNum();
};

UClass* UKFSeqEvent_WaveStart::pClassPointer = NULL;

// Class KFGame.KFSeqEvent_TraderOpened
// 0x0000 (0x0170 - 0x0170)
class UKFSeqEvent_TraderOpened : public USequenceEvent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66014];

        return pClassPointer;
    };

    void SetWaveNum();
};

UClass* UKFSeqEvent_TraderOpened::pClassPointer = NULL;

// Class KFGame.KFTraderDialogManager
// 0x0054 (0x0298 - 0x0244)
class AKFTraderDialogManager : public AActor {
   public:
    DWORD bEnabled : 1;  // 0x0244 (0x0004) [0x0000000000000000] [0x00000001]
    TArray<struct FTraderDialogCoolDownInfo>
        Cooldowns;  // 0x0248 (0x0010) [0x0000000000000000]
    class UClass*
        TraderVoiceGroupClass;  // 0x0258 (0x0008) [0x0000000000000000]
    struct FTraderDialogEventInfo
        ActiveEventInfo;          // 0x0260 (0x0014) [0x0000000000000000]
    float FewZedsDeadPct;         // 0x0274 (0x0004) [0x0000000000000000]
    float ManyZedsDeadPct;        // 0x0278 (0x0004) [0x0000000000000000]
    float FarFromTraderDistance;  // 0x027C (0x0004) [0x0000000000000000]
    float NeedHealPct;            // 0x0280 (0x0004) [0x0000000000000000]
    float TeammateNeedsHealPct;   // 0x0284 (0x0004) [0x0000000000000000]
    int ShareDoshAmount;          // 0x0288 (0x0004) [0x0000000000000000]
    int LowDoshAmount;            // 0x028C (0x0004) [0x0000000000000000]
    float WaveClearDialogDelay;   // 0x0290 (0x0004) [0x0000000000000000]
    int DelayedWaveClearEventID;  // 0x0294 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66015];

        return pClassPointer;
    };

    void PlaySelectItemDialog();
    void PlayObjectiveDialog();
    void PlayOpenTraderMenuDialog();
    void WaveClearDialogTimer();
    void PlayWaveClearDialog();
    void IsSoloHumanPlayer();
    void PlayPlayerSurvivedLastWaveDialog();
    void PlayPlayerDiedLastWaveDialog();
    void PlayBeginTraderTimeDialog();
    void PlayTraderTickDialog();
    void AddRandomOption();
    void PlayCloseTraderDialog();
    void PlayApproachTraderDialog();
    void PlayOpenTraderDialog();
    void PlayGlobalWaveProgressDialog();
    void PlayGlobalDialog();
    void PlayDialog();
    void DialogIsCoolingDown();
    void EndOfDialogTimer();
};

UClass* AKFTraderDialogManager::pClassPointer = NULL;

// Class KFGame.KFGFxCollapsedObjectivesContainer
// 0x0000 (0x00A8 - 0x00A8)
class UKFGFxCollapsedObjectivesContainer : public UKFGFxObject_Container {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66112];

        return pClassPointer;
    };

    void GetWeeklyDataObject();
    void PopulateData();
    void Initialize();
};

UClass* UKFGFxCollapsedObjectivesContainer::pClassPointer = NULL;

// Class KFGame.KFGFxSpecialEventObjectivesContainer
// 0x0090 (0x0138 - 0x00A8)
class UKFGFxSpecialEventObjectivesContainer : public UKFGFxObject_Container {
   public:
    struct FString
        CurrentSpecialEventString;  // 0x00A8 (0x0010) [0x0000000000000000]
    TArray<struct FSSpecialEventObjectiveInfo>
        SpecialEventObjectiveInfoList;  // 0x00B8 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        ObjectiveIconURLs;  // 0x00C8 (0x0010) [0x0000000000000000]
    struct FString
        AllCompleteRewardIconURL;  // 0x00D8 (0x0010) [0x0000000000000000]
    struct FString AllCompleteRewardDescriptionString;  // 0x00E8 (0x0010)
                                                        // [0x0000000000000000]
    TArray<struct FString>
        ChanceDropIconURLs;  // 0x00F8 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        ChanceDropDescriptionStrings;   // 0x0108 (0x0010) [0x0000000000000000]
    struct FString IconURL;             // 0x0118 (0x0010) [0x0000000000000000]
    TArray<DWORD> ObjectiveStatusList;  // 0x0128 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66134];

        return pClassPointer;
    };

    void PopulateChanceDrops();
    void PopulateReward();
    void HasObjectiveStatusChanged();
    void PopulateData();
    void LocalizeMenu();
    void Initialize();
};

UClass* UKFGFxSpecialEventObjectivesContainer::pClassPointer = NULL;

// Class KFGame.KFGFxControlsContainer_ControllerPresets
// 0x00A6 (0x014E - 0x00A8)
class UKFGFxControlsContainer_ControllerPresets
    : public UKFGFxObject_Container {
   public:
    struct FString InputSectionName;  // 0x00A8 (0x0010) [0x0000000000000000]
    struct FString PackageName;       // 0x00B8 (0x0010) [0x0000000000000000]
    struct FString MovementString;    // 0x00C8 (0x0010) [0x0000000000000000]
    struct FString LookString;        // 0x00D8 (0x0010) [0x0000000000000000]
    struct FString
        ShowScoardBoardString;  // 0x00E8 (0x0010) [0x0000000000000000]
    struct FString
        ShowIngameMenuString;   // 0x00F8 (0x0010) [0x0000000000000000]
    struct FString HoldString;  // 0x0108 (0x0010) [0x0000000000000000]
    struct FString TapString;   // 0x0118 (0x0010) [0x0000000000000000]
    struct FString
        CurrentControllerPresetString;  // 0x0128 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        PresetStrings;      // 0x0138 (0x0010) [0x0000000000000000]
    int numGamepadLayouts;  // 0x0148 (0x0004) [0x0000000000000000]
    unsigned char
        CurrentLocalizedIndex;         // 0x014C (0x0001) [0x0000000000000000]
    unsigned char CurrentPresetIndex;  // 0x014D (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66141];

        return pClassPointer;
    };

    void ResetPresetOptions();
    void AddBindingToGFxObject();
    void UpdateButtonDescriptions();
    void LocalizeText();
    void UpdateCurrentPresetArray();
    void Initialize();
};

UClass* UKFGFxControlsContainer_ControllerPresets::pClassPointer = NULL;

// Class KFGame.KFGFxControlsContainer_Input
// 0x00C8 (0x0170 - 0x00A8)
class UKFGFxControlsContainer_Input : public UKFGFxObject_Container {
   public:
    struct FString SensitivityString;  // 0x00A8 (0x0010) [0x0000000000000000]
    struct FString InvertedString;     // 0x00B8 (0x0010) [0x0000000000000000]
    struct FString
        ControllerSensitivityString;  // 0x00C8 (0x0010) [0x0000000000000000]
    struct FString ControllerString;  // 0x00D8 (0x0010) [0x0000000000000000]
    struct FString MouseString;       // 0x00E8 (0x0010) [0x0000000000000000]
    struct FString
        MouseSmoothingString;  // 0x00F8 (0x0010) [0x0000000000000000]
    struct FString
        ZoomSensitivityString;  // 0x0108 (0x0010) [0x0000000000000000]
    struct FString ControllerZoomSensitivityString;  // 0x0118 (0x0010)
                                                     // [0x0000000000000000]
    struct FString
        AimAssistLockOnString;  // 0x0128 (0x0010) [0x0000000000000000]
    struct FString
        AimAssistRotationString;  // 0x0138 (0x0010) [0x0000000000000000]
    struct FString
        AimAssistSlowDownString;         // 0x0148 (0x0010) [0x0000000000000000]
    struct FString ForceFeedbackString;  // 0x0158 (0x0010) [0x0000000000000000]
    class UKFGFxOptionsMenu_Controls*
        ControlsMenu;  // 0x0168 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66259];

        return pClassPointer;
    };

    void ResetInputOptions();
    void InitializeOptions();
    void LocalizeText();
    void Initialize();
};

UClass* UKFGFxControlsContainer_Input::pClassPointer = NULL;

// Class KFGame.KFGFxOptionsMenu_Controls
// 0x0058 (0x0138 - 0x00E0)
class UKFGFxOptionsMenu_Controls : public UKFGFxObject_Menu {
   public:
    class UKFGFxControlsContainer_Keybinding*
        KeybindingsContainer;  // 0x00E0 (0x0008) [0x0000000000000000]
    class UKFGFxControlsContainer_Input*
        InputContainer;  // 0x00E8 (0x0008) [0x0000000000000000]
    class UKFGFxControlsContainer_ControllerPresets*
        ControllerPresetsContainer;      // 0x00F0 (0x0008) [0x0000000000000000]
    float MinControllerLookSensitivity;  // 0x00F8 (0x0004) [0x0000000000000000]
    float MaxControllerLookSensitivity;  // 0x00FC (0x0004) [0x0000000000000000]
    float MinControllerZoomLookSensitivity;  // 0x0100 (0x0004)
                                             // [0x0000000000000000]
    float MaxControllerZoomLookSensitivity;  // 0x0104 (0x0004)
                                             // [0x0000000000000000]
    float MinMouseLookSensitivity;      // 0x0108 (0x0004) [0x0000000000000000]
    float MaxMouseLookSensitivity;      // 0x010C (0x0004) [0x0000000000000000]
    float MinMouseLookZoomSensitivity;  // 0x0110 (0x0004) [0x0000000000000000]
    float MaxMouseLookZoomSensitivity;  // 0x0114 (0x0004) [0x0000000000000000]
    TArray<struct FString> TabStrings;  // 0x0118 (0x0010) [0x0000000000000000]
    struct FString HeaderText;          // 0x0128 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66349];

        return pClassPointer;
    };

    void CallBack_ResetInputOptions();
    void CallBack_ResetPresetOptions();
    void Callback_UpdateControllerPreset();
    void Callback_CloseMenu();
    void Callback_AcceptBind();
    void Callback_ResetControls();
    void Callback_ChangeBind();
    void Callback_ForceFeedbackChanged();
    void Callback_AimAssistSlowDownChanged();
    void Callback_AimAssistRotationChanged();
    void Callback_AimAssistZoomLockOnChanged();
    void Callback_MouseSmoothingChanged();
    void Callback_InvertChanged();
    void Callback_MouseZoomSensitivity();
    void Callback_MouseSensitivity();
    void Callback_ControllerInvertChanged();
    void Callback_ControllerZoomSensitivity();
    void Callback_ControllerSensitivity();
    void eventFilterButtonInput();
    void SaveConfigValues();
    void eventOnClose();
    void OnOpen();
    void eventWidgetInitialized();
    void OnInputTypeChanged();
    void LocalizeText();
    void InitializeMenu();
};

UClass* UKFGFxOptionsMenu_Controls::pClassPointer = NULL;

// Class KFGame.KFGFxControlsContainer_Keybinding
// 0x0168 (0x0210 - 0x00A8)
class UKFGFxControlsContainer_Keybinding : public UKFGFxObject_Container {
   public:
    class UKFGFxMoviePlayer_Manager*
        Manager;  // 0x00A8 (0x0008) [0x0000000000000000]
    TArray<struct FString>
        MovementBindList;  // 0x00B0 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        CombatBindList;  // 0x00C0 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        WeaponSelectBindList;  // 0x00D0 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        InteractionBindList;  // 0x00E0 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        VoiceCommBindList;           // 0x00F0 (0x0010) [0x0000000000000000]
    struct FKeyBind PendingKeyBind;  // 0x0100 (0x001C) [0x0000000000000000]
    struct FKeyBind OldKeyBind;      // 0x011C (0x001C) [0x0000000000000000]
    struct FString bindCommand;      // 0x0138 (0x0010) [0x0000000000000000]
    unsigned char
        CurrentlySelectedSection;     // 0x0148 (0x0001) [0x0000000000000000]
    unsigned char TotalBindSections;  // 0x0149 (0x0001) [0x0000000000000000]
    DWORD bModCtrl : 1;   // 0x014C (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bModShift : 1;  // 0x014C (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bModAlt : 1;    // 0x014C (0x0004) [0x0000000000000000] [0x00000004]
    DWORD
        bWaitForInput : 1;  // 0x014C (0x0004) [0x0000000000000000] [0x00000008]
    struct FString SectionName;  // 0x0150 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        SectionHeaders;          // 0x0160 (0x0010) [0x0000000000000000]
    struct FString ResetString;  // 0x0170 (0x0010) [0x0000000000000000]
    struct FString ApplyString;  // 0x0180 (0x0010) [0x0000000000000000]
    struct FString
        KeyAlreadyBoundString;        // 0x0190 (0x0010) [0x0000000000000000]
    struct FString PressKeyString;    // 0x01A0 (0x0010) [0x0000000000000000]
    struct FString WarningString;     // 0x01B0 (0x0010) [0x0000000000000000]
    struct FString RebindString;      // 0x01C0 (0x0010) [0x0000000000000000]
    struct FString ClearedString;     // 0x01D0 (0x0010) [0x0000000000000000]
    struct FString CancelString;      // 0x01E0 (0x0010) [0x0000000000000000]
    struct FString AcceptString;      // 0x01F0 (0x0010) [0x0000000000000000]
    struct FString IgnoredKeyString;  // 0x0200 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66359];

        return pClassPointer;
    };

    void ClearInputOnContainer();
    void ResetControls();
    void AcceptBind();
    void SetConflictMessage();
    void SetKeyBind();
    void ResetModKeys();
    void UpdateModKeys();
    void BindKey();
    void ChangeBind();
    void SetSectionBindings();
    void UpdateBindList();
    void UpdateAllBindings();
    void InitalizeCommandList();
    void Initialize();
};

UClass* UKFGFxControlsContainer_Keybinding::pClassPointer = NULL;

// Class KFGame.KFGFxExpandedObjectivesContainer
// 0x0018 (0x00C0 - 0x00A8)
class UKFGFxExpandedObjectivesContainer : public UKFGFxObject_Container {
   public:
    class UKFGFxSpecialEventObjectivesContainer*
        SpecialEventsContainer;  // 0x00A8 (0x0008) [0x0000000000000000]
    class UKFGFxWeeklyObjectivesContainer*
        WeeklyEventContainer;  // 0x00B0 (0x0008) [0x0000000000000000]
    class UKFGFxMenu_StartGame*
        StartMenu;  // 0x00B8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66444];

        return pClassPointer;
    };

    void LocalizeMenu();
    void Refresh();
    void Initialize();
};

UClass* UKFGFxExpandedObjectivesContainer::pClassPointer = NULL;

// Class KFGame.KFGFxWeeklyObjectivesContainer
// 0x0004 (0x00AC - 0x00A8)
class UKFGFxWeeklyObjectivesContainer : public UKFGFxObject_Container {
   public:
    DWORD bInitialDataPopulated : 1;  // 0x00A8 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bLastWeeklyComplete : 1;    // 0x00A8 (0x0004) [0x0000000000000000]
                                      // [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66458];

        return pClassPointer;
    };

    void LocalizeMenu();
    void CreateRewardItem();
    void PopulateRewards();
    void PopulateModifiers();
    void PopulateData();
    void Initialize();
};

UClass* UKFGFxWeeklyObjectivesContainer::pClassPointer = NULL;

// Class KFGame.KFGFxGearContainer_PerksSelection
// 0x0010 (0x00B8 - 0x00A8)
class UKFGFxGearContainer_PerksSelection : public UKFGFxObject_Container {
   public:
    TArray<struct UKFGFxGearContainer_PerksSelection_FPerkData>
        PerksData;  // 0x00A8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66462];

        return pClassPointer;
    };

    void UpdatePerkSelection();
    void LocalizeText();
    void Initialize();
};

UClass* UKFGFxGearContainer_PerksSelection::pClassPointer = NULL;

// Class KFGame.KFGFxHUD_ChatBoxWidget
// 0x0004 (0x00A4 - 0x00A0)
class UKFGFxHUD_ChatBoxWidget : public UGFxObject {
   public:
    DWORD bChatBoxVisible : 1;  // 0x00A0 (0x0004) [0x0000000000000000]
                                // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66487];

        return pClassPointer;
    };

    void ClearAndCloseChat();
    void SetLobbyChatVisible();
    void SetDataObjects();
    void GetDataObjects();
    void OpenInputField();
    void AddChatMessage();
    void Init();
};

UClass* UKFGFxHUD_ChatBoxWidget::pClassPointer = NULL;

// Class KFGame.KFGFxHUD_ObjectiveConatiner
// 0x0000 (0x00A0 - 0x00A0)
class UKFGFxHUD_ObjectiveConatiner : public UGFxObject {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66510];

        return pClassPointer;
    };

    void SetCurrentProgress();
    void SetCurrentIcon();
    void SetActive();
};

UClass* UKFGFxHUD_ObjectiveConatiner::pClassPointer = NULL;

// Class KFGame.KFGFxHUD_PlayerBackpack
// 0x0044 (0x00E4 - 0x00A0)
class UKFGFxHUD_PlayerBackpack : public UGFxObject {
   public:
    class AKFPlayerController* MyKFPC;  // 0x00A0 (0x0008) [0x0000000000000000]
    int LastDosh;                       // 0x00A8 (0x0004) [0x0000000000000000]
    int LastSpareAmmo;                  // 0x00AC (0x0004) [0x0000000000000000]
    unsigned char LastMagazineAmmo;     // 0x00B0 (0x0001) [0x0000000000000000]
    unsigned char LastSecondaryAmmo;    // 0x00B1 (0x0001) [0x0000000000000000]
    DWORD bUsesAmmo : 1;  // 0x00B4 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bWasUsingAltFireMode : 1;  // 0x00B4 (0x0004) [0x0000000000000000]
                                     // [0x00000002]
    DWORD bUsesSecondaryAmmo : 1;    // 0x00B4 (0x0004) [0x0000000000000000]
                                     // [0x00000004]
    int LastFlashlightBattery;       // 0x00B8 (0x0004) [0x0000000000000000]
    int LastGrenades;                // 0x00BC (0x0004) [0x0000000000000000]
    int LastSavedBuild;              // 0x00C0 (0x0004) [0x0000000000000000]
    int LastMaxWeight;               // 0x00C4 (0x0004) [0x0000000000000000]
    int LastWeight;                  // 0x00C8 (0x0004) [0x0000000000000000]
    class UClass* LastPerkClass;     // 0x00CC (0x0008) [0x0000000000000000]
    class AKFWeapon* LastWeapon;     // 0x00D4 (0x0008) [0x0000000000000000]
    class AKFInventoryManager*
        MyKFInvManager;  // 0x00DC (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66518];

        return pClassPointer;
    };

    void SetFlashlightBattery();
    void UpdateFlashlight();
    void RefreshWeapon();
    void UpdateFireModeIcon();
    void UpdateWeapon();
    void UpdateGrenades();
    void UpdateDosh();
    void UpdateWeight();
    void TickHud();
    void InitializeHUD();
};

UClass* UKFGFxHUD_PlayerBackpack::pClassPointer = NULL;

// Class KFGame.KFGFxHUD_PlayerMoveList
// 0x0064 (0x0104 - 0x00A0)
class UKFGFxHUD_PlayerMoveList : public UGFxObject {
   public:
    TArray<struct FHUDMoveInfo>
        CurrentMoves;  // 0x00A0 (0x0010) [0x0000000000000000]
    class UGFxObject*
        MoveListObjectArray;           // 0x00B0 (0x0008) [0x0000000000000000]
    class UTexture2D* ZedIconTexture;  // 0x00B8 (0x0008) [0x0000000000000000]
    class AKFPawn_Monster* MyKFPM;     // 0x00C0 (0x0008) [0x0000000000000000]
    class UKFPlayerInput* MyInput;     // 0x00C8 (0x0008) [0x0000000000000000]
    TArray<struct FString>
        PlayerMoveKeyBinds;  // 0x00D0 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        GamepadMoveKeyBinds;  // 0x00E0 (0x0010) [0x0000000000000000]
    TArray<struct FName>
        GamepadKeyPriority;           // 0x00F0 (0x0010) [0x0000000000000000]
    DWORD bUsingGamepadControls : 1;  // 0x0100 (0x0004) [0x0000000000000000]
                                      // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66576];

        return pClassPointer;
    };

    void ClearMoveList();
    void BuildObjectArray();
    void UpdateMoveList();
    void GetAlternateBindName();
    void InitializeMoveList();
    void TickHud();
    void ChangeOwner();
    void InitializeHUD();
};

UClass* UKFGFxHUD_PlayerMoveList::pClassPointer = NULL;

// Class KFGame.KFGFxHud_PlayerRosterWidget
// 0x0018 (0x00B8 - 0x00A0)
class UKFGFxHud_PlayerRosterWidget : public UGFxObject {
   public:
    TArray<struct FSZedPlayerInfo>
        ZedPlayerInfoList;  // 0x00A0 (0x0010) [0x0000000000000000]
    class APlayerReplicationInfo*
        MyPRI;  // 0x00B0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66626];

        return pClassPointer;
    };

    void UpdatePlayerData();
    void TickHud();
    void InitializeHUD();
};

UClass* UKFGFxHud_PlayerRosterWidget::pClassPointer = NULL;

// Class KFGame.KFGFxHUD_PlayerStatus
// 0x0044 (0x00E4 - 0x00A0)
class UKFGFxHUD_PlayerStatus : public UGFxObject {
   public:
    class AKFPlayerController* MyPC;   // 0x00A0 (0x0008) [0x0000000000000000]
    class AKFPawn_Human* MyHumanPawn;  // 0x00A8 (0x0008) [0x0000000000000000]
    class AKFInventoryManager*
        MyInventoryManager;       // 0x00B0 (0x0008) [0x0000000000000000]
    class UClass* LastPerkClass;  // 0x00B8 (0x0008) [0x0000000000000000]
    int LastPerkLevel;            // 0x00C0 (0x0004) [0x0000000000000000]
    int LastHealth;               // 0x00C4 (0x0004) [0x0000000000000000]
    int LastArmor;                // 0x00C8 (0x0004) [0x0000000000000000]
    float LastHealerAmmoPct;      // 0x00CC (0x0004) [0x0000000000000000]
    int LastEXPValue;             // 0x00D0 (0x0004) [0x0000000000000000]
    struct FString EXPString;     // 0x00D4 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66650];

        return pClassPointer;
    };

    void ShowXPBark();
    void UpdateXP();
    void UpdateArmor();
    void UpdateHealth();
    void UpdatePerk();
    void UpdateHealer();
    void ClearBuffIcons();
    void ShowActiveIndicators();
    void TickHud();
    void LocalizeText();
    void InitializeHUD();
};

UClass* UKFGFxHUD_PlayerStatus::pClassPointer = NULL;

// Class KFGame.KFGFxHUD_PostRoundMenu
// 0x00A0 (0x0140 - 0x00A0)
class UKFGFxHUD_PostRoundMenu : public UGFxObject {
   public:
    class UKFGFxPostRoundContainer_Team*
        TeamOneContainer;  // 0x00A0 (0x0008) [0x0000000000000000]
    class UKFGFxPostRoundContainer_Team*
        TeamTwoContainer;               // 0x00A8 (0x0008) [0x0000000000000000]
    struct FString RoundResultsString;  // 0x00B0 (0x0010) [0x0000000000000000]
    struct FString MatchResultsString;  // 0x00C0 (0x0010) [0x0000000000000000]
    struct FString SurvivorVictory;     // 0x00D0 (0x0010) [0x0000000000000000]
    struct FString ZedVictory;          // 0x00E0 (0x0010) [0x0000000000000000]
    struct FString TieString;           // 0x00F0 (0x0010) [0x0000000000000000]
    struct FString YourTeamString;      // 0x0100 (0x0010) [0x0000000000000000]
    struct FString OpposingTeamString;  // 0x0110 (0x0010) [0x0000000000000000]
    struct FString MatchOnGoingString;  // 0x0120 (0x0010) [0x0000000000000000]
    class AKFTeamInfo_Human*
        WinningTeam;  // 0x0130 (0x0008) [0x0000000000000000]
    class AKFGameReplicationInfo*
        KFGRI;  // 0x0138 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66692];

        return pClassPointer;
    };

    void DisplayProgress();
    void eventWidgetInitialized();
    void LocalizeText();
    void InitializeHUD();
};

UClass* UKFGFxHUD_PostRoundMenu::pClassPointer = NULL;

// Class KFGame.KFGFxPostRoundContainer_Team
// 0x0088 (0x0128 - 0x00A0)
class UKFGFxPostRoundContainer_Team : public UGFxObject {
   public:
    struct FString TitleString;          // 0x00A0 (0x0010) [0x0000000000000000]
    struct FString WavesCompleteString;  // 0x00B0 (0x0010) [0x0000000000000000]
    struct FString BossDeadString;       // 0x00C0 (0x0010) [0x0000000000000000]
    struct FString DeathsString;         // 0x00D0 (0x0010) [0x0000000000000000]
    struct FString DamageString;         // 0x00E0 (0x0010) [0x0000000000000000]
    struct FString TotalString;          // 0x00F0 (0x0010) [0x0000000000000000]
    struct FString YourTeamString;       // 0x0100 (0x0010) [0x0000000000000000]
    struct FString OpponentsString;      // 0x0110 (0x0010) [0x0000000000000000]
    int TeamValue;                       // 0x0120 (0x0004) [0x0000000000000000]
    int TeamID;                          // 0x0124 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66720];

        return pClassPointer;
    };

    void LocalizeText();
    void CreateResultsForTeam();
    void Initialize();
};

UClass* UKFGFxPostRoundContainer_Team::pClassPointer = NULL;

// Class KFGame.KFGFxHUD_ScoreboardMapInfoContainer
// 0x003C (0x00DC - 0x00A0)
class UKFGFxHUD_ScoreboardMapInfoContainer : public UGFxObject {
   public:
    int LastMatchTime;              // 0x00A0 (0x0004) [0x0000000000000000]
    struct FString WaveString;      // 0x00A4 (0x0010) [0x0000000000000000]
    struct FString FinalString;     // 0x00B4 (0x0010) [0x0000000000000000]
    int CurrentGameDifficulty;      // 0x00C4 (0x0004) [0x0000000000000000]
    struct FString GameTypeString;  // 0x00C8 (0x0010) [0x0000000000000000]
    DWORD bLocalized : 1;  // 0x00D8 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66724];

        return pClassPointer;
    };

    void UpdateWaveCount();
    void UpdateMatchInfo();
    void LocalizeText();
    void InitializeHUD();
};

UClass* UKFGFxHUD_ScoreboardMapInfoContainer::pClassPointer = NULL;

// Class KFGame.KFGFxHUD_ScoreboardWidget
// 0x0074 (0x0114 - 0x00A0)
class UKFGFxHUD_ScoreboardWidget : public UGFxObject {
   public:
    DWORD bUpdateScoreboard : 1;     // 0x00A0 (0x0004) [0x0000000000000000]
                                     // [0x00000001]
    float ScoreboardUpdateInterval;  // 0x00A4 (0x0004) [0x0000000000000000]
    float LastScoreboardUpdateTime;  // 0x00A8 (0x0004) [0x0000000000000000]
    class UKFGFxHUD_ScoreboardMapInfoContainer*
        MatchInfoContainer;  // 0x00AC (0x0008) [0x0000000000000000]
    TArray<class AKFPlayerReplicationInfo*>
        CurrentPlayerList;         // 0x00B4 (0x0010) [0x0000000000000000]
    struct FString PlayerString;   // 0x00C4 (0x0010) [0x0000000000000000]
    struct FString DoshString;     // 0x00D4 (0x0010) [0x0000000000000000]
    struct FString KillsString;    // 0x00E4 (0x0010) [0x0000000000000000]
    struct FString AssistsString;  // 0x00F4 (0x0010) [0x0000000000000000]
    struct FString PingString;     // 0x0104 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66744];

        return pClassPointer;
    };

    void UpdatePlayerData();
    void SortPlayerList();
    void UpdatePlayerList();
    void UpdateMatchInfo();
    void SetOpen();
    void ForceUpdateNextFrame();
    void TickHud();
    void eventWidgetInitialized();
    void SendServerInfoToGFX();
    void LocalizeText();
    void InitializeHUD();
};

UClass* UKFGFxHUD_ScoreboardWidget::pClassPointer = NULL;

// Class KFGame.KFGFxHUD_ScoreboardVersusWidget
// 0x001C (0x0130 - 0x0114)
class UKFGFxHUD_ScoreboardVersusWidget : public UKFGFxHUD_ScoreboardWidget {
   public:
    struct FString ScoreString;  // 0x0114 (0x0010) [0x0000000000000000]
    int AssistValue;             // 0x0124 (0x0004) [0x0000000000000000]
    int KillValue;               // 0x0128 (0x0004) [0x0000000000000000]
    int DamageValue;             // 0x012C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66791];

        return pClassPointer;
    };

    void UpdatePlayerData();
    void TickHud();
    void LocalizeText();
};

UClass* UKFGFxHUD_ScoreboardVersusWidget::pClassPointer = NULL;

// Class KFGame.KFGFxHUD_SpectatorInfo
// 0x004C (0x00EC - 0x00A0)
class UKFGFxHUD_SpectatorInfo : public UGFxObject {
   public:
    struct FString PrevPlayerString;    // 0x00A0 (0x0010) [0x0000000000000000]
    struct FString NextPlayerString;    // 0x00B0 (0x0010) [0x0000000000000000]
    struct FString ChangeCameraString;  // 0x00C0 (0x0010) [0x0000000000000000]
    class UGFxObject* SpectatorInfoMC;  // 0x00D0 (0x0008) [0x0000000000000000]
    class AKFPlayerReplicationInfo*
        SpectatedKFPRI;           // 0x00D8 (0x0008) [0x0000000000000000]
    unsigned char LastPerkLevel;  // 0x00E0 (0x0001) [0x0000000000000000]
    class UClass* LastPerkClass;  // 0x00E4 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66808];

        return pClassPointer;
    };

    void UpdatePlayerInfo();
    void UpdateSpectateeInfo();
    void SetSpectatedKFPRI();
    void UpdateUsingGamePad();
    void TickHud();
    void SetPlayerInfoVisible();
    void LocalizeText();
    void InitializeHUD();
};

UClass* UKFGFxHUD_SpectatorInfo::pClassPointer = NULL;

// Class KFGame.KFGFxHUD_SpectatorInfo_Versus
// 0x0000 (0x00EC - 0x00EC)
class UKFGFxHUD_SpectatorInfo_Versus : public UKFGFxHUD_SpectatorInfo {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66835];

        return pClassPointer;
    };

    void UpdatePlayerInfo();
};

UClass* UKFGFxHUD_SpectatorInfo_Versus::pClassPointer = NULL;

// Class KFGame.KFGFxWidget_PartyInGame
// 0x0018 (0x063C - 0x0624)
class UKFGFxWidget_PartyInGame : public UKFGFxWidget_BaseParty {
   public:
    class AKFGameReplicationInfo*
        KFGRI;  // 0x0624 (0x0008) [0x0000000000000000]
    class AKFPlayerReplicationInfo*
        MyKFPRI;  // 0x062C (0x0008) [0x0000000000000000]
    class UGFxObject*
        MatchStartContainer;  // 0x0634 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66841];

        return pClassPointer;
    };

    void KickPlayer();
    void AddFriend();
    void ViewProfile();
    void ToggelMuteOnPlayer();
    void RefreshSlot();
    void RefreshParty();
    void GetKFPRIArray();
    void UpdateVOIP();
    void OneSecondLoop();
    void UpdateReadyButtonVisibility();
    void InitializeWidget();
};

UClass* UKFGFxWidget_PartyInGame::pClassPointer = NULL;

// Class KFGame.KFGFxWidget_PartyInGame_Versus
// 0x0040 (0x067C - 0x063C)
class UKFGFxWidget_PartyInGame_Versus : public UKFGFxWidget_PartyInGame {
   public:
    struct FString SwitchTeamsString;  // 0x063C (0x0010) [0x0000000000000000]
    struct FString
        balanceWarningString;  // 0x064C (0x0010) [0x0000000000000000]
    class UGFxObject*
        SwitchTeamsButton;             // 0x065C (0x0008) [0x0000000000000000]
    class UTexture2D* ZedIconTexture;  // 0x0664 (0x0008) [0x0000000000000000]
    struct FScriptDelegate
        __SortPlayers__Delegate;       // 0x066C (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x0670 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66840];

        return pClassPointer;
    };

    void RefreshSlot();
    void SortPlayers();
    void GetKFPRIArray();
    void UpdateTeams();
    void UpdateBalanceWarning();
    void OneSecondLoop();
    void LocalizeText();
    void InitializeWidget();
};

UClass* UKFGFxWidget_PartyInGame_Versus::pClassPointer = NULL;

// Class KFGame.KFGFxHUD_TraderCompass
// 0x0034 (0x00D4 - 0x00A0)
class UKFGFxHUD_TraderCompass : public UGFxObject {
   public:
    class APlayerController* MyPC;  // 0x00A0 (0x0008) [0x0000000000000000]
    class AKFGameReplicationInfo*
        MyKFGRI;                       // 0x00A8 (0x0008) [0x0000000000000000]
    class UGFxObject* TraderPing;      // 0x00B0 (0x0008) [0x0000000000000000]
    float LastDistToTrader;            // 0x00B8 (0x0004) [0x0000000000000000]
    unsigned char LastArrowDirection;  // 0x00BC (0x0001) [0x0000000000000000]
    float LastViewAngleDotProduct;     // 0x00C0 (0x0004) [0x0000000000000000]
    struct FString TraderString;       // 0x00C4 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[66844];

        return pClassPointer;
    };

    void UpdateTraderCompassPosition();
    void UpdateDistanceToTrader();
    void GetCurrentTraderLocation();
    void TickHud();
    void InitializeHUD();
    void eventWidgetInitialized();
};

UClass* UKFGFxHUD_TraderCompass::pClassPointer = NULL;

// Class KFGame.KFGFxMenu_Exit
// 0x0050 (0x0130 - 0x00E0)
class UKFGFxMenu_Exit : public UKFGFxObject_Menu {
   public:
    struct FString HeaderString;  // 0x00E0 (0x0010) [0x0000000000000000]
    struct FString
        ExitToMainDescription;      // 0x00F0 (0x0010) [0x0000000000000000]
    struct FString ExitToMainMenu;  // 0x0100 (0x0010) [0x0000000000000000]
    struct FString ExitKF2;         // 0x0110 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        OptionStrings;  // 0x0120 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[67075];

        return pClassPointer;
    };

    void OnLeaveGameConfirm();
    void ShowLeaveGamePopUp();
    void ShowExitToOSPopUp();
    void HandleAutoExit();
    void Callback_MenuSelected();
    void SetMenuText();
    void SetExitOptions();
    void OnOpen();
    void InitializeMenu();
};

UClass* UKFGFxMenu_Exit::pClassPointer = NULL;

// Class KFGame.KFGFxMenu_Inventory
// 0x0320 (0x0400 - 0x00E0)
class UKFGFxMenu_Inventory : public UKFGFxObject_Menu {
   public:
    struct FString RecycleOneString;  // 0x00E0 (0x0010) [0x0000000000000000]
    struct FString
        RecycleDuplicatesString;   // 0x00F0 (0x0010) [0x0000000000000000]
    struct FString NoItemsString;  // 0x0100 (0x0010) [0x0000000000000000]
    struct FString
        InventoryPopulatingString;       // 0x0110 (0x0010) [0x0000000000000000]
    struct FString InventoryString;      // 0x0120 (0x0010) [0x0000000000000000]
    struct FString EquipString;          // 0x0130 (0x0010) [0x0000000000000000]
    struct FString UnequipString;        // 0x0140 (0x0010) [0x0000000000000000]
    struct FString UseString;            // 0x0150 (0x0010) [0x0000000000000000]
    struct FString RecycleString;        // 0x0160 (0x0010) [0x0000000000000000]
    struct FString CraftString;          // 0x0170 (0x0010) [0x0000000000000000]
    struct FString AllString;            // 0x0180 (0x0010) [0x0000000000000000]
    struct FString WeaponSkinString;     // 0x0190 (0x0010) [0x0000000000000000]
    struct FString CosmeticString;       // 0x01A0 (0x0010) [0x0000000000000000]
    struct FString EmotesString;         // 0x01B0 (0x0010) [0x0000000000000000]
    struct FString CraftingMatsString;   // 0x01C0 (0x0010) [0x0000000000000000]
    struct FString ItemString;           // 0x01D0 (0x0010) [0x0000000000000000]
    struct FString FiltersString;        // 0x01E0 (0x0010) [0x0000000000000000]
    struct FString CraftWeaponString;    // 0x01F0 (0x0010) [0x0000000000000000]
    struct FString CraftCosmeticString;  // 0x0200 (0x0010) [0x0000000000000000]
    struct FString CraftItemString;      // 0x0210 (0x0010) [0x0000000000000000]
    struct FString
        ConfirmCraftItemString;  // 0x0220 (0x0010) [0x0000000000000000]
    struct FString
        RecycleWarningString;          // 0x0230 (0x0010) [0x0000000000000000]
    struct FString RecycleItemString;  // 0x0240 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        CraftWeaponStrings;  // 0x0250 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        CraftCosmeticStrings;  // 0x0260 (0x0010) [0x0000000000000000]
    struct FString
        FailedToExchangeString;      // 0x0270 (0x0010) [0x0000000000000000]
    struct FString MoreItemsString;  // 0x0280 (0x0010) [0x0000000000000000]
    struct FString
        ItemExchangeTimeOutString;  // 0x0290 (0x0010) [0x0000000000000000]
    struct FString TryAgainString;  // 0x02A0 (0x0010) [0x0000000000000000]
    struct FString
        FailedToCraftItemString;  // 0x02B0 (0x0010) [0x0000000000000000]
    struct FString
        CraftRequirementString;  // 0x02C0 (0x0010) [0x0000000000000000]
    struct FString
        CraftCosmeticDescriptionString;  // 0x02D0 (0x0010) [0x0000000000000000]
    struct FString
        CraftWeaponDescriptionString;  // 0x02E0 (0x0010) [0x0000000000000000]
    struct FString RequiresString;     // 0x02F0 (0x0010) [0x0000000000000000]
    struct FString PurchaseKeyString;  // 0x0300 (0x0010) [0x0000000000000000]
    struct FString
        LookUpOnMarketString;           // 0x0310 (0x0010) [0x0000000000000000]
    class UGFxObject* CraftingSubMenu;  // 0x0320 (0x0008) [0x0000000000000000]
    class UGFxObject*
        ItemListContainer;  // 0x0328 (0x0008) [0x0000000000000000]
    class UGFxObject*
        ItemDetailsContainer;       // 0x0330 (0x0008) [0x0000000000000000]
    class UGFxObject* EquipButton;  // 0x0338 (0x0008) [0x0000000000000000]
    class UGFxObject*
        CraftWeaponButton;  // 0x0340 (0x0008) [0x0000000000000000]
    class UGFxObject*
        CraftCosmeticButton;            // 0x0348 (0x0008) [0x0000000000000000]
    class UOnlineSubsystem* OnlineSub;  // 0x0350 (0x0008) [0x0000000000000000]
    class UPlayfabInterface*
        PlayfabInter;                   // 0x0358 (0x0008) [0x0000000000000000]
    class AKFPawn_Customization* KFPH;  // 0x0360 (0x0008) [0x0000000000000000]
    DWORD
        bInitialInventoryPassComplete : 1;  // 0x0368 (0x0004)
                                            // [0x0000000000000000] [0x00000001]
    int TempItemIdHolder;               // 0x036C (0x0004) [0x0000000000000000]
    int UncommonCosmeticID;             // 0x0370 (0x0004) [0x0000000000000000]
    int RareCosmeticID;                 // 0x0374 (0x0004) [0x0000000000000000]
    int ExceptionalCosmeticID;          // 0x0378 (0x0004) [0x0000000000000000]
    int MasterCosmeticID;               // 0x037C (0x0004) [0x0000000000000000]
    int UncommonWeaponID;               // 0x0380 (0x0004) [0x0000000000000000]
    int RareWeaponID;                   // 0x0384 (0x0004) [0x0000000000000000]
    int ExceptionalWeaponID;            // 0x0388 (0x0004) [0x0000000000000000]
    int MasterWeaponID;                 // 0x038C (0x0004) [0x0000000000000000]
    struct FName SoundEvent_Common;     // 0x0390 (0x0008) [0x0000000000000000]
    struct FName SoundEvent_Uncommon;   // 0x0398 (0x0008) [0x0000000000000000]
    struct FName SoundEvent_Rare;       // 0x03A0 (0x0008) [0x0000000000000000]
    struct FName SoundEvent_Legendary;  // 0x03A8 (0x0008) [0x0000000000000000]
    struct FName
        SoundEvent_ExceedinglyRare;     // 0x03B0 (0x0008) [0x0000000000000000]
    struct FName SoundEvent_Mythical;   // 0x03B8 (0x0008) [0x0000000000000000]
    struct FName SoundThemeName;        // 0x03C0 (0x0008) [0x0000000000000000]
    class AKFPlayerController* KFPC;    // 0x03C8 (0x0008) [0x0000000000000000]
    int ValueToPromptDuplicateRecycle;  // 0x03D0 (0x0004) [0x0000000000000000]
    TArray<int> SpecialEventItemIDs;    // 0x03D4 (0x0010) [0x0000000000000000]
    unsigned char
        CurrentInventoryFilter;  // 0x03E4 (0x0001) [0x0000000000000000]
    struct FExchangeRuleSets
        RuleToExchange;  // 0x03E8 (0x0018) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[67366];

        return pClassPointer;
    };

    void Callback_PreviewItem();
    void CallBack_RequestWeaponCraftInfo();
    void CallBack_RequestCosmeticCraftInfo();
    void Callback_CraftOption();
    void Callback_RecycleItem();
    void Callback_CharacterSkin();
    void Callback_UseItem();
    void CallBack_ItemDetailsClicked();
    void Callback_Equip();
    void Callback_InventoryFilter();
    void Callback_RequestInitialnventory();
    void Callback_CrateOpenComplete();
    void GetItemCount();
    void ConfirmCraft();
    void CancelRecycle();
    void ConfirmDuplicatesRecycle();
    void ExchangeDuplicatesEx();
    void ConfirmRecycle();
    void PerformExchange();
    void OnPlayfabExchangeComplete();
    void GetCountOfItem();
    void SetCosmeticCraftDetails();
    void SetWeaponCraftDetails();
    void LocalizeText();
    void IsItemActive();
    void IsSpecialEventItem();
    void IsItemExchangeable();
    void IsItemRecyclable();
    void OnInventoryReadComplete();
    void OnReadPlayfabInventoryComplete();
    void ClearMatinee();
    void SetMatineeColor();
    void FinishCraft();
    void OnItemExhangeTimeOut();
    void InitInventory();
    void OnClose();
    void OnOpen();
    void UpdateCraftButtons();
    void InitializeMenu();
};

UClass* UKFGFxMenu_Inventory::pClassPointer = NULL;

// Class KFGame.KFInventoryCatalog
// 0x0010 (0x0070 - 0x0060)
class UKFInventoryCatalog : public UObject {
   public:
    TArray<struct FItemCatalogEntry>
        ItemKeyArray;  // 0x0060 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[67530];

        return pClassPointer;
    };

    void GetItemSeries();
    void GetItemDisplayContainerType();
};

UClass* UKFInventoryCatalog::pClassPointer = NULL;

// Class KFGame.KFGFxPerksContainer
// 0x0010 (0x00B8 - 0x00A8)
class UKFGFxPerksContainer : public UKFGFxObject_Container {
   public:
    struct FString LevelString;  // 0x00A8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[67720];

        return pClassPointer;
    };
};

UClass* UKFGFxPerksContainer::pClassPointer = NULL;

// Class KFGame.KFGFxPerksContainer_Header
// 0x0030 (0x00E8 - 0x00B8)
class UKFGFxPerksContainer_Header : public UKFGFxPerksContainer {
   public:
    class UGFxObject* PerkTextField;     // 0x00B8 (0x0008) [0x0000000000000000]
    class UGFxObject* LevelTextField;    // 0x00C0 (0x0008) [0x0000000000000000]
    struct FString PrestigeLevelString;  // 0x00C8 (0x0010) [0x0000000000000000]
    struct FString ExperienceString;     // 0x00D8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[67719];

        return pClassPointer;
    };

    void UpdatePerkHeader();
    void Initialize();
};

UClass* UKFGFxPerksContainer_Header::pClassPointer = NULL;

// Class KFGame.KFGFxPerksContainer_Selection
// 0x0068 (0x0120 - 0x00B8)
class UKFGFxPerksContainer_Selection : public UKFGFxPerksContainer {
   public:
    struct FString HeaderTitle;      // 0x00B8 (0x0010) [0x0000000000000000]
    struct FString EndOfWaveString;  // 0x00C8 (0x0010) [0x0000000000000000]
    struct FString
        ChangesAppliedOnCloseString;   // 0x00D8 (0x0010) [0x0000000000000000]
    struct FString OncePerWaveString;  // 0x00E8 (0x0010) [0x0000000000000000]
    TArray<struct UKFGFxPerksContainer_Selection_FPerkData>
        PerksData;                      // 0x00F8 (0x0010) [0x0000000000000000]
    class UKFGFxMenu_Perks* PerksMenu;  // 0x0108 (0x0008) [0x0000000000000000]
    class AKFGameReplicationInfo*
        KFGRI;  // 0x0110 (0x0008) [0x0000000000000000]
    class AKFPlayerReplicationInfo*
        KFPRI;  // 0x0118 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[67721];

        return pClassPointer;
    };

    void SavePerk();
    void SetPendingPerkChanges();
    void UpdatePendingPerkInfo();
    void SetPerkListEnabled();
    void UpdatePerkSelection();
    void LocalizeText();
    void Initialize();
};

UClass* UKFGFxPerksContainer_Selection::pClassPointer = NULL;

// Class KFGame.KFGFxPerksContainer_Details
// 0x0040 (0x00F8 - 0x00B8)
class UKFGFxPerksContainer_Details : public UKFGFxPerksContainer {
   public:
    struct FString ExperienceString;    // 0x00B8 (0x0010) [0x0000000000000000]
    struct FString ObjectivesString;    // 0x00C8 (0x0010) [0x0000000000000000]
    struct FString PerkBonusesString;   // 0x00D8 (0x0010) [0x0000000000000000]
    struct FString BasicLoadoutString;  // 0x00E8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[67722];

        return pClassPointer;
    };

    void UpdatePassives();
    void AddWeaponInfo();
    void UpdateDetails();
    void LocalizeContainer();
    void Initialize();
};

UClass* UKFGFxPerksContainer_Details::pClassPointer = NULL;

// Class KFGame.KFGFxPerksContainer_Skills
// 0x0024 (0x00DC - 0x00B8)
class UKFGFxPerksContainer_Skills : public UKFGFxPerksContainer {
   public:
    int MAX_SLOTS;  // 0x00B8 (0x0004) [0x0000000000000000]
    struct FString
        ConfigureSkillsString;        // 0x00BC (0x0010) [0x0000000000000000]
    struct FString BackButtonString;  // 0x00CC (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[67723];

        return pClassPointer;
    };

    void GetSkillObject();
    void UpdateTierUnlockState();
    void UpdateSkills();
    void LocalizeContainer();
    void Initialize();
};

UClass* UKFGFxPerksContainer_Skills::pClassPointer = NULL;

// Class KFGame.KFGFxPerksContainer_SkillsSummary
// 0x0030 (0x00E8 - 0x00B8)
class UKFGFxPerksContainer_SkillsSummary : public UKFGFxPerksContainer {
   public:
    class UKFGFxMenu_Perks* PerkMenu;  // 0x00B8 (0x0008) [0x0000000000000000]
    unsigned char
        SelectedSkillsHolder[0x5];   // 0x00C0 (0x0005) [0x0000000000000000]
    struct FString ConfigureString;  // 0x00C8 (0x0010) [0x0000000000000000]
    struct FString SkillsString;     // 0x00D8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[67724];

        return pClassPointer;
    };

    void UpdateSkills();
    void LocalizeContainer();
    void DelayedRefresh();
    void Initialize();
};

UClass* UKFGFxPerksContainer_SkillsSummary::pClassPointer = NULL;

// Class KFGame.KFGFxMenu_PostGameReport
// 0x00F4 (0x01D4 - 0x00E0)
class UKFGFxMenu_PostGameReport : public UKFGFxObject_Menu {
   public:
    struct FString MapVoteString;      // 0x00E0 (0x0010) [0x0000000000000000]
    struct FString PlayerStatsString;  // 0x00F0 (0x0010) [0x0000000000000000]
    struct FString TeamAwardsString;   // 0x0100 (0x0010) [0x0000000000000000]
    struct FString
        PostGameReportString;            // 0x0110 (0x0010) [0x0000000000000000]
    struct FString NextMapString;        // 0x0120 (0x0010) [0x0000000000000000]
    struct FString WaveString;           // 0x0130 (0x0010) [0x0000000000000000]
    struct FString XPString;             // 0x0140 (0x0010) [0x0000000000000000]
    struct FString VictoryString;        // 0x0150 (0x0010) [0x0000000000000000]
    struct FString DefeatString;         // 0x0160 (0x0010) [0x0000000000000000]
    struct FString ItemDropTitleString;  // 0x0170 (0x0010) [0x0000000000000000]
    class UKFGFxPostGameContainer_PlayerStats*
        PlayerStatsContainer;  // 0x0180 (0x0008) [0x0000000000000000]
    class UKFGFxPostGameContainer_MapVote*
        MapVoteContainer;  // 0x0188 (0x0008) [0x0000000000000000]
    class UKFGFxPostGameContainer_TeamAwards*
        TeamAwardsContainer;  // 0x0190 (0x0008) [0x0000000000000000]
    class UKFGFxPostGameContainer_PlayerXP*
        playerXPContainer;  // 0x0198 (0x0008) [0x0000000000000000]
    class UKFGFxHUD_ChatBoxWidget*
        ChatBoxWidget;                  // 0x01A0 (0x0008) [0x0000000000000000]
    class UOnlineSubsystem* OnlineSub;  // 0x01A8 (0x0008) [0x0000000000000000]
    int LastNextMapTimeRemaining;       // 0x01B0 (0x0004) [0x0000000000000000]
    TArray<class AKFPlayerReplicationInfo*>
        CurrentPlayerList;  // 0x01B4 (0x0010) [0x0000000000000000]
    TArray<class AKFPlayerReplicationInfo*>
        TalkerPRIs;  // 0x01C4 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[67726];

        return pClassPointer;
    };

    void Callback_MapVote();
    void Callback_BroadcastChatMessage();
    void StartCountdown();
    void RecieveTopMaps();
    void ReceiveMessage();
    void eventWidgetInitialized();
    void OnClose();
    void OnOpen();
    void FormatTime();
    void UpdateNextMapTime();
    void VOIPEventTriggered();
    void SendVoipData();
    void InitPlayerList();
    void SetPlayerInfo();
    void SetSumarryInfo();
    void OnItemRecieved();
    void SearchInventoryForNewItem();
    void OnProcessEndGameRewardsComplete();
    void SearchPlayfabInventoryForNewItem();
    void LocalizeText();
    void OneSecondLoop();
    void InitializeMenu();
};

UClass* UKFGFxMenu_PostGameReport::pClassPointer = NULL;

// Class KFGame.KFGFxPostGameContainer_PlayerStats
// 0x00C4 (0x016C - 0x00A8)
class UKFGFxPostGameContainer_PlayerStats : public UKFGFxObject_Container {
   public:
    struct FString AchievementsString;  // 0x00A8 (0x0010) [0x0000000000000000]
    struct FString ZedKillsString;      // 0x00B8 (0x0010) [0x0000000000000000]
    struct FString TopWeaponsString;    // 0x00C8 (0x0010) [0x0000000000000000]
    struct FString
        TotalDamageDealtString;          // 0x00D8 (0x0010) [0x0000000000000000]
    struct FString HeadShotsString;      // 0x00E8 (0x0010) [0x0000000000000000]
    struct FString LargeZedKillsString;  // 0x00F8 (0x0010) [0x0000000000000000]
    struct FString
        TotalDoshEarnedString;         // 0x0108 (0x0010) [0x0000000000000000]
    struct FString TotalKillsString;   // 0x0118 (0x0010) [0x0000000000000000]
    struct FString AssistsString;      // 0x0128 (0x0010) [0x0000000000000000]
    struct FString DamageDealtString;  // 0x0138 (0x0010) [0x0000000000000000]
    struct FString KnifeString;        // 0x0148 (0x0010) [0x0000000000000000]
    struct FString PlayerStatsString;  // 0x0158 (0x0010) [0x0000000000000000]
    int ItemCount;                     // 0x0168 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[67851];

        return pClassPointer;
    };

    void MakeAwardObject();
    void MakeWeaponObject();
    void MakeZedKillObject();
    void MakeTextObject();
    void SetPlayerStats();
    void LocalizeText();
    void Initialize();
};

UClass* UKFGFxPostGameContainer_PlayerStats::pClassPointer = NULL;

// Class KFGame.KFGFxPostGameContainer_MapVote
// 0x0030 (0x00D8 - 0x00A8)
class UKFGFxPostGameContainer_MapVote : public UKFGFxObject_Container {
   public:
    struct FString YourVoteString;  // 0x00A8 (0x0010) [0x0000000000000000]
    struct FString TopVotesString;  // 0x00B8 (0x0010) [0x0000000000000000]
    struct FString MapVoteString;   // 0x00C8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[67853];

        return pClassPointer;
    };

    void GetMapSource();
    void IndexToTopMapObject();
    void RecieveTopMaps();
    void SetMapOptions();
    void LocalizeText();
    void Initialize();
};

UClass* UKFGFxPostGameContainer_MapVote::pClassPointer = NULL;

// Class KFGame.KFGFxPostGameContainer_TeamAwards
// 0x0038 (0x00E0 - 0x00A8)
class UKFGFxPostGameContainer_TeamAwards : public UKFGFxObject_Container {
   public:
    struct FString
        NoTeamAwardsGivenString;         // 0x00A8 (0x0010) [0x0000000000000000]
    struct FString TeamAwardsString;     // 0x00B8 (0x0010) [0x0000000000000000]
    struct FString PersonalBestsString;  // 0x00C8 (0x0010) [0x0000000000000000]
    class UGFxObject*
        NoAwardsTextField;  // 0x00D8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[67855];

        return pClassPointer;
    };

    void SendTeamAwards();
    void SendPersonalBests();
    void LocalizeText();
    void Initialize();
};

UClass* UKFGFxPostGameContainer_TeamAwards::pClassPointer = NULL;

// Class KFGame.KFGFxPostGameContainer_PlayerXP
// 0x0004 (0x00AC - 0x00A8)
class UKFGFxPostGameContainer_PlayerXP : public UKFGFxObject_Container {
   public:
    int ItemCount;  // 0x00A8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[67856];

        return pClassPointer;
    };

    void MakePerkXPObject();
    void SetXPList();
    void Initialize();
};

UClass* UKFGFxPostGameContainer_PlayerXP::pClassPointer = NULL;

// Class KFGame.KFGFxMenu_ServerBrowser
// 0x0208 (0x02E8 - 0x00E0)
class UKFGFxMenu_ServerBrowser : public UKFGFxObject_Menu {
   public:
    class UGFxObject*
        ServerBrowserHeader;  // 0x00E0 (0x0008) [0x0000000000000000]
    class UKFGFxServerBrowser_ServerList*
        ServerListContainer;  // 0x00E8 (0x0008) [0x0000000000000000]
    class UKFGFxServerBrowser_Filters*
        FiltersContainer;  // 0x00F0 (0x0008) [0x0000000000000000]
    class UKFGFxServerBrowser_ServerDetails*
        ServerDetailsContainer;  // 0x00F8 (0x0008) [0x0000000000000000]
    DWORD
        ApplyFilters : 1;  // 0x0100 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bLogServerBrowser : 1;         // 0x0100 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bUIComponentsInit : 1;         // 0x0100 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD bJoiningAsSpectator : 1;       // 0x0100 (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    struct FString FavoriteString;       // 0x0104 (0x0010) [0x0000000000000000]
    struct FString NameString;           // 0x0114 (0x0010) [0x0000000000000000]
    struct FString RefreshString;        // 0x0124 (0x0010) [0x0000000000000000]
    struct FString ServerBrowserString;  // 0x0134 (0x0010) [0x0000000000000000]
    struct FString RankedString;         // 0x0144 (0x0010) [0x0000000000000000]
    struct FString UnrankedString;       // 0x0154 (0x0010) [0x0000000000000000]
    struct FString DedicatedString;      // 0x0164 (0x0010) [0x0000000000000000]
    struct FString VACSecureString;      // 0x0174 (0x0010) [0x0000000000000000]
    struct FString InLobbyString;        // 0x0184 (0x0010) [0x0000000000000000]
    struct FString InProgressString;     // 0x0194 (0x0010) [0x0000000000000000]
    struct FString BackString;           // 0x01A4 (0x0010) [0x0000000000000000]
    struct FString ApplyString;          // 0x01B4 (0x0010) [0x0000000000000000]
    struct FString ResetString;          // 0x01C4 (0x0010) [0x0000000000000000]
    struct FString PingString;           // 0x01D4 (0x0010) [0x0000000000000000]
    struct FString LengthString;         // 0x01E4 (0x0010) [0x0000000000000000]
    struct FString DifficultyString;     // 0x01F4 (0x0010) [0x0000000000000000]
    struct FString MapString;            // 0x0204 (0x0010) [0x0000000000000000]
    struct FString GameModeString;       // 0x0214 (0x0010) [0x0000000000000000]
    struct FString FiltersString;        // 0x0224 (0x0010) [0x0000000000000000]
    struct FString SearchString;         // 0x0234 (0x0010) [0x0000000000000000]
    struct FString WaveString;           // 0x0244 (0x0010) [0x0000000000000000]
    struct FString PlayersString;        // 0x0254 (0x0010) [0x0000000000000000]
    struct FString ZedCountString;       // 0x0264 (0x0010) [0x0000000000000000]
    struct FString GamesFoundString;     // 0x0274 (0x0010) [0x0000000000000000]
    struct FString
        PasswordPromptString;        // 0x0284 (0x0010) [0x0000000000000000]
    struct FString JoinString;       // 0x0294 (0x0010) [0x0000000000000000]
    struct FString LeaveMenuString;  // 0x02A4 (0x0010) [0x0000000000000000]
    struct FString
        MultiplayerMenuString;  // 0x02B4 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        PingOptionStrings;              // 0x02C4 (0x0010) [0x0000000000000000]
    TArray<struct FString> TabStrings;  // 0x02D4 (0x0010) [0x0000000000000000]
    int WidgetsInited;                  // 0x02E4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[67858];

        return pClassPointer;
    };

    void OneSecondLoop();
    void Callback_ResetFilters();
    void CallBack_ServerSelected();
    void CallBack_ServerDetailsClicked();
    void CallBack_ServerSpectateGame();
    void eventOnClose();
    void OnOpen();
    void OnCancelPassword();
    void OnAttemptPassword();
    void ShowPasswordPopUp();
    void CallBack_ServerJoinGame();
    void CallBack_ServerJoinGameWithPassword();
    void CallBack_ServerRefesh();
    void CallBack_ServerFavorited();
    void CallBack_SearchTabChanged();
    void Callback_PingFilter();
    void Callback_MapFilter();
    void Callback_DifficultyFilter();
    void Callback_LengthFilter();
    void Callback_ModeFilter();
    void Callback_SortList();
    void Callback_FilterChanged();
    void CallBack_FiltersApplied();
    void Callback_RefreshServer();
    void Callback_CloseServerBrowser();
    void CloseMenu();
    void SetAllowSpectate();
    void OnLobbyStatusChanged();
    void HandleCloseRequest();
    void ApproveServerBroswerLeave();
    void GoToMultiplayerMenu();
    void CancelGameSearch();
    void CancelLeaveMenu();
    void LocalizeTabs();
    void OnContainerOpen();
    void eventWidgetInitialized();
    void InitializeMenu();
};

UClass* UKFGFxMenu_ServerBrowser::pClassPointer = NULL;

// Class KFGame.KFGFxServerBrowser_ServerDetails
// 0x0058 (0x0100 - 0x00A8)
class UKFGFxServerBrowser_ServerDetails : public UKFGFxObject_Container {
   public:
    class UKFGFxMenu_ServerBrowser*
        ServerMenu;                     // 0x00A8 (0x0008) [0x0000000000000000]
    struct FString MutatorsString;      // 0x00B0 (0x0010) [0x0000000000000000]
    struct FString ServerInfoString;    // 0x00C0 (0x0010) [0x0000000000000000]
    struct FString JoinGameString;      // 0x00D0 (0x0010) [0x0000000000000000]
    struct FString SpectateGameString;  // 0x00E0 (0x0010) [0x0000000000000000]
    struct FString UnfavoriteString;    // 0x00F0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[67977];

        return pClassPointer;
    };

    void GetMapSource();
    void UpdatePlayerList();
    void CreatePlayerListGFXObject();
    void SetDetails();
    void SetFavoriteButtonActive();
    void GetFavoriteButtonActive();
    void LocalizeText();
    void Initialize();
};

UClass* UKFGFxServerBrowser_ServerDetails::pClassPointer = NULL;

// Class KFGame.KFGFxStartGameContainer_FindGame
// 0x0068 (0x0110 - 0x00A8)
class UKFGFxStartGameContainer_FindGame : public UKFGFxObject_Container {
   public:
    class UKFGFxMenu_StartGame*
        StartMenu;  // 0x00A8 (0x0008) [0x0000000000000000]
    TArray<struct FSWhatsNew>
        WhatsNewItems;  // 0x00B0 (0x0010) [0x0000000000000000]
    TArray<struct FSWhatsNew>
        PS4WhatsNewItems;  // 0x00C0 (0x0010) [0x0000000000000000]
    TArray<struct FSWhatsNew>
        PS4ActiveWhatsNewItems;        // 0x00D0 (0x0010) [0x0000000000000000]
    struct FString MultiplayerString;  // 0x00E0 (0x0010) [0x0000000000000000]
    struct FString SoloString;         // 0x00F0 (0x0010) [0x0000000000000000]
    struct FString TutorialString;     // 0x0100 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68268];

        return pClassPointer;
    };

    void LocalizeMenu();
    void SetWhatsNewItems();
    void DisableSoloButton();
    void Initialize();
};

UClass* UKFGFxStartGameContainer_FindGame::pClassPointer = NULL;

// Class KFGame.KFGFxStartContainer_InGameOverview
// 0x0078 (0x0120 - 0x00A8)
class UKFGFxStartContainer_InGameOverview : public UKFGFxObject_Container {
   public:
    class UKFGFxMenu_StartGame*
        StartMenu;                       // 0x00A8 (0x0008) [0x0000000000000000]
    unsigned char LastDifficultyIndex;   // 0x00B0 (0x0001) [0x0000000000000000]
    unsigned char LastLengthIndex;       // 0x00B1 (0x0001) [0x0000000000000000]
    unsigned char LastPrivacyIndex;      // 0x00B2 (0x0001) [0x0000000000000000]
    struct FString OverviewString;       // 0x00B4 (0x0010) [0x0000000000000000]
    struct FString ChangeString;         // 0x00C4 (0x0010) [0x0000000000000000]
    struct FString AuthorString;         // 0x00D4 (0x0010) [0x0000000000000000]
    struct FString SharedByString;       // 0x00E4 (0x0010) [0x0000000000000000]
    struct FString SharedContentString;  // 0x00F4 (0x0010) [0x0000000000000000]
    class UGFxObject*
        SharedContentButton;  // 0x0104 (0x0008) [0x0000000000000000]
    class UGFxObject*
        ServerWelcomeScreen;   // 0x010C (0x0008) [0x0000000000000000]
    DWORD bContentShared : 1;  // 0x0114 (0x0004) [0x0000000000000000]
                               // [0x00000001]
    class UKFHTTPImageDownloader*
        ImageDownLoader;  // 0x0118 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68274];

        return pClassPointer;
    };

    void SetCurrentMapInfo();
    void UpdateOverviewInGame();
    void UpdatePrivacy();
    void UpdateServerType();
    void UpdateLength();
    void UpdateDifficulty();
    void UpdateMap();
    void UpdateGameMode();
    void GetKFPRIArray();
    void UpdateSharedContent();
    void ShowWelcomeScreen();
    void ImageDownloadComplete();
    void LocalizeWelcomeScreen();
    void LocalizeContainer();
    void HideLengthInfo();
    void Initialize();
};

UClass* UKFGFxStartContainer_InGameOverview::pClassPointer = NULL;

// Class KFGame.KFGFxMissionObjectivesContainer
// 0x0014 (0x00BC - 0x00A8)
class UKFGFxMissionObjectivesContainer : public UKFGFxObject_Container {
   public:
    class UKFGFxCollapsedObjectivesContainer*
        CollapsedObjectiveContainer;  // 0x00A8 (0x0008) [0x0000000000000000]
    class UKFGFxExpandedObjectivesContainer*
        ExpandedObjectiveContainer;  // 0x00B0 (0x0008) [0x0000000000000000]
    DWORD bInitialAutoExpandCheckComplete : 1;  // 0x00B8 (0x0004)
                                                // [0x0000000000000000]
                                                // [0x00000001]
    DWORD bLastShowSpecialEvent : 1;  // 0x00B8 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bLastShowWeekly : 1;        // 0x00B8 (0x0004) [0x0000000000000000]
                                      // [0x00000004]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68276];

        return pClassPointer;
    };

    void Refresh();
    void ShowShouldSpecialEvent();
    void UpdateSpecialEventActive();
    void UpdateWeeklyUIActive();
    void UpdateMissionObjectiveState();
    void Initialize();
};

UClass* UKFGFxMissionObjectivesContainer::pClassPointer = NULL;

// Class KFGame.KFGFxStartContainer_ServerBrowserOverview
// 0x0020 (0x00C8 - 0x00A8)
class UKFGFxStartContainer_ServerBrowserOverview
    : public UKFGFxObject_Container {
   public:
    struct FString DescriptionString;  // 0x00A8 (0x0010) [0x0000000000000000]
    struct FString OverviewString;     // 0x00B8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68279];

        return pClassPointer;
    };

    void SetDescriptionString();
    void LocalizeContainer();
    void Initialize();
};

UClass* UKFGFxStartContainer_ServerBrowserOverview::pClassPointer = NULL;

// Class KFGame.KFGFxSummerSideShowObjectivesContainer
// 0x0000 (0x0138 - 0x0138)
class UKFGFxSummerSideShowObjectivesContainer
    : public UKFGFxSpecialEventObjectivesContainer {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68280];

        return pClassPointer;
    };

    void Initialize();
};

UClass* UKFGFxSummerSideShowObjectivesContainer::pClassPointer = NULL;

// Class KFGame.KFGFxStoreContainer_Details
// 0x0030 (0x00D8 - 0x00A8)
class UKFGFxStoreContainer_Details : public UKFGFxObject_Container {
   public:
    struct FString AddToCartString;  // 0x00A8 (0x0010) [0x0000000000000000]
    struct FString PreviewString;    // 0x00B8 (0x0010) [0x0000000000000000]
    struct FString
        LookUpOnMarketString;  // 0x00C8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68318];

        return pClassPointer;
    };

    void LocalizeText();
    void Initialize();
};

UClass* UKFGFxStoreContainer_Details::pClassPointer = NULL;

// Class KFGame.KFGFxStoreContainer_Main
// 0x0069 (0x0111 - 0x00A8)
class UKFGFxStoreContainer_Main : public UKFGFxObject_Container {
   public:
    struct FString
        WeaponSkinsRotationString;     // 0x00A8 (0x0010) [0x0000000000000000]
    struct FString WeaponSkinsString;  // 0x00B8 (0x0010) [0x0000000000000000]
    struct FString
        MarketConsumablesString;  // 0x00C8 (0x0010) [0x0000000000000000]
    struct FString
        MarketCosmeticsString;          // 0x00D8 (0x0010) [0x0000000000000000]
    struct FString MarketEmotesString;  // 0x00E8 (0x0010) [0x0000000000000000]
    struct FString
        LookUpOnMarketString;           // 0x00F8 (0x0010) [0x0000000000000000]
    class UKFGFxMenu_Store* StoreMenu;  // 0x0108 (0x0008) [0x0000000000000000]
    unsigned char CurrentStoreFilter;   // 0x0110 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68322];

        return pClassPointer;
    };

    void IsFilterSame();
    void CreateStoreItem();
    void SendItems();
    void UpdateFilter();
    void LocalizeText();
    void Initialize();
};

UClass* UKFGFxStoreContainer_Main::pClassPointer = NULL;

// Class KFGame.KFGFxStoreContainer_Cart
// 0x0030 (0x00D8 - 0x00A8)
class UKFGFxStoreContainer_Cart : public UKFGFxObject_Container {
   public:
    struct FString CartString;      // 0x00A8 (0x0010) [0x0000000000000000]
    struct FString TotalString;     // 0x00B8 (0x0010) [0x0000000000000000]
    struct FString CheckOutString;  // 0x00C8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68324];

        return pClassPointer;
    };

    void LocalizeText();
    void Initialize();
};

UClass* UKFGFxStoreContainer_Cart::pClassPointer = NULL;

// Class KFGame.KFGFxTraderContainer_GameInfo
// 0x0030 (0x00D8 - 0x00A8)
class UKFGFxTraderContainer_GameInfo : public UKFGFxObject_Container {
   public:
    struct FString TimeLeftString;  // 0x00A8 (0x0010) [0x0000000000000000]
    struct FString WaveString;      // 0x00B8 (0x0010) [0x0000000000000000]
    struct FString BossWaveString;  // 0x00C8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68440];

        return pClassPointer;
    };

    void SetCurrentWeight();
    void SetDosh();
    void UpdateTraderTimer();
    void UpdateGameInfo();
    void Initialize();
};

UClass* UKFGFxTraderContainer_GameInfo::pClassPointer = NULL;

// Class KFGame.KFGFxTraderContainer_Filter
// 0x0050 (0x00F8 - 0x00A8)
class UKFGFxTraderContainer_Filter : public UKFGFxObject_Container {
   public:
    TArray<struct FString> TabsArray;  // 0x00A8 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        WeaponTypeStrings;         // 0x00B8 (0x0010) [0x0000000000000000]
    struct FString OffPerkString;  // 0x00C8 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        TabIconPaths;  // 0x00D8 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        WeaponTypePath;  // 0x00E8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68441];

        return pClassPointer;
    };

    void SetTabsData();
    void SetTypeFilterData();
    void SetPerkFilterData();
    void ClearFilters();
};

UClass* UKFGFxTraderContainer_Filter::pClassPointer = NULL;

// Class KFGame.KFGFxTraderContainer_Store
// 0x0030 (0x00D8 - 0x00A8)
class UKFGFxTraderContainer_Store : public UKFGFxObject_Container {
   public:
    class UKFGFxMenu_Trader*
        MyTraderMenu;  // 0x00A8 (0x0008) [0x0000000000000000]
    TArray<struct FSTraderItem>
        SlotsItemList;                // 0x00B0 (0x0010) [0x0000000000000000]
    struct FString TraderString;      // 0x00C0 (0x0010) [0x0000000000000000]
    class AKFPlayerController* KFPC;  // 0x00D0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68442];

        return pClassPointer;
    };

    void IsItemFiltered();
    void SetItemInfo();
    void RefreshAllItems();
    void RefreshFavoriteItems();
    void RefreshItemsByType();
    void RefreshWeaponListByPerk();
    void SetSelectedIndex();
    void OnTraderReopened();
    void DelayedRefresh();
    void LocalizeContainer();
    void Initialize();
};

UClass* UKFGFxTraderContainer_Store::pClassPointer = NULL;

// Class KFGame.KFGFxTraderContainer_PlayerInventory
// 0x0074 (0x011C - 0x00A8)
class UKFGFxTraderContainer_PlayerInventory : public UKFGFxObject_Container {
   public:
    class UKFGFxMenu_Trader*
        MyTraderMenu;                 // 0x00A8 (0x0008) [0x0000000000000000]
    struct FString FillString;        // 0x00B0 (0x0010) [0x0000000000000000]
    struct FString MagString;         // 0x00C0 (0x0010) [0x0000000000000000]
    struct FString AutoFillString;    // 0x00D0 (0x0010) [0x0000000000000000]
    struct FString BuyGrenadeString;  // 0x00E0 (0x0010) [0x0000000000000000]
    struct FString ChangePerkString;  // 0x00F0 (0x0010) [0x0000000000000000]
    struct FString ArmorString;       // 0x0100 (0x0010) [0x0000000000000000]
    class AKFPlayerController* KFPC;  // 0x0110 (0x0008) [0x0000000000000000]
    float LowAmmoPercentThreshold;    // 0x0118 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68443];

        return pClassPointer;
    };

    void GetButtonState();
    void SetAutoFill();
    void SetSellInfo();
    void SetFillInfo();
    void SetMagInfo();
    void SetItemInfo();
    void SetGrenadeInfo();
    void SetArmorInfo();
    void RefreshPlayerInventory();
    void UpdateLock();
    void LocalizeContainer();
    void Initialize();
};

UClass* UKFGFxTraderContainer_PlayerInventory::pClassPointer = NULL;

// Class KFGame.KFGFxTraderContainer_PlayerInfo
// 0x0020 (0x00C8 - 0x00A8)
class UKFGFxTraderContainer_PlayerInfo : public UKFGFxObject_Container {
   public:
    struct FString PlayerHeaderString;  // 0x00A8 (0x0010) [0x0000000000000000]
    struct FString SelectPerkString;    // 0x00B8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68444];

        return pClassPointer;
    };

    void SetCharacterImage();
    void SetPerkList();
    void SetPerkInfo();
    void UpdatePlayerInfo();
    void LocalizeText();
    void Initialize();
};

UClass* UKFGFxTraderContainer_PlayerInfo::pClassPointer = NULL;

// Class KFGame.KFGFxTraderContainer_ItemDetails
// 0x0130 (0x01D8 - 0x00A8)
class UKFGFxTraderContainer_ItemDetails : public UKFGFxObject_Container {
   public:
    float MAX_RPM;          // 0x00A8 (0x0004) [0x0000000000000000]
    float MAX_PENETRATION;  // 0x00AC (0x0004) [0x0000000000000000]
    class UKFGFxMenu_Trader*
        MyTraderMenu;                    // 0x00B0 (0x0008) [0x0000000000000000]
    struct FString DamageTitle;          // 0x00B8 (0x0010) [0x0000000000000000]
    struct FString FireRateTitle;        // 0x00C8 (0x0010) [0x0000000000000000]
    struct FString RangeTitle;           // 0x00D8 (0x0010) [0x0000000000000000]
    struct FString PenetrationTitle;     // 0x00E8 (0x0010) [0x0000000000000000]
    struct FString BlockTitle;           // 0x00F8 (0x0010) [0x0000000000000000]
    struct FString ParryTitle;           // 0x0108 (0x0010) [0x0000000000000000]
    struct FString AccuracyTitle;        // 0x0118 (0x0010) [0x0000000000000000]
    struct FString CapacityTitle;        // 0x0128 (0x0010) [0x0000000000000000]
    struct FString MagTitle;             // 0x0138 (0x0010) [0x0000000000000000]
    struct FString HealAmountTitle;      // 0x0148 (0x0010) [0x0000000000000000]
    struct FString HealRechargeTitle;    // 0x0158 (0x0010) [0x0000000000000000]
    struct FString BuyString;            // 0x0168 (0x0010) [0x0000000000000000]
    struct FString SellString;           // 0x0178 (0x0010) [0x0000000000000000]
    struct FString CannotSellString;     // 0x0188 (0x0010) [0x0000000000000000]
    struct FString CannotBuyString;      // 0x0198 (0x0010) [0x0000000000000000]
    struct FString FavoriteString;       // 0x01A8 (0x0010) [0x0000000000000000]
    struct FString UnfavoriteString;     // 0x01B8 (0x0010) [0x0000000000000000]
    class UGFxObject* DetailsContainer;  // 0x01C8 (0x0008) [0x0000000000000000]
    class AKFPlayerController* KFPC;     // 0x01D0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68445];

        return pClassPointer;
    };

    void SetGenericItemDetails();
    void GetStatMax();
    void GetLocalizedStatString();
    void SetPlayerItemDetails();
    void SetShopItemDetails();
    void SetDetailsText();
    void SetDetailsVisible();
    void LocalizeContainer();
    void Initialize();
};

UClass* UKFGFxTraderContainer_ItemDetails::pClassPointer = NULL;

// Class KFGame.KFGFxWidget_ButtonPrompt
// 0x0020 (0x0100 - 0x00E0)
class UKFGFxWidget_ButtonPrompt : public UKFGFxObject_Menu {
   public:
    struct FString CancelString;   // 0x00E0 (0x0010) [0x0000000000000000]
    struct FString ConfirmString;  // 0x00F0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68450];

        return pClassPointer;
    };

    void LocalizeWidget();
    void InitializeMenu();
};

UClass* UKFGFxWidget_ButtonPrompt::pClassPointer = NULL;

// Class KFGame.KFGFxWidget_BossHealthBar
// 0x0034 (0x00D4 - 0x00A0)
class UKFGFxWidget_BossHealthBar : public UGFxObject {
   public:
    class UGFxObject*
        bossNameTextField;            // 0x00A0 (0x0008) [0x0000000000000000]
    class AKFPawn_Monster* BossPawn;  // 0x00A8 (0x0008) [0x0000000000000000]
    float UpdateTickTime;             // 0x00B0 (0x0004) [0x0000000000000000]
    float LastUpdateTime;             // 0x00B4 (0x0004) [0x0000000000000000]
    TArray<int> BattlePhaseColors;    // 0x00B8 (0x0010) [0x0000000000000000]
    class AKFPlayerController* KFPC;  // 0x00C8 (0x0008) [0x0000000000000000]
    DWORD bLastHideValue : 1;         // 0x00D0 (0x0004) [0x0000000000000000]
                                      // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68611];

        return pClassPointer;
    };

    void UpdateBossShield();
    void UpdateBossBattlePhase();
    void UpdateBossHealth();
    void SetBossName();
    void OnNamePlateHidden();
    void SetBossPawn();
    void TickHud();
    void InitializeHUD();
};

UClass* UKFGFxWidget_BossHealthBar::pClassPointer = NULL;

// Class KFGame.KFGFxWidget_KickVote
// 0x0034 (0x00D4 - 0x00A0)
class UKFGFxWidget_KickVote : public UGFxObject {
   public:
    struct FString VoteKickString;  // 0x00A0 (0x0010) [0x0000000000000000]
    DWORD
        bIsVoteActive : 1;  // 0x00B0 (0x0004) [0x0000000000000000] [0x00000001]
    struct FString GBA_VoteYes;  // 0x00B4 (0x0010) [0x0000000000000000]
    struct FString GBA_VoteNo;   // 0x00C4 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68612];

        return pClassPointer;
    };

    void OnNoReleased();
    void OnNoPressed();
    void OnYesReleased();
    void OnYesPressed();
    void VoteClosed();
    void UpdateKickVoteCount();
    void UpdateUsingGamePad();
    void SendVoteKickToAS3();
    void ShowKickVote();
    void LocalizeText();
    void InitializeHUD();
};

UClass* UKFGFxWidget_KickVote::pClassPointer = NULL;

// Class KFGame.KFGFxWidget_VOIPNotification
// 0x0010 (0x00B0 - 0x00A0)
class UKFGFxWidget_VOIPNotification : public UGFxObject {
   public:
    TArray<class AKFPlayerReplicationInfo*>
        TalkerPRIs;  // 0x00A0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68613];

        return pClassPointer;
    };

    void UpdateWidget();
    void VOIPEventTriggered();
};

UClass* UKFGFxWidget_VOIPNotification::pClassPointer = NULL;

// Class KFGame.KFGFxWidget_LevelUpNotification
// 0x0030 (0x00D0 - 0x00A0)
class UKFGFxWidget_LevelUpNotification : public UGFxObject {
   public:
    struct FString LevelUpString;       // 0x00A0 (0x0010) [0x0000000000000000]
    struct FString TierUnlockedString;  // 0x00B0 (0x0010) [0x0000000000000000]
    struct FString
        ObjectiveCompleteString;  // 0x00C0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68614];

        return pClassPointer;
    };

    void ShowAchievementNotification();
    void ShowObjectiveCompleteNotification();
    void ShowLevelUpNotification();
    void FinishedSpecialEvent();
    void SetLocalizedText();
    void InitializeHUD();
};

UClass* UKFGFxWidget_LevelUpNotification::pClassPointer = NULL;

// Class KFGame.KFGFxWidget_MusicNotification
// 0x0000 (0x00A0 - 0x00A0)
class UKFGFxWidget_MusicNotification : public UGFxObject {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68615];

        return pClassPointer;
    };

    void ShowSongInfo();
    void InitializeHUD();
};

UClass* UKFGFxWidget_MusicNotification::pClassPointer = NULL;

// Class KFGame.KFGFxWidget_NonCriticalGameMessage
// 0x0000 (0x00A0 - 0x00A0)
class UKFGFxWidget_NonCriticalGameMessage : public UGFxObject {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68616];

        return pClassPointer;
    };

    void ShowMessage();
};

UClass* UKFGFxWidget_NonCriticalGameMessage::pClassPointer = NULL;

// Class KFGame.KFGFxWidget_RhythmCounter
// 0x0000 (0x00A0 - 0x00A0)
class UKFGFxWidget_RhythmCounter : public UGFxObject {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68617];

        return pClassPointer;
    };

    void SetBonusPercentage();
    void SetCount();
};

UClass* UKFGFxWidget_RhythmCounter::pClassPointer = NULL;

// Class KFGame.KFGFxMoviePlayer_ScreenSize
// 0x0044 (0x0228 - 0x01E4)
class UKFGFxMoviePlayer_ScreenSize : public UGFxMoviePlayer {
   public:
    struct FName SoundThemeName;  // 0x01E4 (0x0008) [0x0000000000000000]
    DWORD
        bUsingGamepad : 1;  // 0x01EC (0x0004) [0x0000000000000000] [0x00000001]
    class UGFxObject* ManagerObject;  // 0x01F0 (0x0008) [0x0000000000000000]
    class UKFGFxMoviePlayer_Manager*
        GFxMenuManager;                 // 0x01F8 (0x0008) [0x0000000000000000]
    class AKFPlayerController* KFPC;    // 0x0200 (0x0008) [0x0000000000000000]
    float AdjustMovePercentage;         // 0x0208 (0x0004) [0x0000000000000000]
    float SafeFrameMinScale;            // 0x020C (0x0004) [0x0000000000000000]
    class UKFGameEngine* KFEngine;      // 0x0210 (0x0008) [0x0000000000000000]
    class UKFProfileSettings* Profile;  // 0x0218 (0x0008) [0x0000000000000000]
    class UKFGFxScreenSizeContainer*
        ScreenSizeContainer;  // 0x0220 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68831];

        return pClassPointer;
    };

    void SaveAndClose();
    void Callback_Cancel();
    void Callback_Confirm();
    void Callback_Shrink();
    void Callback_Enlarge();
    void NotifyControllerReconnected();
    void NotifyControllerDisconnected();
    void GetUsingGamepad();
    void OnInputTypeChanged();
    void CheckIfUsingGamepad();
    void eventFilterButtonInput();
    void eventWidgetInitialized();
    void Init();
};

UClass* UKFGFxMoviePlayer_ScreenSize::pClassPointer = NULL;

// Class KFGame.KFGFxWidget_MenuBar
// 0x00B8 (0x0198 - 0x00E0)
class UKFGFxWidget_MenuBar : public UKFGFxObject_Menu {
   public:
    TArray<struct FString> MenuStrings;  // 0x00E0 (0x0010) [0x0000000000000000]
    struct FString ExitString;           // 0x00F0 (0x0010) [0x0000000000000000]
    struct FString CancelString;         // 0x0100 (0x0010) [0x0000000000000000]
    struct FString ServerBrowserString;  // 0x0110 (0x0010) [0x0000000000000000]
    struct FString MatchmakingString;    // 0x0120 (0x0010) [0x0000000000000000]
    struct FString SoloString;           // 0x0130 (0x0010) [0x0000000000000000]
    struct FString OverviewString;       // 0x0140 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        TitleStrings;  // 0x0150 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        DescriptionStrings;             // 0x0160 (0x0010) [0x0000000000000000]
    struct FString LastHomeString;      // 0x0170 (0x0010) [0x0000000000000000]
    class UGFxObject* InventoryButton;  // 0x0180 (0x0008) [0x0000000000000000]
    class UGFxObject* StoreButton;      // 0x0188 (0x0008) [0x0000000000000000]
    int SaveCurrentMenuIndex;           // 0x0190 (0x0004) [0x0000000000000000]
    DWORD bCachedGameFullyInstalled : 1;  // 0x0194 (0x0004)
                                          // [0x0000000000000000] [0x00000001]
    DWORD
        bAllowBumper : 1;  // 0x0194 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bGearButtonEnabled : 1;  // 0x0194 (0x0004) [0x0000000000000000]
                                   // [0x00000004]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68857];

        return pClassPointer;
    };

    void CanUseStore();
    void CanUseInventory();
    void CanUseGearButton();
    void ShouldStartMenuPulse();
    void GetHomeButtonName();
    void OnLogoutConfirm();
    void OpenLogoutPopup();
    void OnQuitConfirm();
    void OpenQuitPopUp();
    void CheckGameFullyInstalled();
    void SetGearMenuEnabled();
    void UpdateGearButtonState();
    void UpdateInventoryButtonState();
    void HandleButtonSpecialCase();
    void UpdateMenu();
    void UnblockBumper();
    void CalloutButtonBumperPress();
    void InitializeCurrentMenu();
};

UClass* UKFGFxWidget_MenuBar::pClassPointer = NULL;

// Class KFGame.KFGFxOptionsMenu_Selection
// 0x0030 (0x0110 - 0x00E0)
class UKFGFxOptionsMenu_Selection : public UKFGFxObject_Menu {
   public:
    class UKFGFxControlsContainer_Keybinding*
        KeybindingsContainer;  // 0x00E0 (0x0008) [0x0000000000000000]
    class UKFGFxControlsContainer_Input*
        InputContainer;           // 0x00E8 (0x0008) [0x0000000000000000]
    struct FString HeaderString;  // 0x00F0 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        OptionStrings;  // 0x0100 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68868];

        return pClassPointer;
    };

    void Callback_MenuSelected();
    void InitializeMenu();
};

UClass* UKFGFxOptionsMenu_Selection::pClassPointer = NULL;

// Class KFGame.KFGFxOptionsMenu_Audio
// 0x00D8 (0x01B8 - 0x00E0)
class UKFGFxOptionsMenu_Audio : public UKFGFxObject_Menu {
   public:
    struct FString SectionNameString;    // 0x00E0 (0x0010) [0x0000000000000000]
    struct FString OptionsString;        // 0x00F0 (0x0010) [0x0000000000000000]
    struct FString AudioString;          // 0x0100 (0x0010) [0x0000000000000000]
    struct FString DialogVolumeString;   // 0x0110 (0x0010) [0x0000000000000000]
    struct FString MasterVolumeString;   // 0x0120 (0x0010) [0x0000000000000000]
    struct FString MusicString;          // 0x0130 (0x0010) [0x0000000000000000]
    struct FString SFxString;            // 0x0140 (0x0010) [0x0000000000000000]
    struct FString VOIPVolumeString;     // 0x0150 (0x0010) [0x0000000000000000]
    struct FString ConfigureMicString;   // 0x0160 (0x0010) [0x0000000000000000]
    struct FString VocalsString;         // 0x0170 (0x0010) [0x0000000000000000]
    struct FString BattleChatterString;  // 0x0180 (0x0010) [0x0000000000000000]
    struct FString PushToVoIPString;     // 0x0190 (0x0010) [0x0000000000000000]
    struct FString ScreenSizeString;     // 0x01A0 (0x0010) [0x0000000000000000]
    float VoIPMin;                       // 0x01B0 (0x0004) [0x0000000000000000]
    float VoIPMax;                       // 0x01B4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68871];

        return pClassPointer;
    };

    void ResetAudioOptions();
    void CallBack_ResetAudioOptions();
    void Callback_VOIPVolumeChanged();
    void Callback_SFxVolumeChanged();
    void Callback_MusicVolumeChanged();
    void Callback_DialogVolumeChanged();
    void Callback_MasterVolumeChanged();
    void Callback_ConfigureControllerSound();
    void Callback_ConfigureVocals();
    void Callback_PushToTalkChanged();
    void Callback_ConfigureBattleChatter();
    void Callback_ConfigureMicPress();
    void Callback_CloseMenu();
    void Callback_ScreenSizePress();
    void SaveConfigValues();
    void eventOnClose();
    void SetVoIPMinMax();
    void InitValues();
    void ConditionallyHideDurangoButton();
    void LocalizeText();
    void InitializeMenu();
};

UClass* UKFGFxOptionsMenu_Audio::pClassPointer = NULL;

// Class KFGame.KFGFxOptionsMenu_GameSettings
// 0x0135 (0x0215 - 0x00E0)
class UKFGFxOptionsMenu_GameSettings : public UKFGFxObject_Menu {
   public:
    struct FString SectionNameString;   // 0x00E0 (0x0010) [0x0000000000000000]
    struct FString GameSettingsString;  // 0x00F0 (0x0010) [0x0000000000000000]
    struct FString FOVString;           // 0x0100 (0x0010) [0x0000000000000000]
    struct FString
        FriendlyHudScaleString;          // 0x0110 (0x0010) [0x0000000000000000]
    struct FString GoreString;           // 0x0120 (0x0010) [0x0000000000000000]
    struct FString ShowCrosshairString;  // 0x0130 (0x0010) [0x0000000000000000]
    struct FString WiderString;          // 0x0140 (0x0010) [0x0000000000000000]
    struct FString NormalString;         // 0x0150 (0x0010) [0x0000000000000000]
    struct FString
        ClassicWeaponSelectString;    // 0x0160 (0x0010) [0x0000000000000000]
    struct FString KillTickerString;  // 0x0170 (0x0010) [0x0000000000000000]
    struct FString
        DisableAutoUpgradeString;  // 0x0180 (0x0010) [0x0000000000000000]
    struct FString
        HideBossHealthBarString;  // 0x0190 (0x0010) [0x0000000000000000]
    struct FString
        ShowWelderInInvString;  // 0x01A0 (0x0010) [0x0000000000000000]
    struct FString
        UseAltAimOnDualString;  // 0x01B0 (0x0010) [0x0000000000000000]
    struct FString
        AntiMotionSicknessString;      // 0x01C0 (0x0010) [0x0000000000000000]
    struct FString AutoTurnOffString;  // 0x01D0 (0x0010) [0x0000000000000000]
    struct FString
        ReduceHighPitchNoiseString;  // 0x01E0 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        GoreOptionStrings;             // 0x01F0 (0x0010) [0x0000000000000000]
    float FOVMinValue;                 // 0x0200 (0x0004) [0x0000000000000000]
    float FOVMaxValue;                 // 0x0204 (0x0004) [0x0000000000000000]
    float FOVCurrentValue;             // 0x0208 (0x0004) [0x0000000000000000]
    float FriendlyHudScaleMinValue;    // 0x020C (0x0004) [0x0000000000000000]
    float FriendlyHudScaleMaxValue;    // 0x0210 (0x0004) [0x0000000000000000]
    unsigned char SHOW_NO_GORE_LEVEL;  // 0x0214 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68874];

        return pClassPointer;
    };

    void ResetGameOptions();
    void CallBack_ResetGameOptions();
    void Callback_ReduceHighPitchNoiseChanged();
    void Callback_AutoTurnOffChanged();
    void Callback_bShowWelderInInvChanged();
    void Callback_AntiMotionSicknessChanged();
    void Callback_HideBossHealthBarChanged();
    void Callback_UseAltAimOnDualsChanged();
    void Callback_GoreChanged();
    void Callback_KillTickerChanged();
    void Callback_DisableAutoUpgradeChanged();
    void Callback_WeaponSelectChanged();
    void Callback_FriendlyHudChanged();
    void Callback_FOVChanged();
    void Callback_ToggleCrosshair();
    void Callback_CloseMenu();
    void SetFriendlyHudMinMax();
    void SetFOVMinMax();
    void InitValues();
    void LocalizeText();
    void InitializeMenu();
};

UClass* UKFGFxOptionsMenu_GameSettings::pClassPointer = NULL;

// Class KFGame.KFGFxWidget_PartyMainMenu
// 0x0008 (0x062C - 0x0624)
class UKFGFxWidget_PartyMainMenu : public UKFGFxWidget_BaseParty {
   public:
    DWORD bIsInParty : 1;  // 0x0624 (0x0004) [0x0000000000000000] [0x00000001]
    int prevMemberCount;   // 0x0628 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68876];

        return pClassPointer;
    };

    void SendMyOptions();
    void AddFriend();
    void ViewProfile();
    void ToggelMuteOnPlayer();
    void UpdateSearching();
    void UpdatePerkInfoForPlayerID();
    void UpdatePerks();
    void RefreshSlot();
    void HandleLeaderChange();
    void RefreshParty();
    void SetSearchingText();
    void SendSearching();
    void InitializeWidget();
    void OneSecondLoop();
};

UClass* UKFGFxWidget_PartyMainMenu::pClassPointer = NULL;

// Class KFGame.KFGFxOptionsMenu_Graphics_DX10
// 0x0010 (0x0A20 - 0x0A10)
class UKFGFxOptionsMenu_Graphics_DX10 : public UKFGFxOptionsMenu_Graphics {
   public:
    TArray<struct FString>
        AmbientOcclusionStringOptions_DX10;  // 0x0A10 (0x0010)
                                             // [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68881];

        return pClassPointer;
    };

    void SetAmbientOcclusionOptions();
};

UClass* UKFGFxOptionsMenu_Graphics_DX10::pClassPointer = NULL;

// Class KFGame.KFGFxPopup_Gamma
// 0x0018 (0x00F0 - 0x00D8)
class UKFGFxPopup_Gamma : public UKFGFxObject_Popup {
   public:
    class UGFxObject* GammaSlider;  // 0x00D8 (0x0008) [0x0000000000000000]
    struct FString GammaImagePath;  // 0x00E0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68968];

        return pClassPointer;
    };

    void Callback_DefaultGamma();
    void Callback_GammaChanged();
    void Callback_ClosedPopup();
    void ResetGamma();
    void SetGamma();
    void eventOnClosed();
    void InitializePopup();
};

UClass* UKFGFxPopup_Gamma::pClassPointer = NULL;

// Class KFGame.KFGFxPopup_ConnectionError
// 0x0000 (0x00D8 - 0x00D8)
class UKFGFxPopup_ConnectionError : public UKFGFxObject_Popup {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68969];

        return pClassPointer;
    };
};

UClass* UKFGFxPopup_ConnectionError::pClassPointer = NULL;

// Class KFGame.KFGFxPopup_Confirmation
// 0x0020 (0x00F8 - 0x00D8)
class UKFGFxPopup_Confirmation : public UKFGFxObject_Popup {
   public:
    struct FString ConfirmButtonString;  // 0x00D8 (0x0010) [0x0000000000000000]
    struct FString DeclineButtonString;  // 0x00E8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68970];

        return pClassPointer;
    };

    void Callback_ClickedRightOption();
    void Callback_ClickedMiddleOption();
    void Callback_ClickedLeftOption();
    void ClearDelegates();
    void AssignRightButtonDelegate();
    void AssignMiddleButtonDelegate();
    void AssignLeftButtonDelegate();
};

UClass* UKFGFxPopup_Confirmation::pClassPointer = NULL;

// Class KFGame.KFGFxMoviePlayer_Manager_Versus
// 0x0000 (0x03EC - 0x03EC)
class UKFGFxMoviePlayer_Manager_Versus : public UKFGFxMoviePlayer_Manager {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68971];

        return pClassPointer;
    };

    void eventWidgetInitialized();
    void ClientRecieveNewTeam();
};

UClass* UKFGFxMoviePlayer_Manager_Versus::pClassPointer = NULL;

// Class KFGame.KFGFxWidget_MenuBarVersus
// 0x0000 (0x0198 - 0x0198)
class UKFGFxWidget_MenuBarVersus : public UKFGFxWidget_MenuBar {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68978];

        return pClassPointer;
    };

    void CanUseGearButton();
};

UClass* UKFGFxWidget_MenuBarVersus::pClassPointer = NULL;

// Class KFGame.KFGFxMoviePlayer_PlayerInfo
// 0x0074 (0x0258 - 0x01E4)
class UKFGFxMoviePlayer_PlayerInfo : public UGFxMoviePlayer {
   public:
    class AKFPawn_Human* MyKFPH;  // 0x01E4 (0x0008) [0x0000000000000000]
    class AKFPlayerReplicationInfo*
        MyKFPRI;                         // 0x01EC (0x0008) [0x0000000000000000]
    class UGFxObject* PartyMemberHudMC;  // 0x01F4 (0x0008) [0x0000000000000000]
    class UGFxObject* PlayerName;        // 0x01FC (0x0008) [0x0000000000000000]
    class UGFxObject* IconMC;            // 0x0204 (0x0008) [0x0000000000000000]
    class UGFxObject* Icon;              // 0x020C (0x0008) [0x0000000000000000]
    class UGFxObject* ArmorMeter;        // 0x0214 (0x0008) [0x0000000000000000]
    class UGFxObject* HealthMeter;       // 0x021C (0x0008) [0x0000000000000000]
    int LastPerkIndex;                   // 0x0224 (0x0004) [0x0000000000000000]
    float LastHealthPct;                 // 0x0228 (0x0004) [0x0000000000000000]
    int LastArmor;                       // 0x022C (0x0004) [0x0000000000000000]
    struct FString LastPlayerName;       // 0x0230 (0x0010) [0x0000000000000000]
    DWORD bVisible : 1;  // 0x0240 (0x0004) [0x0000000000000000] [0x00000001]
    struct FVector2D MovieSize;     // 0x0244 (0x0008) [0x0000000000000000]
    struct FVector ScreenPosition;  // 0x024C (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[68980];

        return pClassPointer;
    };

    void Callback_MovieSize();
    void SetPlayerPawn();
    void UpdatePlayerName();
    void UpdateArmor();
    void UpdateHealth();
    void UpdatePerk();
    void GetMovieHeight();
    void GetMovieWitdth();
    void SetVisible();
    void TickHud();
    void eventWidgetInitialized();
    void Init();
};

UClass* UKFGFxMoviePlayer_PlayerInfo::pClassPointer = NULL;

// Class KFGame.KFGFxScreenSizeContainer
// 0x0048 (0x0128 - 0x00E0)
class UKFGFxScreenSizeContainer : public UKFGFxObject_Menu {
   public:
    struct FString TitleString;        // 0x00E0 (0x0010) [0x0000000000000000]
    struct FString DescriptionString;  // 0x00F0 (0x0010) [0x0000000000000000]
    struct FString EnlargeString;      // 0x0100 (0x0010) [0x0000000000000000]
    struct FString ShrinkString;       // 0x0110 (0x0010) [0x0000000000000000]
    class UKFPlayerInput* KFPI;        // 0x0120 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[69151];

        return pClassPointer;
    };

    void LocalizeText();
    void UpdateUsingGamePad();
    void HideButtonsThatWeDoNotWantForNow();
    void InitMenu();
};

UClass* UKFGFxScreenSizeContainer::pClassPointer = NULL;

// Class KFGame.KFGFxMoviePlayer_World
// 0x0008 (0x01EC - 0x01E4)
class UKFGFxMoviePlayer_World : public UGFxMoviePlayer {
   public:
    class UGFxObject* MainComponent;  // 0x01E4 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[69156];

        return pClassPointer;
    };
};

UClass* UKFGFxMoviePlayer_World::pClassPointer = NULL;

// Class KFGame.KFGFxWorld_C4Screen
// 0x0008 (0x01F4 - 0x01EC)
class UKFGFxWorld_C4Screen : public UKFGFxMoviePlayer_World {
   public:
    int CurrentMaxCharges;    // 0x01EC (0x0004) [0x0000000000000000]
    int CurrenActiveCharges;  // 0x01F0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[72649];

        return pClassPointer;
    };

    void SetReadOut();
    void SetActiveCharges();
    void SetMaxCharges();
    void eventWidgetInitialized();
};

UClass* UKFGFxWorld_C4Screen::pClassPointer = NULL;

// Class KFGame.KFGFxWorld_HealerScreen
// 0x0001 (0x01ED - 0x01EC)
class UKFGFxWorld_HealerScreen : public UKFGFxMoviePlayer_World {
   public:
    unsigned char CurrentCharge;  // 0x01EC (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[72670];

        return pClassPointer;
    };

    void SetCharge();
    void eventWidgetInitialized();
};

UClass* UKFGFxWorld_HealerScreen::pClassPointer = NULL;

// Class KFGame.KFGFxWorld_MedicOptics
// 0x0010 (0x01F4 - 0x01E4)
class UKFGFxWorld_MedicOptics : public UGFxMoviePlayer {
   public:
    unsigned char CurrentAmmoCount;     // 0x01E4 (0x0001) [0x0000000000000000]
    unsigned char CurrentCharge;        // 0x01E5 (0x0001) [0x0000000000000000]
    class UGFxObject* OpticsContainer;  // 0x01E8 (0x0008) [0x0000000000000000]
    float MinPercentPerShot;            // 0x01F0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[72684];

        return pClassPointer;
    };

    void LockedOn();
    void StartLockOn();
    void ClearLockOn();
    void SetHealerCharge();
    void SetShotPercentCost();
    void SetPrimaryAmmo();
    void InitValues();
    void eventWidgetInitialized();
};

UClass* UKFGFxWorld_MedicOptics::pClassPointer = NULL;

// Class KFGame.KFGFxWorld_WelderScreen
// 0x0002 (0x01EE - 0x01EC)
class UKFGFxWorld_WelderScreen : public UKFGFxMoviePlayer_World {
   public:
    unsigned char CurrentCharge;        // 0x01EC (0x0001) [0x0000000000000000]
    unsigned char IntegrityPercentage;  // 0x01ED (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[72709];

        return pClassPointer;
    };

    void SetIntegrity();
    void SetCharge();
    void eventWidgetInitialized();
};

UClass* UKFGFxWorld_WelderScreen::pClassPointer = NULL;

// Class KFGame.KFGibStaticMeshComponent
// 0x0000 (0x02DC - 0x02DC)
class UKFGibStaticMeshComponent : public UStaticMeshComponent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[72743];

        return pClassPointer;
    };
};

UClass* UKFGibStaticMeshComponent::pClassPointer = NULL;

// Class KFGame.KFGibSkeletalMeshComponent
// 0x0000 (0x0820 - 0x0820)
class UKFGibSkeletalMeshComponent : public USkeletalMeshComponent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[72748];

        return pClassPointer;
    };
};

UClass* UKFGibSkeletalMeshComponent::pClassPointer = NULL;

// Class KFGame.KFGoreChunkAttachment_Skull
// 0x0000 (0x0080 - 0x0080)
class UKFGoreChunkAttachment_Skull : public UKFGoreChunkAttachmentInfo {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[72760];

        return pClassPointer;
    };

    void ShouldDetachGoreChunk();
    void ShouldAttachGoreChunk();
};

UClass* UKFGoreChunkAttachment_Skull::pClassPointer = NULL;

// Class KFGame.KFImpactFXEmitterPool
// 0x0000 (0x02BC - 0x02BC)
class AKFImpactFXEmitterPool : public AEmitterPool {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[73208];

        return pClassPointer;
    };
};

UClass* AKFImpactFXEmitterPool::pClassPointer = NULL;

// Class KFGame.KFWeap_HealerBase
// 0x0058 (0x0918 - 0x08C0)
class AKFWeap_HealerBase : public AKFWeapon {
   public:
    float HealSelfRechargeSeconds;   // 0x08C0 (0x0004) [0x0000000000000000]
    float HealOtherRechargeSeconds;  // 0x08C4 (0x0004) [0x0000000000000000]
    float HealRechargeTime;          // 0x08C8 (0x0004) [0x0000000000000000]
    float HealingIncrement;          // 0x08CC (0x0004) [0x0000000000000000]
    float HealRechargePerSecond;     // 0x08D0 (0x0004) [0x0000000000000000]
    DWORD bIsAmmoRecharging : 1;     // 0x08D4 (0x0004) [0x0000000000200000]
                                     // [0x00000001]
    DWORD bQuickHealMode : 1;        // 0x08D4 (0x0004) [0x0000000000000000]
                                     // [0x00000002]
    DWORD bPlayHealAndReload : 1;    // 0x08D4 (0x0004) [0x0000000000000000]
                                     // [0x00000004]
    DWORD bIsQuickHealMessageShowing : 1;  // 0x08D4 (0x0004)
                                           // [0x0000000000000000] [0x00000008]
    class UAkEvent*
        RechargeCompleteSound;  // 0x08D8 (0x0008) [0x0000000000000000]
    float
        HealAttemptWeakZedGrabCooldown;  // 0x08E0 (0x0004) [0x0000000000000000]
    float HealingRangeSQ;                // 0x08E4 (0x0004) [0x0000000000000000]
    class APawn* HealTarget;             // 0x08E8 (0x0008) [0x0000000000000000]
    class APawn* LastValidHealTarget;    // 0x08F0 (0x0008) [0x0000000000000000]
    float LastReadyHealTime;             // 0x08F8 (0x0004) [0x0000000000000000]
    float StandAloneHealAmount;          // 0x08FC (0x0004) [0x0000000000000000]
    class UClass* ScreenUIClass;         // 0x0900 (0x0008) [0x0000000000000000]
    class UKFGFxWorld_HealerScreen*
        ScreenUI;            // 0x0908 (0x0008) [0x0000000000000000]
    float LastUIUpdateTime;  // 0x0910 (0x0004) [0x0000000000000000]
    float UIUpdateInterval;  // 0x0914 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[73591];

        return pClassPointer;
    };

    void GetActivePlayerCount();
    void ServerStartQuickHeal();
    void Activate();
    void QuickHealFireTimer();
    void QuickHealEndTimer();
    void UpdateHealTarget();
    void UpdateScreenUI();
    void UpdateInteractionMessage();
    void eventTick();
    void ShouldRefire();
    void GetFireInterval();
    void GetHealAnimName();
    void PlayFireEffects();
    void ServerMissHeal();
    void MissHeal();
    void ServerStartHeal();
    void IsValidHealingTarget();
    void StartFire();
    void CustomFire();
    void AltFireMode();
    void CanReload();
    void HealAmmoRegeneration();
    void PerformReload();
    void HasAnyAmmo();
    void GetSpareAmmoForHUD();
    void eventDestroyed();
    void DetachWeapon();
    void AttachWeaponTo();
    void GivenTo();
    void eventReplicatedEvent();
};

UClass* AKFWeap_HealerBase::pClassPointer = NULL;

// Class KFGame.KFKActor
// 0x0001 (0x0379 - 0x0378)
class AKFKActor : public AKActor {
   public:
    unsigned char NetworkType;  // 0x0378 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[73607];

        return pClassPointer;
    };

    void eventPreBeginPlay();
};

UClass* AKFKActor::pClassPointer = NULL;

// Class KFGame.KFKAsset
// 0x0000 (0x0260 - 0x0260)
class AKFKAsset : public AKAsset {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[73632];

        return pClassPointer;
    };
};

UClass* AKFKAsset::pClassPointer = NULL;

// Class KFGame.KFLocalMessage_ServerNotification
// 0x0010 (0x02A8 - 0x0298)
class UKFLocalMessage_ServerNotification : public UKFLocalMessage {
   public:
    struct FString
        TeamPendingBalanceMessage;  // 0x0298 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[73951];

        return pClassPointer;
    };

    void GetString();
};

UClass* UKFLocalMessage_ServerNotification::pClassPointer = NULL;

// Class KFGame.KFMeleeHelperWeapon
// 0x0088 (0x0148 - 0x00C0)
class UKFMeleeHelperWeapon : public UKFMeleeHelperBase {
   public:
    DWORD bUseDirectionalMelee : 1;    // 0x00C0 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bHasChainAttacks : 1;        // 0x00C0 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD bResetChainSequence : 1;     // 0x00C0 (0x0004) [0x0000000000000000]
                                       // [0x00000004]
    DWORD bUseMeleeHitTimer : 1;       // 0x00C0 (0x0004) [0x0000000000000000]
                                       // [0x00000008]
    DWORD bHitEnemyThisAttack : 1;     // 0x00C0 (0x0004) [0x0000000000000000]
                                       // [0x00000010]
    unsigned char ChooseAtkCount;      // 0x00C4 (0x0001) [0x0000000000000000]
    unsigned char NextAttackDir;       // 0x00C5 (0x0001) [0x0000000000000000]
    unsigned char NextAttackType;      // 0x00C6 (0x0001) [0x0000000000000000]
    unsigned char CurrentAttackDir;    // 0x00C7 (0x0001) [0x0000000000000000]
    unsigned char CurrentAtkChainIdx;  // 0x00C8 (0x0001) [0x0000000000000000]
    TArray<unsigned char>
        ChainSequence_F;  // 0x00CC (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        ChainSequence_B;  // 0x00DC (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        ChainSequence_L;  // 0x00EC (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        ChainSequence_R;  // 0x00FC (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        AttackChainSequence;           // 0x010C (0x0010) [0x0000000000000000]
    int NumChainedAttacks;             // 0x011C (0x0004) [0x0000000000000000]
    float LastMeleeAnimEnd_ActorTime;  // 0x0120 (0x0004) [0x0000000000000000]
    float InitialImpactDelay;          // 0x0124 (0x0004) [0x0000000000000000]
    float ImpactRetryDuration;         // 0x0128 (0x0004) [0x0000000000000000]
    float ImpactComplete_ActorTime;    // 0x012C (0x0004) [0x0000000000000000]
    struct FInterpCurveFloat
        FatigueCurve;                // 0x0130 (0x0014) [0x0000000000000000]
    float MeleeImpactCamShakeScale;  // 0x0144 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[74152];

        return pClassPointer;
    };

    void PlayMeleeHitEffects();
    void GetDamageScaleByAngle();
    void GetDamageType();
    void ProcessMeleeHit();
    void ContinueMeleeAttack();
    void MeleeCheckTimer();
    void InitAttackSequence();
    void ChooseAttackDir();
    void GetMeleeBlendInTime();
    void PlayMeleeAttackAnimation();
    void BeginMeleeAttack();
    void HitboxSimpleWorldTrace();
    void eventInitWorldTraceForHitboxCollision();
    void eventProcessHitboxCollision();
    void GetAdjustedRayDir();
    void CalcVictimImpactList();
    void CalcWeaponMeleeAttack();
    void MeleeAttackImpact();
    void MeleeImpactTimer();
    void MeleeImpactNotify();
};

UClass* UKFMeleeHelperWeapon::pClassPointer = NULL;

// Class KFGame.KFSM_InteractionPawnFollower
// 0x0009 (0x013D - 0x0134)
class UKFSM_InteractionPawnFollower : public UKFSpecialMove {
   public:
    class AKFPawn* Leader;            // 0x0134 (0x0008) [0x0000000000000000]
    unsigned char LeaderSpecialMove;  // 0x013C (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[74290];

        return pClassPointer;
    };

    void InteractionStarted();
    void MessageEvent();
    void SpecialMoveEnded();
    void OnLeaderLeavingSpecialMove();
    void SpecialMoveStarted();
};

UClass* UKFSM_InteractionPawnFollower::pClassPointer = NULL;

// Class KFGame.KFMutator
// 0x0008 (0x0268 - 0x0260)
class AKFMutator : public AMutator {
   public:
    class AKFGameInfo* MyKFGI;  // 0x0260 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[74415];

        return pClassPointer;
    };

    void ModifyActivatedPickupFactory();
    void ModifyPickupFactories();
    void ModifyZedTime();
    void ModifyAIEnemy();
    void ModifyAI();
    void ModifyNextTraderIndex();
    void InitMutator();
};

UClass* AKFMutator::pClassPointer = NULL;

// Class KFGame.KFMutatorSummary
// 0x0054 (0x00E8 - 0x0094)
class UKFMutatorSummary : public UUIResourceDataProvider {
   public:
    struct FString ClassName;  // 0x0094 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        SupportedGameTypes;             // 0x00A4 (0x0010) [0x0000000000000000]
    TArray<struct FString> GroupNames;  // 0x00B4 (0x0010) [0x0000000000000000]
    struct FString FriendlyName;        // 0x00C4 (0x0010) [0x0000000000000000]
    struct FString Description;         // 0x00D4 (0x0010) [0x0000000000000000]
    DWORD bIsDisabled : 1;  // 0x00E4 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[74436];

        return pClassPointer;
    };
};

UClass* UKFMutatorSummary::pClassPointer = NULL;

// Class KFGame.KFSM_GrappleVictim
// 0x001F (0x015C - 0x013D)
class UKFSM_GrappleVictim : public UKFSM_InteractionPawnFollower {
   public:
    class AKFPlayerController*
        OwnerController;  // 0x0140 (0x0008) [0x0000000000000000]
    class UAkEvent*
        GrabbedSoundModeStartEvent;  // 0x0148 (0x0008) [0x0000000000000000]
    class UAkEvent*
        GrabbedSoundModeEndEvent;  // 0x0150 (0x0008) [0x0000000000000000]
    float GrabVictimCooldownTime;  // 0x0158 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[75288];

        return pClassPointer;
    };

    void SetGrabEffect();
    void SpecialMoveEnded();
    void SpecialMoveStarted();
};

UClass* UKFSM_GrappleVictim::pClassPointer = NULL;

// Class KFGame.KFSM_DisabledGrappleVictim
// 0x0000 (0x015C - 0x015C)
class UKFSM_DisabledGrappleVictim : public UKFSM_GrappleVictim {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[75289];

        return pClassPointer;
    };
};

UClass* UKFSM_DisabledGrappleVictim::pClassPointer = NULL;

// Class KFGame.KFSM_HansGrappleVictim
// 0x0008 (0x0164 - 0x015C)
class UKFSM_HansGrappleVictim : public UKFSM_GrappleVictim {
   public:
    struct FName AnimName;  // 0x015C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[75290];

        return pClassPointer;
    };

    void SetGrabEffect();
    void SpecialMoveEnded();
    void SpecialMoveStarted();
};

UClass* UKFSM_HansGrappleVictim::pClassPointer = NULL;

// Class KFGame.KFSM_Player_Emote
// 0x0044 (0x0194 - 0x0150)
class UKFSM_Player_Emote : public UKFSM_PlaySingleAnim {
   public:
    class UCameraAnim* CameraAnim;    // 0x0150 (0x0008) [0x0000000000000000]
    struct FName LastCameraMode;      // 0x0158 (0x0008) [0x0000000000000000]
    struct FColor FadeInColor;        // 0x0160 (0x0004) [0x0000000000000000]
    struct FColor FadeOutColor;       // 0x0164 (0x0004) [0x0000000000000000]
    float FadeInTime;                 // 0x0168 (0x0004) [0x0000000000000000]
    float FadeOutTime;                // 0x016C (0x0004) [0x0000000000000000]
    struct FRotator InitialRotation;  // 0x0170 (0x000C) [0x0000000000000000]
    float EmoteCooldownTime;          // 0x017C (0x0004) [0x0000000000000000]
    float LastEmoteTime;              // 0x0180 (0x0004) [0x0000000000000000]
    TArray<class UParticleSystemComponent*>
        AnimParticles;  // 0x0184 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[75291];

        return pClassPointer;
    };

    void GetSMAimRotation();
    void SpecialMoveEnded();
    void Tick();
    void OnAnimNotifyParticleSystemSpawned();
    void SetParticlesVisible();
    void ClearSMParticles();
    void PlayAnimation();
    void SpecialMoveStarted();
    void PackFlagsBase();
    void CanDrawCrosshair();
    void InternalCanDoSpecialMove();
};

UClass* UKFSM_Player_Emote::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Knife_Commando
// 0x0000 (0x00A4 - 0x00A4)
class UKFWeapDef_Knife_Commando : public UKFweapDef_Knife_Base {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[75797];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Knife_Commando::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Grenade_Berserker
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Grenade_Berserker : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[75798];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Grenade_Berserker::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Crovel
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Crovel : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[75960];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Crovel::pClassPointer = NULL;

// Class KFGame.KFweapDef_Knife_Berserker
// 0x0000 (0x00A4 - 0x00A4)
class UKFweapDef_Knife_Berserker : public UKFweapDef_Knife_Base {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[75961];

        return pClassPointer;
    };
};

UClass* UKFweapDef_Knife_Berserker::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Nailgun
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Nailgun : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[75962];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Nailgun::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Pulverizer
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Pulverizer : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[75963];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Pulverizer::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Eviscerator
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Eviscerator : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[75964];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Eviscerator::pClassPointer = NULL;

// Class KFGame.KFWeapDef_AR15
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_AR15 : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76107];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_AR15::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Grenade_Commando
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Grenade_Commando : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76108];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Grenade_Commando::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Bullpup
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Bullpup : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76109];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Bullpup::pClassPointer = NULL;

// Class KFGame.KFWeapDef_AK12
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_AK12 : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76110];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_AK12::pClassPointer = NULL;

// Class KFGame.KFWeapDef_SCAR
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_SCAR : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76111];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_SCAR::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Knife_Demo
// 0x0000 (0x00A4 - 0x00A4)
class UKFWeapDef_Knife_Demo : public UKFweapDef_Knife_Base {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76336];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Knife_Demo::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Grenade_Demo
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Grenade_Demo : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76337];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Grenade_Demo::pClassPointer = NULL;

// Class KFGame.KFWeapDef_M79
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_M79 : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76338];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_M79::pClassPointer = NULL;

// Class KFGame.KFWeapDef_M16M203
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_M16M203 : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76339];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_M16M203::pClassPointer = NULL;

// Class KFGame.KFWeapDef_RPG7
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_RPG7 : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76340];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_RPG7::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Knife_Medic
// 0x0000 (0x00A4 - 0x00A4)
class UKFWeapDef_Knife_Medic : public UKFweapDef_Knife_Base {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76453];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Knife_Medic::pClassPointer = NULL;

// Class KFGame.KFWeapDef_MedicSMG
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_MedicSMG : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76454];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_MedicSMG::pClassPointer = NULL;

// Class KFGame.KFWeapDef_MedicShotgun
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_MedicShotgun : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76455];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_MedicShotgun::pClassPointer = NULL;

// Class KFGame.KFWeapDef_MedicRifle
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_MedicRifle : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76456];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_MedicRifle::pClassPointer = NULL;

// Class KFGame.KFWeapDef_CaulkBurn
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_CaulkBurn : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76585];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_CaulkBurn::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Knife_Firebug
// 0x0000 (0x00A4 - 0x00A4)
class UKFWeapDef_Knife_Firebug : public UKFweapDef_Knife_Base {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76586];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Knife_Firebug::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Grenade_Firebug
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Grenade_Firebug : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76587];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Grenade_Firebug::pClassPointer = NULL;

// Class KFGame.KFWeapDef_DragonsBreath
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_DragonsBreath : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76588];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_DragonsBreath::pClassPointer = NULL;

// Class KFGame.KFWeapDef_FlameThrower
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_FlameThrower : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76589];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_FlameThrower::pClassPointer = NULL;

// Class KFGame.KFWeapDef_MicrowaveGun
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_MicrowaveGun : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76590];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_MicrowaveGun::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Remington1858Dual
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Remington1858Dual : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76763];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Remington1858Dual::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Knife_Gunslinger
// 0x0000 (0x00A4 - 0x00A4)
class UKFWeapDef_Knife_Gunslinger : public UKFweapDef_Knife_Base {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76764];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Knife_Gunslinger::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Grenade_Gunslinger
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Grenade_Gunslinger : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76765];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Grenade_Gunslinger::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Colt1911Dual
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Colt1911Dual : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76766];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Colt1911Dual::pClassPointer = NULL;

// Class KFGame.KFWeapDef_DeagleDual
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_DeagleDual : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76767];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_DeagleDual::pClassPointer = NULL;

// Class KFGame.KFWeapDef_SW500Dual
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_SW500Dual : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76768];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_SW500Dual::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Winchester1894
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Winchester1894 : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76908];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Winchester1894::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Knife_SharpShooter
// 0x0000 (0x00A4 - 0x00A4)
class UKFWeapDef_Knife_SharpShooter : public UKFweapDef_Knife_Base {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76909];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Knife_SharpShooter::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Grenade_Sharpshooter
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Grenade_Sharpshooter : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76910];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Grenade_Sharpshooter::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Crossbow
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Crossbow : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76911];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Crossbow::pClassPointer = NULL;

// Class KFGame.KFWeapDef_M14EBR
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_M14EBR : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76912];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_M14EBR::pClassPointer = NULL;

// Class KFGame.KFWeapDef_RailGun
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_RailGun : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[76913];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_RailGun::pClassPointer = NULL;

// Class KFGame.KFWeapDef_MB500
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_MB500 : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[77073];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_MB500::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Knife_Support
// 0x0000 (0x00A4 - 0x00A4)
class UKFWeapDef_Knife_Support : public UKFweapDef_Knife_Base {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[77074];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Knife_Support::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Grenade_Support
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Grenade_Support : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[77075];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Grenade_Support::pClassPointer = NULL;

// Class KFGame.KFWeapDef_DoubleBarrel
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_DoubleBarrel : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[77076];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_DoubleBarrel::pClassPointer = NULL;

// Class KFGame.KFWeapDef_M4
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_M4 : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[77077];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_M4::pClassPointer = NULL;

// Class KFGame.KFWeapDef_AA12
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_AA12 : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[77078];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_AA12::pClassPointer = NULL;

// Class KFGame.KFWeapDef_MP7
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_MP7 : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[77239];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_MP7::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Random
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Random : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[77241];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Random::pClassPointer = NULL;

// Class KFGame.KFWeapDef_9mmDual
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_9mmDual : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[77363];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_9mmDual::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Knife_SWAT
// 0x0000 (0x00A4 - 0x00A4)
class UKFWeapDef_Knife_SWAT : public UKFweapDef_Knife_Base {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[77365];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Knife_SWAT::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Grenade_SWAT
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Grenade_SWAT : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[77366];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Grenade_SWAT::pClassPointer = NULL;

// Class KFGame.KFWeapDef_MP5RAS
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_MP5RAS : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[77367];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_MP5RAS::pClassPointer = NULL;

// Class KFGame.KFWeapDef_P90
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_P90 : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[77368];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_P90::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Kriss
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Kriss : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[77369];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Kriss::pClassPointer = NULL;

// Class KFGame.KFPerkFXEmitterPool
// 0x0000 (0x02BC - 0x02BC)
class AKFPerkFXEmitterPool : public AEmitterPool {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[77370];

        return pClassPointer;
    };
};

UClass* AKFPerkFXEmitterPool::pClassPointer = NULL;

// Class KFGame.KFPlayerStart
// 0x0004 (0x0390 - 0x038C)
class AKFPlayerStart : public APlayerStart {
   public:
    DWORD bDefaultEnabled : 1;  // 0x038C (0x0004) [0x0000000000000000]
                                // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[78276];

        return pClassPointer;
    };

    void Reset();
    void PreBeginPlay();
};

UClass* AKFPlayerStart::pClassPointer = NULL;

// Class KFGame.KFProj_BallisticExplosive
// 0x002C (0x03C8 - 0x039C)
class AKFProj_BallisticExplosive : public AKFProjectile {
   public:
    DWORD bDud : 1;  // 0x039C (0x0004) [0x00000000001E0000] [0x00000001] (
                     // CPF_EditConst | CPF_GlobalConfig | CPF_Component )
    DWORD bCollideWithTeammates : 1;  // 0x039C (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD
        bClientDudHit : 1;  // 0x039C (0x0004) [0x0000000000000000] [0x00000004]
    float ArmDistSquared;  // 0x03A0 (0x0004) [0x00000000001F0022] ( CPF_Const |
                           // CPF_Net | CPF_Travel | CPF_EditConst |
                           // CPF_GlobalConfig | CPF_Component )
    class UParticleSystem*
        ProjDudTemplate;  // 0x03A4 (0x0008) [0x0000000000000000]
    class UKFImpactEffectInfo*
        GrenadeBounceEffectInfo;  // 0x03AC (0x0008) [0x0000000000000000]
    float DampenFactor;           // 0x03B4 (0x0004) [0x0000000000000000]
    float DampenFactorParallel;   // 0x03B8 (0x0004) [0x0000000000000000]
    struct FVector
        LandedTranslationOffset;  // 0x03BC (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[78614];

        return pClassPointer;
    };

    void SetExplosionActorClass();
    void PrepareExplosionTemplate();
    void TraceProjHitZones();
    void ProcessTouch();
    void GetTerminalVelocity();
    void eventHitWall();
    void CallExplode();
    void Explode();
    void eventPreBeginPlay();
    void SyncOriginalLocation();
};

UClass* AKFProj_BallisticExplosive::pClassPointer = NULL;

// Class KFGame.KFProj_ExplosiveSubmunition_HX25
// 0x0008 (0x03D0 - 0x03C8)
class AKFProj_ExplosiveSubmunition_HX25 : public AKFProj_BallisticExplosive {
   public:
    class AKFWeapon* OwnerWeapon;  // 0x03C8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[78687];

        return pClassPointer;
    };

    void AllowNuke();
    void eventHitWall();
    void PrepareExplosionTemplate();
    void ShouldWarnAIWhenFired();
    void Init();
};

UClass* AKFProj_ExplosiveSubmunition_HX25::pClassPointer = NULL;

// Class KFGame.KFProj_RicochetStickBullet
// 0x0094 (0x0444 - 0x03B0)
class AKFProj_RicochetStickBullet : public AKFProj_RicochetBullet {
   public:
    struct FStickInfo
        RepStickInfo;  // 0x03B0 (0x002C) [0x00000000001E0000]              (
                       // CPF_EditConst | CPF_GlobalConfig | CPF_Component )
    struct FStickInfo DelayedStickInfo;  // 0x03DC (0x002C) [0x0000000000000000]
    float PickupRadius;                  // 0x0408 (0x0004) [0x0000000000000000]
    float PickupHeight;                  // 0x040C (0x0004) [0x0000000000000000]
    struct FName WeaponClassName;        // 0x0410 (0x0008) [0x0000000000000000]
    class UClass* WeaponClass;           // 0x0418 (0x0008) [0x0000000000000000]
    class UAkEvent* AmmoPickupSound;     // 0x0420 (0x0008) [0x0000000000000000]
    struct FVector LastLocation;         // 0x0428 (0x000C) [0x0000000000000000]
    DWORD bStuck : 1;  // 0x0434 (0x0004) [0x0000000000000000] [0x00000001]
    class UParticleSystem*
        ProjPickupTemplate;    // 0x0438 (0x0008) [0x0000000000000000]
    float LifeSpanAfterStick;  // 0x0440 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[78796];

        return pClassPointer;
    };

    void ShouldProcessBulletTouch();
    void ProcessTouch();
    void Tick();
    void DelayedStick();
    void Stick();
    void SpawnFlightEffects();
    void DecodeSmallVector();
    void EncodeSmallVector();
    void eventHitWall();
    void eventPreBeginPlay();
    void eventReplicatedEvent();
};

UClass* AKFProj_RicochetStickBullet::pClassPointer = NULL;

// Class KFGame.KFSeqAct_ShowPath
// 0x000E (0x015E - 0x0150)
class UKFSeqAct_ShowPath : public USequenceAction {
   public:
    DWORD bPathActive : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000001]
    class AKFReplicatedShowPathActor*
        ReplicatedPathActor;            // 0x0154 (0x0008) [0x0000000000000000]
    unsigned char VolumeCheckType;      // 0x015C (0x0001) [0x0000000000000000]
    unsigned char TeamToDisplayPathTo;  // 0x015D (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[78878];

        return pClassPointer;
    };

    void eventActivated();
};

UClass* UKFSeqAct_ShowPath::pClassPointer = NULL;

// Class KFGame.KFReplicatedShowPathActor
// 0x0014 (0x0258 - 0x0244)
class AKFReplicatedShowPathActor : public AActor {
   public:
    unsigned char PathTeamNum;  // 0x0244 (0x0001) [0x0000000000150000] (
                                // CPF_Travel | CPF_GlobalConfig )
    unsigned char VolumeCheckType;  // 0x0245 (0x0001) [0x0000000000160000] (
                                    // CPF_EditConst | CPF_GlobalConfig )
    class AVolume*
        CheckVolume;  // 0x0248 (0x0008) [0x0000000000170000]              (
                      // CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
    class AActor* Target;  // 0x0250 (0x0008) [0x0000000000180000] (
                           // CPF_Component )

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[78887];

        return pClassPointer;
    };

    void ShowPath();
    void Timer_ShowPath();
    void InitPath();
    void SetPathTarget();
    void eventReplicatedEvent();
};

UClass* AKFReplicatedShowPathActor::pClassPointer = NULL;

// Class KFGame.KFSeqAct_SetTraderVolumeIgnore
// 0x0001 (0x0151 - 0x0150)
class UKFSeqAct_SetTraderVolumeIgnore : public USequenceAction {
   public:
    unsigned char VolumeCheckType;  // 0x0150 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[78910];

        return pClassPointer;
    };

    void IsActorInVolume();
    void eventActivated();
};

UClass* UKFSeqAct_SetTraderVolumeIgnore::pClassPointer = NULL;

// Class KFGame.KFSeqAct_SetPawnIconVisibility
// 0x0000 (0x0150 - 0x0150)
class UKFSeqAct_SetPawnIconVisibility : public USequenceAction {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[79043];

        return pClassPointer;
    };

    void eventActivated();
};

UClass* UKFSeqAct_SetPawnIconVisibility::pClassPointer = NULL;

// Class KFGame.KFSeqAct_SetTeleporterURLNum
// 0x0000 (0x0150 - 0x0150)
class UKFSeqAct_SetTeleporterURLNum : public USequenceAction {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[79047];

        return pClassPointer;
    };
};

UClass* UKFSeqAct_SetTeleporterURLNum::pClassPointer = NULL;

// Class KFGame.KFSeqAct_SetTrader
// 0x0004 (0x0154 - 0x0150)
class UKFSeqAct_SetTrader : public USequenceAction {
   public:
    DWORD bAutoSetNextTraderWhenClearing : 1;  // 0x0150 (0x0004)
                                               // [0x0000000000000000]
                                               // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[79049];

        return pClassPointer;
    };

    void eventActivated();
};

UClass* UKFSeqAct_SetTrader::pClassPointer = NULL;

// Class KFGame.KFSeqEvent_MinigameActivated
// 0x0000 (0x0170 - 0x0170)
class UKFSeqEvent_MinigameActivated : public USequenceEvent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[79066];

        return pClassPointer;
    };

    void NotifyStartup();
    void NotifyDeactivation();
    void NotifyDelayedActivation();
    void NotifyActivation();
};

UClass* UKFSeqEvent_MinigameActivated::pClassPointer = NULL;

// Class KFGame.KFSeqEvent_MinigameStateChanged
// 0x0000 (0x0170 - 0x0170)
class UKFSeqEvent_MinigameStateChanged : public USequenceEvent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[79088];

        return pClassPointer;
    };

    void StateChanged();
};

UClass* UKFSeqEvent_MinigameStateChanged::pClassPointer = NULL;

// Class KFGame.KFSeqEvent_WaveEnd
// 0x0000 (0x0170 - 0x0170)
class UKFSeqEvent_WaveEnd : public USequenceEvent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[79101];

        return pClassPointer;
    };

    void SetWaveNum();
};

UClass* UKFSeqEvent_WaveEnd::pClassPointer = NULL;

// Class KFGame.KFSFXVolume
// 0x0018 (0x0298 - 0x0280)
class AKFSFXVolume : public AVolume {
   public:
    float MinInterval;                  // 0x0280 (0x0004) [0x0000000000000000]
    float MaxInterval;                  // 0x0284 (0x0004) [0x0000000000000000]
    TArray<class UAkEvent*> SFXEvents;  // 0x0288 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[79114];

        return pClassPointer;
    };

    void GetRandomInterval();
    void PlaySFX();
    void eventPostBeginPlay();
};

UClass* AKFSFXVolume::pClassPointer = NULL;

// Class KFGame.KFSkeletalMeshActor
// 0x0004 (0x02A8 - 0x02A4)
class AKFSkeletalMeshActor : public ASkeletalMeshActor {
   public:
    DWORD
        bClientsideKismetSetMaterial : 1;  // 0x02A4 (0x0004)
                                           // [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[79176];

        return pClassPointer;
    };

    void OnSetMaterial();
};

UClass* AKFSkeletalMeshActor::pClassPointer = NULL;

// Class KFGame.KFSM_PlayerMeleeBase
// 0x001C (0x0170 - 0x0154)
class UKFSM_PlayerMeleeBase : public UKFSM_MeleeAttack {
   public:
    DWORD bAnimCanBeInterrupted : 1;  // 0x0154 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    TArray<struct FPlayerZedAtkInfo>
        Attacks;                     // 0x0158 (0x0010) [0x0000000000000000]
    class UAkEvent* SoundStopEvent;  // 0x0168 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[79885];

        return pClassPointer;
    };

    void SpecialMoveButtonReleased();
    void SpecialMoveButtonRetriggered();
    void SpecialMoveFlagsUpdated();
    void Timer_AnimInterrupt();
    void UnpackSpecialMoveFlags();
    void GetFourWayMoveDirection();
    void IsInSpecialMode();
    void SpecialMoveEnded();
    void SpecialMoveStarted();
    void PackFlagsBase();
};

UClass* UKFSM_PlayerMeleeBase::pClassPointer = NULL;

// Class KFGame.KFTeleporter
// 0x0014 (0x03BC - 0x03A8)
class AKFTeleporter : public ATeleporter {
   public:
    int URLNum;                   // 0x03A8 (0x0004) [0x0000000000000000]
    TArray<struct FString> URLs;  // 0x03AC (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[80387];

        return pClassPointer;
    };

    void eventSpecialHandling();
    void eventPostTouch();
    void eventPostBeginPlay();
    void OnSetURLNum();
};

UClass* AKFTeleporter::pClassPointer = NULL;

// Class KFGame.KFVoiceInfo
// 0x00BC (0x011C - 0x0060)
class UKFVoiceInfo : public UObject {
   public:
    TArray<class USoundNodeWave*>
        AckSounds;  // 0x0060 (0x0010) [0x0000000000000000]
    TArray<class USoundNodeWave*>
        FriendlyFireSounds;  // 0x0070 (0x0010) [0x0000000000000000]
    TArray<class USoundNodeWave*>
        GotYourBackSounds;  // 0x0080 (0x0010) [0x0000000000000000]
    TArray<class USoundNodeWave*>
        NeedOurFlagSounds;  // 0x0090 (0x0010) [0x0000000000000000]
    TArray<class USoundNodeWave*>
        SniperSounds;  // 0x00A0 (0x0010) [0x0000000000000000]
    TArray<class USoundNodeWave*>
        InPositionSounds;  // 0x00B0 (0x0010) [0x0000000000000000]
    TArray<class USoundNodeWave*>
        HaveFlagSounds;  // 0x00C0 (0x0010) [0x0000000000000000]
    TArray<class USoundNodeWave*>
        AreaSecureSounds;  // 0x00D0 (0x0010) [0x0000000000000000]
    class USoundNodeWave*
        IncomingSound;  // 0x00E0 (0x0008) [0x0000000000000000]
    class USoundNodeWave*
        EnemyFlagCarrierSound;  // 0x00E8 (0x0008) [0x0000000000000000]
    class USoundNodeWave*
        EnemyFlagCarrierHereSound;  // 0x00F0 (0x0008) [0x0000000000000000]
    class USoundNodeWave*
        EnemyFlagCarrierHighSound;  // 0x00F8 (0x0008) [0x0000000000000000]
    class USoundNodeWave*
        EnemyFlagCarrierLowSound;  // 0x0100 (0x0008) [0x0000000000000000]
    class USoundNodeWave*
        MidfieldSound;  // 0x0108 (0x0008) [0x0000000000000000]
    class USoundNodeWave*
        GotOurFlagSound;       // 0x0110 (0x0008) [0x0000000000000000]
    int LocationSpeechOffset;  // 0x0118 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[80768];

        return pClassPointer;
    };

    void GetNeedOurFlagMessageIndex();
    void GetGotYourBackMessageIndex();
    void GetFriendlyFireMessageIndex();
    void GetAckMessageIndex();
};

UClass* UKFVoiceInfo::pClassPointer = NULL;

// Class KFGame.KFWaterMeshActor
// 0x0000 (0x02B0 - 0x02B0)
class AKFWaterMeshActor : public AStaticMeshActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[80925];

        return pClassPointer;
    };
};

UClass* AKFWaterMeshActor::pClassPointer = NULL;

// Class KFGame.KFWeap_GrenadeLauncher_Base
// 0x0004 (0x08C4 - 0x08C0)
class AKFWeap_GrenadeLauncher_Base : public AKFWeapon {
   public:
    float ForceReloadTime;  // 0x08C0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[82457];

        return pClassPointer;
    };

    void ProcessInstantHitEx();
    void GetReloadAnimName();
    void ShouldPlayFireLast();
    void GetForceReloadDelay();
    void eventGetTraderFilter();
    void CalculateTraderWeaponStatDamage();
};

UClass* AKFWeap_GrenadeLauncher_Base::pClassPointer = NULL;

// Class KFGame.KFWeap_RifleBase
// 0x0000 (0x08C0 - 0x08C0)
class AKFWeap_RifleBase : public AKFWeapon {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[82938];

        return pClassPointer;
    };

    void ProcessInstantHitEx();
    void eventGetTraderFilter();
};

UClass* AKFWeap_RifleBase::pClassPointer = NULL;

// Class KFGame.KFWeap_ShotgunBase
// 0x0010 (0x08D0 - 0x08C0)
class AKFWeap_ShotgunBase : public AKFWeapon {
   public:
    TArray<unsigned char> NumPellets;  // 0x08C0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[83005];

        return pClassPointer;
    };

    void eventGetTraderFilter();
    void CalculateTraderWeaponStatDamage();
    void AddMultiShotSpread();
    void AddSpread();
    void HandleWeaponShotTaken();
    void GetNumProjectilesToFire();
    void SpawnProjectile();
};

UClass* AKFWeap_ShotgunBase::pClassPointer = NULL;

// Class KFGame.KFWeap_SMGBase
// 0x0000 (0x08C0 - 0x08C0)
class AKFWeap_SMGBase : public AKFWeapon {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[83044];

        return pClassPointer;
    };

    void eventGetTraderFilter();
};

UClass* AKFWeap_SMGBase::pClassPointer = NULL;

// Class KFGame.KFWeap_ThrownBase
// 0x0044 (0x0904 - 0x08C0)
class AKFWeap_ThrownBase : public AKFWeapon {
   public:
    TArray<struct FName> IdleLastAnims;  // 0x08C0 (0x0010) [0x0000000000000000]
    TArray<struct FName>
        IdleLastPickupAnims;  // 0x08D0 (0x0010) [0x0000000000000000]
    TArray<struct FName>
        MeleeAttackLastAnims;      // 0x08E0 (0x0010) [0x0000000000000000]
    struct FName EquipLastAnim;    // 0x08F0 (0x0008) [0x0000000000000000]
    struct FName PutDownLastAnim;  // 0x08F8 (0x0008) [0x0000000000000000]
    float ConsumeSpareAmmoDelay;   // 0x0900 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[83051];

        return pClassPointer;
    };

    void CalculateTraderWeaponStatDamage();
    void ShouldIncrementFlashCountOnFire();
    void SendToFiringState();
    void PerformArtificialReload();
    void ClientNotifyAmmoAddedEmpty();
    void AllowSprinting();
    void ShouldAutoReload();
    void ShouldPlayFireLast();
    void GetGrenadeThrowAnim();
    void GetEquipAnimName();
    void GetSprintEndAnimName();
    void GetSprintLoopAnimName();
    void GetSprintStartAnimName();
    void GetWeaponPutDownAnimName();
    void GetMeleeAnimName();
    void ShouldPlayLastAnims();
};

UClass* AKFWeap_ThrownBase::pClassPointer = NULL;

// Class KFGame.KFWeapAttach_DualBase
// 0x0038 (0x0420 - 0x03E8)
class AKFWeapAttach_DualBase : public AKFWeaponAttachment {
   public:
    class USkeletalMesh*
        LeftHandSkelMesh;               // 0x03E8 (0x0008) [0x0000000000000000]
    class UAnimSet* LeftWeaponAnimSet;  // 0x03F0 (0x0008) [0x0000000000000000]
    class USkeletalMeshComponent*
        LeftWeapMesh;  // 0x03F8 (0x0008) [0x0000000000000000]
    class UKFMuzzleFlash*
        LeftMuzzleFlash;  // 0x0400 (0x0008) [0x0000000000000000]
    class UKFMuzzleFlash*
        LeftMuzzleFlashTemplate;  // 0x0408 (0x0008) [0x0000000000000000]
    class UAnimNodeSequence*
        LeftWeapAnimNode;             // 0x0410 (0x0008) [0x0000000000000000]
    DWORD bPlayFXOnSecondWeapon : 1;  // 0x0418 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    float LastChooseWeaponTime;       // 0x041C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[83392];

        return pClassPointer;
    };

    void HasOutdoorLighting();
    void HasIndoorLighting();
    void SetMeshLightingChannels();
    void PlayWeaponMeshAnim();
    void GetMuzzleLocation();
    void CauseMuzzleFlash();
    void PlayPawnFireAnim();
    void PlayWeaponFireAnim();
    void ThirdPersonFireEffects();
    void ChooseActiveWeapon();
    void SetWeaponSkin();
    void AttachMuzzleFlash();
    void DetachFrom();
    void AttachTo();
    void eventChangeVisibility();
    void eventPreBeginPlay();
};

UClass* AKFWeapAttach_DualBase::pClassPointer = NULL;

// Class KFGame.KFWeapDef_C4
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_C4 : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[83552];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_C4::pClassPointer = NULL;

// Class KFGame.KFWeapDef_CenterfireMB464
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_CenterfireMB464 : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[83555];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_CenterfireMB464::pClassPointer = NULL;

// Class KFGame.KFWeapDef_FlareGun
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_FlareGun : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[83567];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_FlareGun::pClassPointer = NULL;

// Class KFGame.KFWeapDef_FlareGunDual
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_FlareGunDual : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[83569];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_FlareGunDual::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Healer
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Healer : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[83580];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Healer::pClassPointer = NULL;

// Class KFGame.KFWeapDef_HZ12
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_HZ12 : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[83583];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_HZ12::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Katana
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Katana : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[83585];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Katana::pClassPointer = NULL;

// Class KFGame.KFWeapDef_MaceAndShield
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_MaceAndShield : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[83602];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_MaceAndShield::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Stoner63A
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Stoner63A : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[83621];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Stoner63A::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Welder
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Welder : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[83625];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Welder::pClassPointer = NULL;

// Class KFGame.KFWeapDef_Zweihander
// 0x0001 (0x00A4 - 0x00A3)
class UKFWeapDef_Zweihander : public UKFWeaponDefinition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[83628];

        return pClassPointer;
    };
};

UClass* UKFWeapDef_Zweihander::pClassPointer = NULL;

#ifdef _MSC_VER
#pragma pack(pop)
#endif