/*
#############################################################################################
# Killing Floor 2 (1.8787) SDK
# Generated with TheFeckless UE3 SDK Generator v1.4_Beta-Rev.51
#
=========================================================================================
# # File: Engine_classes.h #
=========================================================================================
# # Credits: uNrEaL, Tamimego, SystemFiles, R00T88, _silencer, the1domo, K@N@VEL
# Thanks: HOOAH07, lowHertz
# Forums: www.uc-forum.com, www.gamedeception.net
#############################################################################################
*/

#ifdef _MSC_VER
#pragma pack(push, 0x4)
#endif

/*
#
=========================================================================================
# # Constants #
=========================================================================================
#
*/

#define CONST_MINFLOORZ 0.7
#define CONST_ACTORMAXSTEPHEIGHT 35.0
#define CONST_RBSTATE_LINVELSCALE 10.0
#define CONST_RBSTATE_ANGVELSCALE 1000.0
#define CONST_RB_None 0x00
#define CONST_RB_NeedsUpdate 0x01
#define CONST_RB_Sleeping 0x02
#define CONST_REP_RBLOCATION_ERROR_TOLERANCE_SQ 16.0f
#define CONST_TRACEFLAG_ForceController 16
#define CONST_TRACEFLAG_Blocking 8
#define CONST_TRACEFLAG_SkipMovers 4
#define CONST_TRACEFLAG_PhysicsVolumes 2
#define CONST_TRACEFLAG_Bullet 1
#define CONST_SDPG_NumBits 3
#define CONST_PIT_All 0x001F
#define CONST_PIT_GameDemo 0x0010
#define CONST_PIT_Durable 0x0008
#define CONST_PIT_Consumable 0x0004
#define CONST_PIT_App 0x0002
#define CONST_PIT_Game 0x0001
#define CONST_LATENT_MOVETOWARD 503
#define CONST_MAX_ACTIVE_CAMERA_ANIMS 8
#define CONST_MAXCLIENTUPDATEINTERVAL 0.25
#define CONST_CLIENTADJUSTUPDATECOST 180.0
#define CONST_MAXVEHICLEPOSITIONERRORSQUARED 900.0
#define CONST_MAXNEARZEROVELOCITYSQUARED 9.0
#define CONST_MAXPOSITIONERRORSQUARED 3.0
#define CONST_BLOCKEDPATHCOST 10000000
#define CONST_INFINITE_PATH_COST 10000000
#define CONST_GET_SAVE_SLOT_INVALID -1
#define CONST_GET_SAVE_SLOT_ERROR -2
#define CONST_COMMON_DATA_SAVE_SLOT_INDEX -1
#define CONST_SAVE_SYSTEM_VERSION_KEY "CloudSaveSystemVersion"
#define CONST_SAVE_DATA_BLOB_NAME_KEY "DataBlobName"
#define CONST_DATA_STORE_ID_KEY "DataStoreID"
#define CONST_NUM_SAVE_SLOTS_KEY "NumSaveSlots"
#define CONST_DEFAULT_SIZE_X 1024
#define CONST_DEFAULT_SIZE_Y 768
#define CONST_MAX_SUPPORTED_GAMEPADS 24
#define CONST_MaxHistory 16
#define CONST_COVERLINK_DangerDist 1536.f
#define CONST_COVERLINK_EdgeExposureDot 0.85f
#define CONST_COVERLINK_EdgeCheckDot 0.25f
#define CONST_COVERLINK_ExposureDot 0.4f
#define CONST_NULLCHARACTER 127
#define CONST_MAX_INSTANCES_PER_CLASS 5
#define CONST_MAX_BOOKMARK_NUMBER 10
#define CONST_FSM_DEFAULTRECYCLETIME 0.2
#define CONST_HeaderFlags_NoEventStrings 1
#define CONST_GAMEEVENT_MATCH_STARTED 0
#define CONST_GAMEEVENT_MATCH_ENDED 1
#define CONST_GAMEEVENT_ROUND_STARTED 2
#define CONST_GAMEEVENT_ROUND_ENDED 3
#define CONST_GAMEEVENT_GAME_CLASS 6
#define CONST_GAMEEVENT_GAME_OPTION_URL 7
#define CONST_GAMEEVENT_GAME_MAPNAME 8
#define CONST_GAMEEVENT_MEMORYUSAGE_POLL 35
#define CONST_GAMEEVENT_FRAMERATE_POLL 36
#define CONST_GAMEEVENT_NETWORKUSAGEIN_POLL 37
#define CONST_GAMEEVENT_NETWORKUSAGEOUT_POLL 38
#define CONST_GAMEEVENT_PING_POLL 39
#define CONST_GAMEEVENT_RENDERTHREAD_POLL 40
#define CONST_GAMEEVENT_GAMETHREAD_POLL 41
#define CONST_GAMEEVENT_GPUFRAMETIME_POLL 42
#define CONST_GAMEEVENT_FRAMETIME_POLL 43
#define CONST_GAMEEVENT_TEAM_CREATED 50
#define CONST_GAMEEVENT_TEAM_GAME_SCORE 51
#define CONST_GAMEEVENT_TEAM_MATCH_WON 4
#define CONST_GAMEEVENT_TEAM_ROUND_WON 5
#define CONST_GAMEEVENT_TEAM_ROUND_STALEMATE 52
#define CONST_GAMEEVENT_PLAYER_LOGIN 100
#define CONST_GAMEEVENT_PLAYER_LOGOUT 101
#define CONST_GAMEEVENT_PLAYER_SPAWN 102
#define CONST_GAMEEVENT_PLAYER_MATCH_WON 103
#define CONST_GAMEEVENT_PLAYER_KILL 104
#define CONST_GAMEEVENT_PLAYER_LOCATION_POLL 105
#define CONST_GAMEEVENT_PLAYER_TEAMCHANGE 106
#define CONST_GAMEEVENT_PLAYER_KILL_STREAK 107
#define CONST_GAMEEVENT_PLAYER_DEATH 108
#define CONST_GAMEEVENT_PLAYER_ROUND_WON 109
#define CONST_GAMEEVENT_PLAYER_ROUND_STALEMATE 110
#define CONST_GAMEEVENT_WEAPON_DAMAGE 150
#define CONST_GAMEEVENT_WEAPON_DAMAGE_MELEE 151
#define CONST_GAMEEVENT_WEAPON_FIRED 152
#define CONST_GAMEEVENT_PLAYER_KILL_NORMAL 200
#define CONST_GAMEEVENT_GENERIC_PARAM_LIST_START 300
#define CONST_GAMEEVENT_GENERIC_PARAM_LIST_END 400
#define CONST_GAMEEVENT_GAME_SPECIFIC 1000
#define CONST_GAMEEVENT_MAX_EVENTID 0x0000FFFF
#define CONST_SCENEFILTER_None 0x00000000
#define CONST_SCENEFILTER_IncludeTransient 0x00000001
#define CONST_SCENEFILTER_InputProcessorOnly 0x00000002
#define CONST_SCENEFILTER_PausersOnly 0x00000004
#define CONST_SCENEFILTER_PrimitiveUsersOnly 0x00000008
#define CONST_SCENEFILTER_UsesPostProcessing 0x00000010
#define CONST_SCENEFILTER_ReceivesFocus 0x00000020
#define CONST_SCENEFILTER_Any 0xFFFFFFFF
#define CONST_MAX_AIGROUP_NUMBER 10
#define CONST_LINECHECK_GRANULARITY 768.f
#define CONST_NUM_PATHFINDING_PARAMS 9
#define CONST_NumBreadCrumbs 10
#define CONST_PROCBUILDING_VERSION 1
#define CONST_ROOF_MINZ 0.7

/*
#
=========================================================================================
# # Enums #
=========================================================================================
#
*/

// Enum Engine.StaticMesh.EFlexCollisionLevel
/*enum EFlexCollisionLevel
{
        Auto                                               = 0,
        On                                                 = 1,
        Off                                                = 2,
        EFlexCollisionLevel_MAX                            = 3
};*/

// Enum Engine.Actor.EActorMetricsType
/*enum EActorMetricsType
{
        METRICS_VERTS                                      = 0,
        METRICS_TRIS                                       = 1,
        METRICS_SECTIONS                                   = 2,
        METRICS_MAX                                        = 3
};*/

// Enum Engine.Actor.EPhysics
/*enum EPhysics
{
        PHYS_None                                          = 0,
        PHYS_Walking                                       = 1,
        PHYS_Falling                                       = 2,
        PHYS_Swimming                                      = 3,
        PHYS_Flying                                        = 4,
        PHYS_Rotating                                      = 5,
        PHYS_Projectile                                    = 6,
        PHYS_Interpolating                                 = 7,
        PHYS_Spider                                        = 8,
        PHYS_Ladder                                        = 9,
        PHYS_RigidBody                                     = 10,
        PHYS_SoftBody                                      = 11,
        PHYS_NavMeshWalking                                = 12,
        PHYS_Unused                                        = 13,
        PHYS_Custom                                        = 14,
        PHYS_MAX                                           = 15
};*/

// Enum Engine.Actor.EMoveDir
/*enum EMoveDir
{
        MD_Stationary                                      = 0,
        MD_Forward                                         = 1,
        MD_Backward                                        = 2,
        MD_Left                                            = 3,
        MD_Right                                           = 4,
        MD_Up                                              = 5,
        MD_Down                                            = 6,
        MD_MAX                                             = 7
};*/

// Enum Engine.Actor.ECollisionType
/*enum ECollisionType
{
        COLLIDE_CustomDefault                              = 0,
        COLLIDE_NoCollision                                = 1,
        COLLIDE_BlockAll                                   = 2,
        COLLIDE_BlockWeapons                               = 3,
        COLLIDE_TouchAll                                   = 4,
        COLLIDE_TouchWeapons                               = 5,
        COLLIDE_BlockAllButWeapons                         = 6,
        COLLIDE_TouchAllButWeapons                         = 7,
        COLLIDE_BlockWeaponsKickable                       = 8,
        COLLIDE_MAX                                        = 9
};*/

// Enum Engine.Actor.ETravelType
/*enum ETravelType
{
        TRAVEL_Absolute                                    = 0,
        TRAVEL_Partial                                     = 1,
        TRAVEL_Relative                                    = 2,
        TRAVEL_MAX                                         = 3
};*/

// Enum Engine.Actor.EDoubleClickDir
/*enum EDoubleClickDir
{
        DCLICK_None                                        = 0,
        DCLICK_Left                                        = 1,
        DCLICK_Right                                       = 2,
        DCLICK_Forward                                     = 3,
        DCLICK_Back                                        = 4,
        DCLICK_Active                                      = 5,
        DCLICK_Done                                        = 6,
        DCLICK_MAX                                         = 7
};*/

// Enum Engine.Actor.EZedTimeType
/*enum EZedTimeType
{
        ZTT_ClientEffect                                   = 0,
        ZTT_Always                                         = 1,
        ZTT_Never                                          = 2,
        ZTT_Manual                                         = 3,
        ZTT_MAX                                            = 4
};*/

// Enum Engine.Actor.ENetRole
/*enum ENetRole
{
        ROLE_None                                          = 0,
        ROLE_SimulatedProxy                                = 1,
        ROLE_AutonomousProxy                               = 2,
        ROLE_Authority                                     = 3,
        ROLE_MAX                                           = 4
};*/

// Enum Engine.PrimitiveComponent.GJKResult
/*enum GJKResult
{
        GJK_Intersect                                      = 0,
        GJK_NoIntersection                                 = 1,
        GJK_Fail                                           = 2,
        GJK_MAX                                            = 3
};*/

// Enum Engine.Scene.EDetailMode
/*enum EDetailMode
{
        DM_Low                                             = 0,
        DM_Medium                                          = 1,
        DM_High                                            = 2,
        DM_MAX                                             = 3
};*/

// Enum Engine.Scene.ESceneDepthPriorityGroup
/*enum ESceneDepthPriorityGroup
{
        SDPG_UnrealEdBackground                            = 0,
        SDPG_World                                         = 1,
        SDPG_Foreground                                    = 2,
        SDPG_UnrealEdForeground                            = 3,
        SDPG_PostProcess                                   = 4,
        SDPG_MAX                                           = 5
};*/

// Enum Engine.PrimitiveComponent.ERBCollisionChannel
/*enum ERBCollisionChannel
{
        RBCC_Default                                       = 0,
        RBCC_Nothing                                       = 1,
        RBCC_Pawn                                          = 2,
        RBCC_Vehicle                                       = 3,
        RBCC_Water                                         = 4,
        RBCC_GameplayPhysics                               = 5,
        RBCC_EffectPhysics                                 = 6,
        RBCC_Untitled1                                     = 7,
        RBCC_Untitled2                                     = 8,
        RBCC_Untitled3                                     = 9,
        RBCC_Untitled4                                     = 10,
        RBCC_Cloth                                         = 11,
        RBCC_FluidDrain                                    = 12,
        RBCC_SoftBody                                      = 13,
        RBCC_FracturedMeshPart                             = 14,
        RBCC_BlockingVolume                                = 15,
        RBCC_DeadPawn                                      = 16,
        RBCC_Clothing                                      = 17,
        RBCC_ClothingCollision                             = 18,
        RBCC_Pickup                                        = 19,
        RBCC_FlexAsset                                     = 20,
        RBCC_CanBecomeDynamic                              = 21,
        RBCC_KnockedDownPawn                               = 22,
        RBCC_Visibility                                    = 23,
        RBCC_MAX                                           = 24
};*/

// Enum Engine.PrimitiveComponent.ERadialImpulseFalloff
/*enum ERadialImpulseFalloff
{
        RIF_Constant                                       = 0,
        RIF_Linear                                         = 1,
        RIF_MAX                                            = 2
};*/

// Enum Engine.Texture.TextureCompressionSettings
/*enum TextureCompressionSettings
{
        TC_Default                                         = 0,
        TC_Normalmap                                       = 1,
        TC_Displacementmap                                 = 2,
        TC_NormalmapAlpha                                  = 3,
        TC_Grayscale                                       = 4,
        TC_HighDynamicRange                                = 5,
        TC_OneBitAlpha                                     = 6,
        TC_NormalmapUncompressed                           = 7,
        TC_NormalmapBC5                                    = 8,
        TC_OneBitMonochrome                                = 9,
        TC_SimpleLightmapModification                      = 10,
        TC_VectorDisplacementmap                           = 11,
        TC_MAX                                             = 12
};*/

// Enum Engine.Texture.EPixelFormat
/*enum EPixelFormat
{
        PF_Unknown                                         = 0,
        PF_A32B32G32R32F                                   = 1,
        PF_A8R8G8B8                                        = 2,
        PF_G8                                              = 3,
        PF_G16                                             = 4,
        PF_DXT1                                            = 5,
        PF_DXT3                                            = 6,
        PF_DXT5                                            = 7,
        PF_UYVY                                            = 8,
        PF_FloatRGB                                        = 9,
        PF_FloatRGBA                                       = 10,
        PF_DepthStencil                                    = 11,
        PF_ShadowDepth                                     = 12,
        PF_FilteredShadowDepth                             = 13,
        PF_R32F                                            = 14,
        PF_G16R16                                          = 15,
        PF_G16R16F                                         = 16,
        PF_G16R16F_FILTER                                  = 17,
        PF_G32R32F                                         = 18,
        PF_A2B10G10R10                                     = 19,
        PF_A16B16G16R16                                    = 20,
        PF_D24                                             = 21,
        PF_R16F                                            = 22,
        PF_R16F_FILTER                                     = 23,
        PF_BC5                                             = 24,
        PF_V8U8                                            = 25,
        PF_A1                                              = 26,
        PF_FloatR11G11B10                                  = 27,
        PF_A4R4G4B4                                        = 28,
        PF_R5G6B5                                          = 29,
        PF_R8G8                                            = 30,
        PF_R32_UINT                                        = 31,
        PF_MAX                                             = 32
};*/

// Enum Engine.Texture.TextureFilter
/*enum TextureFilter
{
        TF_Nearest                                         = 0,
        TF_Linear                                          = 1,
        TF_MAX                                             = 2
};*/

// Enum Engine.Texture.TextureAddress
/*enum TextureAddress
{
        TA_Wrap                                            = 0,
        TA_Clamp                                           = 1,
        TA_Mirror                                          = 2,
        TA_MAX                                             = 3
};*/

// Enum Engine.Texture.TextureGroup
/*enum TextureGroup
{
        TEXTUREGROUP_World                                 = 0,
        TEXTUREGROUP_WorldNormalMap                        = 1,
        TEXTUREGROUP_WorldSpecular                         = 2,
        TEXTUREGROUP_Character                             = 3,
        TEXTUREGROUP_CharacterNormalMap                    = 4,
        TEXTUREGROUP_CharacterSpecular                     = 5,
        TEXTUREGROUP_Weapon                                = 6,
        TEXTUREGROUP_WeaponNormalMap                       = 7,
        TEXTUREGROUP_WeaponSpecular                        = 8,
        TEXTUREGROUP_Vehicle                               = 9,
        TEXTUREGROUP_VehicleNormalMap                      = 10,
        TEXTUREGROUP_VehicleSpecular                       = 11,
        TEXTUREGROUP_Cinematic                             = 12,
        TEXTUREGROUP_Effects                               = 13,
        TEXTUREGROUP_EffectsNotFiltered                    = 14,
        TEXTUREGROUP_Skybox                                = 15,
        TEXTUREGROUP_UI                                    = 16,
        TEXTUREGROUP_Lightmap                              = 17,
        TEXTUREGROUP_RenderTarget                          = 18,
        TEXTUREGROUP_MobileFlattened                       = 19,
        TEXTUREGROUP_ProcBuilding_Face                     = 20,
        TEXTUREGROUP_ProcBuilding_LightMap                 = 21,
        TEXTUREGROUP_Shadowmap                             = 22,
        TEXTUREGROUP_ColorLookupTable                      = 23,
        TEXTUREGROUP_Terrain_Heightmap                     = 24,
        TEXTUREGROUP_Terrain_Weightmap                     = 25,
        TEXTUREGROUP_ImageBasedReflection                  = 26,
        TEXTUREGROUP_Bokeh                                 = 27,
        TEXTUREGROUP_Creature                              = 28,
        TEXTUREGROUP_CreatureNormalMap                     = 29,
        TEXTUREGROUP_CreatureSpecular                      = 30,
        TEXTUREGROUP_Weapon3rd                             = 31,
        TEXTUREGROUP_Weapon3rdNormalMap                    = 32,
        TEXTUREGROUP_Weapon3rdSpecular                     = 33,
        TEXTUREGROUP_Splattermap                           = 34,
        TEXTUREGROUP_Cosmetic                              = 35,
        TEXTUREGROUP_CosmeticNormalMap                     = 36,
        TEXTUREGROUP_CosmeticSpecular                      = 37,
        TEXTUREGROUP_UIWithMips                            = 38,
        TEXTUREGROUP_MAX                                   = 39
};*/

// Enum Engine.Texture.TextureMipGenSettings
/*enum TextureMipGenSettings
{
        TMGS_FromTextureGroup                              = 0,
        TMGS_SimpleAverage                                 = 1,
        TMGS_Sharpen0                                      = 2,
        TMGS_Sharpen1                                      = 3,
        TMGS_Sharpen2                                      = 4,
        TMGS_Sharpen3                                      = 5,
        TMGS_Sharpen4                                      = 6,
        TMGS_Sharpen5                                      = 7,
        TMGS_Sharpen6                                      = 8,
        TMGS_Sharpen7                                      = 9,
        TMGS_Sharpen8                                      = 10,
        TMGS_Sharpen9                                      = 11,
        TMGS_Sharpen10                                     = 12,
        TMGS_NoMipmaps                                     = 13,
        TMGS_LeaveExistingMips                             = 14,
        TMGS_Blur1                                         = 15,
        TMGS_Blur2                                         = 16,
        TMGS_Blur3                                         = 17,
        TMGS_Blur4                                         = 18,
        TMGS_Blur5                                         = 19,
        TMGS_MAX                                           = 20
};*/

// Enum Engine.Texture.ETextureMipCount
/*enum ETextureMipCount
{
        TMC_ResidentMips                                   = 0,
        TMC_AllMips                                        = 1,
        TMC_AllMipsBiased                                  = 2,
        TMC_MAX                                            = 3
};*/

// Enum Engine.OnlineSubsystem.ENATType
/*enum ENATType
{
        NAT_Unknown                                        = 0,
        NAT_Open                                           = 1,
        NAT_Moderate                                       = 2,
        NAT_Strict                                         = 3,
        NAT_MAX                                            = 4
};*/

// Enum Engine.OnlineSubsystem.EOnlineServerConnectionStatus
/*enum EOnlineServerConnectionStatus
{
        OSCS_NotConnected                                  = 0,
        OSCS_Connected                                     = 1,
        OSCS_ConnectionDropped                             = 2,
        OSCS_NoNetworkConnection                           = 3,
        OSCS_ServiceUnavailable                            = 4,
        OSCS_UpdateRequired                                = 5,
        OSCS_ServersTooBusy                                = 6,
        OSCS_DuplicateLoginDetected                        = 7,
        OSCS_InvalidUser                                   = 8,
        OSCS_Banned                                        = 9,
        OSCS_TooYoung                                      = 10,
        OSCS_PSNUnavailable                                = 11,
        OSCS_XBLiveUnavailable                             = 12,
        OSCS_MAX                                           = 13
};*/

// Enum Engine.OnlineSubsystem.ELoginStatus
/*enum ELoginStatus
{
        LS_NotLoggedIn                                     = 0,
        LS_UsingLocalProfile                               = 1,
        LS_LoggedIn                                        = 2,
        LS_MAX                                             = 3
};*/

// Enum Engine.OnlineSubsystem.ItemType
/*enum ItemType
{
        ITP_WeaponSkin                                     = 0,
        ITP_CharacterSkin                                  = 1,
        ITP_KeyCrate                                       = 2,
        ITP_Item                                           = 3,
        ITP_CraftingComponent                              = 4,
        ITP_Emote                                          = 5,
        ITP_NONE                                           = 6,
        ITP_MAX                                            = 7
};*/

// Enum Engine.OnlineSubsystem.ItemRarity
/*enum ItemRarity
{
        ITR_Common                                         = 0,
        ITR_Uncommon                                       = 1,
        ITR_Rare                                           = 2,
        ITR_Mythical                                       = 3,
        ITR_Legendary                                      = 4,
        ITR_ExceedinglyRare                                = 5,
        ITR_NONE                                           = 6,
        ITR_MAX                                            = 7
};*/

// Enum Engine.OnlineSubsystem.ESessionMemberStatus
/*enum ESessionMemberStatus
{
        DSMS_Reserved                                      = 0,
        DSMS_Inactive                                      = 1,
        DSMS_Ready                                         = 2,
        DSMS_Active                                        = 3,
        DSMS_MAX                                           = 4
};*/

// Enum Engine.OnlineSubsystem.EOnlineNewsType
/*enum EOnlineNewsType
{
        ONT_Unknown                                        = 0,
        ONT_GameNews                                       = 1,
        ONT_ContentAnnouncements                           = 2,
        ONT_Misc                                           = 3,
        ONT_MAX                                            = 4
};*/

// Enum Engine.OnlineSubsystem.EInventoryItemState
/*enum EInventoryItemState
{
        IIS_Unknown                                        = 0,
        IIS_All                                            = 1,
        IIS_Enabled                                        = 2,
        IIS_Suspended                                      = 3,
        IIS_Expired                                        = 4,
        IIS_Canceled                                       = 5,
        IIS_MAX                                            = 6
};*/

// Enum Engine.OnlineSubsystem.EMediaItemType
/*enum EMediaItemType
{
        MIT_Unknown                                        = 0,
        MIT_Game                                           = 1,
        MIT_Application                                    = 2,
        MIT_GameContent                                    = 3,
        MIT_GameConsumable                                 = 4,
        MIT_Subscription                                   = 5,
        MIT_All                                            = 6,
        MIT_MAX                                            = 7
};*/

// Enum Engine.OnlineSubsystem.EOnlineEnumerationReadState
/*enum EOnlineEnumerationReadState
{
        OERS_NotStarted                                    = 0,
        OERS_InProgress                                    = 1,
        OERS_Done                                          = 2,
        OERS_Failed                                        = 3,
        OERS_MAX                                           = 4
};*/

// Enum Engine.OnlineSubsystem.EOnlineGameState
/*enum EOnlineGameState
{
        OGS_NoSession                                      = 0,
        OGS_Pending                                        = 1,
        OGS_Starting                                       = 2,
        OGS_InProgress                                     = 3,
        OGS_Ending                                         = 4,
        OGS_Ended                                          = 5,
        OGS_MAX                                            = 6
};*/

// Enum Engine.OnlineSubsystem.ECatalogSortOrder
/*enum ECatalogSortOrder
{
        CSO_FreeAndPaidCountDaily                          = 0,
        CSO_PaidCountAllTime                               = 1,
        CSO_PaidCountDail                                  = 2,
        CSO_DigitalReleaseDate                             = 3,
        CSO_ReleaseDate                                    = 4,
        CSO_UserRatings                                    = 5,
        CSO_MAX                                            = 6
};*/

// Enum Engine.OnlineSubsystem.EAchievementUnlockType
/*enum EAchievementUnlockType
{
        AUT_Unknown                                        = 0,
        AUT_All                                            = 1,
        AUT_Persistent                                     = 2,
        AUT_Challenge                                      = 3,
        AUT_MAX                                            = 4
};*/

// Enum Engine.OnlineSubsystem.EAchievementMediaAssetType
/*enum EAchievementMediaAssetType
{
        AMAT_Unknown                                       = 0,
        AMAT_Icon                                          = 1,
        AMAT_Art                                           = 2,
        AMAT_MAX                                           = 3
};*/

// Enum Engine.OnlineSubsystem.EAchievementParticipationType
/*enum EAchievementParticipationType
{
        EAPT_Unknown                                       = 0,
        EAPT_Individual                                    = 1,
        EAPT_Group                                         = 2,
        EAPT_MAX                                           = 3
};*/

// Enum Engine.OnlineSubsystem.EAchievementProgressState
/*enum EAchievementProgressState
{
        APS_Unknown                                        = 0,
        APS_Achieved                                       = 1,
        APS_NotStarted                                     = 2,
        APS_InProgress                                     = 3,
        APS_MAX                                            = 4
};*/

// Enum Engine.OnlineSubsystem.EAchievementRewardType
/*enum EAchievementRewardType
{
        ART_Unknown                                        = 0,
        ART_Gamerscore                                     = 1,
        ART_InApp                                          = 2,
        ART_Art                                            = 3,
        ART_MAX                                            = 4
};*/

// Enum Engine.OnlineSubsystem.EOnlineFileType
/*enum EOnlineFileType
{
        OFT_Unknown                                        = 0,
        OFT_Binary                                         = 1,
        OFT_Json                                           = 2,
        OFT_MAX                                            = 3
};*/

// Enum Engine.OnlineSubsystem.EOnlineAccountCreateStatus
/*enum EOnlineAccountCreateStatus
{
        OACS_CreateSuccessful                              = 0,
        OACS_UnknownError                                  = 1,
        OACS_InvalidUserName                               = 2,
        OACS_InvalidPassword                               = 3,
        OACS_InvalidUniqueUserName                         = 4,
        OACS_UniqueUserNameInUse                           = 5,
        OACS_ServiceUnavailable                            = 6,
        OACS_MAX                                           = 7
};*/

// Enum Engine.OnlineSubsystem.ELanBeaconState
/*enum ELanBeaconState
{
        LANB_NotUsingLanBeacon                             = 0,
        LANB_Hosting                                       = 1,
        LANB_Searching                                     = 2,
        LANB_MAX                                           = 3
};*/

// Enum Engine.OnlineSubsystem.EOnlineContentType
/*enum EOnlineContentType
{
        OCT_Downloaded                                     = 0,
        OCT_SaveGame                                       = 1,
        OCT_MAX                                            = 2
};*/

// Enum Engine.OnlineSubsystem.EOnlineCreateGameSessionFlag
/*enum EOnlineCreateGameSessionFlag
{
        OCGSF_New                                          = 0,
        OCGSF_ReSubmit                                     = 1,
        OCGSF_MAX                                          = 2
};*/

// Enum Engine.OnlineSubsystem.EOnlineFriendState
/*enum EOnlineFriendState
{
        OFS_Offline                                        = 0,
        OFS_Online                                         = 1,
        OFS_Away                                           = 2,
        OFS_Busy                                           = 3,
        OFS_MAX                                            = 4
};*/

// Enum Engine.OnlineSubsystem.EOnlineAccountTier
/*enum EOnlineAccountTier
{
        OAT_Unknown                                        = 0,
        OAT_NewUser                                        = 1,
        OAT_Silver                                         = 2,
        OAT_Gold                                           = 3,
        OAT_FamilyGold                                     = 4,
        OAT_MAX                                            = 5
};*/

// Enum Engine.OnlineSubsystem.OnGameInviteAcceptedResult
/*enum OnGameInviteAcceptedResult
{
        OGIAR_Success                                      = 0,
        OGIAR_GeneralFailure                               = 1,
        OGIAR_ServerActivity                               = 2,
        OGIAR_WrongAccount                                 = 3,
        OGIAR_MAX                                          = 4
};*/

// Enum Engine.OnlineSubsystem.ENetworkNotificationPosition
/*enum ENetworkNotificationPosition
{
        NNP_TopLeft                                        = 0,
        NNP_TopCenter                                      = 1,
        NNP_TopRight                                       = 2,
        NNP_CenterLeft                                     = 3,
        NNP_Center                                         = 4,
        NNP_CenterRight                                    = 5,
        NNP_BottomLeft                                     = 6,
        NNP_BottomCenter                                   = 7,
        NNP_BottomRight                                    = 8,
        NNP_MAX                                            = 9
};*/

// Enum Engine.OnlineSubsystem.EReputationFeedbackType
/*enum EReputationFeedbackType
{
        RFBT_CommunicationsAbusiveVoice                    = 0,
        RFBT_CommunicationsInappropriateVideo              = 1,
        RFBT_FairPlayCheater                               = 2,
        RFBT_FairPlayKicked                                = 3,
        RFBT_FairPlayKillsTeammates                        = 4,
        RFBT_FairPlayQuitter                               = 5,
        RFBT_FairPlayTampering                             = 6,
        RFBT_InappropriateUserGeneratedContent             = 7,
        RFBT_PositiveHelpfulPlayer                         = 8,
        RFBT_PositiveHighQualityUserGeneratedContent       = 9,
        RFBT_PositiveSkilledPlayer                         = 10,
        RFBT_MAX                                           = 11
};*/

// Enum Engine.OnlineSubsystem.EFeaturePrivilegeLevel
/*enum EFeaturePrivilegeLevel
{
        FPL_Disabled                                       = 0,
        FPL_EnabledFriendsOnly                             = 1,
        FPL_Enabled                                        = 2,
        FPL_Unknown                                        = 3,
        FPL_MAX                                            = 4
};*/

// Enum Engine.OnlineSubsystem.EFeaturePrivilege
/*enum EFeaturePrivilege
{
        FP_OnlinePlay                                      = 0,
        FP_CommunicationText                               = 1,
        FP_CommunicationVideo                              = 2,
        FP_CommunicationVoice                              = 3,
        FP_ShareUserCreatedContent                         = 4,
        FP_PurchaseContent                                 = 5,
        FP_ViewPlayerProfile                               = 6,
        FP_ShowPresenceInformation                         = 7,
        FP_RecordDVRClips                                  = 8,
        FP_CloudStorage                                    = 9,
        FP_PremiumContent                                  = 10,
        FP_PremiumVideoContent                             = 11,
        FP_BrowseInternet                                  = 12,
        FP_SocialNetworkSharing                            = 13,
        FP_KinectSharing                                   = 14,
        FP_FitnessUpload                                   = 15,
        FP_MAX                                             = 16
};*/

// Enum Engine.OnlineAuthInterface.EAuthStatus
/*enum EAuthStatus
{
        AUS_NotStarted                                     = 0,
        AUS_Pending                                        = 1,
        AUS_Authenticated                                  = 2,
        AUS_Failed                                         = 3,
        AUS_MAX                                            = 4
};*/

// Enum Engine.Camera.EViewTargetBlendFunction
/*enum EViewTargetBlendFunction
{
        VTBlend_Linear                                     = 0,
        VTBlend_Cubic                                      = 1,
        VTBlend_EaseIn                                     = 2,
        VTBlend_EaseOut                                    = 3,
        VTBlend_EaseInOut                                  = 4,
        VTBlend_MAX                                        = 5
};*/

// Enum Engine.DOFEffect.EFocusType
/*enum EFocusType
{
        FOCUS_Distance                                     = 0,
        FOCUS_Position                                     = 1,
        FOCUS_MAX                                          = 2
};*/

// Enum Engine.Camera.ECameraAnimPlaySpace
/*enum ECameraAnimPlaySpace
{
        CAPS_CameraLocal                                   = 0,
        CAPS_World                                         = 1,
        CAPS_UserDefined                                   = 2,
        CAPS_MAX                                           = 3
};*/

// Enum Engine.SeqAct_ControlMovieTexture.EMovieControlType
/*enum EMovieControlType
{
        MCT_Play                                           = 0,
        MCT_Stop                                           = 1,
        MCT_Pause                                          = 2,
        MCT_MAX                                            = 3
};*/

// Enum Engine.Settings.EPropertyValueMappingType
/*enum EPropertyValueMappingType
{
        PVMT_RawValue                                      = 0,
        PVMT_PredefinedValues                              = 1,
        PVMT_Ranged                                        = 2,
        PVMT_IdMapped                                      = 3,
        PVMT_MAX                                           = 4
};*/

// Enum Engine.Settings.ESettingsDataType
/*enum ESettingsDataType
{
        SDT_Empty                                          = 0,
        SDT_Int32                                          = 1,
        SDT_Int64                                          = 2,
        SDT_Double                                         = 3,
        SDT_String                                         = 4,
        SDT_Float                                          = 5,
        SDT_Blob                                           = 6,
        SDT_DateTime                                       = 7,
        SDT_UInt32                                         = 8,
        SDT_UInt64                                         = 9,
        SDT_MAX                                            = 10
};*/

// Enum Engine.Settings.EOnlineDataAdvertisementType
/*enum EOnlineDataAdvertisementType
{
        ODAT_DontAdvertise                                 = 0,
        ODAT_OnlineService                                 = 1,
        ODAT_QoS                                           = 2,
        ODAT_OnlineServiceAndQoS                           = 3,
        ODAT_MAX                                           = 4
};*/

// Enum Engine.OnlineGameSearch.EOnlineGameSearchComparisonType
/*enum EOnlineGameSearchComparisonType
{
        OGSCT_Equals                                       = 0,
        OGSCT_NotEquals                                    = 1,
        OGSCT_GreaterThan                                  = 2,
        OGSCT_GreaterThanEquals                            = 3,
        OGSCT_LessThan                                     = 4,
        OGSCT_LessThanEquals                               = 5,
        OGSCT_MAX                                          = 6
};*/

// Enum Engine.OnlineGameSearch.EOnlineGameSearchEntryType
/*enum EOnlineGameSearchEntryType
{
        OGSET_Property                                     = 0,
        OGSET_LocalizedSetting                             = 1,
        OGSET_ObjectProperty                               = 2,
        OGSET_MAX                                          = 3
};*/

// Enum Engine.OnlineGameSearch.EOnlineGameSearchSortType
/*enum EOnlineGameSearchSortType
{
        OGSSO_Ascending                                    = 0,
        OGSSO_Descending                                   = 1,
        OGSSO_MAX                                          = 2
};*/

// Enum Engine.PlayerController.EProgressMessageType
/*enum EProgressMessageType
{
        PMT_Clear                                          = 0,
        PMT_Information                                    = 1,
        PMT_AdminMessage                                   = 2,
        PMT_DownloadProgress                               = 3,
        PMT_ConnectionFailure                              = 4,
        PMT_PeerConnectionFailure                          = 5,
        PMT_PeerHostMigrationFailure                       = 6,
        PMT_SocketFailure                                  = 7,
        PMT_MAX                                            = 8
};*/

// Enum Engine.SkeletalMeshComponent.EPhysBodyOp
/*enum EPhysBodyOp
{
        PBO_None                                           = 0,
        PBO_Term                                           = 1,
        PBO_Disable                                        = 2,
        PBO_MAX                                            = 3
};*/

// Enum Engine.SkeletalMeshComponent.EFaceFXRegOp
/*enum EFaceFXRegOp
{
        FXRO_Add                                           = 0,
        FXRO_Multiply                                      = 1,
        FXRO_Replace                                       = 2,
        FXRO_MAX                                           = 3
};*/

// Enum Engine.SkeletalMeshComponent.EBoneVisibilityStatus
/*enum EBoneVisibilityStatus
{
        BVS_HiddenByParent                                 = 0,
        BVS_Visible                                        = 1,
        BVS_ExplicitlyHidden                               = 2,
        BVS_MAX                                            = 3
};*/

// Enum Engine.SkeletalMeshComponent.EFaceFXBlendMode
/*enum EFaceFXBlendMode
{
        FXBM_Overwrite                                     = 0,
        FXBM_Additive                                      = 1,
        FXBM_MAX                                           = 2
};*/

// Enum Engine.SkeletalMeshComponent.EInstanceWeightUsage
/*enum EInstanceWeightUsage
{
        IWU_PartialSwap                                    = 0,
        IWU_FullSwap                                       = 1,
        IWU_MAX                                            = 2
};*/

// Enum Engine.SkeletalMeshComponent.EAnimRotationOnly
/*enum EAnimRotationOnly
{
        EARO_AnimSet                                       = 0,
        EARO_ForceEnabled                                  = 1,
        EARO_ForceDisabled                                 = 2,
        EARO_MAX                                           = 3
};*/

// Enum Engine.SkeletalMeshComponent.ERootMotionRotationMode
/*enum ERootMotionRotationMode
{
        RMRM_Ignore                                        = 0,
        RMRM_RotateActor                                   = 1,
        RMRM_MAX                                           = 2
};*/

// Enum Engine.SkeletalMeshComponent.ERootMotionMode
/*enum ERootMotionMode
{
        RMM_Translate                                      = 0,
        RMM_Velocity                                       = 1,
        RMM_Ignore                                         = 2,
        RMM_Accel                                          = 3,
        RMM_Relative                                       = 4,
        RMM_MAX                                            = 5
};*/

// Enum Engine.SkeletalMeshComponent.EMaxDistanceScaleMode
/*enum EMaxDistanceScaleMode
{
        MDSM_Multiply                                      = 0,
        MDSM_Substract                                     = 1,
        MDSM_MAX                                           = 2
};*/

// Enum Engine.PlayerController.EInputMatchAction
/*enum EInputMatchAction
{
        IMA_GreaterThan                                    = 0,
        IMA_LessThan                                       = 1,
        IMA_MAX                                            = 2
};*/

// Enum Engine.PlayerController.EInputTypes
/*enum EInputTypes
{
        IT_XAxis                                           = 0,
        IT_YAxis                                           = 1,
        IT_MAX                                             = 2
};*/

// Enum Engine.Pylon.ENavMeshEdgeType
/*enum ENavMeshEdgeType
{
        NAVEDGE_UnknownType                                = 0,
        NAVEDGE_Normal                                     = 1,
        NAVEDGE_Mantle                                     = 2,
        NAVEDGE_Coverslip                                  = 3,
        NAVEDGE_SwatTurn                                   = 4,
        NAVEDGE_DropDown                                   = 5,
        NAVEDGE_PathObject                                 = 6,
        NAVEDGE_BackRefDummy                               = 7,
        NAVEDGE_Jump                                       = 8,
        NAVEDGE_CrossPylon                                 = 9,
        NAVEDGE_OneWayEdge                                 = 10,
        NAVEDGE_MAX                                        = 11
};*/

// Enum Engine.AmbientOcclusionEffect.EAmbientOcclusionQuality
/*enum EAmbientOcclusionQuality
{
        AO_High                                            = 0,
        AO_Medium                                          = 1,
        AO_Low                                             = 2,
        AO_MAX                                             = 3
};*/

// Enum Engine.AmbientOcclusionEffect.EHBAOBlurRadius
/*enum EHBAOBlurRadius
{
        HBAO_BLUR_RADIUS                                   = 0,
        HBAO_BLUR_RADIUS01                                 = 1,
        HBAO_BLUR_RADIUS02                                 = 2,
        HBAO_BLUR_RADIUS_MAX                               = 3
};*/

// Enum Engine.Brush.ECsgOper
/*enum ECsgOper
{
        CSG_Active                                         = 0,
        CSG_Add                                            = 1,
        CSG_Subtract                                       = 2,
        CSG_Intersect                                      = 3,
        CSG_Deintersect                                    = 4,
        CSG_MAX                                            = 5
};*/

// Enum Engine.ReverbVolume.ReverbPreset
/*enum ReverbPreset
{
        REVERB_Default                                     = 0,
        REVERB_Bathroom                                    = 1,
        REVERB_StoneRoom                                   = 2,
        REVERB_Auditorium                                  = 3,
        REVERB_ConcertHall                                 = 4,
        REVERB_Cave                                        = 5,
        REVERB_Hallway                                     = 6,
        REVERB_StoneCorridor                               = 7,
        REVERB_Alley                                       = 8,
        REVERB_Forest                                      = 9,
        REVERB_City                                        = 10,
        REVERB_Mountains                                   = 11,
        REVERB_Quarry                                      = 12,
        REVERB_Plain                                       = 13,
        REVERB_ParkingLot                                  = 14,
        REVERB_SewerPipe                                   = 15,
        REVERB_Underwater                                  = 16,
        REVERB_SmallRoom                                   = 17,
        REVERB_MediumRoom                                  = 18,
        REVERB_LargeRoom                                   = 19,
        REVERB_MediumHall                                  = 20,
        REVERB_LargeHall                                   = 21,
        REVERB_Plate                                       = 22,
        REVERB_MAX                                         = 23
};*/

// Enum Engine.EngineTypes.EPathFindingError
/*enum EPathFindingError
{
        PATHERROR_STARTPOLYNOTFOUND                        = 0,
        PATHERROR_GOALPOLYNOTFOUND                         = 1,
        PATHERROR_ANCHORPYLONNOTFOUND                      = 2,
        PATHERROR_NOPATHFOUND                              = 3,
        PATHERROR_COMPUTEVALIDFINALDEST_FAIL               = 4,
        PATHERROR_GETNEXTMOVELOCATION_FAIL                 = 5,
        PATHERROR_MOVETIMEOUT                              = 6,
        PATHERROR_MAX                                      = 7
};*/

// Enum Engine.AudioDevice.EDebugState
/*enum EDebugState
{
        DEBUGSTATE_None                                    = 0,
        DEBUGSTATE_IsolateDryAudio                         = 1,
        DEBUGSTATE_IsolateReverb                           = 2,
        DEBUGSTATE_TestLPF                                 = 3,
        DEBUGSTATE_TestStereoBleed                         = 4,
        DEBUGSTATE_TestLFEBleed                            = 5,
        DEBUGSTATE_DisableLPF                              = 6,
        DEBUGSTATE_DisableRadio                            = 7,
        DEBUGSTATE_MAX                                     = 8
};*/

// Enum Engine.AudioDevice.ETTSSpeaker
/*enum ETTSSpeaker
{
        TTSSPEAKER_Paul                                    = 0,
        TTSSPEAKER_Harry                                   = 1,
        TTSSPEAKER_Frank                                   = 2,
        TTSSPEAKER_Dennis                                  = 3,
        TTSSPEAKER_Kit                                     = 4,
        TTSSPEAKER_Betty                                   = 5,
        TTSSPEAKER_Ursula                                  = 6,
        TTSSPEAKER_Rita                                    = 7,
        TTSSPEAKER_Wendy                                   = 8,
        TTSSPEAKER_MAX                                     = 9
};*/

// Enum Engine.AudioDevice.ESoundClassName
/*enum ESoundClassName
{
        Ambient                                            = 0,
        Exceptions                                         = 1,
        Master                                             = 2,
        Music                                              = 3,
        SFX                                                = 4,
        Voice                                              = 5,
        Weapons                                            = 6,
        ESoundClassName_MAX                                = 7
};*/

// Enum Engine.SoundNodeAttenuation.ESoundDistanceCalc
/*enum ESoundDistanceCalc
{
        SOUNDDISTANCE_Normal                               = 0,
        SOUNDDISTANCE_InfiniteXYPlane                      = 1,
        SOUNDDISTANCE_InfiniteXZPlane                      = 2,
        SOUNDDISTANCE_InfiniteYZPlane                      = 3,
        SOUNDDISTANCE_MAX                                  = 4
};*/

// Enum Engine.SoundNodeAttenuation.SoundDistanceModel
/*enum SoundDistanceModel
{
        ATTENUATION_Linear                                 = 0,
        ATTENUATION_Logarithmic                            = 1,
        ATTENUATION_Inverse                                = 2,
        ATTENUATION_LogReverse                             = 3,
        ATTENUATION_NaturalSound                           = 4,
        ATTENUATION_MAX                                    = 5
};*/

// Enum Engine.PlatformInterfaceBase.EPlatformInterfaceDataType
/*enum EPlatformInterfaceDataType
{
        PIDT_None                                          = 0,
        PIDT_Int                                           = 1,
        PIDT_Float                                         = 2,
        PIDT_String                                        = 3,
        PIDT_Object                                        = 4,
        PIDT_Custom                                        = 5,
        PIDT_MAX                                           = 6
};*/

// Enum Engine.AnimSequence.AnimationKeyFormat
/*enum AnimationKeyFormat
{
        AKF_ConstantKeyLerp                                = 0,
        AKF_VariableKeyLerp                                = 1,
        AKF_PerTrackCompression                            = 2,
        AKF_MAX                                            = 3
};*/

// Enum Engine.AnimSequence.AnimationCompressionFormat
/*enum AnimationCompressionFormat
{
        ACF_None                                           = 0,
        ACF_Float96NoW                                     = 1,
        ACF_Fixed48NoW                                     = 2,
        ACF_IntervalFixed32NoW                             = 3,
        ACF_Fixed32NoW                                     = 4,
        ACF_Float32NoW                                     = 5,
        ACF_Identity                                       = 6,
        ACF_MAX                                            = 7
};*/

// Enum Engine.AnimNode.ESliderType
/*enum ESliderType
{
        ST_1D                                              = 0,
        ST_2D                                              = 1,
        ST_MAX                                             = 2
};*/

// Enum Engine.AnimNode_MultiBlendPerBone.EWeightCheck
/*enum EWeightCheck
{
        EWC_AnimNodeSlotNotPlaying                         = 0,
        EWC_MAX                                            = 1
};*/

// Enum Engine.AnimNode_MultiBlendPerBone.EBlendType
/*enum EBlendType
{
        EBT_ParentBoneSpace                                = 0,
        EBT_MeshSpace                                      = 1,
        EBT_MAX                                            = 2
};*/

// Enum Engine.AnimNodeAimOffset.EAnimAimDir
/*enum EAnimAimDir
{
        ANIMAIM_LEFTUP                                     = 0,
        ANIMAIM_CENTERUP                                   = 1,
        ANIMAIM_RIGHTUP                                    = 2,
        ANIMAIM_LEFTCENTER                                 = 3,
        ANIMAIM_CENTERCENTER                               = 4,
        ANIMAIM_RIGHTCENTER                                = 5,
        ANIMAIM_LEFTDOWN                                   = 6,
        ANIMAIM_CENTERDOWN                                 = 7,
        ANIMAIM_RIGHTDOWN                                  = 8,
        ANIMAIM_MAX                                        = 9
};*/

// Enum Engine.AnimNodeAimOffset.EAimID
/*enum EAimID
{
        EAID_LeftUp                                        = 0,
        EAID_LeftDown                                      = 1,
        EAID_RightUp                                       = 2,
        EAID_RightDown                                     = 3,
        EAID_ZeroUp                                        = 4,
        EAID_ZeroDown                                      = 5,
        EAID_ZeroLeft                                      = 6,
        EAID_ZeroRight                                     = 7,
        EAID_CellLU                                        = 8,
        EAID_CellCU                                        = 9,
        EAID_CellRU                                        = 10,
        EAID_CellLC                                        = 11,
        EAID_CellCC                                        = 12,
        EAID_CellRC                                        = 13,
        EAID_CellLD                                        = 14,
        EAID_CellCD                                        = 15,
        EAID_CellRD                                        = 16,
        EAID_MAX                                           = 17
};*/

// Enum Engine.AnimNodeBlendByBase.EBaseBlendType
/*enum EBaseBlendType
{
        BBT_ByActorTag                                     = 0,
        BBT_ByActorClass                                   = 1,
        BBT_MAX                                            = 2
};*/

// Enum Engine.AnimNodeSequence.ERootRotationOption
/*enum ERootRotationOption
{
        RRO_Default                                        = 0,
        RRO_Discard                                        = 1,
        RRO_Extract                                        = 2,
        RRO_MAX                                            = 3
};*/

// Enum Engine.AnimNodeSequence.ERootBoneAxis
/*enum ERootBoneAxis
{
        RBA_Default                                        = 0,
        RBA_Discard                                        = 1,
        RBA_Translate                                      = 2,
        RBA_MAX                                            = 3
};*/

// Enum Engine.EngineTypes.EBlendMode
/*enum EBlendMode
{
        BLEND_Opaque                                       = 0,
        BLEND_Masked                                       = 1,
        BLEND_Translucent                                  = 2,
        BLEND_Additive                                     = 3,
        BLEND_Modulate                                     = 4,
        BLEND_ModulateAndAdd                               = 5,
        BLEND_SoftMasked                                   = 6,
        BLEND_AlphaComposite                               = 7,
        BLEND_DitheredTranslucent                          = 8,
        BLEND_MAX                                          = 9
};*/

// Enum Engine.EngineTypes.EMaterialLightingModel
/*enum EMaterialLightingModel
{
        MLM_Phong                                          = 0,
        MLM_NonDirectional                                 = 1,
        MLM_Unlit                                          = 2,
        MLM_SHPRT                                          = 3,
        MLM_Custom                                         = 4,
        MLM_Anisotropic                                    = 5,
        MLM_MAX                                            = 6
};*/

// Enum Engine.EngineTypes.EMaterialTessellationMode
/*enum EMaterialTessellationMode
{
        MTM_NoTessellation                                 = 0,
        MTM_FlatTessellation                               = 1,
        MTM_PNTriangles                                    = 2,
        MTM_MAX                                            = 3
};*/

// Enum Engine.EngineTypes.EMobileValueSource
/*enum EMobileValueSource
{
        MVS_Constant                                       = 0,
        MVS_VertexColorRed                                 = 1,
        MVS_VertexColorGreen                               = 2,
        MVS_VertexColorBlue                                = 3,
        MVS_VertexColorAlpha                               = 4,
        MVS_BaseTextureRed                                 = 5,
        MVS_BaseTextureGreen                               = 6,
        MVS_BaseTextureBlue                                = 7,
        MVS_BaseTextureAlpha                               = 8,
        MVS_MaskTextureRed                                 = 9,
        MVS_MaskTextureGreen                               = 10,
        MVS_MaskTextureBlue                                = 11,
        MVS_MaskTextureAlpha                               = 12,
        MVS_NormalTextureAlpha                             = 13,
        MVS_EmissiveTextureRed                             = 14,
        MVS_EmissiveTextureGreen                           = 15,
        MVS_EmissiveTextureBlue                            = 16,
        MVS_EmissiveTextureAlpha                           = 17,
        MVS_MAX                                            = 18
};*/

// Enum Engine.EngineTypes.EMobileTextureBlendFactorSource
/*enum EMobileTextureBlendFactorSource
{
        MTBFS_VertexColor                                  = 0,
        MTBFS_MaskTexture                                  = 1,
        MTBFS_MAX                                          = 2
};*/

// Enum Engine.EngineTypes.EMobileTexCoordsSource
/*enum EMobileTexCoordsSource
{
        MTCS_TexCoords0                                    = 0,
        MTCS_TexCoords1                                    = 1,
        MTCS_TexCoords2                                    = 2,
        MTCS_TexCoords3                                    = 3,
        MTCS_MAX                                           = 4
};*/

// Enum Engine.EngineTypes.EMobileAlphaValueSource
/*enum EMobileAlphaValueSource
{
        MAVS_DiffuseTextureAlpha                           = 0,
        MAVS_MaskTextureRed                                = 1,
        MAVS_MaskTextureGreen                              = 2,
        MAVS_MaskTextureBlue                               = 3,
        MAVS_MAX                                           = 4
};*/

// Enum Engine.EngineTypes.EMobileColorMultiplySource
/*enum EMobileColorMultiplySource
{
        MCMS_None                                          = 0,
        MCMS_BaseTextureRed                                = 1,
        MCMS_BaseTextureGreen                              = 2,
        MCMS_BaseTextureBlue                               = 3,
        MCMS_BaseTextureAlpha                              = 4,
        MCMS_MaskTextureRed                                = 5,
        MCMS_MaskTextureGreen                              = 6,
        MCMS_MaskTextureBlue                               = 7,
        MCMS_MaskTextureAlpha                              = 8,
        MCMS_MAX                                           = 9
};*/

// Enum Engine.EngineTypes.EMobileEmissiveColorSource
/*enum EMobileEmissiveColorSource
{
        MECS_EmissiveTexture                               = 0,
        MECS_BaseTexture                                   = 1,
        MECS_Constant                                      = 2,
        MECS_MAX                                           = 3
};*/

// Enum Engine.EngineTypes.EMobileEnvironmentBlendMode
/*enum EMobileEnvironmentBlendMode
{
        MEBM_Add                                           = 0,
        MEBM_Lerp                                          = 1,
        MEBM_MAX                                           = 2
};*/

// Enum Engine.EngineTypes.EMobileSpecularMask
/*enum EMobileSpecularMask
{
        MSM_Constant                                       = 0,
        MSM_Luminance                                      = 1,
        MSM_DiffuseRed                                     = 2,
        MSM_DiffuseGreen                                   = 3,
        MSM_DiffuseBlue                                    = 4,
        MSM_DiffuseAlpha                                   = 5,
        MSM_MaskTextureRGB                                 = 6,
        MSM_MaskTextureRed                                 = 7,
        MSM_MaskTextureGreen                               = 8,
        MSM_MaskTextureBlue                                = 9,
        MSM_MaskTextureAlpha                               = 10,
        MSM_MAX                                            = 11
};*/

// Enum Engine.EngineTypes.EMobileAmbientOcclusionSource
/*enum EMobileAmbientOcclusionSource
{
        MAOS_Disabled                                      = 0,
        MAOS_VertexColorRed                                = 1,
        MAOS_VertexColorGreen                              = 2,
        MAOS_VertexColorBlue                               = 3,
        MAOS_VertexColorAlpha                              = 4,
        MAOS_MAX                                           = 5
};*/

// Enum Engine.EngineTypes.ELightingBuildQuality
/*enum ELightingBuildQuality
{
        Quality_Preview                                    = 0,
        Quality_Medium                                     = 1,
        Quality_High                                       = 2,
        Quality_Production                                 = 3,
        Quality_NoGlobalIllumination                       = 4,
        Quality_MAX                                        = 5
};*/

// Enum Engine.EngineTypes.EPrecomputedVisibilityBuildType
/*enum EPrecomputedVisibilityBuildType
{
        BuildType_IncrementalBuild                         = 0,
        BuildType_FullRebuild                              = 1,
        BuildType_DoNotBuild                               = 2,
        BuildType_MAX                                      = 3
};*/

// Enum Engine.Pawn.EPathSearchType
/*enum EPathSearchType
{
        PST_Default                                        = 0,
        PST_Breadth                                        = 1,
        PST_NewBestPathTo                                  = 2,
        PST_Constraint                                     = 3,
        PST_MAX                                            = 4
};*/

// Enum
// Engine.DynamicLightEnvironmentComponent.EDynamicLightEnvironmentBoundsMethod
/*enum EDynamicLightEnvironmentBoundsMethod
{
        DLEB_OwnerComponents                               = 0,
        DLEB_ManualOverride                                = 1,
        DLEB_ActiveComponents                              = 2,
        DLEB_MAX                                           = 3
};*/

// Enum Engine.ApexDestructibleAsset.EImpactDamageOverride
/*enum EImpactDamageOverride
{
        IDO_None                                           = 0,
        IDO_On                                             = 1,
        IDO_Off                                            = 2,
        IDO_MAX                                            = 3
};*/

// Enum Engine.ApexDestructibleDamageParameters.EDamageParameterOverrideMode
/*enum EDamageParameterOverrideMode
{
        DPOM_Absolute                                      = 0,
        DPOM_Multiplier                                    = 1,
        DPOM_MAX                                           = 2
};*/

// Enum Engine.StaticMeshComponent.ELightmapModificationFunction
/*enum ELightmapModificationFunction
{
        MLMF_Modulate                                      = 0,
        MLMF_ModulateAlpha                                 = 1,
        MLMF_MAX                                           = 2
};*/

// Enum Engine.CameraShake.EInitialOscillatorOffset
/*enum EInitialOscillatorOffset
{
        EOO_OffsetRandom                                   = 0,
        EOO_OffsetZero                                     = 1,
        EOO_MAX                                            = 2
};*/

// Enum Engine.Canvas.ECanvasBlendMode
/*enum ECanvasBlendMode
{
        BLEND_CANVAS_Opaque                                = 0,
        BLEND_CANVAS_Masked                                = 1,
        BLEND_CANVAS_Translucent                           = 2,
        BLEND_CANVAS_Additive                              = 3,
        BLEND_CANVAS_Modulate                              = 4,
        BLEND_CANVAS_ModulateAndAdd                        = 5,
        BLEND_CANVAS_SoftMasked                            = 6,
        BLEND_CANVAS_AlphaComposite                        = 7,
        BLEND_CANVAS_DitheredTranslucent                   = 8,
        BLEND_CANVAS_AlphaOnly                             = 9,
        BLEND_CANVAS_MAX                                   = 10
};*/

// Enum Engine.CloudSaveSystem.SaveDataVersionSupport
/*enum SaveDataVersionSupport
{
        SaveDataVersionSupportLessThenEqual                = 0,
        SaveDataVersionSupportEqual                        = 1,
        SaveDataVersionSupportAny                          = 2,
        SaveDataVersionSupport_MAX                         = 3
};*/

// Enum Engine.CloudSaveSystem.SaveSlotOperationEnum
/*enum SaveSlotOperationEnum
{
        SSO_SET                                            = 0,
        SSO_GET                                            = 1,
        SSO_DELETE                                         = 2,
        SSO_MAX                                            = 3
};*/

// Enum Engine.CloudStorageBase.ECloudStorageDelegate
/*enum ECloudStorageDelegate
{
        CSD_KeyValueReadComplete                           = 0,
        CSD_KeyValueWriteComplete                          = 1,
        CSD_ValueChanged                                   = 2,
        CSD_DocumentQueryComplete                          = 3,
        CSD_DocumentReadComplete                           = 4,
        CSD_DocumentWriteComplete                          = 5,
        CSD_DocumentConflictDetected                       = 6,
        CSD_MAX                                            = 7
};*/

// Enum Engine.UIRoot.EInputPlatformType
/*enum EInputPlatformType
{
        IPT_PC                                             = 0,
        IPT                                                = 1,
        IPT_PS3                                            = 2,
        IPT_MAX                                            = 3
};*/

// Enum Engine.Interaction.ETouchType
/*enum ETouchType
{
        Touch_Began                                        = 0,
        Touch_Moved                                        = 1,
        Touch_Stationary                                   = 2,
        Touch_Ended                                        = 3,
        Touch_Cancelled                                    = 4,
        Touch_MAX                                          = 5
};*/

// Enum Engine.CoverGroup.ECoverGroupFillAction
/*enum ECoverGroupFillAction
{
        CGFA_Overwrite                                     = 0,
        CGFA_Add                                           = 1,
        CGFA_Remove                                        = 2,
        CGFA_Clear                                         = 3,
        CGFA_Cylinder                                      = 4,
        CGFA_MAX                                           = 5
};*/

// Enum Engine.CoverLink.ECoverLocationDescription
/*enum ECoverLocationDescription
{
        CoverDesc_None                                     = 0,
        CoverDesc_InWindow                                 = 1,
        CoverDesc_InDoorway                                = 2,
        CoverDesc_BehindCar                                = 3,
        CoverDesc_BehindTruck                              = 4,
        CoverDesc_OnTruck                                  = 5,
        CoverDesc_BehindBarrier                            = 6,
        CoverDesc_BehindColumn                             = 7,
        CoverDesc_BehindCrate                              = 8,
        CoverDesc_BehindWall                               = 9,
        CoverDesc_BehindStatue                             = 10,
        CoverDesc_BehindSandbags                           = 11,
        CoverDesc_MAX                                      = 12
};*/

// Enum Engine.CoverLink.ECoverAction
/*enum ECoverAction
{
        CA_Default                                         = 0,
        CA_BlindLeft                                       = 1,
        CA_BlindRight                                      = 2,
        CA_LeanLeft                                        = 3,
        CA_LeanRight                                       = 4,
        CA_PopUp                                           = 5,
        CA_BlindUp                                         = 6,
        CA_PeekLeft                                        = 7,
        CA_PeekRight                                       = 8,
        CA_PeekUp                                          = 9,
        CA_MAX                                             = 10
};*/

// Enum Engine.CoverLink.ECoverType
/*enum ECoverType
{
        CT_None                                            = 0,
        CT_Standing                                        = 1,
        CT_MidLevel                                        = 2,
        CT_MAX                                             = 3
};*/

// Enum Engine.CoverLink.EFireLinkID
/*enum EFireLinkID
{
        FLI_FireLink                                       = 0,
        FLI_RejectedFireLink                               = 1,
        FLI_MAX                                            = 2
};*/

// Enum Engine.CoverLink.ECoverDirection
/*enum ECoverDirection
{
        CD_Default                                         = 0,
        CD_Left                                            = 1,
        CD_Right                                           = 2,
        CD_Up                                              = 3,
        CD_MAX                                             = 4
};*/

// Enum Engine.DecalComponent.EDecalTransform
/*enum EDecalTransform
{
        DecalTransform_OwnerAbsolute                       = 0,
        DecalTransform_OwnerRelative                       = 1,
        DecalTransform_SpawnRelative                       = 2,
        DecalTransform_MAX                                 = 3
};*/

// Enum Engine.DecalComponent.EFilterMode
/*enum EFilterMode
{
        FM_None                                            = 0,
        FM_Ignore                                          = 1,
        FM_Affect                                          = 2,
        FM_MAX                                             = 3
};*/

// Enum Engine.MaterialInterface.EMaterialUsage
/*enum EMaterialUsage
{
        MATUSAGE_SkeletalMesh                              = 0,
        MATUSAGE_FracturedMeshes                           = 1,
        MATUSAGE_ParticleSprites                           = 2,
        MATUSAGE_BeamTrails                                = 3,
        MATUSAGE_ParticleSubUV                             = 4,
        MATUSAGE_SpeedTree                                 = 5,
        MATUSAGE_StaticLighting                            = 6,
        MATUSAGE_GammaCorrection                           = 7,
        MATUSAGE_LensFlare                                 = 8,
        MATUSAGE_InstancedMeshParticles                    = 9,
        MATUSAGE_FluidSurface                              = 10,
        MATUSAGE_Decals                                    = 11,
        MATUSAGE_MaterialEffect                            = 12,
        MATUSAGE_MorphTargets                              = 13,
        MATUSAGE_FogVolumes                                = 14,
        MATUSAGE_RadialBlur                                = 15,
        MATUSAGE_InstancedMeshes                           = 16,
        MATUSAGE_SplineMesh                                = 17,
        MATUSAGE_ScreenDoorFade                            = 18,
        MATUSAGE_APEXMesh                                  = 19,
        MATUSAGE_Terrain                                   = 20,
        MATUSAGE_Landscape                                 = 21,
        MATUSAGE_MobileLandscape                           = 22,
        MATUSAGE_SPHFluid                                  = 23,
        MATUSAGE_SPHFluidThickness                         = 24,
        MATUSAGE_MAX                                       = 25
};*/

// Enum Engine.Light.ELightAnimationTechnique
/*enum ELightAnimationTechnique
{
        LightAnim_None                                     = 0,
        LightAnim_Flicker                                  = 1,
        LightAnim_Pulse                                    = 2,
        LightAnim_Strobe                                   = 3,
        LightAnim_ChaoticFlicker                           = 4,
        LightAnim_InverseChaoticFlicker                    = 5,
        LightAnim_MAX                                      = 6
};*/

// Enum Engine.LightComponent.ELightAffectsClassification
/*enum ELightAffectsClassification
{
        LAC_USER_SELECTED                                  = 0,
        LAC_DYNAMIC_AFFECTING                              = 1,
        LAC_STATIC_AFFECTING                               = 2,
        LAC_DYNAMIC_AND_STATIC_AFFECTING                   = 3,
        LAC_MAX                                            = 4
};*/

// Enum Engine.LightComponent.ELightShadowMode
/*enum ELightShadowMode
{
        LightShadow_Normal                                 = 0,
        LightShadow_Modulate                               = 1,
        LightShadow_ModulateBetter                         = 2,
        LightShadow_MAX                                    = 3
};*/

// Enum Engine.LightComponent.EShadowProjectionTechnique
/*enum EShadowProjectionTechnique
{
        ShadowProjTech_Default                             = 0,
        ShadowProjTech_PCF                                 = 1,
        ShadowProjTech_VSM                                 = 2,
        ShadowProjTech_BPCF_Low                            = 3,
        ShadowProjTech_BPCF_Medium                         = 4,
        ShadowProjTech_BPCF_High                           = 5,
        ShadowProjTech_MAX                                 = 6
};*/

// Enum Engine.LightComponent.EShadowFilterQuality
/*enum EShadowFilterQuality
{
        SFQ_Low                                            = 0,
        SFQ_Medium                                         = 1,
        SFQ_High                                           = 2,
        SFQ_MAX                                            = 3
};*/

// Enum Engine.DistributionFloatParameterBase.DistributionParamMode
/*enum DistributionParamMode
{
        DPM_Normal                                         = 0,
        DPM_Abs                                            = 1,
        DPM_Direct                                         = 2,
        DPM_MAX                                            = 3
};*/

// Enum Engine.DOFAndBloomEffect.EDOFType
/*enum EDOFType
{
        DOFType_SimpleDOF                                  = 0,
        DOFType_ReferenceDOF                               = 1,
        DOFType_BokehDOF                                   = 2,
        DOFType_VariableWidthDOF                           = 3,
        DOFType_MAX                                        = 4
};*/

// Enum Engine.DOFAndBloomEffect.EDOFQuality
/*enum EDOFQuality
{
        DOFQuality_Low                                     = 0,
        DOFQuality_Medium                                  = 1,
        DOFQuality_High                                    = 2,
        DOFQuality_MAX                                     = 3
};*/

// Enum Engine.DoorMarker.EDoorType
/*enum EDoorType
{
        DOOR_Shoot                                         = 0,
        DOOR_Touch                                         = 1,
        DOOR_MAX                                           = 2
};*/

// Enum Engine.ParticleSystemComponent.EParticleSysParamType
/*enum EParticleSysParamType
{
        PSPT_None                                          = 0,
        PSPT_Scalar                                        = 1,
        PSPT_ScalarRand                                    = 2,
        PSPT_Vector                                        = 3,
        PSPT_VectorRand                                    = 4,
        PSPT_Color                                         = 5,
        PSPT_Actor                                         = 6,
        PSPT_Material                                      = 7,
        PSPT_MAX                                           = 8
};*/

// Enum Engine.ParticleSystemComponent.ParticleReplayState
/*enum ParticleReplayState
{
        PRS_Disabled                                       = 0,
        PRS_Capturing                                      = 1,
        PRS_Replaying                                      = 2,
        PRS_MAX                                            = 3
};*/

// Enum Engine.ParticleSystemComponent.EParticleEventType
/*enum EParticleEventType
{
        EPET_Any                                           = 0,
        EPET_Spawn                                         = 1,
        EPET_Death                                         = 2,
        EPET_Collision                                     = 3,
        EPET_WorldAttractorCollision                       = 4,
        EPET_Kismet                                        = 5,
        EPET_MAX                                           = 6
};*/

// Enum Engine.ParticleSystem.ParticleSystemLODMethod
/*enum ParticleSystemLODMethod
{
        PARTICLESYSTEMLODMETHOD_Automatic                  = 0,
        PARTICLESYSTEMLODMETHOD_DirectSet                  = 1,
        PARTICLESYSTEMLODMETHOD_ActivateAutomatic          = 2,
        PARTICLESYSTEMLODMETHOD_MAX                        = 3
};*/

// Enum Engine.Engine.ETransitionType
/*enum ETransitionType
{
        TT_None                                            = 0,
        TT_Paused                                          = 1,
        TT_Loading                                         = 2,
        TT_Saving                                          = 3,
        TT_Connecting                                      = 4,
        TT_Precaching                                      = 5,
        TT_MAX                                             = 6
};*/

// Enum Engine.FacebookIntegration.EFacebookIntegrationDelegate
/*enum EFacebookIntegrationDelegate
{
        FID_AuthorizationComplete                          = 0,
        FID_FacebookRequestComplete                        = 1,
        FID_DialogComplete                                 = 2,
        FID_FriendsListComplete                            = 3,
        FID_MAX                                            = 4
};*/

// Enum Engine.FileWriter.FWFileType
/*enum FWFileType
{
        FWFT_Log                                           = 0,
        FWFT_Stats                                         = 1,
        FWFT_HTML                                          = 2,
        FWFT_User                                          = 3,
        FWFT_Debug                                         = 4,
        FWFT_MAX                                           = 5
};*/

// Enum Engine.FlexAsset.EFlexAssetType
/*enum EFlexAssetType
{
        FLEX_Cloth                                         = 0,
        FLEX_Solid                                         = 1,
        FLEX_MAX                                           = 2
};*/

// Enum Engine.FlexContainer.RelaxationMode
/*enum RelaxationMode
{
        RelaxationMode_Global                              = 0,
        RelaxationMode_Local                               = 1,
        RelaxationMode_MAX                                 = 2
};*/

// Enum Engine.FluidInfluenceComponent.EInfluenceType
/*enum EInfluenceType
{
        Fluid_Flow                                         = 0,
        Fluid_Raindrops                                    = 1,
        Fluid_Wave                                         = 2,
        Fluid_Sphere                                       = 3,
        Fluid_MAX                                          = 4
};*/

// Enum Engine.FontImportOptions.EFontImportCharacterSet
/*enum EFontImportCharacterSet
{
        FontICS_Default                                    = 0,
        FontICS_Ansi                                       = 1,
        FontICS_Symbol                                     = 2,
        FontICS_MAX                                        = 3
};*/

// Enum Engine.ForceFeedbackWaveform.EWaveformFunction
/*enum EWaveformFunction
{
        WF_Constant                                        = 0,
        WF_LinearIncreasing                                = 1,
        WF_LinearDecreasing                                = 2,
        WF_Sin0to90                                        = 3,
        WF_Sin90to180                                      = 4,
        WF_Sin0to180                                       = 5,
        WF_Noise                                           = 6,
        WF_MAX                                             = 7
};*/

// Enum Engine.WorldInfo.EHostMigrationProgress
/*enum EHostMigrationProgress
{
        HostMigration_None                                 = 0,
        HostMigration_FindingNewHost                       = 1,
        HostMigration_MigratingAsHost                      = 2,
        HostMigration_MigratingAsClient                    = 3,
        HostMigration_ClientTravel                         = 4,
        HostMigration_HostReadyToTravel                    = 5,
        HostMigration_Failed                               = 6,
        HostMigration_MAX                                  = 7
};*/

// Enum Engine.WorldInfo.EConsoleType
/*enum EConsoleType
{
        CONSOLE_Any                                        = 0,
        CONSOLE_Xbox360                                    = 1,
        CONSOLE_PS3                                        = 2,
        CONSOLE_Mobile                                     = 3,
        CONSOLE_IPhone                                     = 4,
        CONSOLE_Android                                    = 5,
        CONSOLE_WiiU                                       = 6,
        CONSOLE_Flash                                      = 7,
        CONSOLE_Orbis                                      = 8,
        CONSOLE_Durango                                    = 9,
        CONSOLE_MAX                                        = 10
};*/

// Enum Engine.WorldInfo.EPreferredLightmapType
/*enum EPreferredLightmapType
{
        EPLT_Default                                       = 0,
        EPLT_Directional                                   = 1,
        EPLT_Simple                                        = 2,
        EPLT_MAX                                           = 3
};*/

// Enum Engine.WorldInfo.EVisibilityAggressiveness
/*enum EVisibilityAggressiveness
{
        VIS_LeastAggressive                                = 0,
        VIS_ModeratelyAggressive                           = 1,
        VIS_MostAggressive                                 = 2,
        VIS_Max                                            = 3
};*/

// Enum Engine.WorldInfo.ENetMode
/*enum ENetMode
{
        NM_Standalone                                      = 0,
        NM_DedicatedServer                                 = 1,
        NM_ListenServer                                    = 2,
        NM_Client                                          = 3,
        NM_MAX                                             = 4
};*/

// Enum Engine.GameEngine.EFullyLoadPackageType
/*enum EFullyLoadPackageType
{
        FULLYLOAD_Map                                      = 0,
        FULLYLOAD_Game_PreLoadClass                        = 1,
        FULLYLOAD_Game_PostLoadClass                       = 2,
        FULLYLOAD_Always                                   = 3,
        FULLYLOAD_Mutator                                  = 4,
        FULLYLOAD_MAX                                      = 5
};*/

// Enum Engine.GameInfo.EStandbyType
/*enum EStandbyType
{
        STDBY_Rx                                           = 0,
        STDBY_Tx                                           = 1,
        STDBY_BadPing                                      = 2,
        STDBY_MAX                                          = 3
};*/

// Enum Engine.GamePadLightbarSubsystem.LightBarState
/*enum LightBarState
{
        ELBS_Standby                                       = 0,
        ELBS_Lerping                                       = 1,
        ELBS_Pulsing                                       = 2,
        ELBS_MAX                                           = 3
};*/

// Enum Engine.GameplayEvents.EGameStatGroups
/*enum EGameStatGroups
{
        GSG_EngineStats                                    = 0,
        GSG_Game                                           = 1,
        GSG_Team                                           = 2,
        GSG_Player                                         = 3,
        GSG_Weapon                                         = 4,
        GSG_Damage                                         = 5,
        GSG_Projectile                                     = 6,
        GSG_Pawn                                           = 7,
        GSG_GameSpecific                                   = 8,
        GSG_Aggregate                                      = 9,
        GSG_MAX                                            = 10
};*/

// Enum Engine.GameViewportClient.ESplitScreenType
/*enum ESplitScreenType
{
        eSST_NONE                                          = 0,
        eSST_2P_HORIZONTAL                                 = 1,
        eSST_2P_VERTICAL                                   = 2,
        eSST_3P_FAVOR_TOP                                  = 3,
        eSST_3P_FAVOR_BOTTOM                               = 4,
        eSST_4P                                            = 5,
        eSST_MAX                                           = 6
};*/

// Enum Engine.GameViewportClient.ESafeZoneType
/*enum ESafeZoneType
{
        eSZ_TOP                                            = 0,
        eSZ_BOTTOM                                         = 1,
        eSZ_LEFT                                           = 2,
        eSZ_RIGHT                                          = 3,
        eSZ_MAX                                            = 4
};*/

// Enum Engine.GameViewportClient.ESetMode
/*enum ESetMode
{
        SetMode_Toggle                                     = 0,
        SetMode_Enable                                     = 1,
        SetMode_Disable                                    = 2,
        SetMode_MAX                                        = 3
};*/

// Enum Engine.InAppMessageBase.EInAppMessageInterfaceDelegate
/*enum EInAppMessageInterfaceDelegate
{
        IAMD_InAppSMSUIComplete                            = 0,
        IAMD_InAppEmailComplete                            = 1,
        IAMD_MAX                                           = 2
};*/

// Enum Engine.InGameAdManager.EAdManagerDelegate
/*enum EAdManagerDelegate
{
        AMD_ClickedBanner                                  = 0,
        AMD_UserClosedAd                                   = 1,
        AMD_MAX                                            = 2
};*/

// Enum Engine.InstancedFoliageSettings.FoliageCullOption
/*enum FoliageCullOption
{
        FOLIAGECULL_Cull                                   = 0,
        FOLIAGECULL_ScaleZ                                 = 1,
        FOLIAGECULL_ScaleXYZ                               = 2,
        FOLIAGECULL_TranslateZ                             = 3,
        FOLIAGECULL_MAX                                    = 4
};*/

// Enum Engine.Interface_NavMeshPathObstacle.EEdgeHandlingStatus
/*enum EEdgeHandlingStatus
{
        EHS_AddedBothDirs                                  = 0,
        EHS_Added0to1                                      = 1,
        EHS_Added1to0                                      = 2,
        EHS_AddedNone                                      = 3,
        EHS_MAX                                            = 4
};*/

// Enum Engine.InterpTrack.ETrackActiveCondition
/*enum ETrackActiveCondition
{
        ETAC_Always                                        = 0,
        ETAC_GoreEnabled                                   = 1,
        ETAC_GoreDisabled                                  = 2,
        ETAC_MAX                                           = 3
};*/

// Enum Engine.InterpTrackHeadTracking.EHeadTrackingAction
/*enum EHeadTrackingAction
{
        EHTA_DisableHeadTracking                           = 0,
        EHTA_EnableHeadTracking                            = 1,
        EHTA_MAX                                           = 2
};*/

// Enum Engine.InterpTrackToggle.ETrackToggleAction
/*enum ETrackToggleAction
{
        ETTA_Off                                           = 0,
        ETTA_On                                            = 1,
        ETTA_Toggle                                        = 2,
        ETTA_Trigger                                       = 3,
        ETTA_MAX                                           = 4
};*/

// Enum Engine.InterpTrackVisibility.EVisibilityTrackCondition
/*enum EVisibilityTrackCondition
{
        EVTC_Always                                        = 0,
        EVTC_GoreEnabled                                   = 1,
        EVTC_GoreDisabled                                  = 2,
        EVTC_MAX                                           = 3
};*/

// Enum Engine.InterpTrackVisibility.EVisibilityTrackAction
/*enum EVisibilityTrackAction
{
        EVTA_Hide                                          = 0,
        EVTA_Show                                          = 1,
        EVTA_Toggle                                        = 2,
        EVTA_MAX                                           = 3
};*/

// Enum Engine.InterpTrackMove.EInterpTrackMoveFrame
/*enum EInterpTrackMoveFrame
{
        IMF_World                                          = 0,
        IMF_RelativeToInitial                              = 1,
        IMF_MAX                                            = 2
};*/

// Enum Engine.InterpTrackMove.EInterpTrackMoveRotMode
/*enum EInterpTrackMoveRotMode
{
        IMR_Keyframed                                      = 0,
        IMR_LookAtGroup                                    = 1,
        IMR_Ignore                                         = 2,
        IMR_MAX                                            = 3
};*/

// Enum Engine.InterpTrackMoveAxis.EInterpMoveAxis
/*enum EInterpMoveAxis
{
        AXIS_TranslationX                                  = 0,
        AXIS_TranslationY                                  = 1,
        AXIS_TranslationZ                                  = 2,
        AXIS_RotationX                                     = 3,
        AXIS_RotationY                                     = 4,
        AXIS_RotationZ                                     = 5,
        AXIS_MAX                                           = 6
};*/

// Enum Engine.Landscape.ELandscapeSetupErrors
/*enum ELandscapeSetupErrors
{
        LSE_None                                           = 0,
        LSE_NoLandscapeInfo                                = 1,
        LSE_CollsionXY                                     = 2,
        LSE_NoLayerInfo                                    = 3,
        LSE_MAX                                            = 4
};*/

// Enum Engine.LandscapeGizmoActiveActor.ELandscapeGizmoType
/*enum ELandscapeGizmoType
{
        LGT_None                                           = 0,
        LGT_Height                                         = 1,
        LGT_Weight                                         = 2,
        LGT_MAX                                            = 3
};*/

// Enum Engine.LevelGridVolume.LevelGridCellShape
/*enum LevelGridCellShape
{
        LGCS_Box                                           = 0,
        LGCS_Hex                                           = 1,
        LGCS_MAX                                           = 2
};*/

// Enum Engine.LevelStreamingVolume.EStreamingVolumeUsage
/*enum EStreamingVolumeUsage
{
        SVB_Loading                                        = 0,
        SVB_LoadingAndVisibility                           = 1,
        SVB_VisibilityBlockingOnLoad                       = 2,
        SVB_BlockingOnLoad                                 = 3,
        SVB_LoadingNotVisible                              = 4,
        SVB_MAX                                            = 5
};*/

// Enum Engine.MaterialExpressionAntialiasedTextureMask.ETextureColorChannel
/*enum ETextureColorChannel
{
        TCC_Red                                            = 0,
        TCC_Green                                          = 1,
        TCC_Blue                                           = 2,
        TCC_Alpha                                          = 3,
        TCC_MAX                                            = 4
};*/

// Enum Engine.MaterialExpressionCustom.ECustomMaterialOutputType
/*enum ECustomMaterialOutputType
{
        CMOT_Float1                                        = 0,
        CMOT_Float2                                        = 1,
        CMOT_Float3                                        = 2,
        CMOT_Float4                                        = 3,
        CMOT_MAX                                           = 4
};*/

// Enum Engine.MaterialExpressionDepthOfFieldFunction.EDepthOfFieldFunctionValue
/*enum EDepthOfFieldFunctionValue
{
        TDOF_NearAndFarMask                                = 0,
        TDOF_NearMask                                      = 1,
        TDOF_FarMask                                       = 2,
        TDOF_MAX                                           = 3
};*/

// Enum Engine.MaterialExpressionFunctionInput.EFunctionInputType
/*enum EFunctionInputType
{
        FunctionInput_Scalar                               = 0,
        FunctionInput_Vector2                              = 1,
        FunctionInput_Vector3                              = 2,
        FunctionInput_Vector4                              = 3,
        FunctionInput_Texture2D                            = 4,
        FunctionInput_TextureCube                          = 5,
        FunctionInput_StaticBool                           = 6,
        FunctionInput_MAX                                  = 7
};*/

// Enum Engine.MaterialExpressionLandscapeLayerBlend.ELandscapeLayerBlendType
/*enum ELandscapeLayerBlendType
{
        LB_AlphaBlend                                      = 0,
        LB_HeightBlend                                     = 1,
        LB_MAX                                             = 2
};*/

// Enum Engine.MaterialExpressionSceneTexture.ESceneTextureType
/*enum ESceneTextureType
{
        SceneTex_Lighting                                  = 0,
        SceneTex_MAX                                       = 1
};*/

// Enum Engine.MaterialExpressionTerrainLayerCoords.ETerrainCoordMappingType
/*enum ETerrainCoordMappingType
{
        TCMT_Auto                                          = 0,
        TCMT_XY                                            = 1,
        TCMT_XZ                                            = 2,
        TCMT_YZ                                            = 3,
        TCMT_MAX                                           = 4
};*/

// Enum Engine.MaterialExpressionTransform.EMaterialVectorCoordTransformSource
/*enum EMaterialVectorCoordTransformSource
{
        TRANSFORMSOURCE_World                              = 0,
        TRANSFORMSOURCE_Local                              = 1,
        TRANSFORMSOURCE_Tangent                            = 2,
        TRANSFORMSOURCE_View                               = 3,
        TRANSFORMSOURCE_MAX                                = 4
};*/

// Enum Engine.MaterialExpressionTransform.EMaterialVectorCoordTransform
/*enum EMaterialVectorCoordTransform
{
        TRANSFORM_World                                    = 0,
        TRANSFORM_View                                     = 1,
        TRANSFORM_Local                                    = 2,
        TRANSFORM_Tangent                                  = 3,
        TRANSFORM_MAX                                      = 4
};*/

// Enum
// Engine.MaterialExpressionTransformPosition.EMaterialPositionTransformSource
/*enum EMaterialPositionTransformSource
{
        TRANSFORMPOSSOURCE_Local                           = 0,
        TRANSFORMPOSSOURCE_PostProjection                  = 1,
        TRANSFORMPOSSOURCE_MAX                             = 2
};*/

// Enum Engine.MaterialExpressionTransformPosition.EMaterialPositionTransform
/*enum EMaterialPositionTransform
{
        TRANSFORMPOS_World                                 = 0,
        TRANSFORMPOS_MAX                                   = 1
};*/

// Enum Engine.MicroTransactionBase.EMicroTransactionDelegate
/*enum EMicroTransactionDelegate
{
        MTD_PurchaseQueryComplete                          = 0,
        MTD_PurchaseComplete                               = 1,
        MTD_MAX                                            = 2
};*/

// Enum Engine.MicroTransactionBase.EMicroTransactionResult
/*enum EMicroTransactionResult
{
        MTR_Succeeded                                      = 0,
        MTR_Failed                                         = 1,
        MTR_Canceled                                       = 2,
        MTR_RestoredFromServer                             = 3,
        MTR_MAX                                            = 4
};*/

// Enum Engine.NxForceFieldGeneric.FFG_ForceFieldCoordinates
/*enum FFG_ForceFieldCoordinates
{
        FFG_CARTESIAN                                      = 0,
        FFG_SPHERICAL                                      = 1,
        FFG_CYLINDRICAL                                    = 2,
        FFG_TOROIDAL                                       = 3,
        FFG_MAX                                            = 4
};*/

// Enum Engine.NxGenericForceFieldBrush.FFB_ForceFieldCoordinates
/*enum FFB_ForceFieldCoordinates
{
        FFB_CARTESIAN                                      = 0,
        FFB_SPHERICAL                                      = 1,
        FFB_CYLINDRICAL                                    = 2,
        FFB_TOROIDAL                                       = 3,
        FFB_MAX                                            = 4
};*/

// Enum Engine.OnlineGameDownloadInterface.EDownloadSpeed
/*enum EDownloadSpeed
{
        EDLS_Pause                                         = 0,
        EDLS_Slow                                          = 1,
        EDLS_Fast                                          = 2,
        EDLS_MAX                                           = 3
};*/

// Enum Engine.OnlineGameInterface.ESteamMatchmakingType
/*enum ESteamMatchmakingType
{
        SMT_Invalid                                        = 0,
        SMT_LAN                                            = 1,
        SMT_Internet                                       = 2,
        SMT_Favorites                                      = 3,
        SMT_Friends                                        = 4,
        SMT_History                                        = 5,
        SMT_MAX                                            = 6
};*/

// Enum Engine.OnlinePlayerStorage.EOnlineProfilePropertyOwner
/*enum EOnlineProfilePropertyOwner
{
        OPPO_None                                          = 0,
        OPPO_OnlineService                                 = 1,
        OPPO_Game                                          = 2,
        OPPO_MAX                                           = 3
};*/

// Enum Engine.OnlinePlayerStorage.EOnlinePlayerStorageAsyncState
/*enum EOnlinePlayerStorageAsyncState
{
        OPAS_NotStarted                                    = 0,
        OPAS_Read                                          = 1,
        OPAS_Write                                         = 2,
        OPAS_Finished                                      = 3,
        OPAS_MAX                                           = 4
};*/

// Enum Engine.OnlineProfileSettings.EProfileSettingID
/*enum EProfileSettingID
{
        PSI_Unknown                                        = 0,
        PSI_ControllerVibration                            = 1,
        PSI_YInversion                                     = 2,
        PSI_GamerCred                                      = 3,
        PSI_GamerRep                                       = 4,
        PSI_VoiceMuted                                     = 5,
        PSI_VoiceThruSpeakers                              = 6,
        PSI_VoiceVolume                                    = 7,
        PSI_GamerPictureKey                                = 8,
        PSI_GamerMotto                                     = 9,
        PSI_GamerTitlesPlayed                              = 10,
        PSI_GamerAchievementsEarned                        = 11,
        PSI_GameDifficulty                                 = 12,
        PSI_ControllerSensitivity                          = 13,
        PSI_PreferredColor1                                = 14,
        PSI_PreferredColor2                                = 15,
        PSI_AutoAim                                        = 16,
        PSI_AutoCenter                                     = 17,
        PSI_MovementControl                                = 18,
        PSI_RaceTransmission                               = 19,
        PSI_RaceCameraLocation                             = 20,
        PSI_RaceBrakeControl                               = 21,
        PSI_RaceAcceleratorControl                         = 22,
        PSI_GameCredEarned                                 = 23,
        PSI_GameAchievementsEarned                         = 24,
        PSI_EndLiveIds                                     = 25,
        PSI_ProfileVersionNum                              = 26,
        PSI_ProfileSaveCount                               = 27,
        PSI_MAX                                            = 28
};*/

// Enum Engine.OnlineProfileSettings.EProfileDifficultyOptions
/*enum EProfileDifficultyOptions
{
        PDO_Normal                                         = 0,
        PDO_Easy                                           = 1,
        PDO_Hard                                           = 2,
        PDO_MAX                                            = 3
};*/

// Enum Engine.OnlineProfileSettings.EProfileControllerSensitivityOptions
/*enum EProfileControllerSensitivityOptions
{
        PCSO_Medium                                        = 0,
        PCSO_Low                                           = 1,
        PCSO_High                                          = 2,
        PCSO_MAX                                           = 3
};*/

// Enum Engine.OnlineProfileSettings.EProfilePreferredColorOptions
/*enum EProfilePreferredColorOptions
{
        PPCO_None                                          = 0,
        PPCO_Black                                         = 1,
        PPCO_White                                         = 2,
        PPCO_Yellow                                        = 3,
        PPCO_Orange                                        = 4,
        PPCO_Pink                                          = 5,
        PPCO_Red                                           = 6,
        PPCO_Purple                                        = 7,
        PPCO_Blue                                          = 8,
        PPCO_Green                                         = 9,
        PPCO_Brown                                         = 10,
        PPCO_Silver                                        = 11,
        PPCO_MAX                                           = 12
};*/

// Enum Engine.OnlineProfileSettings.EProfileAutoAimOptions
/*enum EProfileAutoAimOptions
{
        PAAO_Off                                           = 0,
        PAAO_On                                            = 1,
        PAAO_MAX                                           = 2
};*/

// Enum Engine.OnlineProfileSettings.EProfileAutoCenterOptions
/*enum EProfileAutoCenterOptions
{
        PACO_Off                                           = 0,
        PACO_On                                            = 1,
        PACO_MAX                                           = 2
};*/

// Enum Engine.OnlineProfileSettings.EProfileMovementControlOptions
/*enum EProfileMovementControlOptions
{
        PMCO_L_Thumbstick                                  = 0,
        PMCO_R_Thumbstick                                  = 1,
        PMCO_MAX                                           = 2
};*/

// Enum Engine.OnlineProfileSettings.EProfileRaceTransmissionOptions
/*enum EProfileRaceTransmissionOptions
{
        PRTO_Auto                                          = 0,
        PRTO_Manual                                        = 1,
        PRTO_MAX                                           = 2
};*/

// Enum Engine.OnlineProfileSettings.EProfileRaceCameraLocationOptions
/*enum EProfileRaceCameraLocationOptions
{
        PRCLO_Behind                                       = 0,
        PRCLO_Front                                        = 1,
        PRCLO_Inside                                       = 2,
        PRCLO_MAX                                          = 3
};*/

// Enum Engine.OnlineProfileSettings.EProfileRaceBrakeControlOptions
/*enum EProfileRaceBrakeControlOptions
{
        PRBCO_Trigger                                      = 0,
        PRBCO_Button                                       = 1,
        PRBCO_MAX                                          = 2
};*/

// Enum Engine.OnlineProfileSettings.EProfileRaceAcceleratorControlOptions
/*enum EProfileRaceAcceleratorControlOptions
{
        PRACO_Trigger                                      = 0,
        PRACO_Button                                       = 1,
        PRACO_MAX                                          = 2
};*/

// Enum Engine.OnlineProfileSettings.EProfileYInversionOptions
/*enum EProfileYInversionOptions
{
        PYIO_Off                                           = 0,
        PYIO_On                                            = 1,
        PYIO_MAX                                           = 2
};*/

// Enum Engine.OnlineProfileSettings.EProfileXInversionOptions
/*enum EProfileXInversionOptions
{
        PXIO_Off                                           = 0,
        PXIO_On                                            = 1,
        PXIO_MAX                                           = 2
};*/

// Enum Engine.OnlineProfileSettings.EProfileOmniDirEvadeOptions
/*enum EProfileOmniDirEvadeOptions
{
        PODI_Off                                           = 0,
        PODI_On                                            = 1,
        PODI_MAX                                           = 2
};*/

// Enum Engine.OnlineProfileSettings.EProfileControllerVibrationToggleOptions
/*enum EProfileControllerVibrationToggleOptions
{
        PCVTO_Off                                          = 0,
        PCVTO_IgnoreThis                                   = 1,
        PCVTO_IgnoreThis2                                  = 2,
        PCVTO_On                                           = 3,
        PCVTO_MAX                                          = 4
};*/

// Enum Engine.OnlineProfileSettings.EProfileVoiceThruSpeakersOptions
/*enum EProfileVoiceThruSpeakersOptions
{
        PVTSO_Off                                          = 0,
        PVTSO_On                                           = 1,
        PVTSO_Both                                         = 2,
        PVTSO_MAX                                          = 3
};*/

// Enum Engine.ParticleEmitter.EParticleBurstMethod
/*enum EParticleBurstMethod
{
        EPBM_Instant                                       = 0,
        EPBM_Interpolated                                  = 1,
        EPBM_MAX                                           = 2
};*/

// Enum Engine.ParticleEmitter.EParticleSubUVInterpMethod
/*enum EParticleSubUVInterpMethod
{
        PSUVIM_None                                        = 0,
        PSUVIM_Linear                                      = 1,
        PSUVIM_Linear_Blend                                = 2,
        PSUVIM_Random                                      = 3,
        PSUVIM_Random_Blend                                = 4,
        PSUVIM_MAX                                         = 5
};*/

// Enum Engine.ParticleEmitter.EEmitterRenderMode
/*enum EEmitterRenderMode
{
        ERM_Normal                                         = 0,
        ERM_Point                                          = 1,
        ERM_Cross                                          = 2,
        ERM_None                                           = 3,
        ERM_MAX                                            = 4
};*/

// Enum Engine.ParticleModule.EModuleType
/*enum EModuleType
{
        EPMT_General                                       = 0,
        EPMT_TypeData                                      = 1,
        EPMT_Beam                                          = 2,
        EPMT_Trail                                         = 3,
        EPMT_Spawn                                         = 4,
        EPMT_Required                                      = 5,
        EPMT_Event                                         = 6,
        EPMT_MAX                                           = 7
};*/

// Enum Engine.ParticleModule.EParticleSourceSelectionMethod
/*enum EParticleSourceSelectionMethod
{
        EPSSM_Random                                       = 0,
        EPSSM_Sequential                                   = 1,
        EPSSM_MAX                                          = 2
};*/

// Enum Engine.ParticleModuleAttractorBoneSocket.EBoneSocketAttractorFalloffType
/*enum EBoneSocketAttractorFalloffType
{
        BSFOFF_Constant                                    = 0,
        BSFOFF_Linear                                      = 1,
        BSFOFF_Exponent                                    = 2,
        BSFOFF_MAX                                         = 3
};*/

// Enum Engine.ParticleModuleAttractorBoneSocket.ELocationBoneSocketDestination
/*enum ELocationBoneSocketDestination
{
        BONESOCKETDEST_Bones                               = 0,
        BONESOCKETDEST_Sockets                             = 1,
        BONESOCKETDEST_MAX                                 = 2
};*/

// Enum
// Engine.ParticleModuleAttractorBoneSocket.ELocationBoneSocketDestSelectionMethod
/*enum ELocationBoneSocketDestSelectionMethod
{
        BONESOCKETDESTSEL_Sequential                       = 0,
        BONESOCKETDESTSEL_Random                           = 1,
        BONESOCKETDESTSEL_RandomExhaustive                 = 2,
        BONESOCKETDESTSEL_BlendAll                         = 3,
        BONESOCKETDESTSEL_MAX                              = 4
};*/

// Enum Engine.ParticleModuleAttractorParticle.EAttractorParticleSelectionMethod
/*enum EAttractorParticleSelectionMethod
{
        EAPSM_Random                                       = 0,
        EAPSM_Sequential                                   = 1,
        EAPSM_MAX                                          = 2
};*/

// Enum
// Engine.ParticleModuleAttractorSkelVertSurface.EVertSurfaceAttractorFalloffType
/*enum EVertSurfaceAttractorFalloffType
{
        VSFOFF_Constant                                    = 0,
        VSFOFF_Linear                                      = 1,
        VSFOFF_Exponent                                    = 2,
        VSFOFF_MAX                                         = 3
};*/

// Enum
// Engine.ParticleModuleAttractorSkelVertSurface.EAttractorSkelVertSurfaceDestination
/*enum EAttractorSkelVertSurfaceDestination
{
        VERTSURFACEDEST_Vert                               = 0,
        VERTSURFACEDEST_Surface                            = 1,
        VERTSURFACEDEST_MAX                                = 2
};*/

// Enum Engine.ParticleModuleBeamBase.Beam2SourceTargetMethod
/*enum Beam2SourceTargetMethod
{
        PEB2STM_Default                                    = 0,
        PEB2STM_UserSet                                    = 1,
        PEB2STM_Emitter                                    = 2,
        PEB2STM_Particle                                   = 3,
        PEB2STM_Actor                                      = 4,
        PEB2STM_ActorSocket                                = 5,
        PEB2STM_MAX                                        = 6
};*/

// Enum Engine.ParticleModuleBeamBase.Beam2SourceTargetTangentMethod
/*enum Beam2SourceTargetTangentMethod
{
        PEB2STTM_Direct                                    = 0,
        PEB2STTM_UserSet                                   = 1,
        PEB2STTM_Distribution                              = 2,
        PEB2STTM_Emitter                                   = 3,
        PEB2STTM_MAX                                       = 4
};*/

// Enum Engine.ParticleModuleBeamModifier.BeamModifierType
/*enum BeamModifierType
{
        PEB2MT_Source                                      = 0,
        PEB2MT_Target                                      = 1,
        PEB2MT_MAX                                         = 2
};*/

// Enum Engine.ParticleModuleCameraOffset.EParticleCameraOffsetUpdateMethod
/*enum EParticleCameraOffsetUpdateMethod
{
        EPCOUM_DirectSet                                   = 0,
        EPCOUM_Additive                                    = 1,
        EPCOUM_Scalar                                      = 2,
        EPCOUM_MAX                                         = 3
};*/

// Enum Engine.ParticleModuleCollisionBase.EParticleCollisionComplete
/*enum EParticleCollisionComplete
{
        EPCC_Kill                                          = 0,
        EPCC_Freeze                                        = 1,
        EPCC_HaltCollisions                                = 2,
        EPCC_FreezeTranslation                             = 3,
        EPCC_FreezeRotation                                = 4,
        EPCC_FreezeMovement                                = 5,
        EPCC_MAX                                           = 6
};*/

// Enum Engine.ParticleModuleCollision.ParticleAttractorActionType
/*enum ParticleAttractorActionType
{
        PAAT_None                                          = 0,
        PAAT_Destroy                                       = 1,
        PAAT_Freeze                                        = 2,
        PAAT_Event                                         = 3,
        PAAT_MAX                                           = 4
};*/

// Enum Engine.ParticleModuleLocationBoneSocket.ELocationBoneSocketSource
/*enum ELocationBoneSocketSource
{
        BONESOCKETSOURCE_Bones                             = 0,
        BONESOCKETSOURCE_Sockets                           = 1,
        BONESOCKETSOURCE_MAX                               = 2
};*/

// Enum
// Engine.ParticleModuleLocationBoneSocket.ELocationBoneSocketSelectionMethod
/*enum ELocationBoneSocketSelectionMethod
{
        BONESOCKETSEL_Sequential                           = 0,
        BONESOCKETSEL_Random                               = 1,
        BONESOCKETSEL_RandomExhaustive                     = 2,
        BONESOCKETSEL_MAX                                  = 3
};*/

// Enum Engine.ParticleModuleLocationEmitter.ELocationEmitterSelectionMethod
/*enum ELocationEmitterSelectionMethod
{
        ELESM_Random                                       = 0,
        ELESM_Sequential                                   = 1,
        ELESM_MAX                                          = 2
};*/

// Enum Engine.ParticleModuleLocationPrimitiveCylinder.CylinderHeightAxis
/*enum CylinderHeightAxis
{
        PMLPC_HEIGHTAXIS_X                                 = 0,
        PMLPC_HEIGHTAXIS_Y                                 = 1,
        PMLPC_HEIGHTAXIS_Z                                 = 2,
        PMLPC_HEIGHTAXIS_MAX                               = 3
};*/

// Enum
// Engine.ParticleModuleLocationSkelVertSurface.ELocationSkelVertSurfaceSource
/*enum ELocationSkelVertSurfaceSource
{
        VERTSURFACESOURCE_Vert                             = 0,
        VERTSURFACESOURCE_Surface                          = 1,
        VERTSURFACESOURCE_MAX                              = 2
};*/

// Enum
// Engine.ParticleModuleLocationStaticVertSurface.ELocationStaticVertSurfaceSource
/*enum ELocationStaticVertSurfaceSource
{
        VERTSTATICSURFACESOURCE_Vert                       = 0,
        VERTSTATICSURFACESOURCE_Surface                    = 1,
        VERTSTATICSURFACESOURCE_MAX                        = 2
};*/

// Enum Engine.ParticleModuleOrbit.EOrbitChainMode
/*enum EOrbitChainMode
{
        EOChainMode_Add                                    = 0,
        EOChainMode_Scale                                  = 1,
        EOChainMode_Link                                   = 2,
        EOChainMode_MAX                                    = 3
};*/

// Enum Engine.ParticleModuleOrientationAxisLock.EParticleAxisLock
/*enum EParticleAxisLock
{
        EPAL_NONE                                          = 0,
        EPAL_X                                             = 1,
        EPAL_Y                                             = 2,
        EPAL_Z                                             = 3,
        EPAL_NEGATIVE_X                                    = 4,
        EPAL_NEGATIVE_Y                                    = 5,
        EPAL_NEGATIVE_Z                                    = 6,
        EPAL_ROTATE_X                                      = 7,
        EPAL_ROTATE_Y                                      = 8,
        EPAL_ROTATE_Z                                      = 9,
        EPAL_MAX                                           = 10
};*/

// Enum Engine.ParticleModuleParameterDynamic.EEmitterDynamicParameterValue
/*enum EEmitterDynamicParameterValue
{
        EDPV_UserSet                                       = 0,
        EDPV_VelocityX                                     = 1,
        EDPV_VelocityY                                     = 2,
        EDPV_VelocityZ                                     = 3,
        EDPV_VelocityMag                                   = 4,
        EDPV_MAX                                           = 5
};*/

// Enum Engine.ParticleModulePhysicsVolumes.EParticleLevelInfluenceType
/*enum EParticleLevelInfluenceType
{
        LIT_Never                                          = 0,
        LIT_OutsidePhysicsVolumes                          = 1,
        LIT_Always                                         = 2,
        LIT_MAX                                            = 3
};*/

// Enum Engine.ParticleSpriteEmitter.EParticleScreenAlignment
/*enum EParticleScreenAlignment
{
        PSA_Square                                         = 0,
        PSA_Rectangle                                      = 1,
        PSA_Velocity                                       = 2,
        PSA_TypeSpecific                                   = 3,
        PSA_MAX                                            = 4
};*/

// Enum Engine.ParticleModuleRequired.EParticleSortMode
/*enum EParticleSortMode
{
        PSORTMODE_None                                     = 0,
        PSORTMODE_ViewProjDepth                            = 1,
        PSORTMODE_DistanceToView                           = 2,
        PSORTMODE_Age_OldestFirst                          = 3,
        PSORTMODE_Age_NewestFirst                          = 4,
        PSORTMODE_MAX                                      = 5
};*/

// Enum Engine.ParticleModuleRequired.EEmitterNormalsMode
/*enum EEmitterNormalsMode
{
        ENM_CameraFacing                                   = 0,
        ENM_Spherical                                      = 1,
        ENM_Cylindrical                                    = 2,
        ENM_MAX                                            = 3
};*/

// Enum Engine.ParticleModuleTrailSource.ETrail2SourceMethod
/*enum ETrail2SourceMethod
{
        PET2SRCM_Default                                   = 0,
        PET2SRCM_Particle                                  = 1,
        PET2SRCM_Actor                                     = 2,
        PET2SRCM_MAX                                       = 3
};*/

// Enum Engine.ParticleModuleTrailSpawn.ETrail2SpawnMethod
/*enum ETrail2SpawnMethod
{
        PET2SM_Emitter                                     = 0,
        PET2SM_Velocity                                    = 1,
        PET2SM_Distance                                    = 2,
        PET2SM_MAX                                         = 3
};*/

// Enum Engine.ParticleModuleTrailTaper.ETrailTaperMethod
/*enum ETrailTaperMethod
{
        PETTM_None                                         = 0,
        PETTM_Full                                         = 1,
        PETTM_Partial                                      = 2,
        PETTM_MAX                                          = 3
};*/

// Enum Engine.ParticleModuleTypeDataBeam.EBeamMethod
/*enum EBeamMethod
{
        PEBM_Distance                                      = 0,
        PEBM_EndPoints                                     = 1,
        PEBM_EndPoints_Interpolated                        = 2,
        PEBM_UserSet_EndPoints                             = 3,
        PEBM_UserSet_EndPoints_Interpolated                = 4,
        PEBM_MAX                                           = 5
};*/

// Enum Engine.ParticleModuleTypeDataBeam.EBeamEndPointMethod
/*enum EBeamEndPointMethod
{
        PEBEPM_Calculated                                  = 0,
        PEBEPM_Distribution                                = 1,
        PEBEPM_Distribution_Constant                       = 2,
        PEBEPM_MAX                                         = 3
};*/

// Enum Engine.ParticleModuleTypeDataBeam2.EBeam2Method
/*enum EBeam2Method
{
        PEB2M_Distance                                     = 0,
        PEB2M_Target                                       = 1,
        PEB2M_Branch                                       = 2,
        PEB2M_MAX                                          = 3
};*/

// Enum Engine.ParticleModuleTypeDataBeam2.EBeamTaperMethod
/*enum EBeamTaperMethod
{
        PEBTM_None                                         = 0,
        PEBTM_Full                                         = 1,
        PEBTM_Partial                                      = 2,
        PEBTM_MAX                                          = 3
};*/

// Enum Engine.ParticleModuleTypeDataMesh.EMeshScreenAlignment
/*enum EMeshScreenAlignment
{
        PSMA_MeshFaceCameraWithRoll                        = 0,
        PSMA_MeshFaceCameraWithSpin                        = 1,
        PSMA_MeshFaceCameraWithLockedAxis                  = 2,
        PSMA_MAX                                           = 3
};*/

// Enum Engine.ParticleModuleTypeDataMesh.EMeshCameraFacingUpAxis
/*enum EMeshCameraFacingUpAxis
{
        CameraFacing_NoneUP                                = 0,
        CameraFacing_ZUp                                   = 1,
        CameraFacing_NegativeZUp                           = 2,
        CameraFacing_YUp                                   = 3,
        CameraFacing_NegativeYUp                           = 4,
        CameraFacing_MAX                                   = 5
};*/

// Enum Engine.ParticleModuleTypeDataMesh.EMeshCameraFacingOptions
/*enum EMeshCameraFacingOptions
{
        XAxisFacing_NoUp                                   = 0,
        XAxisFacing_ZUp                                    = 1,
        XAxisFacing_NegativeZUp                            = 2,
        XAxisFacing_YUp                                    = 3,
        XAxisFacing_NegativeYUp                            = 4,
        LockedAxis_ZAxisFacing                             = 5,
        LockedAxis_NegativeZAxisFacing                     = 6,
        LockedAxis_YAxisFacing                             = 7,
        LockedAxis_NegativeYAxisFacing                     = 8,
        VelocityAligned_ZAxisFacing                        = 9,
        VelocityAligned_NegativeZAxisFacing                = 10,
        VelocityAligned_YAxisFacing                        = 11,
        VelocityAligned_NegativeYAxisFacing                = 12,
        EMeshCameraFacingOptions_MAX                       = 13
};*/

// Enum Engine.ParticleModuleTypeDataMeshPhysX.EPhysXMeshRotationMethod
/*enum EPhysXMeshRotationMethod
{
        PMRM_Disabled                                      = 0,
        PMRM_Spherical                                     = 1,
        PMRM_Box                                           = 2,
        PMRM_LongBox                                       = 3,
        PMRM_FlatBox                                       = 4,
        PMRM_Velocity                                      = 5,
        PMRM_MAX                                           = 6
};*/

// Enum Engine.ParticleModuleTypeDataRibbon.ETrailsRenderAxisOption
/*enum ETrailsRenderAxisOption
{
        Trails_CameraUp                                    = 0,
        Trails_SourceUp                                    = 1,
        Trails_WorldUp                                     = 2,
        Trails_MAX                                         = 3
};*/

// Enum Engine.ParticleSystem.EParticleSystemOcclusionBoundsMethod
/*enum EParticleSystemOcclusionBoundsMethod
{
        EPSOBM_None                                        = 0,
        EPSOBM_ParticleBounds                              = 1,
        EPSOBM_CustomBounds                                = 2,
        EPSOBM_MAX                                         = 3
};*/

// Enum Engine.ParticleSystem.EParticleSystemOveridePhysXLevel
/*enum EParticleSystemOveridePhysXLevel
{
        EPSOP_NoOverride                                   = 0,
        EPSOP_PhysXLevel1                                  = 1,
        EPSOP_PhysXLevel2                                  = 2,
        EPSOP_MAX                                          = 3
};*/

// Enum Engine.ParticleSystem.EParticleSystemUpdateMode
/*enum EParticleSystemUpdateMode
{
        EPSUM_RealTime                                     = 0,
        EPSUM_FixedTime                                    = 1,
        EPSUM_MAX                                          = 2
};*/

// Enum Engine.ProcBuildingRuleset.EProcBuildingAxis
/*enum EProcBuildingAxis
{
        EPBAxis_X                                          = 0,
        EPBAxis_Z                                          = 1,
        EPBAxis_MAX                                        = 2
};*/

// Enum Engine.ProcBuilding.EScopeEdge
/*enum EScopeEdge
{
        EPSA_Top                                           = 0,
        EPSA_Bottom                                        = 1,
        EPSA_Left                                          = 2,
        EPSA_Right                                         = 3,
        EPSA_None                                          = 4,
        EPSA_MAX                                           = 5
};*/

// Enum Engine.ProcBuilding.EBuildingStatsBrowserColumns
/*enum EBuildingStatsBrowserColumns
{
        BSBC_Name                                          = 0,
        BSBC_Ruleset                                       = 1,
        BSBC_NumStaticMeshComps                            = 2,
        BSBC_NumInstancedStaticMeshComps                   = 3,
        BSBC_NumInstancedTris                              = 4,
        BSBC_LightmapMemBytes                              = 5,
        BSBC_ShadowmapMemBytes                             = 6,
        BSBC_LODDiffuseMemBytes                            = 7,
        BSBC_LODLightingMemBytes                           = 8,
        BSBC_MAX                                           = 9
};*/

// Enum Engine.ProcBuilding.EPBCornerType
/*enum EPBCornerType
{
        EPBC_Default                                       = 0,
        EPBC_Chamfer                                       = 1,
        EPBC_Round                                         = 2,
        EPBC_MAX                                           = 3
};*/

// Enum Engine.PBRuleNodeEdgeAngle.EProcBuildingEdge
/*enum EProcBuildingEdge
{
        EPBE_Top                                           = 0,
        EPBE_Bottom                                        = 1,
        EPBE_Left                                          = 2,
        EPBE_Right                                         = 3,
        EPBE_MAX                                           = 4
};*/

// Enum Engine.PhysicalMaterial.EPhysEffectType
/*enum EPhysEffectType
{
        EPMET_Impact                                       = 0,
        EPMET_Slide                                        = 1,
        EPMET_MAX                                          = 2
};*/

// Enum Engine.PhysicalMaterialPropertyBase.EMaterialTypes
/*enum EMaterialTypes
{
        EMT_None                                           = 0,
        EMT_Rock                                           = 1,
        EMT_Dirt                                           = 2,
        EMT_Dust                                           = 3,
        EMT_Mud                                            = 4,
        EMT_Poop                                           = 5,
        EMT_Grass                                          = 6,
        EMT_Plant                                          = 7,
        EMT_Water                                          = 8,
        EMT_WaterShallow                                   = 9,
        EMT_Ice                                            = 10,
        EMT_Snow                                           = 11,
        EMT_Metal                                          = 12,
        EMT_MetalHollow                                    = 13,
        EMT_MetalArmor                                     = 14,
        EMT_Wood                                           = 15,
        EMT_WoodHollow                                     = 16,
        EMT_BrickRed                                       = 17,
        EMT_BrickWhite                                     = 18,
        EMT_Plaster                                        = 19,
        EMT_Glass                                          = 20,
        EMT_GlassBroken                                    = 21,
        EMT_Gravel                                         = 22,
        EMT_Concrete                                       = 23,
        EMT_ConcreteWet                                    = 24,
        EMT_Paper                                          = 25,
        EMT_Cloth                                          = 26,
        EMT_Rubber                                         = 27,
        EMT_Asphalt                                        = 28,
        EMT_Flesh                                          = 29,
        EMT_PlasticBag                                     = 30,
        EMT_Sand                                           = 31,
        EMT_Lava                                           = 32,
        EMT_Custom0                                        = 33,
        EMT_Custom1                                        = 34,
        EMT_Custom2                                        = 35,
        EMT_Custom3                                        = 36,
        EMT_Custom4                                        = 37,
        EMT_MAX                                            = 38
};*/

// Enum Engine.PhysXParticleSystem.ESimulationMethod
/*enum ESimulationMethod
{
        ESM_SPH                                            = 0,
        ESM_NO_PARTICLE_INTERACTION                        = 1,
        ESM_MIXED_MODE                                     = 2,
        ESM_MAX                                            = 3
};*/

// Enum Engine.PhysXParticleSystem.EPacketSizeMultiplier
/*enum EPacketSizeMultiplier
{
        EPSM                                               = 0,
        EPSM01                                             = 1,
        EPSM02                                             = 2,
        EPSM03                                             = 3,
        EPSM04                                             = 4,
        EPSM05                                             = 5,
        EPSM_MAX                                           = 6
};*/

// Enum Engine.SceneCaptureComponent.ESceneCaptureViewMode
/*enum ESceneCaptureViewMode
{
        SceneCapView_Lit                                   = 0,
        SceneCapView_Unlit                                 = 1,
        SceneCapView_LitNoShadows                          = 2,
        SceneCapView_Wire                                  = 3,
        SceneCapView_MAX                                   = 4
};*/

// Enum Engine.RB_BodySetup.ESleepFamily
/*enum ESleepFamily
{
        SF_Normal                                          = 0,
        SF_Sensitive                                       = 1,
        SF_MAX                                             = 2
};*/

// Enum Engine.RB_RadialForceActor.ERadialForceType
/*enum ERadialForceType
{
        RFT_Force                                          = 0,
        RFT_Impulse                                        = 1,
        RFT_MAX                                            = 2
};*/

// Enum Engine.Route.ERouteDirection
/*enum ERouteDirection
{
        ERD_Forward                                        = 0,
        ERD_Reverse                                        = 1,
        ERD_MAX                                            = 2
};*/

// Enum Engine.Route.ERouteType
/*enum ERouteType
{
        ERT_Linear                                         = 0,
        ERT_Loop                                           = 1,
        ERT_Circle                                         = 2,
        ERT_MAX                                            = 3
};*/

// Enum Engine.Route.ERouteFillAction
/*enum ERouteFillAction
{
        RFA_Overwrite                                      = 0,
        RFA_Add                                            = 1,
        RFA_Remove                                         = 2,
        RFA_Clear                                          = 3,
        RFA_MAX                                            = 4
};*/

// Enum Engine.SeqAct_ActorFactory.EPointSelection
/*enum EPointSelection
{
        PS_Normal                                          = 0,
        PS_Random                                          = 1,
        PS_Reverse                                         = 2,
        PS_MAX                                             = 3
};*/

// Enum Engine.SeqAct_SetMesh.EMeshType
/*enum EMeshType
{
        MeshType_StaticMesh                                = 0,
        MeshType_SkeletalMesh                              = 1,
        MeshType_MAX                                       = 2
};*/

// Enum Engine.WorldAttractor.EWorldAttractorFalloffType
/*enum EWorldAttractorFalloffType
{
        FOFF_Constant                                      = 0,
        FOFF_Linear                                        = 1,
        FOFF_Exponent                                      = 2,
        FOFF_MAX                                           = 3
};*/

// Enum Engine.SeqEvent_ParticleEvent.EParticleEventOutputType
/*enum EParticleEventOutputType
{
        ePARTICLEOUT_Spawn                                 = 0,
        ePARTICLEOUT_Death                                 = 1,
        ePARTICLEOUT_Collision                             = 2,
        ePARTICLEOUT_AttractorCollision                    = 3,
        ePARTICLEOUT_Kismet                                = 4,
        ePARTICLEOUT_MAX                                   = 5
};*/

// Enum Engine.SkelControlBase.EBoneControlSpace
/*enum EBoneControlSpace
{
        BCS_WorldSpace                                     = 0,
        BCS_ActorSpace                                     = 1,
        BCS_ComponentSpace                                 = 2,
        BCS_ParentBoneSpace                                = 3,
        BCS_BoneSpace                                      = 4,
        BCS_OtherBoneSpace                                 = 5,
        BCS_BaseMeshSpace                                  = 6,
        BCS_MAX                                            = 7
};*/

// Enum Engine.SkelControlSpline.ESplineControlRotMode
/*enum ESplineControlRotMode
{
        SCR_NoChange                                       = 0,
        SCR_AlongSpline                                    = 1,
        SCR_Interpolate                                    = 2,
        SCR_MAX                                            = 3
};*/

// Enum Engine.SkeletalMesh.SoftBodyBoneType
/*enum SoftBodyBoneType
{
        SOFTBODYBONE_Fixed                                 = 0,
        SOFTBODYBONE_BreakableAttachment                   = 1,
        SOFTBODYBONE_TwoWayAttachment                      = 2,
        SOFTBODYBONE_MAX                                   = 3
};*/

// Enum Engine.SkeletalMesh.ClothBoneType
/*enum ClothBoneType
{
        CLOTHBONE_Fixed                                    = 0,
        CLOTHBONE_BreakableAttachment                      = 1,
        CLOTHBONE_TearLine                                 = 2,
        CLOTHBONE_MAX                                      = 3
};*/

// Enum Engine.SkeletalMesh.SkeletalMeshOptimizationNormalMode
/*enum SkeletalMeshOptimizationNormalMode
{
        SMONM_Recalculate                                  = 0,
        SMONM_RecalculateSoft                              = 1,
        SMONM_RecalculateHard                              = 2,
        SMONM_MAX                                          = 3
};*/

// Enum Engine.SkeletalMesh.SkeletalMeshOptimizationImportance
/*enum SkeletalMeshOptimizationImportance
{
        SMOI_Off                                           = 0,
        SMOI_Lowest                                        = 1,
        SMOI_Low                                           = 2,
        SMOI_Normal                                        = 3,
        SMOI_High                                          = 4,
        SMOI_Highest                                       = 5,
        SMOI_MAX                                           = 6
};*/

// Enum Engine.SkeletalMesh.SkeletalMeshOptimizationType
/*enum SkeletalMeshOptimizationType
{
        SMOT_NumOfTriangles                                = 0,
        SMOT_MaxDeviation                                  = 1,
        SMOT_MAX                                           = 2
};*/

// Enum Engine.SkeletalMesh.TriangleSortOption
/*enum TriangleSortOption
{
        TRISORT_None                                       = 0,
        TRISORT_CenterRadialDistance                       = 1,
        TRISORT_Random                                     = 2,
        TRISORT_MergeContiguous                            = 3,
        TRISORT_Custom                                     = 4,
        TRISORT_CustomLeftRight                            = 5,
        TRISORT_MAX                                        = 6
};*/

// Enum Engine.SkeletalMesh.BoneBreakOption
/*enum BoneBreakOption
{
        BONEBREAK_SoftPreferred                            = 0,
        BONEBREAK_AutoDetect                               = 1,
        BONEBREAK_RigidPreferred                           = 2,
        BONEBREAK_MAX                                      = 3
};*/

// Enum Engine.SkeletalMesh.TriangleSortAxis
/*enum TriangleSortAxis
{
        TSA_X_Axis                                         = 0,
        TSA_Y_Axis                                         = 1,
        TSA_Z_Axis                                         = 2,
        TSA_MAX                                            = 3
};*/

// Enum Engine.SkeletalMesh.ClothMovementScaleGen
/*enum ClothMovementScaleGen
{
        ECMDM_DistToFixedVert                              = 0,
        ECMDM_VertexBoneWeight                             = 1,
        ECMDM_Empty                                        = 2,
        ECMDM_MAX                                          = 3
};*/

// Enum Engine.SoundNodeWave.EDecompressionType
/*enum EDecompressionType
{
        DTYPE_Setup                                        = 0,
        DTYPE_Invalid                                      = 1,
        DTYPE_Preview                                      = 2,
        DTYPE_Native                                       = 3,
        DTYPE_RealTime                                     = 4,
        DTYPE_Procedural                                   = 5,
        DTYPE_Xenon                                        = 6,
        DTYPE_Dingo                                        = 7,
        DTYPE_MAX                                          = 8
};*/

// Enum Engine.SpeedTreeComponent.ESpeedTreeMeshType
/*enum ESpeedTreeMeshType
{
        STMT_MinMinusOne                                   = 0,
        STMT_Branches1                                     = 1,
        STMT_Branches2                                     = 2,
        STMT_Fronds                                        = 3,
        STMT_LeafCards                                     = 4,
        STMT_LeafMeshes                                    = 5,
        STMT_Billboards                                    = 6,
        STMT_Max                                           = 7
};*/

// Enum Engine.SVehicleWheel.EWheelSide
/*enum EWheelSide
{
        SIDE_None                                          = 0,
        SIDE_Left                                          = 1,
        SIDE_Right                                         = 2,
        SIDE_MAX                                           = 3
};*/

// Enum Engine.TerrainMaterial.ETerrainMappingType
/*enum ETerrainMappingType
{
        TMT_Auto                                           = 0,
        TMT_XY                                             = 1,
        TMT_XZ                                             = 2,
        TMT_YZ                                             = 3,
        TMT_MAX                                            = 4
};*/

// Enum Engine.TextureFlipBook.TextureFlipBookMethod
/*enum TextureFlipBookMethod
{
        TFBM_UL_ROW                                        = 0,
        TFBM_UL_COL                                        = 1,
        TFBM_UR_ROW                                        = 2,
        TFBM_UR_COL                                        = 3,
        TFBM_LL_ROW                                        = 4,
        TFBM_LL_COL                                        = 5,
        TFBM_LR_ROW                                        = 6,
        TFBM_LR_COL                                        = 7,
        TFBM_RANDOM                                        = 8,
        TFBM_MAX                                           = 9
};*/

// Enum Engine.TextureMovie.EMovieStreamSource
/*enum EMovieStreamSource
{
        MovieStream_File                                   = 0,
        MovieStream_Memory                                 = 1,
        MovieStream_MAX                                    = 2
};*/

// Enum Engine.TwitterIntegrationBase.ETwitterRequestMethod
/*enum ETwitterRequestMethod
{
        TRM_Get                                            = 0,
        TRM_Post                                           = 1,
        TRM_Delete                                         = 2,
        TRM_MAX                                            = 3
};*/

// Enum Engine.TwitterIntegrationBase.ETwitterIntegrationDelegate
/*enum ETwitterIntegrationDelegate
{
        TID_AuthorizeComplete                              = 0,
        TID_TweetUIComplete                                = 1,
        TID_RequestComplete                                = 2,
        TID_MAX                                            = 3
};*/

// Enum Engine.TWOnlineLobby.ELobbyVisibility
/*enum ELobbyVisibility
{
        LV_Public                                          = 0,
        LV_Friends                                         = 1,
        LV_Private                                         = 2,
        LV_Invisible                                       = 3,
        LV_MAX                                             = 4
};*/

// Enum Engine.UberPostProcessEffect.EPostProcessAAType
/*enum EPostProcessAAType
{
        PostProcessAA_Off                                  = 0,
        PostProcessAA_FXAA0                                = 1,
        PostProcessAA_FXAA1                                = 2,
        PostProcessAA_FXAA2                                = 3,
        PostProcessAA_FXAA3                                = 4,
        PostProcessAA_FXAA4                                = 5,
        PostProcessAA_FXAA5                                = 6,
        PostProcessAA_MLAA                                 = 7,
        PostProcessAA_MAX                                  = 8
};*/

// Enum Engine.UberPostProcessEffect.ETonemapperType
/*enum ETonemapperType
{
        Tonemapper_Off                                     = 0,
        Tonemapper_Filmic                                  = 1,
        Tonemapper_Customizable                            = 2,
        Tonemapper_MAX                                     = 3
};*/

// Enum Engine.UIDataProvider_MenuItem.EMenuOptionType
/*enum EMenuOptionType
{
        MENUOT_ComboReadOnly                               = 0,
        MENUOT_ComboNumeric                                = 1,
        MENUOT_CheckBox                                    = 2,
        MENUOT_Slider                                      = 3,
        MENUOT_Spinner                                     = 4,
        MENUOT_EditBox                                     = 5,
        MENUOT_CollectionCheckBox                          = 6,
        MENUOT_CollapsingList                              = 7,
        MENUOT_MAX                                         = 8
};*/

// Enum Engine.UIDataStore_OnlineStats.EStatsFetchType
/*enum EStatsFetchType
{
        SFT_Player                                         = 0,
        SFT_CenteredOnPlayer                               = 1,
        SFT_Friends                                        = 2,
        SFT_TopRankings                                    = 3,
        SFT_MAX                                            = 4
};*/

// Enum Engine.Weapon.EWeaponFireType
/*enum EWeaponFireType
{
        EWFT_InstantHit                                    = 0,
        EWFT_Projectile                                    = 1,
        EWFT_Custom                                        = 2,
        EWFT_None                                          = 3,
        EWFT_MAX                                           = 4
};*/

/*
#
=========================================================================================
# # Classes #
=========================================================================================
#
*/

// Class Engine.Actor
// 0x01E4 (0x0244 - 0x0060)
class AActor : public UObject {
   public:
    TArray<class UActorComponent*>
        Components;  // 0x0060 (0x0010) [0x0000000000000000]
    TArray<class UActorComponent*>
        AllComponents;         // 0x0070 (0x0010) [0x0000000000000000]
    struct FVector Location;   // 0x0080 (0x000C) [0x0000000000000000]
    struct FRotator Rotation;  // 0x008C (0x000C) [0x0000000000010000] (
                               // CPF_Travel )
    float DrawScale;  // 0x0098 (0x0004) [0x000000000002033A]              (
                      // CPF_Const | CPF_ExportObject | CPF_OptionalParm |
                      // CPF_Net | CPF_OutParm | CPF_SkipParm | CPF_EditConst )
    struct FVector DrawScale3D;     // 0x009C (0x000C) [0x0000000000000000]
    struct FVector PrePivot;        // 0x00A8 (0x000C) [0x0000000000000000]
    struct FColor EditorIconColor;  // 0x00B4 (0x0004) [0x0000000000000000]
    struct FRenderCommandFence
        DetachFence;           // 0x00B8 (0x0004) [0x0000000000000000]
    float CustomTimeDilation;  // 0x00BC (0x0004) [0x0000000000000000]
    unsigned char Physics;  // 0x00C0 (0x0001) [0x000000000003018D] ( CPF_Edit |
                            // CPF_Input | CPF_ExportObject | CPF_Parm |
                            // CPF_OutParm | CPF_Travel | CPF_EditConst )
    unsigned char
        RemoteRole;  // 0x00C1 (0x0001) [0x00000000000402BA]              (
                     // CPF_Const | CPF_ExportObject | CPF_OptionalParm |
                     // CPF_Net | CPF_Parm | CPF_SkipParm | CPF_GlobalConfig )
    unsigned char
        Role;  // 0x00C2 (0x0001) [0x00000000000502BA]              ( CPF_Const
               // | CPF_ExportObject | CPF_OptionalParm | CPF_Net | CPF_Parm |
               // CPF_SkipParm | CPF_Travel | CPF_GlobalConfig )
    unsigned char CollisionType;  // 0x00C3 (0x0001) [0x0000000000000000]
    unsigned char
        ReplicatedCollisionType;  // 0x00C4 (0x0001) [0x000000000006033A] (
                                  // CPF_Const | CPF_ExportObject |
                                  // CPF_OptionalParm | CPF_Net | CPF_OutParm |
                                  // CPF_SkipParm | CPF_EditConst |
                                  // CPF_GlobalConfig )
    unsigned char TickGroup;  // 0x00C5 (0x0001) [0x0000000000000000]
    class AActor*
        Owner;  // 0x00C8 (0x0008) [0x000000000007037A]              ( CPF_Const
                // | CPF_ExportObject | CPF_OptionalParm | CPF_Net |
                // CPF_EditConstArray | CPF_OutParm | CPF_SkipParm | CPF_Travel
                // | CPF_EditConst | CPF_GlobalConfig )
    class AActor* Base;  // 0x00D0 (0x0008) [0x00000000000800B8]              (
                         // CPF_ExportObject | CPF_OptionalParm | CPF_Net |
                         // CPF_Parm | CPF_Component )
    TArray<struct FTimerData> Timers;  // 0x00D8 (0x0010) [0x0000000000000000]
    DWORD bStatic : 1;    // 0x00E8 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bHidden : 1;    // 0x00E8 (0x0004) [0x000000000009021C] [0x00000002] (
                          // CPF_Input | CPF_ExportObject | CPF_OptionalParm |
                          // CPF_SkipParm | CPF_Travel | CPF_Component )
    DWORD bNoDelete : 1;  // 0x00E8 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bDeleteMe : 1;  // 0x00E8 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bTicked : 1;    // 0x00E8 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD
        bOnlyOwnerSee : 1;  // 0x00E8 (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bTickIsDisabled : 1;          // 0x00E8 (0x0004) [0x0000000000000000]
                                        // [0x00000040]
    DWORD bWorldGeometry : 1;           // 0x00E8 (0x0004) [0x0000000000000000]
                                        // [0x00000080]
    DWORD bIgnoreRigidBodyPawns : 1;    // 0x00E8 (0x0004) [0x0000000000000000]
                                        // [0x00000100]
    DWORD bOrientOnSlope : 1;           // 0x00E8 (0x0004) [0x0000000000000000]
                                        // [0x00000200]
    DWORD bIgnoreEncroachers : 1;       // 0x00E8 (0x0004) [0x0000000000000000]
                                        // [0x00000400]
    DWORD bPushedByEncroachers : 1;     // 0x00E8 (0x0004) [0x0000000000000000]
                                        // [0x00000800]
    DWORD bDestroyedByInterpActor : 1;  // 0x00E8 (0x0004) [0x0000000000000000]
                                        // [0x00001000]
    DWORD bRouteBeginPlayEvenIfStatic : 1;  // 0x00E8 (0x0004)
                                            // [0x0000000000000000] [0x00002000]
    DWORD bIsMoving : 1;  // 0x00E8 (0x0004) [0x0000000000000000] [0x00004000]
    DWORD bAlwaysEncroachCheck : 1;  // 0x00E8 (0x0004) [0x0000000000000000]
                                     // [0x00008000]
    DWORD bHasAlternateTargetLocation : 1;  // 0x00E8 (0x0004)
                                            // [0x0000000000000000] [0x00010000]
    DWORD
        bCanStepUpOn : 1;  // 0x00E8 (0x0004) [0x0000000000000000] [0x00020000]
    DWORD
        bNetTemporary : 1;  // 0x00E8 (0x0004) [0x0000000000000000] [0x00040000]
    DWORD bOnlyRelevantToOwner : 1;  // 0x00E8 (0x0004) [0x0000000000000000]
                                     // [0x00080000]
    DWORD bNetDirty : 1;  // 0x00E8 (0x0004) [0x0000000000000000] [0x00100000]
    DWORD bAlwaysRelevant : 1;       // 0x00E8 (0x0004) [0x0000000000000000]
                                     // [0x00200000]
    DWORD bReplicateInstigator : 1;  // 0x00E8 (0x0004) [0x0000000000000000]
                                     // [0x00400000]
    DWORD bReplicateMovement : 1;    // 0x00E8 (0x0004) [0x0000000000000000]
                                     // [0x00800000]
    DWORD
        bSkipActorPropertyReplication : 1;  // 0x00E8 (0x0004)
                                            // [0x0000000000000000] [0x01000000]
    DWORD bUpdateSimulatedPosition : 1;  // 0x00E8 (0x0004) [0x0000000000000000]
                                         // [0x02000000]
    DWORD bTearOff : 1;  // 0x00E8 (0x0004) [0x00000000000A02BA] [0x04000000] (
                         // CPF_Const | CPF_ExportObject | CPF_OptionalParm |
                         // CPF_Net | CPF_Parm | CPF_SkipParm | CPF_EditConst |
                         // CPF_Component )
    DWORD bOnlyDirtyReplication : 1;  // 0x00E8 (0x0004) [0x0000000000000000]
                                      // [0x08000000]
    DWORD
        bAllowFluidSurfaceInteraction : 1;  // 0x00E8 (0x0004)
                                            // [0x0000000000000000] [0x10000000]
    DWORD bDemoRecording : 1;  // 0x00E8 (0x0004) [0x0000000000000000]
                               // [0x20000000]
    DWORD bDemoOwner : 1;  // 0x00E8 (0x0004) [0x0000000000000000] [0x40000000]
    DWORD bForceDemoRelevant : 1;   // 0x00E8 (0x0004) [0x0000000000000000]
                                    // [0x80000000]
    DWORD bNetInitialRotation : 1;  // 0x00EC (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    DWORD bReplicateRigidBodyLocation : 1;  // 0x00EC (0x0004)
                                            // [0x0000000000000000] [0x00000002]
    DWORD bKillDuringLevelTransition : 1;   // 0x00EC (0x0004)
                                            // [0x0000000000000000] [0x00000004]
    DWORD bExchangedRoles : 1;  // 0x00EC (0x0004) [0x0000000000000000]
                                // [0x00000008]
    DWORD bConsiderAllStaticMeshComponentsForStreaming : 1;  // 0x00EC (0x0004)
                                                             // [0x0000000000000000]
                                                             // [0x00000010]
    DWORD bDebug : 1;  // 0x00EC (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bPostRenderIfNotVisible : 1;  // 0x00EC (0x0004) [0x0000000000000000]
                                        // [0x00000040]
    DWORD bForceNetUpdate : 1;          // 0x00EC (0x0004) [0x0000000000000000]
                                        // [0x00000080]
    DWORD bPendingNetUpdate : 1;        // 0x00EC (0x0004) [0x0000000000000000]
                                        // [0x00000100]
    DWORD
        bHardAttach : 1;  // 0x00EC (0x0004) [0x00000000000B01EB] [0x00000200] (
                          // CPF_Edit | CPF_Const | CPF_ExportObject | CPF_Net |
                          // CPF_EditConstArray | CPF_Parm | CPF_OutParm |
                          // CPF_Travel | CPF_EditConst | CPF_Component )
    DWORD bIgnoreBaseRotation : 1;  // 0x00EC (0x0004) [0x0000000000000000]
                                    // [0x00000400]
    DWORD bShadowParented : 1;      // 0x00EC (0x0004) [0x0000000000000000]
                                    // [0x00000800]
    DWORD bSkipAttachedMoves : 1;   // 0x00EC (0x0004) [0x0000000000000000]
                                    // [0x00001000]
    DWORD bCanBeAdheredTo : 1;      // 0x00EC (0x0004) [0x0000000000000000]
                                    // [0x00002000]
    DWORD bCanBeFrictionedTo : 1;   // 0x00EC (0x0004) [0x0000000000000000]
                                    // [0x00004000]
    DWORD bHurtEntry : 1;  // 0x00EC (0x0004) [0x0000000000000000] [0x00008000]
    DWORD
        bGameRelevant : 1;  // 0x00EC (0x0004) [0x0000000000000000] [0x00010000]
    DWORD bMovable : 1;     // 0x00EC (0x0004) [0x0000000000000000] [0x00020000]
    DWORD bDestroyInPainVolume : 1;  // 0x00EC (0x0004) [0x0000000000000000]
                                     // [0x00040000]
    DWORD
        bCanBeDamaged : 1;  // 0x00EC (0x0004) [0x0000000000000000] [0x00080000]
    DWORD bShouldBaseAtStartup : 1;  // 0x00EC (0x0004) [0x0000000000000000]
                                     // [0x00100000]
    DWORD bPendingDelete : 1;        // 0x00EC (0x0004) [0x0000000000000000]
                                     // [0x00200000]
    DWORD
        bCanTeleport : 1;   // 0x00EC (0x0004) [0x0000000000000000] [0x00400000]
    DWORD bAlwaysTick : 1;  // 0x00EC (0x0004) [0x0000000000000000] [0x00800000]
    DWORD bBlocksNavigation : 1;    // 0x00EC (0x0004) [0x0000000000000000]
                                    // [0x01000000]
    DWORD BlockRigidBody : 1;       // 0x00EC (0x0004) [0x0000000000000000]
                                    // [0x02000000]
    DWORD bCollideWhenPlacing : 1;  // 0x00EC (0x0004) [0x0000000000000000]
                                    // [0x04000000]
    DWORD bCollideActors : 1;       // 0x00EC (0x0004) [0x00000000000C033A]
                               // [0x08000000] ( CPF_Const | CPF_ExportObject |
                               // CPF_OptionalParm | CPF_Net | CPF_OutParm |
                               // CPF_SkipParm | CPF_GlobalConfig |
                               // CPF_Component )
    DWORD
        bCollideWorld : 1;  // 0x00EC (0x0004) [0x00000000000D033A] [0x10000000]
                            // ( CPF_Const | CPF_ExportObject | CPF_OptionalParm
                            // | CPF_Net | CPF_OutParm | CPF_SkipParm |
                            // CPF_Travel | CPF_GlobalConfig | CPF_Component )
    DWORD bCollideComplex : 1;  // 0x00EC (0x0004) [0x0000000000000000]
                                // [0x20000000]
    DWORD
        bBlockActors : 1;  // 0x00EC (0x0004) [0x00000000000E025C] [0x40000000]
                           // ( CPF_Input | CPF_ExportObject | CPF_OptionalParm
                           // | CPF_EditConstArray | CPF_SkipParm |
                           // CPF_EditConst | CPF_GlobalConfig | CPF_Component )
    DWORD
        bProjTarget : 1;  // 0x00EC (0x0004) [0x00000000000F025C] [0x80000000] (
                          // CPF_Input | CPF_ExportObject | CPF_OptionalParm |
                          // CPF_EditConstArray | CPF_SkipParm | CPF_Travel |
                          // CPF_EditConst | CPF_GlobalConfig | CPF_Component )
    DWORD bBlocksTeleport : 1;          // 0x00F0 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bMoveIgnoresDestruction : 1;  // 0x00F0 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD
        bProjectileMoveSingleBlocking : 1;  // 0x00F0 (0x0004)
                                            // [0x0000000000000000] [0x00000004]
    DWORD bNoEncroachCheck : 1;      // 0x00F0 (0x0004) [0x0000000000000000]
                                     // [0x00000008]
    DWORD bCollideAsEncroacher : 1;  // 0x00F0 (0x0004) [0x0000000000000000]
                                     // [0x00000010]
    DWORD
        bPhysRigidBodyOutOfWorldCheck : 1;  // 0x00F0 (0x0004)
                                            // [0x0000000000000000] [0x00000020]
    DWORD bComponentOutsideWorld : 1;    // 0x00F0 (0x0004) [0x0000000000000000]
                                         // [0x00000040]
    DWORD bForceOctreeSNFilter : 1;      // 0x00F0 (0x0004) [0x0000000000000000]
                                         // [0x00000080]
    DWORD bForceOctreeMNFilter : 1;      // 0x00F0 (0x0004) [0x0000000000000000]
                                         // [0x00000100]
    DWORD bRigidBodyWasAwake : 1;        // 0x00F0 (0x0004) [0x0000000000000000]
                                         // [0x00000200]
    DWORD bCallRigidBodyWakeEvents : 1;  // 0x00F0 (0x0004) [0x0000000000000000]
                                         // [0x00000400]
    DWORD bBounce : 1;  // 0x00F0 (0x0004) [0x0000000000000000] [0x00000800]
    DWORD bJustTeleported : 1;     // 0x00F0 (0x0004) [0x0000000000000000]
                                   // [0x00001000]
    DWORD bEnableMobileTouch : 1;  // 0x00F0 (0x0004) [0x0000000000000000]
                                   // [0x00002000]
    DWORD bNetInitial : 1;  // 0x00F0 (0x0004) [0x0000000000000000] [0x00004000]
    DWORD bNetOwner : 1;  // 0x00F0 (0x0004) [0x00000000001002BA] [0x00008000] (
                          // CPF_Const | CPF_ExportObject | CPF_OptionalParm |
                          // CPF_Net | CPF_Parm | CPF_SkipParm )
    DWORD bHiddenEd : 1;  // 0x00F0 (0x0004) [0x0000000000000000] [0x00010000]
    DWORD bEditable : 1;  // 0x00F0 (0x0004) [0x0000000000000000] [0x00020000]
    DWORD bHiddenEdGroup : 1;      // 0x00F0 (0x0004) [0x0000000000000000]
                                   // [0x00040000]
    DWORD bHiddenEdLayer : 1;      // 0x00F0 (0x0004) [0x0000000000000000]
                                   // [0x00080000]
    DWORD bHiddenEdCustom : 1;     // 0x00F0 (0x0004) [0x0000000000000000]
                                   // [0x00100000]
    DWORD bHiddenEdTemporary : 1;  // 0x00F0 (0x0004) [0x0000000000000000]
                                   // [0x00200000]
    DWORD bHiddenEdLevel : 1;      // 0x00F0 (0x0004) [0x0000000000000000]
                                   // [0x00400000]
    DWORD bHiddenEdScene : 1;      // 0x00F0 (0x0004) [0x0000000000000000]
                                   // [0x00800000]
    DWORD
        bEdShouldSnap : 1;  // 0x00F0 (0x0004) [0x0000000000000000] [0x01000000]
    DWORD bTempEditor : 1;  // 0x00F0 (0x0004) [0x0000000000000000] [0x02000000]
    DWORD bPathColliding : 1;  // 0x00F0 (0x0004) [0x0000000000000000]
                               // [0x04000000]
    DWORD bPathTemp : 1;  // 0x00F0 (0x0004) [0x0000000000000000] [0x08000000]
    DWORD bScriptInitialized : 1;  // 0x00F0 (0x0004) [0x0000000000000000]
                                   // [0x10000000]
    DWORD
        bLockLocation : 1;  // 0x00F0 (0x0004) [0x0000000000000000] [0x20000000]
    DWORD
        bForceAllowKismetModification : 1;  // 0x00F0 (0x0004)
                                            // [0x0000000000000000] [0x40000000]
    DWORD bDebugEffectIsRelevant : 1;  // 0x00F0 (0x0004) [0x0000000000000000]
                                       // [0x80000000]
    DWORD bLoadIfPhysXLevel0 : 1;      // 0x00F4 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bLoadIfPhysXLevel1 : 1;      // 0x00F4 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD bLoadIfPhysXLevel2 : 1;      // 0x00F4 (0x0004) [0x0000000000000000]
                                       // [0x00000004]
    DWORD bCrawlable : 1;  // 0x00F4 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bIgnoreAudioOcclusion : 1;  // 0x00F4 (0x0004) [0x0000000000000000]
                                      // [0x00000010]
    DWORD
        bIgnoreNetRelevancyCollision : 1;  // 0x00F4 (0x0004)
                                           // [0x0000000000000000] [0x00000020]
    DWORD bOverride_OcclusionFlags : 1;  // 0x00F4 (0x0004) [0x0000000000000000]
                                         // [0x00000040]
    DWORD
        bSkipPostTickComponentUpdate : 1;  // 0x00F4 (0x0004)
                                           // [0x0000000000000000] [0x00000080]
    int SkelMeshCompTickTag;   // 0x00F8 (0x0004) [0x0000000000000000]
    int NetTag;                // 0x00FC (0x0004) [0x0000000000000000]
    float NetUpdateTime;       // 0x0100 (0x0004) [0x0000000000000000]
    float NetUpdateFrequency;  // 0x0104 (0x0004) [0x0000000000000000]
    float NetPriority;         // 0x0108 (0x0004) [0x0000000000000000]
    float LastNetUpdateTime;   // 0x010C (0x0004) [0x0000000000000000]
    float TimeSinceLastTick;   // 0x0110 (0x0004) [0x0000000000000000]
    class APawn* Instigator;  // 0x0114 (0x0008) [0x00000000001102EB] ( CPF_Edit
                              // | CPF_Const | CPF_ExportObject | CPF_Net |
                              // CPF_EditConstArray | CPF_Parm | CPF_SkipParm |
                              // CPF_Travel )
    class AWorldInfo* WorldInfo;      // 0x011C (0x0008) [0x0000000000000000]
    float LifeSpan;                   // 0x0124 (0x0004) [0x0000000000000000]
    float CreationTime;               // 0x0128 (0x0004) [0x0000000000000000]
    float LastRenderTime;             // 0x012C (0x0004) [0x0000000000000000]
    struct FName Tag;                 // 0x0130 (0x0008) [0x0000000000000000]
    struct FName InitialState;        // 0x0138 (0x0008) [0x0000000000000000]
    struct FName Layer;               // 0x0140 (0x0008) [0x0000000000000000]
    struct FName Group;               // 0x0148 (0x0008) [0x0000000000000000]
    struct FQWord HiddenEditorViews;  // 0x0150 (0x0008) [0x0000000000000000]
    TArray<class AActor*> Touching;   // 0x0158 (0x0010) [0x0000000000000000]
    TArray<class AActor*> Children;   // 0x0168 (0x0010) [0x0000000000000000]
    float LatentFloat;                // 0x0178 (0x0004) [0x0000000000000000]
    class UAnimNodeSequence*
        LatentSeqNode;  // 0x017C (0x0008) [0x0000000000000000]
    class APhysicsVolume*
        PhysicsVolume;        // 0x0184 (0x0008) [0x0000000000000000]
    struct FVector Velocity;  // 0x018C (0x000C) [0x000000000012018D] ( CPF_Edit
                              // | CPF_Input | CPF_ExportObject | CPF_Parm |
                              // CPF_OutParm | CPF_EditConst )
    struct FVector Acceleration;     // 0x0198 (0x000C) [0x0000000000000000]
    struct FVector AngularVelocity;  // 0x01A4 (0x000C) [0x0000000000000000]
    class USkeletalMeshComponent*
        BaseSkelComponent;            // 0x01B0 (0x0008) [0x0000000000000000]
    struct FName BaseBoneName;        // 0x01B8 (0x0008) [0x0000000000000000]
    TArray<class AActor*> Attached;   // 0x01C0 (0x0010) [0x0000000000000000]
    struct FVector RelativeLocation;  // 0x01D0 (0x000C) [0x00000000001300F8] (
                                      // CPF_ExportObject | CPF_OptionalParm |
                                      // CPF_Net | CPF_EditConstArray | CPF_Parm
                                      // | CPF_Travel | CPF_EditConst )
    struct FRotator
        RelativeRotation;  // 0x01DC (0x000C) [0x00000000001400F8] (
                           // CPF_ExportObject | CPF_OptionalParm | CPF_Net |
                           // CPF_EditConstArray | CPF_Parm | CPF_GlobalConfig )
    class UPrimitiveComponent*
        CollisionComponent;        // 0x01E8 (0x0008) [0x0000000000000000]
    int OverlapTag;                // 0x01F0 (0x0004) [0x0000000000000000]
    struct FRotator RotationRate;  // 0x01F4 (0x000C) [0x0000000000000000]
    class AActor* PendingTouch;    // 0x0200 (0x0008) [0x0000000000000000]
    class UClass* MessageClass;    // 0x0208 (0x0008) [0x0000000000000000]
    TArray<class UClass*>
        SupportedEvents;  // 0x0210 (0x0010) [0x0000000000000000]
    TArray<class USequenceEvent*>
        GeneratedEvents;  // 0x0220 (0x0010) [0x0000000000000000]
    TArray<class USeqAct_Latent*>
        LatentActions;       // 0x0230 (0x0010) [0x0000000000000000]
    float ActorTimeSeconds;  // 0x0240 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[125];

        return pClassPointer;
    };

    void ActorTimeSince();
    void GetActorTimeSeconds();
    void OnAnimNotifyParticleSystemSpawned();
    void AdjustRadiusDamage();
    void GetActorSpriteComponent();
    void GetActorMetrics();
    void eventOnMobileTouch();
    void IsMobileTouchEnabled();
    void ShouldBeHiddenBySHOW_NavigationNodes();
    void WillOverlap();
    void GetAvoidanceVector();
    void eventReplicationEnded();
    void eventPostDemoRewind();
    void eventAnimTreeUpdated();
    void SupportsKismetModification();
    void GetAnimTrailParticleSystem();
    void eventTrailsNotifyEnd();
    void eventTrailsNotifyTick();
    void eventTrailsNotify();
    void eventCreateForceField();
    void eventPlayParticleEffect();
    void GetAimAdhesionExtent();
    void GetAimFrictionExtent();
    void IsInPersistentLevel();
    void eventOnRigidBodySpringOverextension();
    void GetPackageGuid();
    void eventPostInitAnimTree();
    void eventRootMotionExtracted();
    void eventRootMotionProcessed();
    void eventRootMotionModeChanged();
    void eventPostRenderFor();
    void NativePostRenderFor();
    void SetHUDLocation();
    void eventOnRanOver();
    void eventRigidBodyCollision();
    void eventInterpolationChanged();
    void eventInterpolationFinished();
    void eventInterpolationStarted();
    void eventSpawnedByKismet();
    void GetTargetLocation();
    void FindGoodEndView();
    void NotifyLocalPlayerTeamReceived();
    void eventScriptGetTeamNum();
    void GetTeamNum();
    void PawnBaseDied();
    void IsPlayerOwned();
    void eventGetActorEyesViewPoint();
    void IsStationary();
    void eventGetActorFaceFXAsset();
    void CanActorPlayFaceFXAnim();
    void IsActorPlayingFaceFXAnim();
    void eventTickSkelControl();
    void eventSetSkelControlScale();
    void eventSetMorphWeight();
    void eventStopActorFaceFXAnim();
    void eventPlayActorFaceFXAnim();
    void eventFinishAnimControl();
    void eventSetAnimPosition();
    void eventBeginAnimControl();
    void eventOnAnimPlay();
    void eventOnAnimEnd();
    void DoKismetAttachment();
    void OnAttachToActor();
    void OnToggleHidden();
    void OnChangeCollision();
    void OnSetPhysics();
    void OnSetBlockRigidBody();
    void OnSetVelocity();
    void OnTeleport();
    void OnModifyHealth();
    void PrestreamTextures();
    void eventShutDown();
    void SetNetUpdateTime();
    void eventForceNetRelevant();
    void OnDestroy();
    void ClearLatentAction();
    void FindEventsOfClass();
    void ActivateEventClass();
    void TriggerGlobalEventClass();
    void eventReceivedNewEvent();
    void TriggerEventClass();
    void eventDebugMessagePlayer();
    void ImpactEffectIsRelevant();
    void ActorEffectIsRelevant();
    void EffectIsRelevant();
    void ApplyFluidSurfaceImpact();
    void CanSplash();
    void PlayTeleportEffect();
    void IsInPain();
    void eventReset();
    void eventGetFaceFXAudioComponent();
    void eventModifyHearSoundComponent();
    void GetPhysicsName();
    void DisplayDebug();
    void GetDebugName();
    void MatchStarting();
    void GetLocalString();
    void ReplaceText();
    void GetHumanReadableName();
    void GetItemName();
    void CalcCamera();
    void eventEndViewTarget();
    void eventBecomeViewTarget();
    void CheckForErrors();
    void eventDebugFreezeGame();
    void GetGravityZ();
    void CheckHitInfo();
    void TakeRadiusDamage();
    void eventHealDamage();
    void eventTakeDamage();
    void KilledBy();
    void HurtRadius();
    void StopsProjectile();
    void eventNotifySkelControlBeyondLimit();
    void eventConstraintBrokenNotify();
    void eventSetInitialState();
    void eventPostBeginPlay();
    void eventBroadcastLocalizedTeamMessage();
    void eventBroadcastLocalizedMessage();
    void eventPreBeginPlay();
    void GetALocalPlayerController();
    void LocalPlayerControllers();
    void AllOwnedComponents();
    void ComponentList();
    void OverlappingActors();
    void CollidingActors();
    void VisibleCollidingActors();
    void VisibleActors();
    void TraceActors();
    void TouchingActors();
    void BasedActors();
    void ChildActors();
    void DynamicActors();
    void AllActors();
    void GetURLMap();
    void PostTeleport();
    void PreTeleport();
    void GetDestination();
    void CalculateMinSpeedTrajectory();
    void SuggestTossVelocity();
    void PlayerCanSeeMe();
    void MakeNoise();
    void ActivateOcclusion();
    void PostTrigger();
    void SetSwitch();
    void SetState();
    void GetAKRotation();
    void SetRTPCValue();
    void StopAkEventsOnBone();
    void PostAkEventOnBone();
    void PostAkEventAtLocation();
    void PostAkEvent();
    void PlaySoundBase();
    void PlayAkEvent();
    void PlaySound();
    void CreateAudioComponent();
    void ResetTimerTimeDilation();
    void ModifyTimerTimeDilation();
    void GetRemainingTimeForTimer();
    void GetTimerRate();
    void GetTimerCount();
    void IsTimerActive();
    void PauseTimer();
    void ClearAllTimers();
    void ClearTimer();
    void SetTimer();
    void eventTornOff();
    void Destroy();
    void Spawn();
    void IsBlockedBy();
    void GetBoundingCylinder();
    void GetComponentsBoundingBox();
    void IsOverlapping();
    void ContainsPoint();
    void FindSpot();
    void TraceAllPhysicsAssetInteractions();
    void FastTrace();
    void PointCheckComponent();
    void TraceComponent();
    void Trace();
    void VolumeBasedDestroy();
    void eventOutsideWorldBounds();
    void eventFellOutOfWorld();
    void UsedBy();
    void eventOverRotated();
    void ClampRotation();
    void eventOnSleepRBPhysics();
    void eventOnWakeRBPhysics();
    void eventRanInto();
    void eventEncroachedBy();
    void eventEncroachingOn();
    void eventCollisionChanged();
    void eventSpecialHandling();
    void eventDetach();
    void eventAttach();
    void eventBaseChange();
    void eventBump();
    void eventUnTouch();
    void eventPostTouch();
    void eventTouch();
    void eventPhysicsVolumeChange();
    void eventLanded();
    void eventFalling();
    void eventHitWall();
    void eventTimer();
    void eventTick();
    void eventLostChild();
    void eventGainedChild();
    void eventDestroyed();
    void SetTickIsDisabled();
    void SetTickGroup();
    void ReattachComponent();
    void DetachComponent();
    void AttachComponent();
    void UnClock();
    void Clock();
    void SetPhysics();
    void SetOnlyOwnerSee();
    void SetHidden();
    void ChartData();
    void FlushDebugStrings();
    void DrawDebugFrustrum();
    void DrawDebugString();
    void DrawDebugCone();
    void DrawDebugCylinder();
    void DrawDebugSphere();
    void DrawDebugCoordinateSystem();
    void DrawDebugStar();
    void DrawDebugBox();
    void DrawDebugPoint();
    void DrawDebugLine();
    void FlushPersistentDebugLines();
    void GetBasedPosition();
    void SetBasedPosition();
    void BP2Vect();
    void Vect2BP();
    void SetForcedInitialReplicatedProperty();
    void eventReplicatedEvent();
    void GetAggregateBaseVelocity();
    void IsOwnedBy();
    void GetBaseMost();
    void IsBasedOn();
    void SearchForBaseBelow();
    void FindBase();
    void SetOwner();
    void SetBase();
    void GetTerminalVelocity();
    void AutonomousPhysics();
    void MoveSmooth();
    void fixedTurn();
    void SetShadowParentOnAllAttachedComponents();
    void SetHardAttach();
    void SetRelativeLocation();
    void SetRelativeRotation();
    void SetZone();
    void MovingWhichWay();
    void SetRotation();
    void SetLocation();
    void Move();
    void SetDrawScale3D();
    void SetDrawScale();
    void SetCollisionType();
    void SetCollisionSize();
    void SetCollision();
    void FinishAnim();
    void Sleep();
    void ConsoleCommand();
    void ForceUpdateComponents();
};

UClass* AActor::pClassPointer = NULL;

// Class Engine.Info
// 0x0000 (0x0244 - 0x0244)
class AInfo : public AActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[127];

        return pClassPointer;
    };
};

UClass* AInfo::pClassPointer = NULL;

// Class Engine.ZoneInfo
// 0x0014 (0x0258 - 0x0244)
class AZoneInfo : public AInfo {
   public:
    float KillZ;                    // 0x0244 (0x0004) [0x0000000000000000]
    float SoftKill;                 // 0x0248 (0x0004) [0x0000000000000000]
    class UClass* KillZDamageType;  // 0x024C (0x0008) [0x0000000000000000]
    DWORD bSoftKillZ : 1;  // 0x0254 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[129];

        return pClassPointer;
    };
};

UClass* AZoneInfo::pClassPointer = NULL;

// Class Engine.WorldInfo
// 0x0A88 (0x0CE0 - 0x0258)
class AWorldInfo : public AZoneInfo {
   public:
    DWORD UseCheckbackMatchmaking : 1;  // 0x0258 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bPersistPostProcessToNextLevel : 1;    // 0x0258 (0x0004)
                                                 // [0x0000000000000000]
                                                 // [0x00000002]
    DWORD bDisableWholeSceneDominantShadow : 1;  // 0x0258 (0x0004)
                                                 // [0x0000000000000000]
                                                 // [0x00000004]
    DWORD bFogEnabled : 1;  // 0x0258 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bBumpOffsetEnabled : 1;   // 0x0258 (0x0004) [0x0000000000000000]
                                    // [0x00000010]
    DWORD bUseGammaCorrection : 1;  // 0x0258 (0x0004) [0x0000000000000000]
                                    // [0x00000020]
    DWORD
        bMapNeedsLightingFullyRebuilt : 1;  // 0x0258 (0x0004)
                                            // [0x0000000000000000] [0x00000040]
    DWORD
        bMapHasMultipleDominantLightsAffectingOnePrimitive : 1;  // 0x0258
                                                                 // (0x0004)
                                                                 // [0x0000000000000000]
                                                                 // [0x00000080]
    DWORD bMapHasPathingErrors : 1;  // 0x0258 (0x0004) [0x0000000000000000]
                                     // [0x00000100]
    DWORD
        bRequestedBlockOnAsyncLoading : 1;  // 0x0258 (0x0004)
                                            // [0x0000000000000000] [0x00000200]
    DWORD bBegunPlay : 1;  // 0x0258 (0x0004) [0x0000000000000000] [0x00000400]
    DWORD
        bPlayersOnly : 1;  // 0x0258 (0x0004) [0x0000000000000000] [0x00000800]
    DWORD bPlayersOnlyPending : 1;  // 0x0258 (0x0004) [0x0000000000000000]
                                    // [0x00001000]
    DWORD bSuspendAI : 1;   // 0x0258 (0x0004) [0x0000000000000000] [0x00002000]
    DWORD bDropDetail : 1;  // 0x0258 (0x0004) [0x0000000000000000] [0x00004000]
    DWORD bAggressiveLOD : 1;  // 0x0258 (0x0004) [0x0000000000000000]
                               // [0x00008000]
    DWORD bStartup : 1;  // 0x0258 (0x0004) [0x0000000000000000] [0x00010000]
    DWORD
        bPathsRebuilt : 1;  // 0x0258 (0x0004) [0x0000000000000000] [0x00020000]
    DWORD
        bHasPathNodes : 1;  // 0x0258 (0x0004) [0x0000000000000000] [0x00040000]
    DWORD
        bIsMenuLevel : 1;  // 0x0258 (0x0004) [0x0000000000000000] [0x00080000]
    DWORD bDebugPauseExecution : 1;  // 0x0258 (0x0004) [0x0000000000000000]
                                     // [0x00100000]
    DWORD bDebugStepExecution : 1;   // 0x0258 (0x0004) [0x0000000000000000]
                                     // [0x00200000]
    DWORD bUseConsoleInput : 1;      // 0x0258 (0x0004) [0x0000000000000000]
                                     // [0x00400000]
    DWORD
        bMapNeedsSplatterMapsRebuilt : 1;  // 0x0258 (0x0004)
                                           // [0x0000000000000000] [0x00800000]
    DWORD bMapNeedsPrecomputedVisibilityRebuilt : 1;  // 0x0258 (0x0004)
                                                      // [0x0000000000000000]
                                                      // [0x01000000]
    DWORD bMinimizeBSPSections : 1;  // 0x0258 (0x0004) [0x0000000000000000]
                                     // [0x02000000]
    DWORD
        bNoDefaultInventoryForPlayer : 1;  // 0x0258 (0x0004)
                                           // [0x0000000000000000] [0x04000000]
    DWORD bNoPathWarnings : 1;       // 0x0258 (0x0004) [0x0000000000000000]
                                     // [0x08000000]
    DWORD bNoMobileMapWarnings : 1;  // 0x0258 (0x0004) [0x0000000000000000]
                                     // [0x10000000]
    DWORD bHighPriorityLoading : 1;  // 0x0258 (0x0004) [0x0000000000150000]
                                     // [0x20000000] ( CPF_Travel |
                                     // CPF_GlobalConfig )
    DWORD bHighPriorityLoadingLocal : 1;  // 0x0258 (0x0004)
                                          // [0x0000000000000000] [0x40000000]
    DWORD bUseProcBuildingRulesetOverride : 1;  // 0x0258 (0x0004)
                                                // [0x0000000000000000]
                                                // [0x80000000]
    DWORD bInteractiveMode : 1;  // 0x025C (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    DWORD
        bSupportDoubleBufferedPhysics : 1;  // 0x025C (0x0004)
                                            // [0x0000000000000000] [0x00000002]
    DWORD bPhysicsIgnoreDeltaTime : 1;  // 0x025C (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    DWORD bEnableChanceOfPhysicsChunkOverride : 1;  // 0x025C (0x0004)
                                                    // [0x0000000000000000]
                                                    // [0x00000008]
    DWORD bLimitExplosionChunkSize : 1;  // 0x025C (0x0004) [0x0000000000000000]
                                         // [0x00000010]
    DWORD bLimitDamageChunkSize : 1;     // 0x025C (0x0004) [0x0000000000000000]
                                         // [0x00000020]
    DWORD bPrecomputeVisibility : 1;     // 0x025C (0x0004) [0x0000000000000000]
                                         // [0x00000040]
    DWORD bPlaceCellsOnSurfaces : 1;     // 0x025C (0x0004) [0x0000000000000000]
                                         // [0x00000080]
    DWORD bPlaceCellsOnOpaqueOnly : 1;   // 0x025C (0x0004) [0x0000000000000000]
                                         // [0x00000100]
    DWORD bCompressVisibilityData : 1;   // 0x025C (0x0004) [0x0000000000000000]
                                         // [0x00000200]
    DWORD bAllowTemporalAA : 1;          // 0x025C (0x0004) [0x0000000000000000]
                                         // [0x00000400]
    DWORD bUseGlobalIllumination : 1;    // 0x025C (0x0004) [0x0000000000000000]
                                         // [0x00000800]
    DWORD bForceNoPrecomputedLighting : 1;  // 0x025C (0x0004)
                                            // [0x0000000000000000] [0x00001000]
    DWORD bHaveActiveCrowd : 1;     // 0x025C (0x0004) [0x0000000000000000]
                                    // [0x00002000]
    DWORD bAllowHostMigration : 1;  // 0x025C (0x0004) [0x0000000000000000]
                                    // [0x00004000]
    DWORD bGameplayFramePause : 1;  // 0x025C (0x0004) [0x0000000000000000]
                                    // [0x00008000]
    DWORD bUsePxVisibilityCollision : 1;  // 0x025C (0x0004)
                                          // [0x0000000000000000] [0x00010000]
    DWORD bAllowExplosionLights : 1;  // 0x025C (0x0004) [0x0000000000000000]
                                      // [0x00020000]
    DWORD bDropHighDetail : 1;        // 0x025C (0x0004) [0x0000000000000000]
                                      // [0x00040000]
    struct FPostProcessSettings
        DefaultPostProcessSettings;  // 0x0260 (0x0220) [0x0000000000000000]
    class UPostProcessChain*
        WorldPostProcessChain;   // 0x0480 (0x0008) [0x0000000000000000]
    float SquintModeKernelSize;  // 0x0488 (0x0004) [0x0000000000000000]
    float LevelShadowDepthBias;  // 0x048C (0x0004) [0x0000000000000000]
    class APostProcessVolume*
        HighestPriorityPostProcessVolume;  // 0x0490 (0x0008)
                                           // [0x0000000000000000]
    struct FReverbSettings
        DefaultReverbSettings;  // 0x0498 (0x0010) [0x0000000000000000]
    struct FInteriorSettings
        DefaultAmbientZoneSettings;  // 0x04A8 (0x0024) [0x0000000000000000]
    float FogStart;                  // 0x04CC (0x0004) [0x0000000000000000]
    float FogEnd;                    // 0x04D0 (0x0004) [0x0000000000000000]
    struct FColor FogColor;          // 0x04D4 (0x0004) [0x0000000000000000]
    float BumpEnd;                   // 0x04D8 (0x0004) [0x0000000000000000]
    class AReverbVolume*
        HighestPriorityReverbVolume;  // 0x04DC (0x0008) [0x0000000000000000]
    TArray<class AMassiveLODOverrideVolume*>
        MassiveLODOverrideVolumes;  // 0x04E4 (0x0010) [0x0000000000000000]
    TArray<class APortalVolume*>
        PortalVolumes;  // 0x04F4 (0x0010) [0x0000000000000000]
    TArray<class AEnvironmentVolume*>
        EnvironmentVolumes;  // 0x0504 (0x0010) [0x0000000000000000]
    TArray<class ULevelStreaming*>
        StreamingLevels;  // 0x0514 (0x0010) [0x0000000000000000]
    struct FDouble
        LastTimeUnbuiltLightingWasEncountered;  // 0x0524 (0x0008)
                                                // [0x0000000000000000]
    class UBookMark* BookMarks[0xA];  // 0x052C (0x0050) [0x0000000000000000]
    class UKismetBookMark*
        KismetBookMarks[0xA];  // 0x057C (0x0050) [0x0000000000000000]
    TArray<class UClipPadEntry*>
        ClipPadEntries;  // 0x05CC (0x0010) [0x0000000000000000]
    float TimeDilation;  // 0x05DC (0x0004) [0x0000000000160000]              (
                         // CPF_EditConst | CPF_GlobalConfig )
    float DemoPlayTimeDilation;  // 0x05E0 (0x0004) [0x0000000000000000]
    float TimeSeconds;           // 0x05E4 (0x0004) [0x0000000000000000]
    float RealTimeSeconds;       // 0x05E8 (0x0004) [0x0000000000000000]
    float AudioTimeSeconds;      // 0x05EC (0x0004) [0x0000000000000000]
    float DeltaSeconds;          // 0x05F0 (0x0004) [0x0000000000000000]
    float PauseDelay;            // 0x05F4 (0x0004) [0x0000000000000000]
    float RealTimeToUnPause;     // 0x05F8 (0x0004) [0x0000000000000000]
    class APlayerReplicationInfo*
        Pauser;  // 0x05FC (0x0008) [0x0000000000170000]              (
                 // CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
    struct FString VisibleGroups;        // 0x0604 (0x0010) [0x0000000000000000]
    struct FString VisibleLayers;        // 0x0614 (0x0010) [0x0000000000000000]
    class UTexture2D* DefaultTexture;    // 0x0624 (0x0008) [0x0000000000000000]
    class UTexture2D* WireframeTexture;  // 0x062C (0x0008) [0x0000000000000000]
    class UTexture2D*
        WhiteSquareTexture;         // 0x0634 (0x0008) [0x0000000000000000]
    class UTexture2D* LargeVertex;  // 0x063C (0x0008) [0x0000000000000000]
    class UTexture2D* BSPVertex;    // 0x0644 (0x0008) [0x0000000000000000]
    TArray<struct FString>
        DeferredExecs;                // 0x064C (0x0010) [0x0000000000000000]
    class AGameReplicationInfo* GRI;  // 0x065C (0x0008) [0x0000000000000000]
    unsigned char NetMode;            // 0x0664 (0x0001) [0x0000000000000000]
    unsigned char NextTravelType;     // 0x0665 (0x0001) [0x0000000000000000]
    unsigned char
        VisibilityAggressiveness;  // 0x0666 (0x0001) [0x0000000000000000]
    unsigned char
        PreferredLightmapType;           // 0x0667 (0x0001) [0x0000000000000000]
    unsigned char LevelLightingQuality;  // 0x0668 (0x0001) [0x0000000000000000]
    struct FString ComputerName;         // 0x066C (0x0010) [0x0000000000000000]
    struct FString EngineVersion;        // 0x067C (0x0010) [0x0000000000000000]
    struct FString MinNetVersion;        // 0x068C (0x0010) [0x0000000000000000]
    class AGameInfo* Game;               // 0x069C (0x0008) [0x0000000000000000]
    float StallZ;                        // 0x06A4 (0x0004) [0x0000000000000000]
    float WorldGravityZ;  // 0x06A8 (0x0004) [0x0000000000180000]              (
                          // CPF_Component )
    float DefaultGravityZ;          // 0x06AC (0x0004) [0x0000000000000000]
    float GlobalGravityZ;           // 0x06B0 (0x0004) [0x0000000000000000]
    float RBPhysicsGravityScaling;  // 0x06B4 (0x0004) [0x0000000000000000]
    class ANavigationPoint*
        NavigationPointList;            // 0x06B8 (0x0008) [0x0000000000000000]
    class AController* ControllerList;  // 0x06C0 (0x0008) [0x0000000000000000]
    class APawn* PawnList;              // 0x06C8 (0x0008) [0x0000000000000000]
    class ACoverLink* CoverList;        // 0x06D0 (0x0008) [0x0000000000000000]
    class APylon* PylonList;            // 0x06D8 (0x0008) [0x0000000000000000]
    float MoveRepSize;                  // 0x06E0 (0x0004) [0x0000000000000000]
    TArray<struct FNetViewer>
        ReplicationViewers;     // 0x06E4 (0x0010) [0x0000000000000000]
    struct FString NextURL;     // 0x06F4 (0x0010) [0x0000000000000000]
    float NextSwitchCountdown;  // 0x0704 (0x0004) [0x0000000000000000]
    int PackedLightAndShadowMapTextureSize;  // 0x0708 (0x0004)
                                             // [0x0000000000000000]
    struct FVector DefaultColorScale;  // 0x070C (0x000C) [0x0000000000000000]
    class UClass* DefaultGameType;     // 0x0718 (0x0008) [0x0000000000000000]
    TArray<class UClass*>
        GameTypesSupportedOnThisMap;  // 0x0720 (0x0010) [0x0000000000000000]
    class UClass* GameTypeForPIE;     // 0x0730 (0x0008) [0x0000000000000000]
    TArray<class UObject*>
        ClientDestroyedActorContent;  // 0x0738 (0x0010) [0x0000000000000000]
    TArray<struct FName>
        PreparingLevelNames;  // 0x0748 (0x0010) [0x0000000000000000]
    struct FName
        CommittedPersistentLevelName;  // 0x0758 (0x0008) [0x0000000000000000]
    class UObjectReferencer*
        PersistentMapForcedObjects;    // 0x0760 (0x0008) [0x0000000000000000]
    class UAudioComponent* MusicComp;  // 0x0768 (0x0008) [0x0000000000000000]
    struct FMusicTrackStruct
        CurrentMusicTrack;  // 0x0770 (0x002C) [0x0000000000000000]
    struct FMusicTrackStruct
        ReplicatedMusicTrack;  // 0x079C (0x002C) [0x0000000000190000] (
                               // CPF_Travel | CPF_Component )
    struct FString Title;       // 0x07C8 (0x0010) [0x0000000000000000]
    struct FString Author;      // 0x07D8 (0x0010) [0x0000000000000000]
    class UMapInfo* MyMapInfo;  // 0x07E8 (0x0008) [0x0000000000000000]
    struct FString
        EmitterPoolClassPath;           // 0x07F0 (0x0010) [0x0000000000000000]
    class AEmitterPool* MyEmitterPool;  // 0x0800 (0x0008) [0x0000000000000000]
    struct FString
        DecalManagerClassPath;  // 0x0808 (0x0010) [0x0000000000000000]
    class ADecalManager*
        MyDecalManager;  // 0x0818 (0x0008) [0x0000000000000000]
    struct FString
        FractureManagerClassPath;  // 0x0820 (0x0010) [0x0000000000000000]
    class AFractureManager*
        MyFractureManager;  // 0x0830 (0x0008) [0x0000000000000000]
    struct FString
        ParticleEventManagerClassPath;  // 0x0838 (0x0010) [0x0000000000000000]
    class AParticleEventManager*
        MyParticleEventManager;  // 0x0848 (0x0008) [0x0000000000000000]
    class UProcBuildingRuleset*
        ProcBuildingRulesetOverride;  // 0x0850 (0x0008) [0x0000000000000000]
    int SkelMeshCompTickTagCount;     // 0x0858 (0x0004) [0x0000000000000000]
    float MaxPhysicsDeltaTime;        // 0x085C (0x0004) [0x0000000000000000]
    int MaxPhysicsSubsteps;           // 0x0860 (0x0004) [0x0000000000000000]
    struct FPhysXSceneProperties
        PhysicsProperties;  // 0x0864 (0x003C) [0x0000000000000000]
    TArray<struct FCompartmentRunList>
        CompartmentRunFrames;     // 0x08A0 (0x0010) [0x0000000000000000]
    float DefaultSkinWidth;       // 0x08B0 (0x0004) [0x0000000000000000]
    float ApexLODResourceBudget;  // 0x08B4 (0x0004) [0x0000000000000000]
    float ApexDestructionLODResourceValue;  // 0x08B8 (0x0004)
                                            // [0x0000000000000000]
    float ApexClothingLODResourceValue;  // 0x08BC (0x0004) [0x0000000000000000]
    struct FApexModuleDestructibleSettings
        DestructibleSettings;  // 0x08C0 (0x0014) [0x0000000000000000]
    class UPhysicsLODVerticalEmitter*
        EmitterVertical;  // 0x08D4 (0x0008) [0x0000000000000000]
    struct FPhysXVerticalProperties
        VerticalProperties;  // 0x08DC (0x0018) [0x0000000000000000]
    TArray<struct FPointer>
        WorldAttractors;                 // 0x08F4 (0x0010) [0x0000000000000000]
    float ChanceOfPhysicsChunkOverride;  // 0x0904 (0x0004) [0x0000000000000000]
    float MaxExplosionChunkSize;         // 0x0908 (0x0004) [0x0000000000000000]
    float MaxDamageChunkSize;            // 0x090C (0x0004) [0x0000000000000000]
    float FractureExplosionVelScale;     // 0x0910 (0x0004) [0x0000000000000000]
    int MaxNumFacturedChunksToSpawnInAFrame;  // 0x0914 (0x0004)
                                              // [0x0000000000000000]
    int NumFacturedChunksSpawnedThisFrame;    // 0x0918 (0x0004)
                                              // [0x0000000000000000]
    float FracturedMeshWeaponDamage;    // 0x091C (0x0004) [0x0000000000000000]
    int VisibilityCellSize;             // 0x0920 (0x0004) [0x0000000000000000]
    int VisibilitySpreadingIterations;  // 0x0924 (0x0004) [0x0000000000000000]
    float MeshBoundsScale;              // 0x0928 (0x0004) [0x0000000000000000]
    float PlayAreaHeight;               // 0x092C (0x0004) [0x0000000000000000]
    int MinMeshSamples;                 // 0x0930 (0x0004) [0x0000000000000000]
    int MaxMeshSamples;                 // 0x0934 (0x0004) [0x0000000000000000]
    int NumCellSamples;                 // 0x0938 (0x0004) [0x0000000000000000]
    int NumImportanceSamples;           // 0x093C (0x0004) [0x0000000000000000]
    int CellRenderingBucketSize;        // 0x0940 (0x0004) [0x0000000000000000]
    int NumCellRenderingBuckets;        // 0x0944 (0x0004) [0x0000000000000000]
    int NumCellDistributionBuckets;     // 0x0948 (0x0004) [0x0000000000000000]
    float
        CharacterLitIndirectBrightness;  // 0x094C (0x0004) [0x0000000000000000]
    float CharacterLitIndirectContrastFactor;       // 0x0950 (0x0004)
                                                    // [0x0000000000000000]
    float CharacterShadowedIndirectBrightness;      // 0x0954 (0x0004)
                                                    // [0x0000000000000000]
    float CharacterShadowedIndirectContrastFactor;  // 0x0958 (0x0004)
                                                    // [0x0000000000000000]
    float CharacterLightingContrastFactor;          // 0x095C (0x0004)
                                                    // [0x0000000000000000]
    class UTexture2D*
        ImageReflectionEnvironmentTexture;  // 0x0960 (0x0008)
                                            // [0x0000000000000000]
    struct FLinearColor
        ImageReflectionEnvironmentColor;       // 0x0968 (0x0010)
                                               // [0x0000000000000000]
    float ImageReflectionEnvironmentRotation;  // 0x0978 (0x0004)
                                               // [0x0000000000000000]
    struct FMap_Mirror ScreenMessages;  // 0x097C (0x0048) [0x0000000000000000]
    TArray<struct FScreenMessageString>
        PriorityScreenMessages;  // 0x09C4 (0x0010) [0x0000000000000000]
    int MaxTrianglesPerLeaf;     // 0x09D4 (0x0004) [0x0000000000000000]
    class ULightmassLevelSettings*
        LMLevelSettings;  // 0x09D8 (0x0008) [0x0000000000000000]
    unsigned char
        UnknownData00[0x48];  // 0x09E0 (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.WorldInfo.LandscapeInfoMap
    struct FLightmassWorldInfoSettings
        LightmassSettings;  // 0x0A28 (0x0058) [0x0000000000000000]
    unsigned char
        UnknownData01[0x48];  // 0x0A80 (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.WorldInfo.NavMeshPathConstraintCache
    unsigned char
        UnknownData02[0x48];  // 0x0AC8 (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.WorldInfo.NavMeshPathGoalEvaluatorCache
    class ACrowdPopulationManagerBase*
        PopulationManager;  // 0x0B10 (0x0008) [0x0000000000000000]
    struct FHostMigrationState
        PeerHostMigration;       // 0x0B18 (0x0020) [0x0000000000000000]
    float HostMigrationTimeout;  // 0x0B38 (0x0004) [0x0000000000000000]
    class APhysicsVolume*
        FirstPhysicsVolume;             // 0x0B3C (0x0008) [0x0000000000000000]
    class AFileWriter* GameBalanceLog;  // 0x0B44 (0x0008) [0x0000000000000000]
    struct FInterpCurveFloat
        FlickerCurve;  // 0x0B4C (0x0014) [0x0000000000000000]
    struct FInterpCurveFloat
        PulseCurve;  // 0x0B60 (0x0014) [0x0000000000000000]
    struct FInterpCurveFloat
        StrobeCurve;  // 0x0B74 (0x0014) [0x0000000000000000]
    struct FInterpCurveFloat
        ChaoticFlickerCurve;  // 0x0B88 (0x0014) [0x0000000000000000]
    struct FInterpCurveFloat
        InverseChaoticFlickerCurve;  // 0x0B9C (0x0014) [0x0000000000000000]
    float FlickerBrightnessLowerBoundClamp;  // 0x0BB0 (0x0004)
                                             // [0x0000000000000000]
    float
        PulseBrightnessLowerBoundClamp;  // 0x0BB4 (0x0004) [0x0000000000000000]
    float StrobeBrightnessLowerBoundClamp;          // 0x0BB8 (0x0004)
                                                    // [0x0000000000000000]
    float ChaoticFlickerBrightnessLowerBoundClamp;  // 0x0BBC (0x0004)
                                                    // [0x0000000000000000]
    float
        InverseChaoticFlickerBrightnessLowerBoundClamp;  // 0x0BC0 (0x0004)
                                                         // [0x0000000000000000]
    TArray<class UMaterialInstanceConstant*>
        ZedTimeMICs;                 // 0x0BC4 (0x0010) [0x0000000000000000]
    float EmitterPoolScale;          // 0x0BD4 (0x0004) [0x0000000000000000]
    float DestructionLifetimeScale;  // 0x0BD8 (0x0004) [0x0000000000000000]
    struct FString
        GameplayPoolManagerClassPath;  // 0x0BDC (0x0010) [0x0000000000000000]
    class AActor*
        MyGameplayPoolManager;  // 0x0BEC (0x0008) [0x0000000000000000]
    struct FString
        ImpactEffectManagerClassPath;  // 0x0BF4 (0x0010) [0x0000000000000000]
    class AActor*
        MyImpactEffectManager;  // 0x0C04 (0x0008) [0x0000000000000000]
    struct FString
        GoreEffectManagerClassPath;     // 0x0C0C (0x0010) [0x0000000000000000]
    class AActor* MyGoreEffectManager;  // 0x0C1C (0x0008) [0x0000000000000000]
    struct FString LightPoolClassPath;  // 0x0C24 (0x0010) [0x0000000000000000]
    class AActor* MyLightPool;          // 0x0C34 (0x0008) [0x0000000000000000]
    struct FString
        TWDeferredWorkManagerClassPath;  // 0x0C3C (0x0010) [0x0000000000000000]
    class AActor* DeferredWorkManager;   // 0x0C4C (0x0008) [0x0000000000000000]
    struct FString
        TurbEffectPoolClassPath;     // 0x0C54 (0x0010) [0x0000000000000000]
    class AActor* MyTurbEffectPool;  // 0x0C64 (0x0008) [0x0000000000000000]
    struct FString
        GroundFireEmitterPoolClassPath;  // 0x0C6C (0x0010) [0x0000000000000000]
    class AEmitterPool*
        GroundFireEmitterPool;  // 0x0C7C (0x0008) [0x0000000000000000]
    struct FString
        ImpactFXEmitterPoolClassPath;  // 0x0C84 (0x0010) [0x0000000000000000]
    class AEmitterPool*
        ImpactFXEmitterPool;  // 0x0C94 (0x0008) [0x0000000000000000]
    int MaxExplosionDecals;   // 0x0C9C (0x0004) [0x0000000000000000]
    class ADecalManager*
        ExplosionDecalManager;  // 0x0CA0 (0x0008) [0x0000000000000000]
    struct FString
        TimerHelperClassPath;   // 0x0CA8 (0x0010) [0x0000000000000000]
    class AActor* TimerHelper;  // 0x0CB8 (0x0008) [0x0000000000000000]
    struct FString
        LastSuccessfulPathBuildTime;  // 0x0CC0 (0x0010) [0x0000000000000000]
    TArray<struct FFlexMeshContactInfo>
        FlexMeshContacts;  // 0x0CD0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[131];

        return pClassPointer;
    };

    void TWPushLogs();
    void TWLogEvent();
    void TWLogsInit();
    void LogGameBalance();
    void GetAkEnvironmentName();
    void GetReverbVolume();
    void ClearObjectPools();
    void ToggleHostMigration();
    void eventNotifyHostMigrationStateChanged();
    void BeginHostMigration();
    void eventCanBeginHostMigration();
    void FindEnvironmentVolume();
    void GetWorldInfo();
    void GetWorldFractureSettings();
    void DoMemoryTracking();
    void GetDemoRewindPoints();
    void GetDemoFrameInfo();
    void IsPlayingDemo();
    void IsRecordingDemo();
    void GetDetailMode();
    void GetMapName();
    void SetMapInfo();
    void GetMapInfo();
    void SetSeamlessTravelMidpointPause();
    void IsInSeamlessTravel();
    void SeamlessTravel();
    void CommitMapChange();
    void CancelPendingMapChange();
    void IsMapChangeReady();
    void IsPreparingMapChange();
    void PrepareMapChange();
    void NotifyMatchStarted();
    void AllClientConnections();
    void AllPawns();
    void AllControllers();
    void NavigationPointCheck();
    void RadiusNavigationPoints();
    void AllNavigationPoints();
    void Reset();
    void PostBeginPlay();
    void PreBeginPlay();
    void ThisIsNeverExecuted();
    void eventServerTravel();
    void GetGameClass();
    void GetAddressURL();
    void VerifyNavList();
    void ForceGarbageCollection();
    void IsPlayInMobilePreview();
    void IsPlayInPreview();
    void IsPlayInEditor();
    void IsWithGFx();
    void GetResolutionBasedHUDScale();
    void IsConsoleBuild();
    void IsNeoCheckerboardRendering();
    void IsE3Build();
    void IsConsoleDedicatedServer();
    void IsDemoBuild();
    void GetLocalURL();
    void SetLevelRBGravity();
    void GetAllRootSequences();
    void GetGameSequence();
    void GetGravityZ();
    void UpdateMusicTrack();
    void SetMusicVolume();
    void IsMenuLevel();
    void AddOnScreenDebugMessage();
    void eventReplicatedEvent();
    void GetNavMeshPathGoalEvaluatorFromCache();
    void GetNavMeshPathConstraintFromCache();
    void ReleaseCachedConstraintsAndEvaluators();
};

UClass* AWorldInfo::pClassPointer = NULL;

// Class Engine.DownloadableContentEnumerator
// 0x0040 (0x00A0 - 0x0060)
class UDownloadableContentEnumerator : public UObject {
   public:
    TArray<struct FOnlineContent>
        DLCBundles;             // 0x0060 (0x0010) [0x0000000000000000]
    struct FString DLCRootDir;  // 0x0070 (0x0010) [0x0000000000000000]
    TArray<struct FScriptDelegate>
        FindDLCDelegates;  // 0x0080 (0x0010) [0x0000000000000000]
    struct FScriptDelegate
        __OnFindDLCComplete__Delegate;  // 0x0090 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x0094 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[133];

        return pClassPointer;
    };

    void TriggerFindDLCDelegates();
    void InstallDLC();
    void InstallAllDLC();
    void DeleteDLC();
    void ClearFindDLCDelegate();
    void AddFindDLCDelegate();
    void OnFindDLCComplete();
    void FindDLC();
};

UClass* UDownloadableContentEnumerator::pClassPointer = NULL;

// Class Engine.DownloadableContentManager
// 0x00B0 (0x0110 - 0x0060)
class UDownloadableContentManager : public UObject {
   public:
    TArray<struct FPointer>
        DLCConfigCacheChanges;  // 0x0060 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        InstalledDLC;  // 0x0070 (0x0010) [0x0000000000000000]
    struct FMap_Mirror
        NonPackageFilePathMap;  // 0x0080 (0x0048) [0x0000000000000000]
    TArray<class UClass*>
        ClassesToReload;  // 0x00C8 (0x0010) [0x0000000000000000]
    TArray<class UObject*>
        ObjectsToReload;  // 0x00D8 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        QueuedFullyLoadPackageInis;  // 0x00E8 (0x0010) [0x0000000000000000]
    class UGameEngine* GameEngine;   // 0x00F8 (0x0008) [0x0000000000000000]
    struct FScriptDelegate
        __OnRefreshComplete__Delegate;  // 0x0100 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x0104 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[135];

        return pClassPointer;
    };

    void OnRefreshComplete();
    void AddPackagesToFullyLoad();
    void RefreshDLCEnumComplete();
    void RefreshDLC();
    void OnContentChange();
    void OnStorageDeviceChange();
    void OnLoginChange();
    void eventInit();
    void InstallNonPackageFiles();
    void InstallPackages();
    void UpdateObjectLists();
    void MarkPerObjectConfigPendingKill();
    void AddSectionToObjectList();
    void GetDLCNonPackageFilePath();
    void ClearDLC();
    void InstallDLCs();
    void InstallDLC();
};

UClass* UDownloadableContentManager::pClassPointer = NULL;

// Class Engine.Engine
// 0x089C (0x0904 - 0x0068)
class UEngine : public USubsystem {
   public:
    class UFont* TinyFont;            // 0x0068 (0x0008) [0x0000000000000000]
    struct FString TinyFontName;      // 0x0070 (0x0010) [0x0000000000000000]
    class UFont* SmallFont;           // 0x0080 (0x0008) [0x0000000000000000]
    struct FString SmallFontName;     // 0x0088 (0x0010) [0x0000000000000000]
    class UFont* MediumFont;          // 0x0098 (0x0008) [0x0000000000000000]
    struct FString MediumFontName;    // 0x00A0 (0x0010) [0x0000000000000000]
    class UFont* LargeFont;           // 0x00B0 (0x0008) [0x0000000000000000]
    struct FString LargeFontName;     // 0x00B8 (0x0010) [0x0000000000000000]
    class UFont* SubtitleFont;        // 0x00C8 (0x0008) [0x0000000000000000]
    struct FString SubtitleFontName;  // 0x00D0 (0x0010) [0x0000000000000000]
    TArray<class UFont*>
        AdditionalFonts;  // 0x00E0 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        AdditionalFontNames;          // 0x00F0 (0x0010) [0x0000000000000000]
    class UClass* ConsoleClass;       // 0x0100 (0x0008) [0x0000000000000000]
    struct FString ConsoleClassName;  // 0x0108 (0x0010) [0x0000000000000000]
    class UClass*
        GameViewportClientClass;  // 0x0118 (0x0008) [0x0000000000000000]
    struct FString
        GameViewportClientClassName;     // 0x0120 (0x0010) [0x0000000000000000]
    class UClass* DataStoreClientClass;  // 0x0130 (0x0008) [0x0000000000000000]
    struct FString
        DataStoreClientClassName;    // 0x0138 (0x0010) [0x0000000000000000]
    class UClass* LocalPlayerClass;  // 0x0148 (0x0008) [0x0000000000000000]
    struct FString
        LocalPlayerClassName;            // 0x0150 (0x0010) [0x0000000000000000]
    class UMaterial* DefaultMaterial;    // 0x0160 (0x0008) [0x0000000000000000]
    struct FString DefaultMaterialName;  // 0x0168 (0x0010) [0x0000000000000000]
    class UMaterial*
        DefaultDecalMaterial;  // 0x0178 (0x0008) [0x0000000000000000]
    struct FString
        DefaultDecalMaterialName;        // 0x0180 (0x0010) [0x0000000000000000]
    class UTexture* DefaultTexture;      // 0x0190 (0x0008) [0x0000000000000000]
    struct FString DefaultTextureName;   // 0x0198 (0x0010) [0x0000000000000000]
    class UMaterial* WireframeMaterial;  // 0x01A8 (0x0008) [0x0000000000000000]
    struct FString
        WireframeMaterialName;  // 0x01B0 (0x0010) [0x0000000000000000]
    class UMaterial*
        EmissiveTexturedMaterial;  // 0x01C0 (0x0008) [0x0000000000000000]
    struct FString
        EmissiveTexturedMaterialName;  // 0x01C8 (0x0010) [0x0000000000000000]
    class UMaterial* GeomMaterial;     // 0x01D8 (0x0008) [0x0000000000000000]
    struct FString GeomMaterialName;   // 0x01E0 (0x0010) [0x0000000000000000]
    class UMaterial*
        DefaultFogVolumeMaterial;  // 0x01F0 (0x0008) [0x0000000000000000]
    struct FString
        DefaultFogVolumeMaterialName;  // 0x01F8 (0x0010) [0x0000000000000000]
    class UMaterial* TickMaterial;     // 0x0208 (0x0008) [0x0000000000000000]
    struct FString TickMaterialName;   // 0x0210 (0x0010) [0x0000000000000000]
    class UMaterial* CrossMaterial;    // 0x0220 (0x0008) [0x0000000000000000]
    struct FString CrossMaterialName;  // 0x0228 (0x0010) [0x0000000000000000]
    class UMaterial*
        LevelColorationLitMaterial;  // 0x0238 (0x0008) [0x0000000000000000]
    struct FString
        LevelColorationLitMaterialName;  // 0x0240 (0x0010) [0x0000000000000000]
    class UMaterial*
        LevelColorationUnlitMaterial;  // 0x0250 (0x0008) [0x0000000000000000]
    struct FString LevelColorationUnlitMaterialName;  // 0x0258 (0x0010)
                                                      // [0x0000000000000000]
    class UMaterial*
        LightingTexelDensityMaterial;  // 0x0268 (0x0008) [0x0000000000000000]
    struct FString
        LightingTexelDensityName;  // 0x0270 (0x0010) [0x0000000000000000]
    class UMaterial* ShadedLevelColorationLitMaterial;  // 0x0280 (0x0008)
                                                        // [0x0000000000000000]
    struct FString
        ShadedLevelColorationLitMaterialName;  // 0x0288 (0x0010)
                                               // [0x0000000000000000]
    class UMaterial*
        ShadedLevelColorationUnlitMaterial;  // 0x0298 (0x0008)
                                             // [0x0000000000000000]
    struct FString
        ShadedLevelColorationUnlitMaterialName;  // 0x02A0 (0x0010)
                                                 // [0x0000000000000000]
    class UMaterial*
        RemoveSurfaceMaterial;  // 0x02B0 (0x0008) [0x0000000000000000]
    struct FString
        RemoveSurfaceMaterialName;  // 0x02B8 (0x0010) [0x0000000000000000]
    class UMaterial*
        VertexColorMaterial;  // 0x02C8 (0x0008) [0x0000000000000000]
    struct FString
        VertexColorMaterialName;  // 0x02D0 (0x0010) [0x0000000000000000]
    class UMaterial*
        VertexColorViewModeMaterial_ColorOnly;  // 0x02E0 (0x0008)
                                                // [0x0000000000000000]
    struct FString
        VertexColorViewModeMaterialName_ColorOnly;  // 0x02E8 (0x0010)
                                                    // [0x0000000000000000]
    class UMaterial*
        VertexColorViewModeMaterial_AlphaAsColor;  // 0x02F8 (0x0008)
                                                   // [0x0000000000000000]
    struct FString
        VertexColorViewModeMaterialName_AlphaAsColor;  // 0x0300 (0x0010)
                                                       // [0x0000000000000000]
    class UMaterial*
        VertexColorViewModeMaterial_RedOnly;  // 0x0310 (0x0008)
                                              // [0x0000000000000000]
    struct FString
        VertexColorViewModeMaterialName_RedOnly;  // 0x0318 (0x0010)
                                                  // [0x0000000000000000]
    class UMaterial*
        VertexColorViewModeMaterial_GreenOnly;  // 0x0328 (0x0008)
                                                // [0x0000000000000000]
    struct FString
        VertexColorViewModeMaterialName_GreenOnly;  // 0x0330 (0x0010)
                                                    // [0x0000000000000000]
    class UMaterial*
        VertexColorViewModeMaterial_BlueOnly;  // 0x0340 (0x0008)
                                               // [0x0000000000000000]
    struct FString
        VertexColorViewModeMaterialName_BlueOnly;  // 0x0348 (0x0010)
                                                   // [0x0000000000000000]
    class UMaterial* HeatmapMaterial;    // 0x0358 (0x0008) [0x0000000000000000]
    struct FString HeatmapMaterialName;  // 0x0360 (0x0010) [0x0000000000000000]
    class UMaterial*
        BoneWeightMaterial;  // 0x0370 (0x0008) [0x0000000000000000]
    struct FString
        BoneWeightMaterialName;  // 0x0378 (0x0010) [0x0000000000000000]
    class UMaterial*
        TangentColorMaterial;  // 0x0388 (0x0008) [0x0000000000000000]
    struct FString
        TangentColorMaterialName;  // 0x0390 (0x0010) [0x0000000000000000]
    class UMaterial*
        MobileEmulationMasterMaterial;  // 0x03A0 (0x0008) [0x0000000000000000]
    struct FString MobileEmulationMasterMaterialName;  // 0x03A8 (0x0010)
                                                       // [0x0000000000000000]
    class UMaterial*
        ProcBuildingSimpleMaterial;  // 0x03B8 (0x0008) [0x0000000000000000]
    struct FString
        ProcBuildingSimpleMaterialName;  // 0x03C0 (0x0010) [0x0000000000000000]
    class UStaticMesh*
        BuildingQuadStaticMesh;  // 0x03D0 (0x0008) [0x0000000000000000]
    struct FString
        BuildingQuadStaticMeshName;  // 0x03D8 (0x0010) [0x0000000000000000]
    float ProcBuildingLODColorTexelsPerWorldUnit;      // 0x03E8 (0x0004)
                                                       // [0x0000000000000000]
    float ProcBuildingLODLightingTexelsPerWorldUnit;   // 0x03EC (0x0004)
                                                       // [0x0000000000000000]
    int MaxProcBuildingLODColorTextureSize;            // 0x03F0 (0x0004)
                                                       // [0x0000000000000000]
    int MaxProcBuildingLODLightingTextureSize;         // 0x03F4 (0x0004)
                                                       // [0x0000000000000000]
    DWORD UseProcBuildingLODTextureCropping : 1;       // 0x03F8 (0x0004)
                                                       // [0x0000000000000000]
                                                       // [0x00000001]
    DWORD ForcePowerOfTwoProcBuildingLODTextures : 1;  // 0x03F8 (0x0004)
                                                       // [0x0000000000000000]
                                                       // [0x00000002]
    DWORD bCombineSimilarMappings : 1;  // 0x03F8 (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    DWORD bRenderLightMapDensityGrayscale : 1;  // 0x03F8 (0x0004)
                                                // [0x0000000000000000]
                                                // [0x00000008]
    DWORD bScreenshotRequested : 1;  // 0x03F8 (0x0004) [0x0000000000000000]
                                     // [0x00000010]
    DWORD bUseSound : 1;  // 0x03F8 (0x0004) [0x0000000000000000] [0x00000020]
    DWORD
        bUseBackgroundLevelStreaming : 1;  // 0x03F8 (0x0004)
                                           // [0x0000000000000000] [0x00000040]
    DWORD bSubtitlesEnabled : 1;    // 0x03F8 (0x0004) [0x0000000000000000]
                                    // [0x00000080]
    DWORD bSubtitlesForcedOff : 1;  // 0x03F8 (0x0004) [0x0000000000000000]
                                    // [0x00000100]
    DWORD bSmoothFrameRate : 1;     // 0x03F8 (0x0004) [0x0000000000000000]
                                    // [0x00000200]
    DWORD bCheckForMultiplePawnsSpawnedInAFrame : 1;  // 0x03F8 (0x0004)
                                                      // [0x0000000000000000]
                                                      // [0x00000400]
    DWORD bShouldGenerateSimpleLightmaps : 1;         // 0x03F8 (0x0004)
                                                      // [0x0000000000000000]
                                                      // [0x00000800]
    DWORD bForceStaticTerrain : 1;      // 0x03F8 (0x0004) [0x0000000000000000]
                                        // [0x00001000]
    DWORD bForceCPUSkinning : 1;        // 0x03F8 (0x0004) [0x0000000000000000]
                                        // [0x00002000]
    DWORD bUsePostProcessEffects : 1;   // 0x03F8 (0x0004) [0x0000000000000000]
                                        // [0x00004000]
    DWORD bOnScreenKismetWarnings : 1;  // 0x03F8 (0x0004) [0x0000000000000000]
                                        // [0x00008000]
    DWORD bEnableKismetLogging : 1;     // 0x03F8 (0x0004) [0x0000000000000000]
                                        // [0x00010000]
    DWORD bAllowMatureLanguage : 1;     // 0x03F8 (0x0004) [0x0000000000000000]
                                        // [0x00020000]
    DWORD
        bDisablePhysXHardwareSupport : 1;  // 0x03F8 (0x0004)
                                           // [0x0000000000000000] [0x00040000]
    DWORD bPauseOnLossOfFocus : 1;       // 0x03F8 (0x0004) [0x0000000000000000]
                                         // [0x00080000]
    DWORD bCheckParticleRenderSize : 1;  // 0x03F8 (0x0004) [0x0000000000000000]
                                         // [0x00100000]
    DWORD bEnableColorClear : 1;         // 0x03F8 (0x0004) [0x0000000000000000]
                                         // [0x00200000]
    DWORD bAreConstraintsDirty : 1;      // 0x03F8 (0x0004) [0x0000000000000000]
                                         // [0x00400000]
    DWORD bHasPendingGlobalReattach : 1;  // 0x03F8 (0x0004)
                                          // [0x0000000000000000] [0x00800000]
    DWORD
        bEnableOnScreenDebugMessages : 1;  // 0x03F8 (0x0004)
                                           // [0x0000000000000000] [0x01000000]
    DWORD bEnableOnScreenDebugMessagesDisplay : 1;  // 0x03F8 (0x0004)
                                                    // [0x0000000000000000]
                                                    // [0x02000000]
    DWORD bSuppressMapWarnings : 1;  // 0x03F8 (0x0004) [0x0000000000000000]
                                     // [0x04000000]
    DWORD bCookSeparateSharedMPGameContent : 1;  // 0x03F8 (0x0004)
                                                 // [0x0000000000000000]
                                                 // [0x08000000]
    DWORD bUseRecastNavMesh : 1;  // 0x03F8 (0x0004) [0x0000000000000000]
                                  // [0x10000000]
    DWORD bDisableAILogging : 1;  // 0x03F8 (0x0004) [0x0000000000000000]
                                  // [0x20000000]
    DWORD bUseNormalMapsForSimpleLightMaps : 1;  // 0x03F8 (0x0004)
                                                 // [0x0000000000000000]
                                                 // [0x40000000]
    DWORD bStartWithMatineeCapture : 1;  // 0x03F8 (0x0004) [0x0000000000000000]
                                         // [0x80000000]
    DWORD bCompressMatineeCapture : 1;   // 0x03FC (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bLockReadOnlyLevels : 1;       // 0x03FC (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    float MaxRMSDForCombiningMappings;   // 0x0400 (0x0004) [0x0000000000000000]
    int ImageReflectionTextureSize;      // 0x0404 (0x0004) [0x0000000000000000]
    struct FLinearColor
        LightingOnlyBrightness;  // 0x0408 (0x0010) [0x0000000000000000]
    TArray<struct FColor>
        LightComplexityColors;  // 0x0418 (0x0010) [0x0000000000000000]
    TArray<struct FLinearColor>
        ShaderComplexityColors;  // 0x0428 (0x0010) [0x0000000000000000]
    float MaxPixelShaderAdditiveComplexityCount;  // 0x0438 (0x0004)
                                                  // [0x0000000000000000]
    float MinTextureDensity;     // 0x043C (0x0004) [0x0000000000000000]
    float IdealTextureDensity;   // 0x0440 (0x0004) [0x0000000000000000]
    float MaxTextureDensity;     // 0x0444 (0x0004) [0x0000000000000000]
    float MinLightMapDensity;    // 0x0448 (0x0004) [0x0000000000000000]
    float IdealLightMapDensity;  // 0x044C (0x0004) [0x0000000000000000]
    float MaxLightMapDensity;    // 0x0450 (0x0004) [0x0000000000000000]
    float RenderLightMapDensityGrayscaleScale;  // 0x0454 (0x0004)
                                                // [0x0000000000000000]
    float RenderLightMapDensityColorScale;      // 0x0458 (0x0004)
                                                // [0x0000000000000000]
    struct FLinearColor
        LightMapDensityVertexMappedColor;  // 0x045C (0x0010)
                                           // [0x0000000000000000]
    struct FLinearColor
        LightMapDensitySelectedColor;  // 0x046C (0x0010) [0x0000000000000000]
    TArray<struct FStatColorMapping>
        StatColorMappings;  // 0x047C (0x0010) [0x0000000000000000]
    class UMaterial*
        EditorBrushMaterial;  // 0x048C (0x0008) [0x0000000000000000]
    struct FString
        EditorBrushMaterialName;  // 0x0494 (0x0010) [0x0000000000000000]
    class UPhysicalMaterial*
        DefaultPhysMaterial;  // 0x04A4 (0x0008) [0x0000000000000000]
    struct FString
        DefaultPhysMaterialName;  // 0x04AC (0x0010) [0x0000000000000000]
    class UPhysicalMaterial*
        LandscapeHolePhysMaterial;  // 0x04BC (0x0008) [0x0000000000000000]
    struct FString
        LandscapeHolePhysMaterialName;  // 0x04C4 (0x0010) [0x0000000000000000]
    class UApexDestructibleDamageParameters*
        ApexDamageParams;  // 0x04D4 (0x0008) [0x0000000000000000]
    struct FString
        ApexDamageParamsName;  // 0x04DC (0x0010) [0x0000000000000000]
    class UMaterial*
        TerrainErrorMaterial;  // 0x04EC (0x0008) [0x0000000000000000]
    struct FString
        TerrainErrorMaterialName;        // 0x04F4 (0x0010) [0x0000000000000000]
    int TerrainMaterialMaxTextureCount;  // 0x0504 (0x0004) [0x0000000000000000]
    int TerrainTessellationCheckCount;   // 0x0508 (0x0004) [0x0000000000000000]
    float TerrainTessellationCheckDistance;  // 0x050C (0x0004)
                                             // [0x0000000000000000]
    class UClass* OnlineSubsystemClass;  // 0x0510 (0x0008) [0x0000000000000000]
    struct FString
        DefaultOnlineSubsystemName;  // 0x0518 (0x0010) [0x0000000000000000]
    class UPostProcessChain*
        DefaultPostProcess;  // 0x0528 (0x0008) [0x0000000000000000]
    struct FString
        DefaultPostProcessName;  // 0x0530 (0x0010) [0x0000000000000000]
    class UPostProcessChain*
        ThumbnailSkeletalMeshPostProcess;  // 0x0540 (0x0008)
                                           // [0x0000000000000000]
    struct FString
        ThumbnailSkeletalMeshPostProcessName;  // 0x0548 (0x0010)
                                               // [0x0000000000000000]
    class UPostProcessChain*
        ThumbnailParticleSystemPostProcess;  // 0x0558 (0x0008)
                                             // [0x0000000000000000]
    struct FString
        ThumbnailParticleSystemPostProcessName;  // 0x0560 (0x0010)
                                                 // [0x0000000000000000]
    class UPostProcessChain*
        ThumbnailMaterialPostProcess;  // 0x0570 (0x0008) [0x0000000000000000]
    struct FString ThumbnailMaterialPostProcessName;  // 0x0578 (0x0010)
                                                      // [0x0000000000000000]
    class UPostProcessChain*
        DefaultUIScenePostProcess;  // 0x0588 (0x0008) [0x0000000000000000]
    struct FString
        DefaultUIScenePostProcessName;  // 0x0590 (0x0010) [0x0000000000000000]
    class UMaterial*
        DefaultUICaretMaterial;  // 0x05A0 (0x0008) [0x0000000000000000]
    struct FString
        DefaultUICaretMaterialName;  // 0x05A8 (0x0010) [0x0000000000000000]
    class UMaterial* SceneCaptureReflectActorMaterial;  // 0x05B8 (0x0008)
                                                        // [0x0000000000000000]
    struct FString
        SceneCaptureReflectActorMaterialName;  // 0x05C0 (0x0010)
                                               // [0x0000000000000000]
    class UMaterial*
        SceneCaptureCubeActorMaterial;  // 0x05D0 (0x0008) [0x0000000000000000]
    struct FString SceneCaptureCubeActorMaterialName;  // 0x05D8 (0x0010)
                                                       // [0x0000000000000000]
    class UTexture2D*
        ScreenDoorNoiseTexture;  // 0x05E8 (0x0008) [0x0000000000000000]
    struct FString
        ScreenDoorNoiseTextureName;  // 0x05F0 (0x0010) [0x0000000000000000]
    class UTexture2D*
        ImageGrainNoiseTexture;  // 0x0600 (0x0008) [0x0000000000000000]
    struct FString
        ImageGrainNoiseTextureName;  // 0x0608 (0x0010) [0x0000000000000000]
    class UTexture2D*
        RandomAngleTexture;  // 0x0618 (0x0008) [0x0000000000000000]
    struct FString
        RandomAngleTextureName;  // 0x0620 (0x0010) [0x0000000000000000]
    class UTexture2D*
        RandomNormalTexture;  // 0x0630 (0x0008) [0x0000000000000000]
    struct FString
        RandomNormalTextureName;  // 0x0638 (0x0010) [0x0000000000000000]
    class UTexture2D*
        RandomMirrorDiscTexture;  // 0x0648 (0x0008) [0x0000000000000000]
    struct FString
        RandomMirrorDiscTextureName;  // 0x0650 (0x0010) [0x0000000000000000]
    class UTexture*
        WeightMapPlaceholderTexture;  // 0x0660 (0x0008) [0x0000000000000000]
    struct FString WeightMapPlaceholderTextureName;  // 0x0668 (0x0010)
                                                     // [0x0000000000000000]
    class UTexture2D*
        LightMapDensityTexture;  // 0x0678 (0x0008) [0x0000000000000000]
    struct FString
        LightMapDensityTextureName;  // 0x0680 (0x0010) [0x0000000000000000]
    class UTexture2D*
        LightMapDensityNormal;  // 0x0690 (0x0008) [0x0000000000000000]
    struct FString
        LightMapDensityNormalName;  // 0x0698 (0x0010) [0x0000000000000000]
    class UTexture2D*
        SplatterMapDensityTexture;  // 0x06A8 (0x0008) [0x0000000000000000]
    struct FString
        SplatterMapDensityTextureName;  // 0x06B0 (0x0010) [0x0000000000000000]
    class UTexture2D*
        PersistentBloodMasterTexture;  // 0x06C0 (0x0008) [0x0000000000000000]
    struct FString PersistentBloodMasterTextureName;  // 0x06C8 (0x0010)
                                                      // [0x0000000000000000]
    class UTexture2D* DitherTexture;     // 0x06D8 (0x0008) [0x0000000000000000]
    struct FString DitherTextureName;    // 0x06E0 (0x0010) [0x0000000000000000]
    class USoundNodeWave* DefaultSound;  // 0x06F0 (0x0008) [0x0000000000000000]
    struct FString DefaultSoundName;     // 0x06F8 (0x0010) [0x0000000000000000]
    float TimeBetweenPurgingPendingKillObjects;  // 0x0708 (0x0004)
                                                 // [0x0000000000000000]
    class UClient* Client;  // 0x070C (0x0008) [0x0000000000000000]
    TArray<class ULocalPlayer*>
        GamePlayers;  // 0x0714 (0x0010) [0x0000000000000000]
    class UGameViewportClient*
        GameViewport;  // 0x0724 (0x0008) [0x0000000000000000]
    TArray<struct FString>
        DeferredCommands;        // 0x072C (0x0010) [0x0000000000000000]
    int TickCycles;              // 0x073C (0x0004) [0x0000000000000000]
    int GameCycles;              // 0x0740 (0x0004) [0x0000000000000000]
    int ClientCycles;            // 0x0744 (0x0004) [0x0000000000000000]
    float MaxSmoothedFrameRate;  // 0x0748 (0x0004) [0x0000000000000000]
    float MinSmoothedFrameRate;  // 0x074C (0x0004) [0x0000000000000000]
    int NumPawnsAllowedToBeSpawnedInAFrame;  // 0x0750 (0x0004)
                                             // [0x0000000000000000]
    struct FPointer RemoteControlExec;  // 0x0754 (0x0008) [0x0000000000000000]
    struct FPointer
        MobileMaterialEmulator;       // 0x075C (0x0008) [0x0000000000000000]
    struct FColor C_WorldBox;         // 0x0764 (0x0004) [0x0000000000000000]
    struct FColor C_BrushWire;        // 0x0768 (0x0004) [0x0000000000000000]
    struct FColor C_AddWire;          // 0x076C (0x0004) [0x0000000000000000]
    struct FColor C_SubtractWire;     // 0x0770 (0x0004) [0x0000000000000000]
    struct FColor C_SemiSolidWire;    // 0x0774 (0x0004) [0x0000000000000000]
    struct FColor C_NonSolidWire;     // 0x0778 (0x0004) [0x0000000000000000]
    struct FColor C_WireBackground;   // 0x077C (0x0004) [0x0000000000000000]
    struct FColor C_ScaleBoxHi;       // 0x0780 (0x0004) [0x0000000000000000]
    struct FColor C_VolumeCollision;  // 0x0784 (0x0004) [0x0000000000000000]
    struct FColor C_BSPCollision;     // 0x0788 (0x0004) [0x0000000000000000]
    struct FColor C_OrthoBackground;  // 0x078C (0x0004) [0x0000000000000000]
    struct FColor C_Volume;           // 0x0790 (0x0004) [0x0000000000000000]
    struct FColor C_BrushShape;       // 0x0794 (0x0004) [0x0000000000000000]
    float StreamingDistanceFactor;    // 0x0798 (0x0004) [0x0000000000000000]
    struct FString ScoutClassName;    // 0x079C (0x0010) [0x0000000000000000]
    unsigned char TransitionType;     // 0x07AC (0x0001) [0x0000000000000000]
    struct FString
        TransitionDescription;           // 0x07B0 (0x0010) [0x0000000000000000]
    struct FString TransitionGameType;   // 0x07C0 (0x0010) [0x0000000000000000]
    float MeshLODRange;                  // 0x07D0 (0x0004) [0x0000000000000000]
    float CameraRotationThreshold;       // 0x07D4 (0x0004) [0x0000000000000000]
    float CameraTranslationThreshold;    // 0x07D8 (0x0004) [0x0000000000000000]
    float PrimitiveProbablyVisibleTime;  // 0x07DC (0x0004) [0x0000000000000000]
    float LightProbablyVisibleTime;      // 0x07E0 (0x0004) [0x0000000000000000]
    float PercentUnoccludedRequeries;    // 0x07E4 (0x0004) [0x0000000000000000]
    float MaxOcclusionPixelsFraction;    // 0x07E8 (0x0004) [0x0000000000000000]
    int PhysXLevel;                      // 0x07EC (0x0004) [0x0000000000000000]
    int MaxFluidNumVerts;                // 0x07F0 (0x0004) [0x0000000000000000]
    float FluidSimulationTimeLimit;      // 0x07F4 (0x0004) [0x0000000000000000]
    int MaxParticleResize;               // 0x07F8 (0x0004) [0x0000000000000000]
    int MaxParticleResizeWarn;           // 0x07FC (0x0004) [0x0000000000000000]
    int MaxParticleVertexMemory;         // 0x0800 (0x0004) [0x0000000000000000]
    int MaxParticleSpriteCount;          // 0x0804 (0x0004) [0x0000000000000000]
    int MaxParticleSubUVCount;           // 0x0808 (0x0004) [0x0000000000000000]
    int BeginUPTryCount;                 // 0x080C (0x0004) [0x0000000000000000]
    TArray<struct FDropNoteInfo>
        PendingDroppedNotes;  // 0x0810 (0x0010) [0x0000000000000000]
    struct FString
        DynamicCoverMeshComponentName;   // 0x0820 (0x0010) [0x0000000000000000]
    float NetClientTicksPerSecond;       // 0x0830 (0x0004) [0x0000000000000000]
    float MaxTrackedOcclusionIncrement;  // 0x0834 (0x0004) [0x0000000000000000]
    float TrackedOcclusionStepSize;      // 0x0838 (0x0004) [0x0000000000000000]
    struct FLinearColor
        DefaultSelectedMaterialColor;  // 0x083C (0x0010) [0x0000000000000000]
    struct FLinearColor
        DefaultHoveredMaterialColor;  // 0x084C (0x0010) [0x0000000000000000]
    struct FLinearColor
        SelectedMaterialColor;  // 0x085C (0x0010) [0x0000000000000000]
    struct FLinearColor
        UnselectedMaterialColor;  // 0x086C (0x0010) [0x0000000000000000]
    TArray<struct FName>
        IgnoreSimulatedFuncWarnings;  // 0x087C (0x0010) [0x0000000000000000]
    struct FString
        AISubsystemClassName;           // 0x088C (0x0010) [0x0000000000000000]
    class UAISubsystem* AISys;          // 0x089C (0x0008) [0x0000000000000000]
    int ScreenSaverInhibitorSemaphore;  // 0x08A4 (0x0004) [0x0000000000000000]
    struct FPointer
        ScreenSaverInhibitor;  // 0x08A8 (0x0008) [0x0000000000000000]
    class UTranslationContext*
        GlobalTranslationContext;  // 0x08B0 (0x0008) [0x0000000000000000]
    struct FDouble
        LoadingMovieStartTime;          // 0x08B8 (0x0008) [0x0000000000000000]
    struct FString MatineeCaptureName;  // 0x08C0 (0x0010) [0x0000000000000000]
    struct FString
        MatineePackageCaptureName;  // 0x08D0 (0x0010) [0x0000000000000000]
    struct FString
        VisibleLevelsForMatineeCapture;  // 0x08E0 (0x0010) [0x0000000000000000]
    int MatineeCaptureFPS;               // 0x08F0 (0x0004) [0x0000000000000000]
    int MatineeCaptureType;              // 0x08F4 (0x0004) [0x0000000000000000]
    class UNetDriver* QueryNetDriver;    // 0x08F8 (0x0008) [0x0000000000000000]
    float SafeFrameScale;                // 0x0900 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[137];

        return pClassPointer;
    };

    void GetSystemSettingFloat();
    void GetSystemSettingInt();
    void GetSystemSettingBool();
    void GetPhysXLevel();
    void LaunchURL();
    void BasicLoadObject();
    void BasicSaveObject();
    void AddTextureStreamingSlaveLoc();
    void GetWorldPostProcessChain();
    void GetDefaultPostProcessChain();
    void GetEngine();
    void IsRealDStereoEnabled();
    void AddOverlayWrapped();
    void AddOverlay();
    void RemoveAllOverlays();
    void StopMovie();
    void PlayLoadMapMovie();
    void GetLastMovieName();
    void GetAISubsystem();
    void GetAudioDevice();
    void IsUsingES2Renderer();
    void IsStereoscopic3D();
    void IsSplitScreen();
    void GetAdditionalFont();
    void GetSubtitleFont();
    void GetLargeFont();
    void GetMediumFont();
    void GetSmallFont();
    void GetTinyFont();
    void HasNetworkConnection();
    void BuildBugSubmissionString();
    void GetDevicePushNotificationToken();
    void GetTitleSafeArea();
    void GetOSVersion();
    void GetDeviceUUID();
    void GetBuildDate();
    void GetCurrentWorldInfo();
    void IsGame();
    void IsEditor();
};

UClass* UEngine::pClassPointer = NULL;

// Class Engine.GameEngine
// 0x024C (0x0B50 - 0x0904)
class UGameEngine : public UEngine {
   public:
    class UPendingLevel* GPendingLevel;  // 0x0904 (0x0008) [0x0000000000000000]
    struct FString
        PendingLevelPlayerControllerClassName;  // 0x090C (0x0010)
                                                // [0x0000000000000000]
    struct FURL LastURL;        // 0x091C (0x0068) [0x0000000000000000]
    struct FURL LastRemoteURL;  // 0x0984 (0x0068) [0x0000000000000000]
    TArray<struct FString>
        ServerActors;          // 0x09EC (0x0010) [0x0000000000000000]
    struct FString TravelURL;  // 0x09FC (0x0010) [0x0000000000000000]
    unsigned char TravelType;  // 0x0A0C (0x0001) [0x0000000000000000]
    struct FString
        ClientOptionsForTakeoverURL;    // 0x0A10 (0x0010) [0x0000000000000000]
    struct FString TakeoverURL;         // 0x0A20 (0x0010) [0x0000000000000000]
    DWORD bUsedForTakeover : 1;         // 0x0A30 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bAvailableForTakeover : 1;    // 0x0A30 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bPrivateServer : 1;           // 0x0A30 (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    DWORD bWorldWasLoadedThisTick : 1;  // 0x0A30 (0x0004) [0x0000000000000000]
                                        // [0x00000008]
    DWORD bCheckForMovieCapture : 1;    // 0x0A30 (0x0004) [0x0000000000000000]
                                        // [0x00000010]
    DWORD bTriggerPostLoadMap : 1;      // 0x0A30 (0x0004) [0x0000000000000000]
                                        // [0x00000020]
    DWORD bStartedLoadMapMovie : 1;     // 0x0A30 (0x0004) [0x0000000000000000]
                                        // [0x00000040]
    DWORD bSaveBenchmarkGraphs : 1;     // 0x0A30 (0x0004) [0x0000000000000000]
                                        // [0x00000080]
    DWORD
        bShouldCommitPendingMapChange : 1;  // 0x0A30 (0x0004)
                                            // [0x0000000000000000] [0x00000100]
    DWORD bClearAnimSetLinkupCachesOnLoadMap : 1;  // 0x0A30 (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00000200]
    DWORD bEnableSecondaryDisplay : 1;   // 0x0A30 (0x0004) [0x0000000000000000]
                                         // [0x00000400]
    DWORD bEnableSecondaryViewport : 1;  // 0x0A30 (0x0004) [0x0000000000000000]
                                         // [0x00000800]
    DWORD
        bTrialActive : 1;  // 0x0A30 (0x0004) [0x0000000000000000] [0x00001000]
    class UOnlineSubsystem*
        OnlineSubsystem;  // 0x0A34 (0x0008) [0x0000000000000000]
    class UPlayfabInterface*
        PlayfabInterfaceInst;  // 0x0A3C (0x0008) [0x0000000000000000]
    class UGamePadLightbarSubsystem*
        GamePadLightbarSubsystem;  // 0x0A44 (0x0008) [0x0000000000000000]
    class UDownloadableContentEnumerator*
        DLCEnumerator;  // 0x0A4C (0x0008) [0x0000000000000000]
    struct FString
        DownloadableContentEnumeratorClassName;  // 0x0A54 (0x0010)
                                                 // [0x0000000000000000]
    class UDownloadableContentManager*
        DLCManager;  // 0x0A64 (0x0008) [0x0000000000000000]
    TArray<struct FBenchmarkSample>
        BenchmarkSamples;  // 0x0A6C (0x0010) [0x0000000000000000]
    struct FString DownloadableContentManagerClassName;  // 0x0A7C (0x0010)
                                                         // [0x0000000000000000]
    TArray<struct FName>
        LevelsToLoadForPendingMapChange;  // 0x0A8C (0x0010)
                                          // [0x0000000000000000]
    TArray<class ULevel*>
        LoadedLevelsForPendingMapChange;                // 0x0A9C (0x0010)
                                                        // [0x0000000000000000]
    struct FString PendingMapChangeFailureDescription;  // 0x0AAC (0x0010)
                                                        // [0x0000000000000000]
    float MaxDeltaTime;  // 0x0ABC (0x0004) [0x0000000000000000]
    struct FString SecondaryViewportClientClassName;  // 0x0AC0 (0x0010)
                                                      // [0x0000000000000000]
    TArray<class UScriptViewportClient*>
        SecondaryViewportClients;  // 0x0AD0 (0x0010) [0x0000000000000000]
    TArray<struct FPointer>
        SecondaryViewportFrames;  // 0x0AE0 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        IgnoredUsesGUIDPackages;  // 0x0AF0 (0x0010) [0x0000000000000000]
    TArray<struct FLevelStreamingStatus>
        PendingLevelStreamingStatusUpdates;  // 0x0B00 (0x0010)
                                             // [0x0000000000000000]
    TArray<class UObjectReferencer*>
        ObjectReferencers;  // 0x0B10 (0x0010) [0x0000000000000000]
    TArray<struct FFullyLoadedPackagesInfo>
        PackagesToFullyLoad;  // 0x0B20 (0x0010) [0x0000000000000000]
    TArray<struct FNamedNetDriver>
        NamedNetDrivers;               // 0x0B30 (0x0010) [0x0000000000000000]
    TArray<struct FAnimTag> AnimTags;  // 0x0B40 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[139];

        return pClassPointer;
    };

    void GetChunkInstallProgress();
    void GetChunksInstallProgress();
    void AreChunksInstalled();
    void IsGameFullyInstalled();
    void GetPercentageOfStreamingInstallComplete();
    void DecodeURLString();
    void EncodeURLString();
    void DisableServerTakeover();
    void GetWebAdminPort();
    void TakeoverServer();
    void HasSecondaryScreenActive();
    void GetDLCManager();
    void GetDLCEnumerator();
    void GetPlayfabInterface();
    void GetOnlineSubsystem();
    void DestroyNamedNetDriver();
    void CreateNamedNetDriver();
};

UClass* UGameEngine::pClassPointer = NULL;

// Class Engine.EngineBaseTypes
// 0x0000 (0x0060 - 0x0060)
class UEngineBaseTypes : public UObject {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[141];

        return pClassPointer;
    };
};

UClass* UEngineBaseTypes::pClassPointer = NULL;

// Class Engine.Brush
// 0x0030 (0x0274 - 0x0244)
class ABrush : public AActor {
   public:
    unsigned char CsgOper;     // 0x0244 (0x0001) [0x0000000000000000]
    struct FColor BrushColor;  // 0x0248 (0x0004) [0x0000000000000000]
    int PolyFlags;             // 0x024C (0x0004) [0x0000000000000000]
    DWORD bColored : 1;  // 0x0250 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bSolidWhenSelected : 1;  // 0x0250 (0x0004) [0x0000000000000000]
                                   // [0x00000002]
    DWORD bPlaceableFromClassBrowser : 1;  // 0x0250 (0x0004)
                                           // [0x0000000000000000] [0x00000004]
    class UModel* Brush;  // 0x0254 (0x0008) [0x0000000000000000]
    class UBrushComponent*
        BrushComponent;  // 0x025C (0x0008) [0x0000000000000000]
    TArray<struct FGeomSelection>
        SavedSelections;  // 0x0264 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[143];

        return pClassPointer;
    };
};

UClass* ABrush::pClassPointer = NULL;

// Class Engine.BrushShape
// 0x0000 (0x0274 - 0x0274)
class ABrushShape : public ABrush {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[145];

        return pClassPointer;
    };
};

UClass* ABrushShape::pClassPointer = NULL;

// Class Engine.Volume
// 0x000C (0x0280 - 0x0274)
class AVolume : public ABrush {
   public:
    class AActor* AssociatedActor;  // 0x0274 (0x0008) [0x0000000000000000]
    DWORD bForcePawnWalk : 1;       // 0x027C (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    DWORD bProcessAllActors : 1;    // 0x027C (0x0004) [0x0000000000000000]
                                    // [0x00000002]
    DWORD bPawnsOnly : 1;  // 0x027C (0x0004) [0x0000000000000000] [0x00000004]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[147];

        return pClassPointer;
    };

    void eventProcessActorSetVolume();
    void eventCollisionChanged();
    void OnToggle();
    void DisplayDebug();
    void eventPostBeginPlay();
    void EncompassesPoint();
    void Encompasses();
};

UClass* AVolume::pClassPointer = NULL;

// Class Engine.BlockingVolume
// 0x0004 (0x0284 - 0x0280)
class ABlockingVolume : public AVolume {
   public:
    DWORD
        bBlockCamera : 1;  // 0x0280 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[149];

        return pClassPointer;
    };

    void OnToggle();
};

UClass* ABlockingVolume::pClassPointer = NULL;

// Class Engine.DynamicBlockingVolume
// 0x0004 (0x0288 - 0x0284)
class ADynamicBlockingVolume : public ABlockingVolume {
   public:
    DWORD bEnabled : 1;  // 0x0284 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[151];

        return pClassPointer;
    };

    void ApplyCheckpointRecord();
    void CreateCheckpointRecord();
    void eventPostBeginPlay();
};

UClass* ADynamicBlockingVolume::pClassPointer = NULL;

// Class Engine.CullDistanceVolume
// 0x0014 (0x0294 - 0x0280)
class ACullDistanceVolume : public AVolume {
   public:
    TArray<struct FCullDistanceSizePair>
        CullDistances;   // 0x0280 (0x0010) [0x0000000000000000]
    DWORD bEnabled : 1;  // 0x0290 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[153];

        return pClassPointer;
    };
};

UClass* ACullDistanceVolume::pClassPointer = NULL;

// Class Engine.LevelGridVolume
// 0x00A4 (0x0324 - 0x0280)
class ALevelGridVolume : public AVolume {
   public:
    struct FString LevelGridVolumeName;  // 0x0280 (0x0010) [0x0000000000000000]
    unsigned char CellShape;             // 0x0290 (0x0001) [0x0000000000000000]
    int Subdivisions[0x3];               // 0x0294 (0x000C) [0x0000000000000000]
    float LoadingDistance;               // 0x02A0 (0x0004) [0x0000000000000000]
    float KeepLoadedRange;               // 0x02A4 (0x0004) [0x0000000000000000]
    struct FKConvexElem CellConvexElem;  // 0x02A8 (0x007C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[155];

        return pClassPointer;
    };
};

UClass* ALevelGridVolume::pClassPointer = NULL;

// Class Engine.LevelStreamingVolume
// 0x001C (0x029C - 0x0280)
class ALevelStreamingVolume : public AVolume {
   public:
    TArray<class ULevelStreaming*>
        StreamingLevels;          // 0x0280 (0x0010) [0x0000000000000000]
    DWORD bEditorPreVisOnly : 1;  // 0x0290 (0x0004) [0x0000000000000000]
                                  // [0x00000001]
    DWORD bDisabled : 1;  // 0x0290 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bTestDistanceToVolume : 1;  // 0x0290 (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    unsigned char StreamingUsage;     // 0x0294 (0x0001) [0x0000000000000000]
    unsigned char Usage;              // 0x0295 (0x0001) [0x0000000000000000]
    float TestVolumeDistance;         // 0x0298 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[157];

        return pClassPointer;
    };

    void ApplyCheckpointRecord();
    void CreateCheckpointRecord();
    void OnToggle();
};

UClass* ALevelStreamingVolume::pClassPointer = NULL;

// Class Engine.LightmassCharacterIndirectDetailVolume
// 0x0000 (0x0280 - 0x0280)
class ALightmassCharacterIndirectDetailVolume : public AVolume {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[159];

        return pClassPointer;
    };
};

UClass* ALightmassCharacterIndirectDetailVolume::pClassPointer = NULL;

// Class Engine.LightmassImportanceVolume
// 0x0000 (0x0280 - 0x0280)
class ALightmassImportanceVolume : public AVolume {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[161];

        return pClassPointer;
    };
};

UClass* ALightmassImportanceVolume::pClassPointer = NULL;

// Class Engine.MassiveLODOverrideVolume
// 0x0000 (0x0280 - 0x0280)
class AMassiveLODOverrideVolume : public AVolume {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[163];

        return pClassPointer;
    };
};

UClass* AMassiveLODOverrideVolume::pClassPointer = NULL;

// Class Engine.PathBlockingVolume
// 0x0000 (0x0280 - 0x0280)
class APathBlockingVolume : public AVolume {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[165];

        return pClassPointer;
    };
};

UClass* APathBlockingVolume::pClassPointer = NULL;

// Class Engine.PhysicsVolume
// 0x0050 (0x02D0 - 0x0280)
class APhysicsVolume : public AVolume {
   public:
    struct FVector ZoneVelocity;        // 0x0280 (0x000C) [0x0000000000000000]
    DWORD bVelocityAffectsWalking : 1;  // 0x028C (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD
        bPainCausing : 1;  // 0x028C (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bAIShouldIgnorePain : 1;  // 0x028C (0x0004) [0x0000000000000000]
                                    // [0x00000004]
    DWORD bEntryPain : 1;  // 0x028C (0x0004) [0x0000000000000000] [0x00000008]
    DWORD BACKUP_bPainCausing : 1;  // 0x028C (0x0004) [0x0000000000000000]
                                    // [0x00000010]
    DWORD
        bDestructive : 1;  // 0x028C (0x0004) [0x0000000000000000] [0x00000020]
    DWORD
        bNoInventory : 1;  // 0x028C (0x0004) [0x0000000000000000] [0x00000040]
    DWORD bMoveProjectiles : 1;  // 0x028C (0x0004) [0x0000000000000000]
                                 // [0x00000080]
    DWORD bBounceVelocity : 1;   // 0x028C (0x0004) [0x0000000000000000]
                                 // [0x00000100]
    DWORD
        bNeutralZone : 1;  // 0x028C (0x0004) [0x0000000000000000] [0x00000200]
    DWORD bCrowdAgentsPlayDeathAnim : 1;  // 0x028C (0x0004)
                                          // [0x0000000000000000] [0x00000400]
    DWORD bPhysicsOnContact : 1;  // 0x028C (0x0004) [0x0000000000000000]
                                  // [0x00000800]
    DWORD
        bWaterVolume : 1;  // 0x028C (0x0004) [0x0000000000000000] [0x00001000]
    float GroundFriction;  // 0x0290 (0x0004) [0x0000000000000000]
    float TerminalVelocity;    // 0x0294 (0x0004) [0x0000000000000000]
    float DamagePerSec;        // 0x0298 (0x0004) [0x0000000000000000]
    class UClass* DamageType;  // 0x029C (0x0008) [0x0000000000000000]
    int Priority;              // 0x02A4 (0x0004) [0x0000000000000000]
    float FluidFriction;       // 0x02A8 (0x0004) [0x0000000000000000]
    float PainInterval;        // 0x02AC (0x0004) [0x0000000000000000]
    float RigidBodyDamping;    // 0x02B0 (0x0004) [0x0000000000000000]
    float MaxDampingForce;     // 0x02B4 (0x0004) [0x0000000000000000]
    class AInfo* PainTimer;    // 0x02B8 (0x0008) [0x0000000000000000]
    class AController*
        DamageInstigator;  // 0x02C0 (0x0008) [0x0000000000000000]
    class APhysicsVolume*
        NextPhysicsVolume;  // 0x02C8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[167];

        return pClassPointer;
    };

    void ApplyCheckpointRecord();
    void CreateCheckpointRecord();
    void ShouldSaveForCheckpoint();
    void OnSetDamageInstigator();
    void NotifyPawnBecameViewTarget();
    void ModifyPlayer();
    void CausePainTo();
    void eventTouch();
    void TimerPop();
    void eventCollisionChanged();
    void OnToggle();
    void eventPawnLeavingVolume();
    void eventPawnEnteredVolume();
    void eventActorLeavingVolume();
    void eventActorEnteredVolume();
    void eventPhysicsChangedFor();
    void Reset();
    void eventPostBeginPlay();
    void GetZoneVelocityForActor();
    void GetGravityZ();
};

UClass* APhysicsVolume::pClassPointer = NULL;

// Class Engine.DefaultPhysicsVolume
// 0x0000 (0x02D0 - 0x02D0)
class ADefaultPhysicsVolume : public APhysicsVolume {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[169];

        return pClassPointer;
    };

    void eventDestroyed();
};

UClass* ADefaultPhysicsVolume::pClassPointer = NULL;

// Class Engine.GravityVolume
// 0x0004 (0x02D4 - 0x02D0)
class AGravityVolume : public APhysicsVolume {
   public:
    float GravityZ;  // 0x02D0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[171];

        return pClassPointer;
    };
};

UClass* AGravityVolume::pClassPointer = NULL;

// Class Engine.LadderVolume
// 0x0040 (0x0310 - 0x02D0)
class ALadderVolume : public APhysicsVolume {
   public:
    struct FRotator WallDir;      // 0x02D0 (0x000C) [0x0000000000000000]
    struct FVector LookDir;       // 0x02DC (0x000C) [0x0000000000000000]
    struct FVector ClimbDir;      // 0x02E8 (0x000C) [0x0000000000000000]
    class ALadder* LadderList;    // 0x02F4 (0x0008) [0x0000000000000000]
    DWORD bNoPhysicalLadder : 1;  // 0x02FC (0x0004) [0x0000000000000000]
                                  // [0x00000001]
    DWORD bAutoPath : 1;  // 0x02FC (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bAllowLadderStrafing : 1;  // 0x02FC (0x0004) [0x0000000000000000]
                                     // [0x00000004]
    class APawn* PendingClimber;     // 0x0300 (0x0008) [0x0000000000000000]
    class UArrowComponent*
        WallDirArrow;  // 0x0308 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[173];

        return pClassPointer;
    };

    void eventPhysicsChangedFor();
    void eventPawnLeavingVolume();
    void eventPawnEnteredVolume();
    void InUse();
    void eventPostBeginPlay();
};

UClass* ALadderVolume::pClassPointer = NULL;

// Class Engine.PortalVolume
// 0x0010 (0x0290 - 0x0280)
class APortalVolume : public AVolume {
   public:
    TArray<class APortalTeleporter*>
        Portals;  // 0x0280 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[175];

        return pClassPointer;
    };
};

UClass* APortalVolume::pClassPointer = NULL;

// Class Engine.PostProcessVolume
// 0x0230 (0x04B0 - 0x0280)
class APostProcessVolume : public AVolume {
   public:
    float Priority;  // 0x0280 (0x0004) [0x0000000000000000]
    DWORD bOverrideWorldPostProcessChain : 1;  // 0x0284 (0x0004)
                                               // [0x0000000000000000]
                                               // [0x00000001]
    DWORD bEnabled : 1;  // 0x0284 (0x0004) [0x0000000000150000] [0x00000002] (
                         // CPF_Travel | CPF_GlobalConfig )
    struct FPostProcessSettings
        Settings;  // 0x0288 (0x0220) [0x0000000000000000]
    class APostProcessVolume*
        NextLowerPriorityVolume;  // 0x04A8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[177];

        return pClassPointer;
    };

    void OnToggle();
};

UClass* APostProcessVolume::pClassPointer = NULL;

// Class Engine.PrecomputedVisibilityOverrideVolume
// 0x0020 (0x02A0 - 0x0280)
class APrecomputedVisibilityOverrideVolume : public AVolume {
   public:
    TArray<class AActor*>
        OverrideVisibleActors;  // 0x0280 (0x0010) [0x0000000000000000]
    TArray<class AActor*>
        OverrideInvisibleActors;  // 0x0290 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[179];

        return pClassPointer;
    };
};

UClass* APrecomputedVisibilityOverrideVolume::pClassPointer = NULL;

// Class Engine.PrecomputedVisibilityVolume
// 0x0000 (0x0280 - 0x0280)
class APrecomputedVisibilityVolume : public AVolume {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[181];

        return pClassPointer;
    };
};

UClass* APrecomputedVisibilityVolume::pClassPointer = NULL;

// Class Engine.ReverbVolume
// 0x0044 (0x02C4 - 0x0280)
class AReverbVolume : public AVolume {
   public:
    float Priority;      // 0x0280 (0x0004) [0x0000000000000000]
    DWORD bEnabled : 1;  // 0x0284 (0x0004) [0x0000000000150000] [0x00000001] (
                         // CPF_Travel | CPF_GlobalConfig )
    struct FReverbSettings Settings;  // 0x0288 (0x0010) [0x0000000000000000]
    struct FInteriorSettings
        AmbientZoneSettings;  // 0x0298 (0x0024) [0x0000000000000000]
    class AReverbVolume*
        NextLowerPriorityVolume;  // 0x02BC (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[183];

        return pClassPointer;
    };

    void GetEnvironmentEchoDistance();
};

UClass* AReverbVolume::pClassPointer = NULL;

// Class Engine.TriggerVolume
// 0x0000 (0x0280 - 0x0280)
class ATriggerVolume : public AVolume {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[185];

        return pClassPointer;
    };

    void StopsProjectile();
    void eventPostBeginPlay();
};

UClass* ATriggerVolume::pClassPointer = NULL;

// Class Engine.DroppedPickup
// 0x001C (0x0260 - 0x0244)
class ADroppedPickup : public AActor {
   public:
    class AInventory* Inventory;   // 0x0244 (0x0008) [0x0000000000000000]
    class UClass* InventoryClass;  // 0x024C (0x0008) [0x0000000000150000] (
                                   // CPF_Travel | CPF_GlobalConfig )
    class ANavigationPoint*
        PickupCache;     // 0x0254 (0x0008) [0x0000000000000000]
    DWORD bFadeOut : 1;  // 0x025C (0x0004) [0x0000000000160000] [0x00000001] (
                         // CPF_EditConst | CPF_GlobalConfig )

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[187];

        return pClassPointer;
    };

    void RecheckValidTouch();
    void PickedUpBy();
    void GiveTo();
    void eventLanded();
    void DetourWeight();
    void eventEncroachedBy();
    void eventSetPickupParticles();
    void eventSetPickupMesh();
    void Reset();
    void eventReplicatedEvent();
    void eventDestroyed();
    void RemoveFromNavigation();
    void AddToNavigation();
};

UClass* ADroppedPickup::pClassPointer = NULL;

// Class Engine.DynamicSMActor
// 0x0050 (0x0294 - 0x0244)
class ADynamicSMActor : public AActor {
   public:
    class UStaticMeshComponent*
        StaticMeshComponent;  // 0x0244 (0x0008) [0x0000000000000000]
    class UDynamicLightEnvironmentComponent*
        LightEnvironment;               // 0x024C (0x0008) [0x0000000000000000]
    class UStaticMesh* ReplicatedMesh;  // 0x0254 (0x0008) [0x0000000000150000]
                                        // ( CPF_Travel | CPF_GlobalConfig )
    class UMaterialInterface*
        ReplicatedMaterial0;  // 0x025C (0x0008) [0x0000000000160000] (
                              // CPF_EditConst | CPF_GlobalConfig )
    class UMaterialInterface*
        ReplicatedMaterial1;  // 0x0264 (0x0008) [0x0000000000170000] (
                              // CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
    DWORD bForceStaticDecals : 1;  // 0x026C (0x0004) [0x0000000000180000]
                                   // [0x00000001] ( CPF_Component )
    DWORD bPawnCanBaseOn : 1;      // 0x026C (0x0004) [0x0000000000000000]
                                   // [0x00000002]
    DWORD bSafeBaseIfAsleep : 1;   // 0x026C (0x0004) [0x0000000000000000]
                                   // [0x00000004]
    struct FVector
        ReplicatedMeshTranslation;  // 0x0270 (0x000C) [0x0000000000190000] (
                                    // CPF_Travel | CPF_Component )
    struct FRotator
        ReplicatedMeshRotation;  // 0x027C (0x000C) [0x00000000001A0000] (
                                 // CPF_EditConst | CPF_Component )
    struct FVector
        ReplicatedMeshScale3D;  // 0x0288 (0x000C) [0x00000000001B0000] (
                                // CPF_Travel | CPF_EditConst | CPF_Component )

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[189];

        return pClassPointer;
    };

    void SetLightEnvironmentToNotBeDynamic();
    void eventDetach();
    void eventAttach();
    void CanBasePawn();
    void SetStaticMesh();
    void OnSetMaterial();
    void OnSetMesh();
    void eventReplicatedEvent();
    void eventPostBeginPlay();
};

UClass* ADynamicSMActor::pClassPointer = NULL;

// Class Engine.InterpActor
// 0x004C (0x02E0 - 0x0294)
class AInterpActor : public ADynamicSMActor {
   public:
    DWORD bShouldSaveForCheckpoint : 1;  // 0x0294 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD
        bMonitorMover : 1;  // 0x0294 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bMonitorZVelocity : 1;  // 0x0294 (0x0004) [0x0000000000000000]
                                  // [0x00000004]
    DWORD
        bDestroyProjectilesOnEncroach : 1;  // 0x0294 (0x0004)
                                            // [0x0000000000000000] [0x00000008]
    DWORD bContinueOnEncroachPhysicsObject : 1;  // 0x0294 (0x0004)
                                                 // [0x0000000000000000]
                                                 // [0x00000010]
    DWORD bStopOnEncroach : 1;  // 0x0294 (0x0004) [0x0000000000000000]
                                // [0x00000020]
    DWORD bShouldShadowParentAllAttachedActors : 1;  // 0x0294 (0x0004)
                                                     // [0x0000000000000000]
                                                     // [0x00000040]
    DWORD bIsLift : 1;  // 0x0294 (0x0004) [0x0000000000000000] [0x00000080]
    class ANavigationPoint* MyMarker;  // 0x0298 (0x0008) [0x0000000000000000]
    float MaxZVelocity;                // 0x02A0 (0x0004) [0x0000000000000000]
    float StayOpenTime;                // 0x02A4 (0x0004) [0x0000000000000000]
    class UAkBaseSoundObject*
        OpenSound;  // 0x02A8 (0x0008) [0x0000000000000000]
    class USoundCue*
        OpeningAmbientSound;  // 0x02B0 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        OpenedSound;  // 0x02B8 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        CloseSound;  // 0x02C0 (0x0008) [0x0000000000000000]
    class USoundCue*
        ClosingAmbientSound;  // 0x02C8 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        ClosedSound;  // 0x02D0 (0x0008) [0x0000000000000000]
    class UAudioComponent*
        AmbientSoundComponent;  // 0x02D8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[191];

        return pClassPointer;
    };

    void ApplyCheckpointRecord();
    void CreateCheckpointRecord();
    void ShouldSaveForCheckpoint();
    void ShutDown();
    void eventInterpolationChanged();
    void eventInterpolationFinished();
    void eventInterpolationStarted();
    void PlayMovingSound();
    void FinishedOpen();
    void Restart();
    void eventDetach();
    void eventAttach();
    void eventRanInto();
    void eventEncroachingOn();
    void eventPostBeginPlay();
};

UClass* AInterpActor::pClassPointer = NULL;

// Class Engine.FlexActor
// 0x0000 (0x02E0 - 0x02E0)
class AFlexActor : public AInterpActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[193];

        return pClassPointer;
    };
};

UClass* AFlexActor::pClassPointer = NULL;

// Class Engine.Emitter
// 0x0014 (0x0258 - 0x0244)
class AEmitter : public AActor {
   public:
    class UParticleSystemComponent*
        ParticleSystemComponent;  // 0x0244 (0x0008) [0x0000000000000000]
    class UDynamicLightEnvironmentComponent*
        LightEnvironment;              // 0x024C (0x0008) [0x0000000000000000]
    DWORD bDestroyOnSystemFinish : 1;  // 0x0254 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bPostUpdateTickGroup : 1;    // 0x0254 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD
        bCurrentlyActive : 1;  // 0x0254 (0x0004) [0x0000000000150000]
                               // [0x00000004] ( CPF_Travel | CPF_GlobalConfig )
    DWORD bDepthTestEnabled : 1;  // 0x0254 (0x0004) [0x0000000000000000]
                                  // [0x00000008]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[195];

        return pClassPointer;
    };

    void HideSelf();
    void ApplyCheckpointRecord();
    void CreateCheckpointRecord();
    void ShouldSaveForCheckpoint();
    void OnSetParticleSysParam();
    void SetActorParameter();
    void SetExtColorParameter();
    void SetColorParameter();
    void SetVectorParameter();
    void SetFloatParameter();
    void ShutDown();
    void OnParticleEventGenerator();
    void OnToggle();
    void OnParticleSystemFinished();
    void eventReplicatedEvent();
    void eventPostBeginPlay();
    void eventSetTemplate();
};

UClass* AEmitter::pClassPointer = NULL;

// Class Engine.EmitterPool
// 0x0078 (0x02BC - 0x0244)
class AEmitterPool : public AActor {
   public:
    class UParticleSystemComponent*
        PSCTemplate;  // 0x0244 (0x0008) [0x0000000000000000]
    TArray<class UParticleSystemComponent*>
        PoolComponents;  // 0x024C (0x0010) [0x0000000000000000]
    TArray<class UParticleSystemComponent*>
        ActiveComponents;  // 0x025C (0x0010) [0x0000000000000000]
    class UParticleSystemComponent*
        FlexSurrogateComponent;      // 0x026C (0x0008) [0x0000000000000000]
    int MaxActiveEffects;            // 0x0274 (0x0004) [0x0000000000000000]
    DWORD bLogPoolOverflow : 1;      // 0x0278 (0x0004) [0x0000000000000000]
                                     // [0x00000001]
    DWORD bLogPoolOverflowList : 1;  // 0x0278 (0x0004) [0x0000000000000000]
                                     // [0x00000002]
    TArray<struct FEmitterBaseInfo>
        RelativePSCs;                    // 0x027C (0x0010) [0x0000000000000000]
    float SMC_MIC_ReductionTime;         // 0x028C (0x0004) [0x0000000000000000]
    float SMC_MIC_CurrentReductionTime;  // 0x0290 (0x0004) [0x0000000000000000]
    int IdealStaticMeshComponents;       // 0x0294 (0x0004) [0x0000000000000000]
    int IdealMaterialInstanceConstants;  // 0x0298 (0x0004) [0x0000000000000000]
    TArray<class UStaticMeshComponent*>
        FreeSMComponents;  // 0x029C (0x0010) [0x0000000000000000]
    TArray<class UMaterialInstanceConstant*>
        FreeMatInstConsts;  // 0x02AC (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[197];

        return pClassPointer;
    };

    void PostBeginPlay();
    void SpawnEmitterCustomLifetime();
    void SpawnEmitterMeshAttachment();
    void SpawnEmitter();
    void GetPooledComponent();
    void GetFreeMatInstConsts();
    void FreeMaterialInstanceConstants();
    void GetFreeStaticMeshComponent();
    void FreeStaticMeshComponents();
    void ReturnToPool();
    void ClearPoolComponents();
    void OnParticleSystemFinished();
};

UClass* AEmitterPool::pClassPointer = NULL;

// Class Engine.HUD
// 0x0320 (0x0564 - 0x0244)
class AHUD : public AActor {
   public:
    struct FColor WhiteColor;  // 0x0244 (0x0004) [0x0000000000000000]
    struct FColor GreenColor;  // 0x0248 (0x0004) [0x0000000000000000]
    struct FColor RedColor;    // 0x024C (0x0004) [0x0000000000000000]
    class APlayerController*
        PlayerOwner;             // 0x0250 (0x0008) [0x0000000000000000]
    DWORD bLostFocusPaused : 1;  // 0x0258 (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    DWORD bShowHUD : 1;     // 0x0258 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bShowScores : 1;  // 0x0258 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bShowDebugInfo : 1;           // 0x0258 (0x0004) [0x0000000000000000]
                                        // [0x00000008]
    DWORD bShowBadConnectionAlert : 1;  // 0x0258 (0x0004) [0x0000000000000000]
                                        // [0x00000010]
    DWORD bShowDirectorInfoDebug : 1;   // 0x0258 (0x0004) [0x0000000000000000]
                                        // [0x00000020]
    DWORD bShowDirectorInfoHUD : 1;     // 0x0258 (0x0004) [0x0000000000000000]
                                        // [0x00000040]
    DWORD
        bMessageBeep : 1;  // 0x0258 (0x0004) [0x0000000000000000] [0x00000080]
    DWORD bRenderFullScreen : 1;  // 0x0258 (0x0004) [0x0000000000000000]
                                  // [0x00000100]
    DWORD
        bScaleCanvasForCinematicMode : 1;  // 0x0258 (0x0004)
                                           // [0x0000000000000000] [0x00000200]
    DWORD
        bShowOverlays : 1;  // 0x0258 (0x0004) [0x0000000000000000] [0x00000400]
    float HudCanvasScale;   // 0x025C (0x0004) [0x0000000000000000]
    TArray<class AActor*>
        PostRenderedActors;  // 0x0260 (0x0010) [0x0000000000000000]
    TArray<struct FConsoleMessage>
        ConsoleMessages;         // 0x0270 (0x0010) [0x0000000000000000]
    struct FColor ConsoleColor;  // 0x0280 (0x0004) [0x0000000000000000]
    int ConsoleMessageCount;     // 0x0284 (0x0004) [0x0000000000000000]
    int ConsoleFontSize;         // 0x0288 (0x0004) [0x0000000000000000]
    int MessageFontOffset;       // 0x028C (0x0004) [0x0000000000000000]
    int MaxHUDAreaMessageCount;  // 0x0290 (0x0004) [0x0000000000000000]
    struct FHudLocalizedMessage
        LocalMessages[0x8];             // 0x0294 (0x0280) [0x0000000000000000]
    float ConsoleMessagePosX;           // 0x0514 (0x0004) [0x0000000000000000]
    float ConsoleMessagePosY;           // 0x0518 (0x0004) [0x0000000000000000]
    class UCanvas* Canvas;              // 0x051C (0x0008) [0x0000000000000000]
    float LastHUDRenderTime;            // 0x0524 (0x0004) [0x0000000000000000]
    float RenderDelta;                  // 0x0528 (0x0004) [0x0000000000000000]
    float SizeX;                        // 0x052C (0x0004) [0x0000000000000000]
    float SizeY;                        // 0x0530 (0x0004) [0x0000000000000000]
    float CenterX;                      // 0x0534 (0x0004) [0x0000000000000000]
    float CenterY;                      // 0x0538 (0x0004) [0x0000000000000000]
    float RatioX;                       // 0x053C (0x0004) [0x0000000000000000]
    float RatioY;                       // 0x0540 (0x0004) [0x0000000000000000]
    TArray<struct FName> DebugDisplay;  // 0x0544 (0x0010) [0x0000000000000000]
    TArray<struct FKismetDrawTextInfo>
        KismetTextInfo;  // 0x0554 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[199];

        return pClassPointer;
    };

    void eventOnLostFocusPause();
    void NotifyBindPostProcessEffects();
    void PlayerOwnerDied();
    void GetFontSizeIndex();
    void DrawText();
    void DisplayKismetMessages();
    void DisplayLocalMessages();
    void DrawMessageText();
    void DrawMessage();
    void GetScreenCoords();
    void AddLocalizedMessage();
    void LocalizedMessage();
    void AddConsoleMessage();
    void ShouldShowConsoleMessage();
    void DisplayConsoleMessages();
    void Message();
    void ClearMessage();
    void DisplayBadConnectionAlert();
    void DrawHUD();
    void eventPostRender();
    void PreCalcValues();
    void DrawRoute();
    void ShowDebugInfo();
    void ToggleDirectorInfoDebug();
    void ToggleDirectorInfoHUD();
    void ShouldDisplayDebug();
    void ShowDebug();
    void SetShowScores();
    void ShowScores();
    void ShowHUD();
    void ToggleHUD();
    void AddPostRenderedActor();
    void RemovePostRenderedActor();
    void DrawActorOverlays();
    void eventPostBeginPlay();
    void Draw2DLine();
    void Draw3DLine();
};

UClass* AHUD::pClassPointer = NULL;

// Class Engine.AutoTestManager
// 0x00C4 (0x0308 - 0x0244)
class AAutoTestManager : public AInfo {
   public:
    DWORD bAutomatedPerfTesting : 1;     // 0x0244 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bAutoContinueToNextRound : 1;  // 0x0244 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD
        bUsingAutomatedTestingMapList : 1;  // 0x0244 (0x0004)
                                            // [0x0000000000000000] [0x00000004]
    DWORD bAutomatedTestingWithOpen : 1;    // 0x0244 (0x0004)
                                            // [0x0000000000000000] [0x00000008]
    DWORD bExitOnCyclesComplete : 1;  // 0x0244 (0x0004) [0x0000000000000000]
                                      // [0x00000010]
    DWORD bCheckingForFragmentation : 1;  // 0x0244 (0x0004)
                                          // [0x0000000000000000] [0x00000020]
    DWORD bCheckingForMemLeaks : 1;  // 0x0244 (0x0004) [0x0000000000000000]
                                     // [0x00000040]
    DWORD bDoingASentinelRun : 1;    // 0x0244 (0x0004) [0x0000000000000000]
                                     // [0x00000080]
    DWORD bSentinelStreamingLevelStillLoading : 1;  // 0x0244 (0x0004)
                                                    // [0x0000000000000000]
                                                    // [0x00000100]
    int AutomatedPerfRemainingTime;  // 0x0248 (0x0004) [0x0000000000000000]
    int AutomatedTestingMapIndex;    // 0x024C (0x0004) [0x0000000000000000]
    TArray<struct FString>
        AutomatedMapTestingList;       // 0x0250 (0x0010) [0x0000000000000000]
    int NumAutomatedMapTestingCycles;  // 0x0260 (0x0004) [0x0000000000000000]
    int NumberOfMatchesPlayed;         // 0x0264 (0x0004) [0x0000000000000000]
    int NumMapListCyclesDone;          // 0x0268 (0x0004) [0x0000000000000000]
    struct FString
        AutomatedTestingExecCommandToRunAtStartMatch;  // 0x026C (0x0010)
                                                       // [0x0000000000000000]
    struct FString AutomatedMapTestingTransitionMap;   // 0x027C (0x0010)
                                                       // [0x0000000000000000]
    struct FString
        SentinelTaskDescription;  // 0x028C (0x0010) [0x0000000000000000]
    struct FString
        SentinelTaskParameter;       // 0x029C (0x0010) [0x0000000000000000]
    struct FString SentinelTagDesc;  // 0x02AC (0x0010) [0x0000000000000000]
    class APlayerController*
        SentinelPC;  // 0x02BC (0x0008) [0x0000000000000000]
    TArray<struct FVector>
        SentinelTravelArray;    // 0x02C4 (0x0010) [0x0000000000000000]
    int SentinelNavigationIdx;  // 0x02D4 (0x0004) [0x0000000000000000]
    int SentinelIdx;            // 0x02D8 (0x0004) [0x0000000000000000]
    int NumRotationsIncrement;  // 0x02DC (0x0004) [0x0000000000000000]
    int TravelPointsIncrement;  // 0x02E0 (0x0004) [0x0000000000000000]
    int NumMinutesPerMap;       // 0x02E4 (0x0004) [0x0000000000000000]
    TArray<struct FString>
        CommandsToRunAtEachTravelTheWorldNode;  // 0x02E8 (0x0010)
                                                // [0x0000000000000000]
    struct FString CommandStringToExec;  // 0x02F8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[201];

        return pClassPointer;
    };

    void CheckForSentinelRun();
    void StartMatch();
    void GetNextAutomatedTestingMap();
    void IncrementNumberOfMatchesPlayed();
    void IncrementAutomatedTestingMapIndex();
    void CloseAutomatedMapTestTimer();
    void StartAutomatedMapTestTimerWorker();
    void eventStartAutomatedMapTestTimer();
    void DoMemoryTracking();
    void DoTimeBasedSentinelStatGathering();
    void DoSentinel_ViewDependentMemoryAtSpecificLocation();
    void DoSentinel_PerfAtSpecificLocation();
    void DoSentinel_MemoryAtSpecificLocation();
    void GetTravelLocations();
    void HandlePerLoadedMapAudioStats();
    void DoSentinelActionPerLoadedMap();
    void DoTravelTheWorld();
    void EndSentinelRun();
    void AddSentinelPerTimePeriodStats();
    void BeginSentinelRun();
    void InitializeOptions();
    void eventTimer();
    void eventPostBeginPlay();
};

UClass* AAutoTestManager::pClassPointer = NULL;

// Class Engine.CoverGroup
// 0x0018 (0x025C - 0x0244)
class ACoverGroup : public AInfo {
   public:
    TArray<struct FActorReference>
        CoverLinkRefs;       // 0x0244 (0x0010) [0x0000000000000000]
    float AutoSelectRadius;  // 0x0254 (0x0004) [0x0000000000000000]
    float AutoSelectHeight;  // 0x0258 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[203];

        return pClassPointer;
    };

    void OnToggle();
    void ToggleGroup();
    void DisableGroup();
    void EnableGroup();
};

UClass* ACoverGroup::pClassPointer = NULL;

// Class Engine.FileWriter
// 0x0020 (0x0264 - 0x0244)
class AFileWriter : public AInfo {
   public:
    struct FPointer ArchivePtr;   // 0x0244 (0x0008) [0x0000000000000000]
    struct FString Filename;      // 0x024C (0x0010) [0x0000000000000000]
    unsigned char FileType;       // 0x025C (0x0001) [0x0000000000000000]
    DWORD bFlushEachWrite : 1;    // 0x0260 (0x0004) [0x0000000000000000]
                                  // [0x00000001]
    DWORD bWantsAsyncWrites : 1;  // 0x0260 (0x0004) [0x0000000000000000]
                                  // [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[205];

        return pClassPointer;
    };

    void eventDestroyed();
    void Logf();
    void CloseFile();
    void OpenFile();
};

UClass* AFileWriter::pClassPointer = NULL;

// Class Engine.FileLog
// 0x0000 (0x0264 - 0x0264)
class AFileLog : public AFileWriter {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[207];

        return pClassPointer;
    };

    void CloseLog();
    void OpenLog();
};

UClass* AFileLog::pClassPointer = NULL;

// Class Engine.GameInfo
// 0x0254 (0x0498 - 0x0244)
class AGameInfo : public AInfo {
   public:
    DWORD
        bRestartLevel : 1;  // 0x0244 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bPauseable : 1;   // 0x0244 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bTeamGame : 1;    // 0x0244 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bGameEnded : 1;   // 0x0244 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bOverTime : 1;    // 0x0244 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD
        bDelayedStart : 1;  // 0x0244 (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bWaitingToStartMatch : 1;  // 0x0244 (0x0004) [0x0000000000000000]
                                     // [0x00000040]
    DWORD
        bChangeLevels : 1;  // 0x0244 (0x0004) [0x0000000000000000] [0x00000080]
    DWORD bAlreadyChanged : 1;  // 0x0244 (0x0004) [0x0000000000000000]
                                // [0x00000100]
    DWORD bAdminCanPause : 1;   // 0x0244 (0x0004) [0x0000000000000000]
                                // [0x00000200]
    DWORD bGameRestarted : 1;   // 0x0244 (0x0004) [0x0000000000000000]
                                // [0x00000400]
    DWORD
        bLevelChange : 1;  // 0x0244 (0x0004) [0x0000000000000000] [0x00000800]
    DWORD bKickLiveIdlers : 1;    // 0x0244 (0x0004) [0x0000000000000000]
                                  // [0x00001000]
    DWORD bUsingArbitration : 1;  // 0x0244 (0x0004) [0x0000000000000000]
                                  // [0x00002000]
    DWORD
        bHasArbitratedHandshakeBegun : 1;  // 0x0244 (0x0004)
                                           // [0x0000000000000000] [0x00004000]
    DWORD bNeedsEndGameHandshake : 1;  // 0x0244 (0x0004) [0x0000000000000000]
                                       // [0x00008000]
    DWORD bIsEndGameHandshakeComplete : 1;  // 0x0244 (0x0004)
                                            // [0x0000000000000000] [0x00010000]
    DWORD bHasEndGameHandshakeBegun : 1;    // 0x0244 (0x0004)
                                            // [0x0000000000000000] [0x00020000]
    DWORD bFixedPlayerStart : 1;    // 0x0244 (0x0004) [0x0000000000000000]
                                    // [0x00040000]
    DWORD bDoFearCostFallOff : 1;   // 0x0244 (0x0004) [0x0000000000000000]
                                    // [0x00080000]
    DWORD bUseSeamlessTravel : 1;   // 0x0244 (0x0004) [0x0000000000000000]
                                    // [0x00100000]
    DWORD bHasNetworkError : 1;     // 0x0244 (0x0004) [0x0000000000000000]
                                    // [0x00200000]
    DWORD bRequiresPushToTalk : 1;  // 0x0244 (0x0004) [0x0000000000000000]
                                    // [0x00400000]
    DWORD bIsStandbyCheckingEnabled : 1;  // 0x0244 (0x0004)
                                          // [0x0000000000000000] [0x00800000]
    DWORD bIsStandbyCheckingOn : 1;  // 0x0244 (0x0004) [0x0000000000000000]
                                     // [0x01000000]
    DWORD bHasStandbyCheatTriggered : 1;  // 0x0244 (0x0004)
                                          // [0x0000000000000000] [0x02000000]
    struct FString CauseEventCommand;  // 0x0248 (0x0010) [0x0000000000000000]
    struct FString BugLocString;       // 0x0258 (0x0010) [0x0000000000000000]
    struct FString BugRotString;       // 0x0268 (0x0010) [0x0000000000000000]
    TArray<class APlayerController*>
        PendingArbitrationPCs;  // 0x0278 (0x0010) [0x0000000000000000]
    TArray<class APlayerController*>
        ArbitrationPCs;                 // 0x0288 (0x0010) [0x0000000000000000]
    float ArbitrationHandshakeTimeout;  // 0x0298 (0x0004) [0x0000000000000000]
    float GameDifficulty;               // 0x029C (0x0004) [0x0000000000000000]
    int GoreLevel;                      // 0x02A0 (0x0004) [0x0000000000000000]
    float GameSpeed;                    // 0x02A4 (0x0004) [0x0000000000000000]
    class UClass* DefaultPawnClass;     // 0x02A8 (0x0008) [0x0000000000000000]
    class UClass* HUDType;              // 0x02B0 (0x0008) [0x0000000000000000]
    class UClass* SecondaryHUDType;     // 0x02B8 (0x0008) [0x0000000000000000]
    int MaxSpectators;                  // 0x02C0 (0x0004) [0x0000000000000000]
    int MaxSpectatorsAllowed;           // 0x02C4 (0x0004) [0x0000000000000000]
    int NumSpectators;                  // 0x02C8 (0x0004) [0x0000000000000000]
    int MaxPlayers;                     // 0x02CC (0x0004) [0x0000000000000000]
    int MaxPlayersAllowed;              // 0x02D0 (0x0004) [0x0000000000000000]
    int NumPlayers;                     // 0x02D4 (0x0004) [0x0000000000000000]
    int NumBots;                        // 0x02D8 (0x0004) [0x0000000000000000]
    int NumTravellingPlayers;           // 0x02DC (0x0004) [0x0000000000000000]
    int CurrentID;                      // 0x02E0 (0x0004) [0x0000000000000000]
    struct FString DefaultPlayerName;   // 0x02E4 (0x0010) [0x0000000000000000]
    struct FString GameName;            // 0x02F4 (0x0010) [0x0000000000000000]
    float FearCostFallOff;              // 0x0304 (0x0004) [0x0000000000000000]
    int GoalScore;                      // 0x0308 (0x0004) [0x0000000000000000]
    int MaxLives;                       // 0x030C (0x0004) [0x0000000000000000]
    int TimeLimit;                      // 0x0310 (0x0004) [0x0000000000000000]
    class UClass* DeathMessageClass;    // 0x0314 (0x0008) [0x0000000000000000]
    class UClass* GameMessageClass;     // 0x031C (0x0008) [0x0000000000000000]
    class AMutator* BaseMutator;        // 0x0324 (0x0008) [0x0000000000000000]
    class UClass* AccessControlClass;   // 0x032C (0x0008) [0x0000000000000000]
    class AAccessControl*
        AccessControl;  // 0x0334 (0x0008) [0x0000000000000000]
    class UClass*
        BroadcastHandlerClass;  // 0x033C (0x0008) [0x0000000000000000]
    class ABroadcastHandler*
        BroadcastHandler;                // 0x0344 (0x0008) [0x0000000000000000]
    class UClass* AutoTestManagerClass;  // 0x034C (0x0008) [0x0000000000000000]
    class AAutoTestManager*
        MyAutoTestManager;  // 0x0354 (0x0008) [0x0000000000000000]
    class UClass*
        PlayerControllerClass;  // 0x035C (0x0008) [0x0000000000000000]
    class UClass*
        PlayerReplicationInfoClass;  // 0x0364 (0x0008) [0x0000000000000000]
    class UClass*
        GameReplicationInfoClass;  // 0x036C (0x0008) [0x0000000000000000]
    class AGameReplicationInfo*
        GameReplicationInfo;  // 0x0374 (0x0008) [0x0000000000000000]
    class ACrowdPopulationManagerBase*
        PopulationManager;  // 0x037C (0x0008) [0x0000000000000000]
    class UClass*
        PopulationManagerClass;  // 0x0384 (0x0008) [0x0000000000000000]
    float MaxIdleTime;           // 0x038C (0x0004) [0x0000000000000000]
    float MaxTimeMargin;         // 0x0390 (0x0004) [0x0000000000000000]
    float TimeMarginSlack;       // 0x0394 (0x0004) [0x0000000000000000]
    float MinTimeMargin;         // 0x0398 (0x0004) [0x0000000000000000]
    TArray<class APlayerReplicationInfo*>
        InactivePRIArray;  // 0x039C (0x0010) [0x0000000000000000]
    TArray<struct FScriptDelegate>
        Pausers;                        // 0x03AC (0x0010) [0x0000000000000000]
    class UOnlineSubsystem* OnlineSub;  // 0x03BC (0x0008) [0x0000000000000000]
    class UPlayfabInterface*
        PlayfabInter;  // 0x03C4 (0x0008) [0x0000000000000000]
    class UOnlineGameInterface*
        GameInterface;                 // 0x03CC (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x8];  // 0x03D4 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UClass*
        OnlineStatsWriteClass;    // 0x03DC (0x0008) [0x0000000000000000]
    int LeaderboardId;            // 0x03E4 (0x0004) [0x0000000000000000]
    int ArbitratedLeaderboardId;  // 0x03E8 (0x0004) [0x0000000000000000]
    class ACoverReplicator*
        CoverReplicatorBase;  // 0x03EC (0x0008) [0x0000000000000000]
    class UClass*
        OnlineGameSettingsClass;       // 0x03F4 (0x0008) [0x0000000000000000]
    struct FString ServerOptions;      // 0x03FC (0x0010) [0x0000000000000000]
    int AdjustedNetSpeed;              // 0x040C (0x0004) [0x0000000000000000]
    float LastNetSpeedUpdateTime;      // 0x0410 (0x0004) [0x0000000000000000]
    int TotalNetBandwidth;             // 0x0414 (0x0004) [0x0000000000000000]
    int MinDynamicBandwidth;           // 0x0418 (0x0004) [0x0000000000000000]
    int MaxDynamicBandwidth;           // 0x041C (0x0004) [0x0000000000000000]
    float StandbyRxCheatTime;          // 0x0420 (0x0004) [0x0000000000000000]
    float StandbyTxCheatTime;          // 0x0424 (0x0004) [0x0000000000000000]
    int BadPingThreshold;              // 0x0428 (0x0004) [0x0000000000000000]
    float PercentMissingForRxStandby;  // 0x042C (0x0004) [0x0000000000000000]
    float PercentMissingForTxStandby;  // 0x0430 (0x0004) [0x0000000000000000]
    float PercentForBadPing;           // 0x0434 (0x0004) [0x0000000000000000]
    float
        JoinInProgressStandbyWaitTime;  // 0x0438 (0x0004) [0x0000000000000000]
    class UMaterial*
        StreamingPauseIcon;  // 0x043C (0x0008) [0x0000000000000000]
    TArray<struct FGameClassShortName>
        GameInfoClassAliases;        // 0x0444 (0x0010) [0x0000000000000000]
    struct FString DefaultGameType;  // 0x0454 (0x0010) [0x0000000000000000]
    TArray<struct FGameTypePrefix>
        DefaultMapPrefixes;  // 0x0464 (0x0010) [0x0000000000000000]
    TArray<struct FGameTypePrefix>
        CustomMapPrefixes;  // 0x0474 (0x0010) [0x0000000000000000]
    int AnimTreePoolSize;   // 0x0484 (0x0004) [0x0000000000000000]
    struct FScriptDelegate
        __CanUnpause__Delegate;        // 0x0488 (0x0010) [0x0000000000000000]
    unsigned char UnknownData01[0x4];  // 0x048C (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[209];

        return pClassPointer;
    };

    void eventGetRequiresPassword();
    void NotifyControllerReconnected();
    void NotifyControllerDisconnected();
    void eventGetFriendlyNameForCurrentGameMode();
    void WasLaunchedByPlayfab();
    void eventOnRetreivedPFInternalUserData();
    void ClearOnlineDelegates();
    void InitCrowdPopulationManager();
    void eventOnEngineHasLoaded();
    void OnDestroyOnlineGameComplete();
    void eventStandbyCheatDetected();
    void EnableStandbyCheatDetection();
    void BeginBVT();
    void CheckForSentinelRun();
    void ShouldAutoContinueToNextRound();
    void IsDoingASentinelRun();
    void IsCheckingForMemLeaks();
    void IsCheckingForFragmentation();
    void IsAutomatedPerfTesting();
    void SetBandwidthLimit();
    void DoTravelTheWorld();
    void TellClientsToTravelToSession();
    void TellClientsPartyHostIsLeaving();
    void TellClientsToReturnToPartyHost();
    void OnServerCreateComplete();
    void RegisterServer();
    void OnLoginChange();
    void OnLoginFailed();
    void ClearAutoLoginDelegates();
    void ProcessServerLogin();
    void eventMatineeCancelled();
    void RecalculateSkillRating();
    void UpdateGameplayMuteList();
    void NotifyArbitratedMatchEnd();
    void MatchIsInProgress();
    void ArbitrationRegistrationComplete();
    void RegisterServerForArbitration();
    void StartArbitratedMatch();
    void StartArbitrationRegistration();
    void ProcessClientRegistrationCompletion();
    void UpdateGameSettingsCounts();
    void SetSeamlessTravelViewTarget();
    void eventHandleSeamlessTravelPlayer();
    void UpdateGameSettings();
    void eventPostSeamlessTravel();
    void SwapPlayerControllers();
    void eventGetSeamlessTravelActorList();
    void OverridePRI();
    void FindInactivePRI();
    void AddInactivePRI();
    void eventPostCommitMapChange();
    void eventPreCommitMapChange();
    void AllowPausing();
    void AllowCheats();
    void AllowMutator();
    void PlayerCanRestart();
    void PlayerCanRestartGame();
    void DriverLeftVehicle();
    void CanLeaveVehicle();
    void DriverEnteredVehicle();
    void ModifyScoreKill();
    void ScoreKill();
    void CheckScore();
    void ScoreObjective();
    void AddObjectiveScore();
    void RatePlayerStart();
    void ChoosePlayerStart();
    void FindPlayerStart();
    void ShouldSpawnAtStartSpot();
    void EndLogging();
    void GameEventsPoll();
    void EndOnlineGame();
    void PerformEndGameHandling();
    void EndGame();
    void WriteOnlinePlayerScores();
    void WriteOnlineStats();
    void CheckEndGame();
    void CheckModifiedEndGame();
    void eventBroadcastLocalizedTeam();
    void eventBroadcastLocalized();
    void BroadcastTeam();
    void eventBroadcast();
    void RestartGame();
    void GetTravelType();
    void GetNextMap();
    void SendPlayer();
    void PickTeam();
    void ChangeTeam();
    void ChangeName();
    void DiscardInventory();
    void PickupQuery();
    void ShouldRespawn();
    void CheckRelevance();
    void ReduceDamage();
    void CanSpectate();
    void KickBan();
    void Kick();
    void BroadcastDeathMessage();
    void PreventDeath();
    void Killed();
    void NotifyKilled();
    void SetPlayerDefaults();
    void Mutate();
    void eventAddDefaultInventory();
    void eventAcceptInventory();
    void UnregisterPlayer();
    void Logout();
    void eventPreExit();
    void CalculatedNetSpeed();
    void UpdateNetSpeeds();
    void eventPostLogin();
    void UpdateBestNextHosts();
    void BestNextHostSort();
    void GenericPlayerInitialization();
    void ReplicateStreamingStatus();
    void GetDefaultPlayerClass();
    void SpawnDefaultPawnFor();
    void RestartPlayer();
    void StartBots();
    void StartHumans();
    void OnStartOnlineGameComplete();
    void StartOnlineGame();
    void StartMatch();
    void SetNeedsReload();
    void SetNeedsRestart();
    void eventConfirmReservation();
    void eventMakeReservations();
    void eventSeatPlayer();
    void ScoreHeal();
    void ScoreDamage();
    void AllowAnalyticsLogging();
    void eventLogin();
    void SpawnPlayerController();
    void GetNextPlayerID();
    void AtCapacity();
    void RejectLogin();
    void ResumeLogin();
    void PauseLogin();
    void eventPreLogin();
    void RequiresPassword();
    void ProcessClientTravel();
    void ProcessServerTravel();
    void CheckNextMap();
    void RemoveMutator();
    void AddMutator();
    void eventNotifyPendingConnectionLost();
    void eventInitGame();
    void eventSetGameType();
    void eventGetDefaultGameClassPath();
    void GetIntOption();
    void HasOption();
    void ParseOption();
    void GetKeyValue();
    void GrabOption();
    void SetGameSpeed();
    void DebugPause();
    void ForceClearUnpauseDelegates();
    void eventClearPause();
    void SetPause();
    void CanUnpause();
    void GetNumPlayers();
    void GetNetworkNumber();
    void InitGameReplicationInfo();
    void eventForceKickPlayer();
    void eventKickIdler();
    void eventGameEnding();
    void NotifyNavigationChanged();
    void DoNavFearCostFallOff();
    void ShouldStartInCinematicMode();
    void eventTimer();
    void ResetLevel();
    void ShouldReset();
    void Reset();
    void DisplayDebug();
    void OnServerTitleDataRead();
    void eventPostBeginPlay();
    void GetCoverReplicator();
    void eventPreBeginPlay();
    void GetMapCommonPackageName();
    void GetSupportedGameTypes();
};

UClass* AGameInfo::pClassPointer = NULL;

// Class Engine.Mutator
// 0x001C (0x0260 - 0x0244)
class AMutator : public AInfo {
   public:
    class AMutator* NextMutator;        // 0x0244 (0x0008) [0x0000000000000000]
    TArray<struct FString> GroupNames;  // 0x024C (0x0010) [0x0000000000000000]
    DWORD bUserAdded : 1;  // 0x025C (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[211];

        return pClassPointer;
    };

    void ModifyZedTime();
    void ModifyActivatedPickupFactory();
    void ModifyPickupFactories();
    void ModifyAIEnemy();
    void ModifyAI();
    void ModifyNextTraderIndex();
    void NetDamage();
    void ScoreKill();
    void ScoreObjective();
    void PreventDeath();
    void OverridePickupQuery();
    void CheckEndGame();
    void HandleRestartGame();
    void FindPlayerStart();
    void GetSeamlessTravelActorList();
    void InitMutator();
    void DriverLeftVehicle();
    void CanLeaveVehicle();
    void DriverEnteredVehicle();
    void NotifyLogin();
    void NotifyLogout();
    void CheckReplacement();
    void CheckRelevance();
    void IsRelevant();
    void AlwaysKeep();
    void AddMutator();
    void ModifyPlayer();
    void ModifyLogin();
    void Mutate();
    void eventDestroyed();
    void MutatorIsAllowed();
    void eventPreBeginPlay();
};

UClass* AMutator::pClassPointer = NULL;

// Class Engine.PotentialClimbWatcher
// 0x0000 (0x0244 - 0x0244)
class APotentialClimbWatcher : public AInfo {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[213];

        return pClassPointer;
    };

    void eventTick();
};

UClass* APotentialClimbWatcher::pClassPointer = NULL;

// Class Engine.Route
// 0x0024 (0x0268 - 0x0244)
class ARoute : public AInfo {
   public:
    struct FPointer
        VfTable_IEditorLinkSelectionInterface;  // 0x0244 (0x0008)
                                                // [0x0000000000000000]
    unsigned char RouteType;  // 0x024C (0x0001) [0x0000000000000000]
    TArray<struct FActorReference>
        RouteList;         // 0x0250 (0x0010) [0x0000000000000000]
    float FudgeFactor;     // 0x0260 (0x0004) [0x0000000000000000]
    int RouteIndexOffset;  // 0x0264 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[215];

        return pClassPointer;
    };

    void MoveOntoRoutePath();
    void ResolveRouteIndex();
};

UClass* ARoute::pClassPointer = NULL;

// Class Engine.WindPointSource
// 0x0008 (0x024C - 0x0244)
class AWindPointSource : public AInfo {
   public:
    class UWindPointSourceComponent*
        Component;  // 0x0244 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[217];

        return pClassPointer;
    };
};

UClass* AWindPointSource::pClassPointer = NULL;

// Class Engine.Inventory
// 0x0074 (0x02B8 - 0x0244)
class AInventory : public AActor {
   public:
    class AInventory* Inventory;  // 0x0244 (0x0008) [0x0000000000150000] (
                                  // CPF_Travel | CPF_GlobalConfig )
    class AInventoryManager*
        InvManager;  // 0x024C (0x0008) [0x0000000000160000]              (
                     // CPF_EditConst | CPF_GlobalConfig )
    struct FString ItemName;  // 0x0254 (0x0010) [0x0000000000000000]
    DWORD
        bDropOnDeath : 1;  // 0x0264 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD
        bDelayedSpawn : 1;  // 0x0264 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bPredictRespawns : 1;        // 0x0264 (0x0004) [0x0000000000000000]
                                       // [0x00000004]
    float RespawnTime;                 // 0x0268 (0x0004) [0x0000000000000000]
    float MaxDesireability;            // 0x026C (0x0004) [0x0000000000000000]
    struct FString PickupMessage;      // 0x0270 (0x0010) [0x0000000000000000]
    class USoundCue* PickupSound;      // 0x0280 (0x0008) [0x0000000000000000]
    struct FString PickupForce;        // 0x0288 (0x0010) [0x0000000000000000]
    class UClass* DroppedPickupClass;  // 0x0298 (0x0008) [0x0000000000000000]
    class UPrimitiveComponent*
        DroppedPickupMesh;  // 0x02A0 (0x0008) [0x0000000000000000]
    class UPrimitiveComponent*
        PickupFactoryMesh;  // 0x02A8 (0x0008) [0x0000000000000000]
    class UParticleSystemComponent*
        DroppedPickupParticles;  // 0x02B0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[219];

        return pClassPointer;
    };

    void GetLocalString();
    void DropFrom();
    void DenyPickupQuery();
    void ItemRemovedFromInvManager();
    void ClientGivenTo();
    void GivenTo();
    void AnnouncePickup();
    void GiveTo();
    void DetourWeight();
    void BotDesireability();
    void eventDestroyed();
    void GetHumanReadableName();
};

UClass* AInventory::pClassPointer = NULL;

// Class Engine.Weapon
// 0x00D0 (0x0388 - 0x02B8)
class AWeapon : public AInventory {
   public:
    unsigned char CurrentFireMode;  // 0x02B8 (0x0001) [0x0000000000000000]
    TArray<struct FName>
        FiringStatesArray;  // 0x02BC (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        WeaponFireTypes;  // 0x02CC (0x0010) [0x0000000000000000]
    TArray<class UClass*>
        WeaponProjectiles;             // 0x02DC (0x0010) [0x0000000000000000]
    TArray<float> FireInterval;        // 0x02EC (0x0010) [0x0000000000000000]
    TArray<float> Spread;              // 0x02FC (0x0010) [0x0000000000000000]
    TArray<float> InstantHitDamage;    // 0x030C (0x0010) [0x0000000000000000]
    TArray<float> InstantHitMomentum;  // 0x031C (0x0010) [0x0000000000000000]
    TArray<class UClass*>
        InstantHitDamageTypes;  // 0x032C (0x0010) [0x0000000000000000]
    float EquipTime;            // 0x033C (0x0004) [0x0000000000000000]
    float PutDownTime;          // 0x0340 (0x0004) [0x0000000000000000]
    struct FVector FireOffset;  // 0x0344 (0x000C) [0x0000000000000000]
    DWORD bWeaponPutDown : 1;   // 0x0350 (0x0004) [0x0000000000000000]
                                // [0x00000001]
    DWORD bCanThrow : 1;  // 0x0350 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bWasOptionalSet : 1;    // 0x0350 (0x0004) [0x0000000000000000]
                                  // [0x00000004]
    DWORD bWasDoNotActivate : 1;  // 0x0350 (0x0004) [0x0000000000000000]
                                  // [0x00000008]
    DWORD bInstantHit : 1;  // 0x0350 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD
        bMeleeWeapon : 1;  // 0x0350 (0x0004) [0x0000000000000000] [0x00000020]
    float WeaponRange;     // 0x0354 (0x0004) [0x0000000000000000]
    class UMeshComponent* Mesh;         // 0x0358 (0x0008) [0x0000000000000000]
    float DefaultAnimSpeed;             // 0x0360 (0x0004) [0x0000000000000000]
    float Priority;                     // 0x0364 (0x0004) [0x0000000000000000]
    class AAIController* AIController;  // 0x0368 (0x0008) [0x0000000000000000]
    TArray<unsigned char>
        ShouldFireOnRelease;  // 0x0370 (0x0010) [0x0000000000000000]
    float AIRating;           // 0x0380 (0x0004) [0x0000000000000000]
    float CachedMaxRange;     // 0x0384 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[221];

        return pClassPointer;
    };

    void SetMeshLightingChannels();
    void GetTargetDistance();
    void CacheAIController();
    void WeaponIsDown();
    void StillFiring();
    void ShouldRefire();
    void NotifyWeaponFinishedFiring();
    void NotifyWeaponFired();
    void HandleFinishedFiring();
    void CanProcessPendingFire();
    void TryPutDown();
    void eventGetPhysicalFireStartLoc();
    void eventGetMuzzleLoc();
    void CustomFire();
    void ProjectileFire();
    void ProcessInstantHit();
    void InstantFire();
    void PassThroughDamage();
    void CalcWeaponFire();
    void GetTraceOwner();
    void eventGetTraceRange();
    void GetAdjustedAim();
    void FireAmmunition();
    void FireModeUpdated();
    void SetCurrentFireMode();
    void SendToFiringState();
    void ForceEndFire();
    void EndFire();
    void ServerStopFire();
    void StopFire();
    void BeginFire();
    void ServerStartFire();
    void StartFire();
    void ClientWeaponSet();
    void ClientGivenTo();
    void DetachWeapon();
    void AttachWeaponTo();
    void ClearFlashLocation();
    void SetFlashLocation();
    void ClearFlashCount();
    void IncrementFlashCount();
    void WeaponEmpty();
    void DenyPickupQuery();
    void PutDownWeapon();
    void Activate();
    void TimeWeaponEquipping();
    void TimeWeaponPutDown();
    void RefireCheckTimer();
    void TimeWeaponFiring();
    void GetFireInterval();
    void StopFireEffects();
    void PlayFireEffects();
    void StopWeaponAnimation();
    void PlayWeaponAnimation();
    void GetWeaponAnimNodeSeq();
    void FireOnRelease();
    void CanAttack();
    void GetWeaponRating();
    void GetAIRating();
    void MaxRange();
    void AddSpread();
    void GetProjectileClass();
    void ClearPendingFire();
    void SetPendingFire();
    void PendingFire();
    void GetPendingFireLength();
    void HasAnyAmmo();
    void HasAmmo();
    void AddAmmo();
    void ConsumeAmmo();
    void GetWeaponDebug();
    void DisplayDebug();
    void DrawHUD();
    void DenyClientWeaponSet();
    void eventIsFiring();
    void ClientWeaponThrown();
    void CanThrow();
    void DropFrom();
    void DoOverridePrevWeapon();
    void DoOverrideNextWeapon();
    void HolderDied();
    void ItemRemovedFromInvManager();
    void eventDestroyed();
    void ShouldWeaponIgnoreStartFire();
    void GetModifiedFOVAngle();
    void ShouldOwnerWalk();
};

UClass* AWeapon::pClassPointer = NULL;

// Class Engine.InventoryManager
// 0x002C (0x0270 - 0x0244)
class AInventoryManager : public AActor {
   public:
    class AInventory* InventoryChain;  // 0x0244 (0x0008) [0x0000000000150000]
                                       // ( CPF_Travel | CPF_GlobalConfig )
    class AWeapon* PendingWeapon;      // 0x024C (0x0008) [0x0000000000000000]
    class AWeapon*
        LastAttemptedSwitchToWeapon;  // 0x0254 (0x0008) [0x0000000000000000]
    DWORD bMustHoldWeapon : 1;        // 0x025C (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    TArray<int> PendingFire;          // 0x0260 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[223];

        return pClassPointer;
    };

    void UpdateController();
    void ClientWeaponSet();
    void ChangedWeapon();
    void ClearPendingWeapon();
    void CancelWeaponChange();
    void SetPendingWeapon();
    void InternalSetCurrentWeapon();
    void ServerSetCurrentWeapon();
    void SetCurrentWeapon();
    void NextWeapon();
    void PrevWeapon();
    void SwitchToBestWeapon();
    void GetBestWeapon();
    void GetWeaponRatingFor();
    void DrawHUD();
    void OwnerDied();
    void eventDiscardInventory();
    void RemoveFromInventory();
    void AddInventory();
    void CreateInventory();
    void eventFindInventoryType();
    void HandlePickupQuery();
    void eventDestroyed();
    void SetupFor();
    void InventoryActors();
    void ClearAllPendingFire();
    void IsPendingFire();
    void ClearPendingFire();
    void SetPendingFire();
    void GetPendingFireLength();
    void eventPostBeginPlay();
};

UClass* AInventoryManager::pClassPointer = NULL;

// Class Engine.Keypoint
// 0x0008 (0x024C - 0x0244)
class AKeypoint : public AActor {
   public:
    class USpriteComponent* SpriteComp;  // 0x0244 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[225];

        return pClassPointer;
    };
};

UClass* AKeypoint::pClassPointer = NULL;

// Class Engine.TargetPoint
// 0x000C (0x0258 - 0x024C)
class ATargetPoint : public AKeypoint {
   public:
    class UTexture2D*
        SpawnSpriteTexture;  // 0x024C (0x0008) [0x0000000000000000]
    int SpawnRefCount;       // 0x0254 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[227];

        return pClassPointer;
    };
};

UClass* ATargetPoint::pClassPointer = NULL;

// Class Engine.MaterialInstanceActor
// 0x0008 (0x024C - 0x0244)
class AMaterialInstanceActor : public AActor {
   public:
    class UMaterialInstanceConstant*
        MatInst;  // 0x0244 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[229];

        return pClassPointer;
    };
};

UClass* AMaterialInstanceActor::pClassPointer = NULL;

// Class Engine.MatineeActor
// 0x00E0 (0x0324 - 0x0244)
class AMatineeActor : public AActor {
   public:
    class USeqAct_Interp* InterpAction;  // 0x0244 (0x0008) [0x0000000000150000]
                                         // ( CPF_Travel | CPF_GlobalConfig )
    DWORD bIsPlaying : 1;  // 0x024C (0x0004) [0x0000000000160020] [0x00000001]
                           // ( CPF_Net | CPF_EditConst | CPF_GlobalConfig )
    DWORD bReversePlayback : 1;  // 0x024C (0x0004) [0x0000000000170020]
                                 // [0x00000002] ( CPF_Net | CPF_Travel |
                                 // CPF_EditConst | CPF_GlobalConfig )
    DWORD bPaused : 1;  // 0x024C (0x0004) [0x0000000000180020] [0x00000004] (
                        // CPF_Net | CPF_Component )
    DWORD AllAIGroupsInitialized : 1;  // 0x024C (0x0004) [0x0000000000000000]
                                       // [0x00000008]
    float PlayRate;  // 0x0250 (0x0004) [0x0000000000190020]              (
                     // CPF_Net | CPF_Travel | CPF_Component )
    float Position;  // 0x0254 (0x0004) [0x00000000001A0020]              (
                     // CPF_Net | CPF_EditConst | CPF_Component )
    struct FName
        AIGroupNames[0xA];  // 0x0258 (0x0050) [0x00000000001B0020] ( CPF_Net |
                            // CPF_Travel | CPF_EditConst | CPF_Component )
    class APawn*
        AIGroupPawns[0xA];  // 0x02A8 (0x0050) [0x0000000000250020] ( CPF_Net |
                            // CPF_Travel | CPF_GlobalConfig )
    int AIGroupInitStage[0xA];  // 0x02F8 (0x0028) [0x0000000000000000]
    float ClientSidePositionErrorTolerance;  // 0x0320 (0x0004)
                                             // [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[231];

        return pClassPointer;
    };

    void CheckPriorityRefresh();
    void eventUpdate();
    void AddAIGroupActor();
};

UClass* AMatineeActor::pClassPointer = NULL;

// Class Engine.NavigationPoint
// 0x0138 (0x037C - 0x0244)
class ANavigationPoint : public AActor {
   public:
    DWORD bEndPoint : 1;  // 0x0244 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bTransientEndPoint : 1;  // 0x0244 (0x0004) [0x0000000000000000]
                                   // [0x00000002]
    DWORD bHideEditorPaths : 1;    // 0x0244 (0x0004) [0x0000000000000000]
                                   // [0x00000004]
    DWORD bCanReach : 1;    // 0x0244 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bBlocked : 1;     // 0x0244 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bOneWayPath : 1;  // 0x0244 (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bNeverUseStrafing : 1;   // 0x0244 (0x0004) [0x0000000000000000]
                                   // [0x00000040]
    DWORD bAlwaysUseStrafing : 1;  // 0x0244 (0x0004) [0x0000000000000000]
                                   // [0x00000080]
    DWORD bForceNoStrafing : 1;    // 0x0244 (0x0004) [0x0000000000000000]
                                   // [0x00000100]
    DWORD bAutoBuilt : 1;  // 0x0244 (0x0004) [0x0000000000000000] [0x00000200]
    DWORD
        bSpecialMove : 1;  // 0x0244 (0x0004) [0x0000000000000000] [0x00000400]
    DWORD bAllowPathConnections : 1;  // 0x0244 (0x0004) [0x0000000000000000]
                                      // [0x00000800]
    DWORD bWallNode : 1;  // 0x0244 (0x0004) [0x0000000000000000] [0x00001000]
    DWORD bNoAutoConnect : 1;            // 0x0244 (0x0004) [0x0000000000000000]
                                         // [0x00002000]
    DWORD bNotifyOnAddToRouteCache : 1;  // 0x0244 (0x0004) [0x0000000000000000]
                                         // [0x00004000]
    DWORD bNotBased : 1;  // 0x0244 (0x0004) [0x0000000000000000] [0x00008000]
    DWORD
        bPathsChanged : 1;  // 0x0244 (0x0004) [0x0000000000000000] [0x00010000]
    DWORD bDestinationOnly : 1;  // 0x0244 (0x0004) [0x0000000000000000]
                                 // [0x00020000]
    DWORD bSourceOnly : 1;  // 0x0244 (0x0004) [0x0000000000000000] [0x00040000]
    DWORD bSpecialForced : 1;    // 0x0244 (0x0004) [0x0000000000000000]
                                 // [0x00080000]
    DWORD bMustBeReachable : 1;  // 0x0244 (0x0004) [0x0000000000000000]
                                 // [0x00100000]
    DWORD bBlockable : 1;  // 0x0244 (0x0004) [0x0000000000000000] [0x00200000]
    DWORD bFlyingPreferred : 1;  // 0x0244 (0x0004) [0x0000000000000000]
                                 // [0x00400000]
    DWORD
        bMayCausePain : 1;  // 0x0244 (0x0004) [0x0000000000000000] [0x00800000]
    DWORD bAlreadyVisited : 1;           // 0x0244 (0x0004) [0x0000000000000000]
                                         // [0x01000000]
    DWORD bVehicleDestination : 1;       // 0x0244 (0x0004) [0x0000000000000000]
                                         // [0x02000000]
    DWORD bMakeSourceOnly : 1;           // 0x0244 (0x0004) [0x0000000000000000]
                                         // [0x04000000]
    DWORD bMustTouchToReach : 1;         // 0x0244 (0x0004) [0x0000000000000000]
                                         // [0x08000000]
    DWORD bCanWalkOnToReach : 1;         // 0x0244 (0x0004) [0x0000000000000000]
                                         // [0x10000000]
    DWORD bBuildLongPaths : 1;           // 0x0244 (0x0004) [0x0000000000000000]
                                         // [0x20000000]
    DWORD bBlockedForVehicles : 1;       // 0x0244 (0x0004) [0x0000000000000000]
                                         // [0x40000000]
    DWORD bPreferredVehiclePath : 1;     // 0x0244 (0x0004) [0x0000000000000000]
                                         // [0x80000000]
    DWORD bHasCrossLevelPaths : 1;       // 0x0248 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bShouldSaveForCheckpoint : 1;  // 0x0248 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bConnectToSameFloorOnly : 1;   // 0x0248 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD bNoAutoConnectBiDirectional : 1;  // 0x0248 (0x0004)
                                            // [0x0000000000000000] [0x00000008]
    DWORD
        bBadPlacement : 1;  // 0x0248 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bUnnecessaryNavPoint : 1;  // 0x0248 (0x0004) [0x0000000000000000]
                                     // [0x00000020]
    struct FNavigationOctreeObject
        NavOctreeObject;                 // 0x024C (0x003C) [0x0000000000000000]
    float Luminance;                     // 0x0288 (0x0004) [0x0000000000000000]
    struct FLinearColor Intensity;       // 0x028C (0x0010) [0x0000000000000000]
    struct FName DebugTag;               // 0x029C (0x0008) [0x0000000000000000]
    TArray<class UReachSpec*> PathList;  // 0x02A4 (0x0010) [0x0000000000000000]
    TArray<struct FActorReference>
        EditorProscribedPaths;  // 0x02B4 (0x0010) [0x0000000000000000]
    TArray<struct FActorReference>
        EditorForcedPaths;  // 0x02C4 (0x0010) [0x0000000000000000]
    TArray<struct FActorReference>
        Volumes;         // 0x02D4 (0x0010) [0x0000000000000000]
    int visitedWeight;   // 0x02E4 (0x0004) [0x0000000000000000]
    int bestPathWeight;  // 0x02E8 (0x0004) [0x0000000000000000]
    class ANavigationPoint*
        nextNavigationPoint;  // 0x02EC (0x0008) [0x0000000000000000]
    class ANavigationPoint*
        nextOrdered;  // 0x02F4 (0x0008) [0x0000000000000000]
    class ANavigationPoint*
        prevOrdered;  // 0x02FC (0x0008) [0x0000000000000000]
    class ANavigationPoint*
        previousPath;   // 0x0304 (0x0008) [0x0000000000000000]
    int Cost;           // 0x030C (0x0004) [0x0000000000000000]
    int ExtraCost;      // 0x0310 (0x0004) [0x0000000000000000]
    int TransientCost;  // 0x0314 (0x0004) [0x0000000000000000]
    int FearCost;       // 0x0318 (0x0004) [0x0000000000000000]
    TArray<struct FDebugNavCost>
        CostArray;  // 0x031C (0x0010) [0x0000000000000000]
    class ADroppedPickup*
        InventoryCache;      // 0x032C (0x0008) [0x0000000000000000]
    float InventoryDist;     // 0x0334 (0x0004) [0x0000000000000000]
    float LastDetourWeight;  // 0x0338 (0x0004) [0x0000000000000000]
    class UCylinderComponent*
        CylinderComponent;               // 0x033C (0x0008) [0x0000000000000000]
    struct FCylinder MaxPathSize;        // 0x0344 (0x0008) [0x0000000000000000]
    struct FGuid NavGuid;                // 0x034C (0x0010) [0x0000000000000000]
    class USpriteComponent* GoodSprite;  // 0x035C (0x0008) [0x0000000000000000]
    class USpriteComponent* BadSprite;   // 0x0364 (0x0008) [0x0000000000000000]
    int NetworkID;                       // 0x036C (0x0004) [0x0000000000000000]
    class APawn* AnchoredPawn;           // 0x0370 (0x0008) [0x0000000000000000]
    float LastAnchoredPawnTime;          // 0x0378 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[233];

        return pClassPointer;
    };

    void eventGetDebugAbbrev();
    void ApplyCheckpointRecord();
    void CreateCheckpointRecord();
    void ShouldSaveForCheckpoint();
    void eventShutDown();
    void OnToggle();
    void IsOnDifferentNetwork();
    void GetAllNavInRadius();
    void GetNearestNavToPoint();
    void GetNearestNavToActor();
    void ProceedWithMove();
    void eventSuggestMovePreparation();
    void eventDetourWeight();
    void eventAccept();
    void eventSpecialCost();
    void CanTeleport();
    void IsUsableAnchorFor();
    void GetReachSpecTo();
    void GetBoundingCylinder();
};

UClass* ANavigationPoint::pClassPointer = NULL;

// Class Engine.CoverLink
// 0x0099 (0x0415 - 0x037C)
class ACoverLink : public ANavigationPoint {
   public:
    DWORD GLOBAL_bUseSlotMarkers : 1;  // 0x037C (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bDisabled : 1;  // 0x037C (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bClaimAllSlots : 1;  // 0x037C (0x0004) [0x0000000000000000]
                               // [0x00000004]
    DWORD bAutoSort : 1;    // 0x037C (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bAutoAdjust : 1;  // 0x037C (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bCircular : 1;    // 0x037C (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bLooped : 1;      // 0x037C (0x0004) [0x0000000000000000] [0x00000040]
    DWORD bPlayerOnly : 1;  // 0x037C (0x0004) [0x0000000000000000] [0x00000080]
    DWORD
        bDynamicCover : 1;  // 0x037C (0x0004) [0x0000000000000000] [0x00000100]
    DWORD bFractureOnTouch : 1;         // 0x037C (0x0004) [0x0000000000000000]
                                        // [0x00000200]
    DWORD bDebug_FireLinks : 1;         // 0x037C (0x0004) [0x0000000000000000]
                                        // [0x00000400]
    DWORD bDebug_ExposedLinks : 1;      // 0x037C (0x0004) [0x0000000000000000]
                                        // [0x00000800]
    DWORD bDebug_CoverGen : 1;          // 0x037C (0x0004) [0x0000000000000000]
                                        // [0x00001000]
    DWORD bDoAutoSlotDensityFixup : 1;  // 0x037C (0x0004) [0x0000000000000000]
                                        // [0x00002000]
    float LeanTraceDist;                // 0x0380 (0x0004) [0x0000000000000000]
    TArray<struct FCoverSlot> Slots;    // 0x0384 (0x0010) [0x0000000000000000]
    TArray<struct FDynamicLinkInfo>
        DynamicLinkInfos;               // 0x0394 (0x0010) [0x0000000000000000]
    TArray<class APawn*> Claims;        // 0x03A4 (0x0010) [0x0000000000000000]
    float InvalidateDistance;           // 0x03B4 (0x0004) [0x0000000000000000]
    float MaxFireLinkDist;              // 0x03B8 (0x0004) [0x0000000000000000]
    struct FVector CircularOrigin;      // 0x03BC (0x000C) [0x0000000000000000]
    float CircularRadius;               // 0x03C8 (0x0004) [0x0000000000000000]
    float AlignDist;                    // 0x03CC (0x0004) [0x0000000000000000]
    float AutoCoverSlotInterval;        // 0x03D0 (0x0004) [0x0000000000000000]
    float StandHeight;                  // 0x03D4 (0x0004) [0x0000000000000000]
    float MidHeight;                    // 0x03D8 (0x0004) [0x0000000000000000]
    struct FVector StandingLeanOffset;  // 0x03DC (0x000C) [0x0000000000000000]
    struct FVector CrouchLeanOffset;    // 0x03E8 (0x000C) [0x0000000000000000]
    struct FVector PopupOffset;         // 0x03F4 (0x000C) [0x0000000000000000]
    float SlipDist;                     // 0x0400 (0x0004) [0x0000000000000000]
    float TurnDist;                     // 0x0404 (0x0004) [0x0000000000000000]
    float DangerScale;                  // 0x0408 (0x0004) [0x0000000000000000]
    class ACoverLink* NextCoverLink;    // 0x040C (0x0008) [0x0000000000000000]
    unsigned char LocationDescription;  // 0x0414 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[235];

        return pClassPointer;
    };

    void eventGetDebugAbbrev();
    void GetLocationDescription();
    void eventGetDebugString();
    void AddCoverSlot();
    void eventTick();
    void BreakFracturedMeshes();
    void GetSwatTurnTarget();
    void eventShutDown();
    void ApplyCheckpointRecord();
    void CreateCheckpointRecord();
    void OnToggle();
    void IsEnabled();
    void AutoAdjustSlot();
    void OnModifyCover();
    void eventSetSlotPlayerOnly();
    void NotifySlotOwnerCoverDisabled();
    void eventSetSlotEnabled();
    void eventSetDisabled();
    void GetSlotActions();
    void HasFireLinkTo();
    void GetFireLinkTo();
    void AllowLeftTransition();
    void AllowRightTransition();
    void GetSlotIdxToRight();
    void GetSlotIdxToLeft();
    void IsRightEdgeSlot();
    void IsLeftEdgeSlot();
    void IsEdgeSlot();
    void FindSlots();
    void IsStationarySlot();
    void IsValidClaimBetween();
    void IsValidClaim();
    void eventUnClaim();
    void eventClaim();
    void eventSetInvalidUntil();
    void IsExposedTo();
    void GetSlotViewPoint();
    void GetSlotRotation();
    void GetSlotLocation();
    void UnPackFireLinkInteractionInfo();
    void PackFireLinkInteractionInfo();
    void GetFireLinkTargetCoverInfo();
};

UClass* ACoverLink::pClassPointer = NULL;

// Class Engine.DoorMarker
// 0x0018 (0x0394 - 0x037C)
class ADoorMarker : public ANavigationPoint {
   public:
    class AInterpActor* MyDoor;  // 0x037C (0x0008) [0x0000000000000000]
    unsigned char DoorType;      // 0x0384 (0x0001) [0x0000000000000000]
    class AActor* DoorTrigger;   // 0x0388 (0x0008) [0x0000000000000000]
    DWORD bWaitUntilCompletelyOpened : 1;  // 0x0390 (0x0004)
                                           // [0x0000000000000000] [0x00000001]
    DWORD bInitiallyClosed : 1;    // 0x0390 (0x0004) [0x0000000000000000]
                                   // [0x00000002]
    DWORD bBlockedWhenClosed : 1;  // 0x0390 (0x0004) [0x0000000000000000]
                                   // [0x00000004]
    DWORD bDoorOpen : 1;  // 0x0390 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bTempDisabledCollision : 1;  // 0x0390 (0x0004) [0x0000000000000000]
                                       // [0x00000010]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[237];

        return pClassPointer;
    };

    void eventSuggestMovePreparation();
    void ProceedWithMove();
    void eventSpecialHandling();
    void MoverClosed();
    void MoverOpened();
    void eventPostBeginPlay();
};

UClass* ADoorMarker::pClassPointer = NULL;

// Class Engine.DynamicAnchor
// 0x0008 (0x0384 - 0x037C)
class ADynamicAnchor : public ANavigationPoint {
   public:
    class AController* CurrentUser;  // 0x037C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[239];

        return pClassPointer;
    };
};

UClass* ADynamicAnchor::pClassPointer = NULL;

// Class Engine.Ladder
// 0x0010 (0x038C - 0x037C)
class ALadder : public ANavigationPoint {
   public:
    class ALadderVolume* MyLadder;  // 0x037C (0x0008) [0x0000000000000000]
    class ALadder* LadderList;      // 0x0384 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[241];

        return pClassPointer;
    };

    void eventSuggestMovePreparation();
};

UClass* ALadder::pClassPointer = NULL;

// Class Engine.AutoLadder
// 0x0000 (0x038C - 0x038C)
class AAutoLadder : public ALadder {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[243];

        return pClassPointer;
    };
};

UClass* AAutoLadder::pClassPointer = NULL;

// Class Engine.LiftCenter
// 0x0028 (0x03A4 - 0x037C)
class ALiftCenter : public ANavigationPoint {
   public:
    class AInterpActor* MyLift;  // 0x037C (0x0008) [0x0000000000000000]
    float MaxDist2D;             // 0x0384 (0x0004) [0x0000000000000000]
    struct FVector LiftOffset;   // 0x0388 (0x000C) [0x0000000000000000]
    DWORD bJumpLift : 1;    // 0x0394 (0x0004) [0x0000000000000000] [0x00000001]
    float CollisionHeight;  // 0x0398 (0x0004) [0x0000000000000000]
    class ATrigger* LiftTrigger;  // 0x039C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[245];

        return pClassPointer;
    };

    void ProceedWithMove();
    void eventSuggestMovePreparation();
    void eventSpecialHandling();
    void eventPostBeginPlay();
};

UClass* ALiftCenter::pClassPointer = NULL;

// Class Engine.LiftExit
// 0x000C (0x0388 - 0x037C)
class ALiftExit : public ANavigationPoint {
   public:
    class ALiftCenter* MyLiftCenter;  // 0x037C (0x0008) [0x0000000000000000]
    DWORD bExitOnly : 1;  // 0x0384 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[247];

        return pClassPointer;
    };

    void eventSuggestMovePreparation();
    void WaitForLift();
    void CanBeReachedFromLiftBy();
};

UClass* ALiftExit::pClassPointer = NULL;

// Class Engine.PathNode
// 0x0000 (0x037C - 0x037C)
class APathNode : public ANavigationPoint {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[249];

        return pClassPointer;
    };

    void eventGetDebugAbbrev();
};

UClass* APathNode::pClassPointer = NULL;

// Class Engine.VolumePathNode
// 0x0008 (0x0384 - 0x037C)
class AVolumePathNode : public APathNode {
   public:
    float StartingRadius;  // 0x037C (0x0004) [0x0000000000000000]
    float StartingHeight;  // 0x0380 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[251];

        return pClassPointer;
    };
};

UClass* AVolumePathNode::pClassPointer = NULL;

// Class Engine.PickupFactory
// 0x002C (0x03A8 - 0x037C)
class APickupFactory : public ANavigationPoint {
   public:
    DWORD bOnlyReplicateHidden : 1;  // 0x037C (0x0004) [0x0000000000000000]
                                     // [0x00000001]
    DWORD bPickupHidden : 1;         // 0x037C (0x0004) [0x0000000000150000]
                              // [0x00000002] ( CPF_Travel | CPF_GlobalConfig )
    DWORD bPredictRespawns : 1;  // 0x037C (0x0004) [0x0000000000000000]
                                 // [0x00000004]
    DWORD
        bIsSuperItem : 1;  // 0x037C (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bRespawnPaused : 1;  // 0x037C (0x0004) [0x0000000000000000]
                               // [0x00000010]
    class UClass*
        InventoryType;  // 0x0380 (0x0008) [0x0000000000160020]              (
                        // CPF_Net | CPF_EditConst | CPF_GlobalConfig )
    float RespawnEffectTime;  // 0x0388 (0x0004) [0x0000000000000000]
    float MaxDesireability;   // 0x038C (0x0004) [0x0000000000000000]
    class UPrimitiveComponent*
        PickupMesh;  // 0x0390 (0x0008) [0x0000000000000000]
    class APickupFactory*
        ReplacementFactory;  // 0x0398 (0x0008) [0x0000000000000000]
    class APickupFactory*
        OriginalFactory;  // 0x03A0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[253];

        return pClassPointer;
    };

    void DelayRespawn();
    void eventDestroyed();
    void SetPickupVisible();
    void SetPickupHidden();
    void RespawnEffect();
    void GetRespawnTime();
    void RecheckValidTouch();
    void PickedUpBy();
    void GiveTo();
    void ReadyToPickup();
    void SpawnCopyFor();
    void eventDetourWeight();
    void StartSleeping();
    void SetRespawn();
    void CheckForErrors();
    void Reset();
    void SetPickupMesh();
    void ShutDown();
    void eventSetInitialState();
    void InitializePickup();
    void eventPreBeginPlay();
    void eventReplicatedEvent();
};

UClass* APickupFactory::pClassPointer = NULL;

// Class Engine.PlayerStart
// 0x0010 (0x038C - 0x037C)
class APlayerStart : public ANavigationPoint {
   public:
    DWORD bEnabled : 1;  // 0x037C (0x0004) [0x0000000000000000] [0x00000001]
    DWORD
        bPrimaryStart : 1;  // 0x037C (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bBestStart : 1;   // 0x037C (0x0004) [0x0000000000000000] [0x00000004]
    int TeamIndex;          // 0x0380 (0x0004) [0x0000000000000000]
    int Score;              // 0x0384 (0x0004) [0x0000000000000000]
    int SelectionIndex;     // 0x0388 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[255];

        return pClassPointer;
    };

    void eventPostRenderFor();
    void OnToggle();
};

UClass* APlayerStart::pClassPointer = NULL;

// Class Engine.PortalMarker
// 0x0008 (0x0384 - 0x037C)
class APortalMarker : public ANavigationPoint {
   public:
    class APortalTeleporter* MyPortal;  // 0x037C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[257];

        return pClassPointer;
    };

    void CanTeleport();
};

UClass* APortalMarker::pClassPointer = NULL;

// Class Engine.Pylon
// 0x0130 (0x04AC - 0x037C)
class APylon : public ANavigationPoint {
   public:
    struct FPointer
        VfTable_IEditorLinkSelectionInterface;  // 0x037C (0x0008)
                                                // [0x0000000000000000]
    struct FPointer
        VfTable_IInterface_NavigationHandle;  // 0x0384 (0x0008)
                                              // [0x0000000000000000]
    struct FPointer NavMeshPtr;    // 0x038C (0x0008) [0x0000000000000000]
    struct FPointer ObstacleMesh;  // 0x0394 (0x0008) [0x0000000000000000]
    struct FPointer
        DynamicObstacleMesh;        // 0x039C (0x0008) [0x0000000000000000]
    struct FPointer WorkingSetPtr;  // 0x03A4 (0x0008) [0x0000000000000000]
    struct FPointer
        PathObjectsThatAffectThisPylon;  // 0x03AC (0x0008) [0x0000000000000000]
    TArray<struct FVector>
        NextPassSeedList;               // 0x03B4 (0x0010) [0x0000000000000000]
    struct FOctreeElementId OctreeId;   // 0x03C4 (0x000C) [0x0000000000000000]
    struct FPointer OctreeIWasAddedTo;  // 0x03D0 (0x0008) [0x0000000000000000]
    class APylon* NextPylon;            // 0x03D8 (0x0008) [0x0000000000000000]
    TArray<class AVolume*>
        ExpansionVolumes;      // 0x03E0 (0x0010) [0x0000000000000000]
    float ExpansionRadius;     // 0x03F0 (0x0004) [0x0000000000000000]
    float MaxExpansionRadius;  // 0x03F4 (0x0004) [0x0000000000000000]
    class UDrawPylonRadiusComponent*
        PylonRadiusPreview;  // 0x03F8 (0x0008) [0x0000000000000000]
    DWORD
        bImportedMesh : 1;  // 0x0400 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bUseExpansionSphereOverride : 1;  // 0x0400 (0x0004)
                                            // [0x0000000000000000] [0x00000002]
    DWORD bNeedsCostCheck : 1;        // 0x0400 (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    DWORD bPylonInHighLevelPath : 1;  // 0x0400 (0x0004) [0x0000000000000000]
                                      // [0x00000008]
    DWORD bUseRecast : 1;  // 0x0400 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bAllowRecastGenerator : 1;   // 0x0400 (0x0004) [0x0000000000000000]
                                       // [0x00000020]
    DWORD bAllowNavMeshOverLoads : 1;  // 0x0400 (0x0004) [0x0000000000000000]
                                       // [0x00000040]
    DWORD bHightlightOneWayReachSpecs : 1;  // 0x0400 (0x0004)
                                            // [0x0000000000000000] [0x00000080]
    DWORD bDrawEdgePolys : 1;         // 0x0400 (0x0004) [0x0000000000000000]
                                      // [0x00000100]
    DWORD bDrawPolyBounds : 1;        // 0x0400 (0x0004) [0x0000000000000000]
                                      // [0x00000200]
    DWORD bRenderInShowPaths : 1;     // 0x0400 (0x0004) [0x0000000000000000]
                                      // [0x00000400]
    DWORD bDrawWalkableSurface : 1;   // 0x0400 (0x0004) [0x0000000000000000]
                                      // [0x00000800]
    DWORD bDrawObstacleSurface : 1;   // 0x0400 (0x0004) [0x0000000000000000]
                                      // [0x00001000]
    DWORD bSolidObstaclesInGame : 1;  // 0x0400 (0x0004) [0x0000000000000000]
                                      // [0x00002000]
    DWORD bBuildThisPylon : 1;        // 0x0400 (0x0004) [0x0000000000000000]
                                      // [0x00004000]
    DWORD bDisabled : 1;  // 0x0400 (0x0004) [0x0000000000000000] [0x00008000]
    DWORD bForceObstacleMeshCollision : 1;  // 0x0400 (0x0004)
                                            // [0x0000000000000000] [0x00010000]
    struct FVector
        ExpansionSphereCenter;  // 0x0404 (0x000C) [0x0000000000000000]
    class UNavMeshRenderingComponent*
        RenderingComp;  // 0x0410 (0x0008) [0x0000000000000000]
    class USpriteComponent*
        BrokenSprite;  // 0x0418 (0x0008) [0x0000000000000000]
    TArray<class APylon*>
        ImposterPylons;  // 0x0420 (0x0010) [0x0000000000000000]
    TArray<class AActor*>
        OnBuild_DisableCollisionForThese;  // 0x0430 (0x0010)
                                           // [0x0000000000000000]
    TArray<class AActor*>
        OnBuild_EnableCollisionForThese;  // 0x0440 (0x0010)
                                          // [0x0000000000000000]
    float MaxPolyHeight_Optional;    // 0x0450 (0x0004) [0x0000000000000000]
    unsigned char NavMeshGenerator;  // 0x0454 (0x0001) [0x0000000000000000]
    float Recast_CellSize;           // 0x0458 (0x0004) [0x0000000000000000]
    float Recast_CellHeight;         // 0x045C (0x0004) [0x0000000000000000]
    float Recast_AgentMaxSlope;      // 0x0460 (0x0004) [0x0000000000000000]
    float NavMeshGen_MaxStepHeight;  // 0x0464 (0x0004) [0x0000000000000000]
    float NavMeshGen_MinPolyArea;    // 0x0468 (0x0004) [0x0000000000000000]
    TArray<struct FKAggregateGeom>
        VoxelFilterBounds;  // 0x046C (0x0010) [0x0000000000000000]
    TArray<struct FMatrix>
        VoxelFilterTM;  // 0x047C (0x0010) [0x0000000000000000]
    float
        BufferEpsilonToAddedToBoundsBoxForDropEdgeCheck;  // 0x048C (0x0004)
                                                          // [0x0000000000000000]
    int DebugEdgeCount;              // 0x0490 (0x0004) [0x0000000000000000]
    struct FVector DebugPathExtent;  // 0x0494 (0x000C) [0x0000000000000000]
    struct FVector
        DebugPathStartLocation;  // 0x04A0 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[259];

        return pClassPointer;
    };

    void CanReachPylon();
    void OnToggle();
    void eventIsEnabled();
    void eventSetEnabled();
    void PostBeginPlay();
    void eventNotifyPathChanged();
    void VerifyTopLevelConnections();
    void GetTestPathExtent();
    void FlushDynamicEdges();
    void UpdateMeshForPreExistingNavMeshObstacles();
    void OnPylonStatusChange();
};

UClass* APylon::pClassPointer = NULL;

// Class Engine.AISwitchablePylon
// 0x0004 (0x04B0 - 0x04AC)
class AAISwitchablePylon : public APylon {
   public:
    DWORD bOpen : 1;  // 0x04AC (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[261];

        return pClassPointer;
    };

    void eventIsEnabled();
    void eventSetEnabled();
    void PostBeginPlay();
};

UClass* AAISwitchablePylon::pClassPointer = NULL;

// Class Engine.DynamicPylon
// 0x0004 (0x04B0 - 0x04AC)
class ADynamicPylon : public APylon {
   public:
    DWORD bMoving : 1;  // 0x04AC (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[263];

        return pClassPointer;
    };

    void eventStoppedMoving();
    void eventStartedMoving();
    void FlushDynamicEdges();
    void RebuildDynamicEdges();
    void PostBeginPlay();
};

UClass* ADynamicPylon::pClassPointer = NULL;

// Class Engine.Teleporter
// 0x002C (0x03A8 - 0x037C)
class ATeleporter : public ANavigationPoint {
   public:
    struct FString URL;  // 0x037C (0x0010) [0x0000000000150000]              (
                         // CPF_Travel | CPF_GlobalConfig )
    struct FName ProductRequired;  // 0x038C (0x0008) [0x0000000000000000]
    DWORD bChangesVelocity : 1;    // 0x0394 (0x0004) [0x0000000000160011]
                                 // [0x00000001] ( CPF_Edit | CPF_OptionalParm |
                                 // CPF_EditConst | CPF_GlobalConfig )
    DWORD bChangesYaw : 1;  // 0x0394 (0x0004) [0x0000000000170011] [0x00000002]
                            // ( CPF_Edit | CPF_OptionalParm | CPF_Travel |
                            // CPF_EditConst | CPF_GlobalConfig )
    DWORD bReversesX : 1;   // 0x0394 (0x0004) [0x0000000000180011] [0x00000004]
                            // ( CPF_Edit | CPF_OptionalParm | CPF_Component )
    DWORD bReversesY : 1;   // 0x0394 (0x0004) [0x0000000000190011] [0x00000008]
                            // ( CPF_Edit | CPF_OptionalParm | CPF_Travel |
                            // CPF_Component )
    DWORD bReversesZ : 1;   // 0x0394 (0x0004) [0x00000000001A0011] [0x00000010]
                            // ( CPF_Edit | CPF_OptionalParm | CPF_EditConst |
                            // CPF_Component )
    DWORD bEnabled : 1;  // 0x0394 (0x0004) [0x00000000001B0000] [0x00000020] (
                         // CPF_Travel | CPF_EditConst | CPF_Component )
    DWORD bCanTeleportVehicles : 1;  // 0x0394 (0x0004) [0x0000000000000000]
                                     // [0x00000040]
    struct FVector TargetVelocity;   // 0x0398 (0x000C) [0x00000000001C0011] (
                                    // CPF_Edit | CPF_OptionalParm |
                                    // CPF_GlobalConfig | CPF_Component )
    float LastFired;  // 0x03A4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[265];

        return pClassPointer;
    };

    void eventSpecialHandling();
    void eventPostTouch();
    void eventTouch();
    void eventAccept();
    void eventPostBeginPlay();
    void CanTeleport();
};

UClass* ATeleporter::pClassPointer = NULL;

// Class Engine.Note
// 0x0010 (0x0254 - 0x0244)
class ANote : public AActor {
   public:
    struct FString Text;  // 0x0244 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[267];

        return pClassPointer;
    };
};

UClass* ANote::pClassPointer = NULL;

// Class Engine.Projectile
// 0x005C (0x02A0 - 0x0244)
class AProjectile : public AActor {
   public:
    float Speed;                       // 0x0244 (0x0004) [0x0000000000000000]
    float MaxSpeed;                    // 0x0248 (0x0004) [0x0000000000000000]
    DWORD bSwitchToZeroCollision : 1;  // 0x024C (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bBlockedByInstigator : 1;    // 0x024C (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD bBegunPlay : 1;  // 0x024C (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bRotationFollowsVelocity : 1;  // 0x024C (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    DWORD bIgnoreFoliageTouch : 1;       // 0x024C (0x0004) [0x0000000000000000]
                                         // [0x00000010]
    class AActor* ZeroCollider;          // 0x0250 (0x0008) [0x0000000000000000]
    class UPrimitiveComponent*
        ZeroColliderComponent;     // 0x0258 (0x0008) [0x0000000000000000]
    float Damage;                  // 0x0260 (0x0004) [0x0000000000000000]
    float DamageRadius;            // 0x0264 (0x0004) [0x0000000000000000]
    float MomentumTransfer;        // 0x0268 (0x0004) [0x0000000000000000]
    class UClass* MyDamageType;    // 0x026C (0x0008) [0x0000000000000000]
    class USoundCue* SpawnSound;   // 0x0274 (0x0008) [0x0000000000000000]
    class USoundCue* ImpactSound;  // 0x027C (0x0008) [0x0000000000000000]
    class AController*
        InstigatorController;      // 0x0284 (0x0008) [0x0000000000000000]
    class AActor* ImpactedActor;   // 0x028C (0x0008) [0x0000000000000000]
    float NetCullDistanceSquared;  // 0x0294 (0x0004) [0x0000000000000000]
    class UCylinderComponent*
        CylinderComponent;  // 0x0298 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[269];

        return pClassPointer;
    };

    void ApplyFluidSurfaceImpact();
    void GetRange();
    void StaticGetTimeToLocation();
    void GetTimeToLocation();
    void eventFellOutOfWorld();
    void IsStationary();
    void RandSpin();
    void Explode();
    void eventEncroachedBy();
    void eventHitWall();
    void ProcessTouch();
    void eventTouch();
    void HurtRadius();
    void ProjectileHurtRadius();
    void Reset();
    void CanSplash();
    void GetTeamNum();
    void Init();
    void eventPostBeginPlay();
    void eventPreBeginPlay();
    void eventEncroachingOn();
};

UClass* AProjectile::pClassPointer = NULL;

// Class Engine.RigidBodyBase
// 0x0000 (0x0244 - 0x0244)
class ARigidBodyBase : public AActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[271];

        return pClassPointer;
    };
};

UClass* ARigidBodyBase::pClassPointer = NULL;

// Class Engine.SceneCaptureActor
// 0x0008 (0x024C - 0x0244)
class ASceneCaptureActor : public AActor {
   public:
    class USceneCaptureComponent*
        SceneCapture;  // 0x0244 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[273];

        return pClassPointer;
    };

    void OnToggle();
};

UClass* ASceneCaptureActor::pClassPointer = NULL;

// Class Engine.SceneCapture2DActor
// 0x0008 (0x0254 - 0x024C)
class ASceneCapture2DActor : public ASceneCaptureActor {
   public:
    class UDrawFrustumComponent*
        DrawFrustum;  // 0x024C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[275];

        return pClassPointer;
    };
};

UClass* ASceneCapture2DActor::pClassPointer = NULL;

// Class Engine.SceneCaptureCubeMapActor
// 0x0010 (0x025C - 0x024C)
class ASceneCaptureCubeMapActor : public ASceneCaptureActor {
   public:
    class UStaticMeshComponent*
        StaticMesh;  // 0x024C (0x0008) [0x0000000000000000]
    class UMaterialInstanceConstant*
        CubeMaterialInst;  // 0x0254 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[277];

        return pClassPointer;
    };
};

UClass* ASceneCaptureCubeMapActor::pClassPointer = NULL;

// Class Engine.SceneCaptureReflectActor
// 0x0010 (0x025C - 0x024C)
class ASceneCaptureReflectActor : public ASceneCaptureActor {
   public:
    class UStaticMeshComponent*
        StaticMesh;  // 0x024C (0x0008) [0x0000000000000000]
    class UMaterialInstanceConstant*
        ReflectMaterialInst;  // 0x0254 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[279];

        return pClassPointer;
    };
};

UClass* ASceneCaptureReflectActor::pClassPointer = NULL;

// Class Engine.SceneCapturePortalActor
// 0x0000 (0x025C - 0x025C)
class ASceneCapturePortalActor : public ASceneCaptureReflectActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[281];

        return pClassPointer;
    };
};

UClass* ASceneCapturePortalActor::pClassPointer = NULL;

// Class Engine.PortalTeleporter
// 0x001C (0x0278 - 0x025C)
class APortalTeleporter : public ASceneCapturePortalActor {
   public:
    class APortalTeleporter*
        SisterPortal;                   // 0x025C (0x0008) [0x0000000000000000]
    int TextureResolutionX;             // 0x0264 (0x0004) [0x0000000000000000]
    int TextureResolutionY;             // 0x0268 (0x0004) [0x0000000000000000]
    class APortalMarker* MyMarker;      // 0x026C (0x0008) [0x0000000000000000]
    DWORD bMovablePortal : 1;           // 0x0274 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bAlwaysTeleportNonPawns : 1;  // 0x0274 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bCanTeleportVehicles : 1;     // 0x0274 (0x0004) [0x0000000000000000]
                                        // [0x00000004]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[283];

        return pClassPointer;
    };

    void StopsProjectile();
    void CreatePortalTexture();
    void TransformHitLocation();
    void TransformVectorDir();
    void TransformActor();
};

UClass* APortalTeleporter::pClassPointer = NULL;

// Class Engine.StaticMeshActorBase
// 0x0000 (0x0244 - 0x0244)
class AStaticMeshActorBase : public AActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[285];

        return pClassPointer;
    };
};

UClass* AStaticMeshActorBase::pClassPointer = NULL;

// Class Engine.StaticMeshActor
// 0x006C (0x02B0 - 0x0244)
class AStaticMeshActor : public AStaticMeshActorBase {
   public:
    class UStaticMeshComponent*
        StaticMeshComponent;  // 0x0244 (0x0008) [0x0000000000000000]
    DWORD bDisableAutoBaseOnProcBuilding : 1;  // 0x024C (0x0004)
                                               // [0x0000000000000000]
                                               // [0x00000001]
    DWORD bProxy : 1;  // 0x024C (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bHiddenByProxy : 1;  // 0x024C (0x0004) [0x0000000000000000]
                               // [0x00000004]
    DWORD
        OldCastShadow : 1;  // 0x024C (0x0004) [0x0000000000000000] [0x00000008]
    DWORD OldAcceptsLights : 1;  // 0x024C (0x0004) [0x0000000000000000]
                                 // [0x00000010]
    DWORD
        bResetCapable : 1;  // 0x024C (0x0004) [0x0000000000000000] [0x00000020]
    unsigned char OldCollisionType;      // 0x0250 (0x0001) [0x0000000000000000]
    unsigned char UnknownData00[0xF];    // 0x0251 (0x000F) MISSED OFFSET
    struct FMatrix DefaultLocalToWorld;  // 0x0260 (0x0040) [0x0000000000000000]
    TArray<struct FPreCombinedStaticMeshActor>
        PreCombinedStaticMeshActors;  // 0x02A0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[287];

        return pClassPointer;
    };

    void eventReset();
    void ResetToDefaults();
    void eventPreBeginPlay();
};

UClass* AStaticMeshActor::pClassPointer = NULL;

// Class Engine.StaticMeshCollectionActor
// 0x0014 (0x0258 - 0x0244)
class AStaticMeshCollectionActor : public AStaticMeshActorBase {
   public:
    TArray<class UStaticMeshComponent*>
        StaticMeshComponents;     // 0x0244 (0x0010) [0x0000000000000000]
    int MaxStaticMeshComponents;  // 0x0254 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[289];

        return pClassPointer;
    };
};

UClass* AStaticMeshCollectionActor::pClassPointer = NULL;

// Class Engine.StaticMeshActorBasedOnExtremeContent
// 0x0028 (0x026C - 0x0244)
class AStaticMeshActorBasedOnExtremeContent : public AActor {
   public:
    class UStaticMeshComponent*
        StaticMeshComponent;  // 0x0244 (0x0008) [0x0000000000000000]
    TArray<struct FSMMaterialSetterDatum>
        ExtremeContent;  // 0x024C (0x0010) [0x0000000000000000]
    TArray<struct FSMMaterialSetterDatum>
        NonExtremeContent;  // 0x025C (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[291];

        return pClassPointer;
    };

    void SetMaterialBasedOnExtremeContent();
    void eventPostBeginPlay();
};

UClass* AStaticMeshActorBasedOnExtremeContent::pClassPointer = NULL;

// Class Engine.Trigger
// 0x0010 (0x0254 - 0x0244)
class ATrigger : public AActor {
   public:
    class UCylinderComponent*
        CylinderComponent;         // 0x0244 (0x0008) [0x0000000000000000]
    DWORD bRecentlyTriggered : 1;  // 0x024C (0x0004) [0x0000000000000000]
                                   // [0x00000001]
    float AITriggerDelay;          // 0x0250 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[293];

        return pClassPointer;
    };

    void ApplyCheckpointRecord();
    void CreateCheckpointRecord();
    void ShouldSaveForCheckpoint();
    void StopsProjectile();
    void UnTrigger();
    void NotifyTriggered();
    void eventTouch();
    void eventPostBeginPlay();
};

UClass* ATrigger::pClassPointer = NULL;

// Class Engine.Trigger_PawnsOnly
// 0x0000 (0x0254 - 0x0254)
class ATrigger_PawnsOnly : public ATrigger {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[295];

        return pClassPointer;
    };
};

UClass* ATrigger_PawnsOnly::pClassPointer = NULL;

// Class Engine.ActorComponent
// 0x0015 (0x0085 - 0x0070)
class UActorComponent : public UComponent {
   public:
    struct FPointer Scene;  // 0x0070 (0x0008) [0x0000000000000000]
    class AActor* Owner;    // 0x0078 (0x0008) [0x0000000000000000]
    DWORD bAttached : 1;    // 0x0080 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD
        bTickInEditor : 1;  // 0x0080 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bNeedsReattach : 1;         // 0x0080 (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    DWORD bNeedsUpdateTransform : 1;  // 0x0080 (0x0004) [0x0000000000000000]
                                      // [0x00000008]
    unsigned char TickGroup;          // 0x0084 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[297];

        return pClassPointer;
    };

    void DetachFromAny();
    void ForceUpdate();
    void SetComponentRBFixed();
    void SetTickGroup();
};

UClass* UActorComponent::pClassPointer = NULL;

// Class Engine.AudioComponent
// 0x022B (0x02B0 - 0x0085)
class UAudioComponent : public UActorComponent {
   public:
    class USoundCue* SoundCue;       // 0x0088 (0x0008) [0x0000000000000000]
    class USoundNode* CueFirstNode;  // 0x0090 (0x0008) [0x0000000000000000]
    TArray<struct FAudioComponentParam>
        InstanceParameters;       // 0x0098 (0x0010) [0x0000000000000000]
    DWORD bUseOwnerLocation : 1;  // 0x00A8 (0x0004) [0x0000000000000000]
                                  // [0x00000001]
    DWORD bAutoPlay : 1;  // 0x00A8 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD
        bAutoDestroy : 1;  // 0x00A8 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bStopWhenOwnerDestroyed : 1;  // 0x00A8 (0x0004) [0x0000000000000000]
                                        // [0x00000008]
    DWORD
        bShouldRemainActiveIfDropped : 1;  // 0x00A8 (0x0004)
                                           // [0x0000000000000000] [0x00000010]
    DWORD
        bWasOccluded : 1;  // 0x00A8 (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bSuppressSubtitles : 1;  // 0x00A8 (0x0004) [0x0000000000000000]
                                   // [0x00000040]
    DWORD bWasPlaying : 1;  // 0x00A8 (0x0004) [0x0000000000000000] [0x00000080]
    DWORD bAllowSpatialization : 1;  // 0x00A8 (0x0004) [0x0000000000000000]
                                     // [0x00000100]
    DWORD bFinished : 1;  // 0x00A8 (0x0004) [0x0000000000000000] [0x00000200]
    DWORD bApplyRadioFilter : 1;     // 0x00A8 (0x0004) [0x0000000000000000]
                                     // [0x00000400]
    DWORD bRadioFilterSelected : 1;  // 0x00A8 (0x0004) [0x0000000000000000]
                                     // [0x00000800]
    DWORD bPreviewComponent : 1;     // 0x00A8 (0x0004) [0x0000000000000000]
                                     // [0x00001000]
    DWORD bIgnoreForFlushing : 1;    // 0x00A8 (0x0004) [0x0000000000000000]
                                     // [0x00002000]
    float StereoBleed;               // 0x00AC (0x0004) [0x0000000000000000]
    float LFEBleed;                  // 0x00B0 (0x0004) [0x0000000000000000]
    DWORD bEQFilterApplied : 1;      // 0x00B4 (0x0004) [0x0000000000000000]
                                     // [0x00000001]
    DWORD bAlwaysPlay : 1;  // 0x00B4 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bIsUISound : 1;   // 0x00B4 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bIsMusic : 1;     // 0x00B4 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bReverb : 1;      // 0x00B4 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bCenterChannelOnly : 1;  // 0x00B4 (0x0004) [0x0000000000000000]
                                   // [0x00000020]
    TArray<struct FPointer>
        WaveInstances;  // 0x00B8 (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        SoundNodeData;  // 0x00C8 (0x0010) [0x0000000000000000]
    unsigned char
        UnknownData00[0x48];  // 0x00D8 (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.AudioComponent.SoundNodeOffsetMap
    struct FMultiMap_Mirror
        SoundNodeResetWaveMap;           // 0x0120 (0x0048) [0x0000000000000000]
    struct FPointer Listener;            // 0x0168 (0x0008) [0x0000000000000000]
    float PlaybackTime;                  // 0x0170 (0x0004) [0x0000000000000000]
    class APortalVolume* PortalVolume;   // 0x0174 (0x0008) [0x0000000000000000]
    struct FVector Location;             // 0x017C (0x000C) [0x0000000000000000]
    struct FVector ComponentLocation;    // 0x0188 (0x000C) [0x0000000000000000]
    class AActor* LastOwner;             // 0x0194 (0x0008) [0x0000000000000000]
    float SubtitlePriority;              // 0x019C (0x0004) [0x0000000000000000]
    float FadeInStartTime;               // 0x01A0 (0x0004) [0x0000000000000000]
    float FadeInStopTime;                // 0x01A4 (0x0004) [0x0000000000000000]
    float FadeInTargetVolume;            // 0x01A8 (0x0004) [0x0000000000000000]
    float FadeOutStartTime;              // 0x01AC (0x0004) [0x0000000000000000]
    float FadeOutStopTime;               // 0x01B0 (0x0004) [0x0000000000000000]
    float FadeOutTargetVolume;           // 0x01B4 (0x0004) [0x0000000000000000]
    float AdjustVolumeStartTime;         // 0x01B8 (0x0004) [0x0000000000000000]
    float AdjustVolumeStopTime;          // 0x01BC (0x0004) [0x0000000000000000]
    float AdjustVolumeTargetVolume;      // 0x01C0 (0x0004) [0x0000000000000000]
    float CurrAdjustVolumeTargetVolume;  // 0x01C4 (0x0004) [0x0000000000000000]
    class USoundNode* CurrentNotifyBufferFinishedHook;  // 0x01C8 (0x0008)
                                                        // [0x0000000000000000]
    struct FVector CurrentLocation;  // 0x01D0 (0x000C) [0x0000000000000000]
    struct FVector CurrentVelocity;  // 0x01DC (0x000C) [0x0000000000000000]
    float CurrentVolume;             // 0x01E8 (0x0004) [0x0000000000000000]
    float CurrentPitch;              // 0x01EC (0x0004) [0x0000000000000000]
    float CurrentHighFrequencyGain;  // 0x01F0 (0x0004) [0x0000000000000000]
    int CurrentUseSpatialization;    // 0x01F4 (0x0004) [0x0000000000000000]
    int CurrentNotifyOnLoop;         // 0x01F8 (0x0004) [0x0000000000000000]
    float OmniRadius;                // 0x01FC (0x0004) [0x0000000000000000]
    float CurrentVolumeMultiplier;   // 0x0200 (0x0004) [0x0000000000000000]
    float CurrentPitchMultiplier;    // 0x0204 (0x0004) [0x0000000000000000]
    float CurrentHighFrequencyGainMultiplier;  // 0x0208 (0x0004)
                                               // [0x0000000000000000]
    float CurrentVoiceCenterChannelVolume;     // 0x020C (0x0004)
                                               // [0x0000000000000000]
    float CurrentRadioFilterVolume;  // 0x0210 (0x0004) [0x0000000000000000]
    float CurrentRadioFilterVolumeThreshold;  // 0x0214 (0x0004)
                                              // [0x0000000000000000]
    struct FDouble LastUpdateTime;  // 0x0218 (0x0008) [0x0000000000000000]
    float SourceInteriorVolume;     // 0x0220 (0x0004) [0x0000000000000000]
    float SourceInteriorLPF;        // 0x0224 (0x0004) [0x0000000000000000]
    float CurrentInteriorVolume;    // 0x0228 (0x0004) [0x0000000000000000]
    float CurrentInteriorLPF;       // 0x022C (0x0004) [0x0000000000000000]
    struct FVector LastLocation;    // 0x0230 (0x000C) [0x0000000000000000]
    struct FInteriorSettings
        LastInteriorSettings;           // 0x023C (0x0024) [0x0000000000000000]
    int LastReverbVolumeIndex;          // 0x0260 (0x0004) [0x0000000000000000]
    float VolumeMultiplier;             // 0x0264 (0x0004) [0x0000000000000000]
    float PitchMultiplier;              // 0x0268 (0x0004) [0x0000000000000000]
    float HighFrequencyGainMultiplier;  // 0x026C (0x0004) [0x0000000000000000]
    float OcclusionCheckInterval;       // 0x0270 (0x0004) [0x0000000000000000]
    float LastOcclusionCheckTime;       // 0x0274 (0x0004) [0x0000000000000000]
    class UDrawSoundRadiusComponent*
        PreviewSoundRadius;  // 0x0278 (0x0008) [0x0000000000000000]
    class USkeletalMeshComponent*
        SkelMeshBase;                   // 0x0280 (0x0008) [0x0000000000000000]
    struct FName SkelMeshBaseBoneName;  // 0x0288 (0x0008) [0x0000000000000000]
    struct FScriptDelegate
        __OnAudioFinished__Delegate;   // 0x0290 (0x0010) [0x0000000000000000]
    unsigned char UnknownData01[0x4];  // 0x0294 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __OnQueueSubtitles__Delegate;  // 0x02A0 (0x0010) [0x0000000000000000]
    unsigned char UnknownData02[0x4];  // 0x02A4 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[299];

        return pClassPointer;
    };

    void eventOcclusionChanged();
    void OnQueueSubtitles();
    void OnAudioFinished();
    void ResetToDefaults();
    void SetWaveParameter();
    void SetFloatParameter();
    void AdjustVolume();
    void FadeOut();
    void FadeIn();
    void IsFadingOut();
    void IsFadingIn();
    void IsPlaying();
    void Stop();
    void Play();
};

UClass* UAudioComponent::pClassPointer = NULL;

// Class Engine.SplineAudioComponent
// 0x0018 (0x02C8 - 0x02B0)
class USplineAudioComponent : public UAudioComponent {
   public:
    float ListenerScopeRadius;      // 0x02B0 (0x0004) [0x0000000000000000]
    int ClosestPointOnSplineIndex;  // 0x02B4 (0x0004) [0x0000000000000000]
    TArray<struct FInterpPointOnSpline>
        Points;  // 0x02B8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[301];

        return pClassPointer;
    };
};

UClass* USplineAudioComponent::pClassPointer = NULL;

// Class Engine.MultiCueSplineAudioComponent
// 0x0014 (0x02DC - 0x02C8)
class UMultiCueSplineAudioComponent : public USplineAudioComponent {
   public:
    TArray<struct FMultiCueSplineSoundSlot>
        SoundSlots;        // 0x02C8 (0x0010) [0x0000000000000000]
    int CurrentSlotIndex;  // 0x02D8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[303];

        return pClassPointer;
    };
};

UClass* UMultiCueSplineAudioComponent::pClassPointer = NULL;

// Class Engine.SimpleSplineAudioComponent
// 0x0038 (0x0300 - 0x02C8)
class USimpleSplineAudioComponent : public USplineAudioComponent {
   public:
    DWORD bAttenuateWithLPF : 1;      // 0x02C8 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    float LPFRadiusMin;               // 0x02CC (0x0004) [0x0000000000000000]
    float LPFRadiusMax;               // 0x02D0 (0x0004) [0x0000000000000000]
    float dBAttenuationAtMax;         // 0x02D4 (0x0004) [0x0000000000000000]
    float FlattenAttenuationRadius;   // 0x02D8 (0x0004) [0x0000000000000000]
    unsigned char DistanceAlgorithm;  // 0x02DC (0x0001) [0x0000000000000000]
    float RadiusMin;                  // 0x02E0 (0x0004) [0x0000000000000000]
    float RadiusMax;                  // 0x02E4 (0x0004) [0x0000000000000000]
    TArray<struct FSplineSoundSlot>
        SoundSlots;  // 0x02E8 (0x0010) [0x0000000000000000]
    class USoundNode*
        NotifyBufferFinishedHook;  // 0x02F8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[305];

        return pClassPointer;
    };
};

UClass* USimpleSplineAudioComponent::pClassPointer = NULL;

// Class Engine.SimpleSplineNonLoopAudioComponent
// 0x0028 (0x0328 - 0x0300)
class USimpleSplineNonLoopAudioComponent : public USimpleSplineAudioComponent {
   public:
    float DelayMin;              // 0x0300 (0x0004) [0x0000000000000000]
    float DelayMax;              // 0x0304 (0x0004) [0x0000000000000000]
    float PitchMin;              // 0x0308 (0x0004) [0x0000000000000000]
    float PitchMax;              // 0x030C (0x0004) [0x0000000000000000]
    float VolumeMin;             // 0x0310 (0x0004) [0x0000000000000000]
    float VolumeMax;             // 0x0314 (0x0004) [0x0000000000000000]
    int CurrentSlotIndex;        // 0x0318 (0x0004) [0x0000000000000000]
    float UsedVolumeModulation;  // 0x031C (0x0004) [0x0000000000000000]
    float UsedPitchModulation;   // 0x0320 (0x0004) [0x0000000000000000]
    float NextSoundTime;         // 0x0324 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[307];

        return pClassPointer;
    };
};

UClass* USimpleSplineNonLoopAudioComponent::pClassPointer = NULL;

// Class Engine.HeightFogComponent
// 0x001F (0x00A4 - 0x0085)
class UHeightFogComponent : public UActorComponent {
   public:
    DWORD bEnabled : 1;     // 0x0088 (0x0004) [0x0000000000000000] [0x00000001]
    float Height;           // 0x008C (0x0004) [0x0000000000000000]
    float Density;          // 0x0090 (0x0004) [0x0000000000000000]
    float LightBrightness;  // 0x0094 (0x0004) [0x0000000000000000]
    struct FColor LightColor;  // 0x0098 (0x0004) [0x0000000000000000]
    float ExtinctionDistance;  // 0x009C (0x0004) [0x0000000000000000]
    float StartDistance;       // 0x00A0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[309];

        return pClassPointer;
    };

    void SetEnabled();
};

UClass* UHeightFogComponent::pClassPointer = NULL;

// Class Engine.PrimitiveComponent
// 0x01B3 (0x0238 - 0x0085)
class UPrimitiveComponent : public UActorComponent {
   public:
    int Tag;                            // 0x0088 (0x0004) [0x0000000000000000]
    struct FBoxSphereBounds Bounds;     // 0x008C (0x001C) [0x0000000000000000]
    struct FPointer SceneInfo;          // 0x00A8 (0x0008) [0x0000000000000000]
    int DetachFence;                    // 0x00B0 (0x0004) [0x0000000000000000]
    float LocalToWorldDeterminant;      // 0x00B4 (0x0004) [0x0000000000000000]
    unsigned char UnknownData00[0x8];   // 0x00B8 (0x0008) MISSED OFFSET
    struct FMatrix LocalToWorld;        // 0x00C0 (0x0040) [0x0000000000000000]
    int MotionBlurInfoIndex;            // 0x0100 (0x0004) [0x0000000000000000]
    TArray<struct FPointer> DecalList;  // 0x0104 (0x0010) [0x0000000000000000]
    TArray<class UDecalComponent*>
        DecalsToReattach;  // 0x0114 (0x0010) [0x0000000000000000]
    class UPrimitiveComponent*
        ShadowParent;  // 0x0124 (0x0008) [0x0000000000000000]
    class UPrimitiveComponent*
        ReplacementPrimitive;  // 0x012C (0x0008) [0x0000000000000000]
    class UFogVolumeDensityComponent*
        FogVolumeComponent;  // 0x0134 (0x0008) [0x0000000000000000]
    class ULightComponent*
        OverrideLightComponent;  // 0x013C (0x0008) [0x0000000000000000]
    class ULightEnvironmentComponent*
        LightEnvironment;  // 0x0144 (0x0008) [0x0000000000000000]
    class ULightEnvironmentComponent*
        PreviousLightEnvironment;      // 0x014C (0x0008) [0x0000000000000000]
    float MinDrawDistance;             // 0x0154 (0x0004) [0x0000000000000000]
    float MassiveLODDistance;          // 0x0158 (0x0004) [0x0000000000000000]
    float MaxDrawDistance;             // 0x015C (0x0004) [0x0000000000000000]
    float CachedMaxDrawDistance;       // 0x0160 (0x0004) [0x0000000000000000]
    float MotionBlurInstanceScale;     // 0x0164 (0x0004) [0x0000000000000000]
    float CullDistance;                // 0x0168 (0x0004) [0x0000000000000000]
    float CachedCullDistance;          // 0x016C (0x0004) [0x0000000000000000]
    unsigned char DepthPriorityGroup;  // 0x0170 (0x0001) [0x0000000000000000]
    unsigned char
        ViewOwnerDepthPriorityGroup;  // 0x0171 (0x0001) [0x0000000000000000]
    unsigned char DetailMode;         // 0x0172 (0x0001) [0x0000000000000000]
    unsigned char RBChannel;          // 0x0173 (0x0001) [0x0000000000000000]
    unsigned char RBDominanceGroup;   // 0x0174 (0x0001) [0x0000000000000000]
    unsigned char
        PreviewEnvironmentShadowing;  // 0x0175 (0x0001) [0x0000000000000000]
    DWORD bUseViewOwnerDepthPriorityGroup : 1;  // 0x0178 (0x0004)
                                                // [0x0000000000000000]
                                                // [0x00000001]
    DWORD bAllowCullDistanceVolume : 1;  // 0x0178 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD HiddenGame : 1;  // 0x0178 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD
        HiddenEditor : 1;   // 0x0178 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bOwnerNoSee : 1;  // 0x0178 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD
        bOnlyOwnerSee : 1;  // 0x0178 (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bIgnoreOwnerHidden : 1;  // 0x0178 (0x0004) [0x0000000000000000]
                                   // [0x00000040]
    DWORD bUseAsOccluder : 1;      // 0x0178 (0x0004) [0x0000000000000000]
                                   // [0x00000080]
    DWORD bAllowApproximateOcclusion : 1;  // 0x0178 (0x0004)
                                           // [0x0000000000000000] [0x00000100]
    DWORD bFirstFrameOcclusion : 1;  // 0x0178 (0x0004) [0x0000000000000000]
                                     // [0x00000200]
    DWORD
        bIgnoreNearPlaneIntersection : 1;  // 0x0178 (0x0004)
                                           // [0x0000000000000000] [0x00000400]
    DWORD bSelectable : 1;  // 0x0178 (0x0004) [0x0000000000000000] [0x00000800]
    DWORD bForceMipStreaming : 1;  // 0x0178 (0x0004) [0x0000000000000000]
                                   // [0x00001000]
    DWORD bAcceptsDecals : 1;      // 0x0178 (0x0004) [0x0000000000000000]
                                   // [0x00002000]
    DWORD
        bAcceptsDecalsDuringGameplay : 1;  // 0x0178 (0x0004)
                                           // [0x0000000000000000] [0x00004000]
    DWORD bAcceptsStaticDecals : 1;   // 0x0178 (0x0004) [0x0000000000000000]
                                      // [0x00008000]
    DWORD bAcceptsDynamicDecals : 1;  // 0x0178 (0x0004) [0x0000000000000000]
                                      // [0x00010000]
    DWORD bIsRefreshingDecals : 1;    // 0x0178 (0x0004) [0x0000000000000000]
                                      // [0x00020000]
    DWORD
        bAllowDecalAutomaticReAttach : 1;  // 0x0178 (0x0004)
                                           // [0x0000000000000000] [0x00040000]
    DWORD bUsePerInstanceHitProxies : 1;   // 0x0178 (0x0004)
                                           // [0x0000000000000000] [0x00080000]
    DWORD CastShadow : 1;  // 0x0178 (0x0004) [0x0000000000000000] [0x00100000]
    DWORD bForceDirectLightMap : 1;  // 0x0178 (0x0004) [0x0000000000000000]
                                     // [0x00200000]
    DWORD bCastDynamicShadow : 1;    // 0x0178 (0x0004) [0x0000000000000000]
                                     // [0x00400000]
    DWORD bCastStaticShadow : 1;     // 0x0178 (0x0004) [0x0000000000000000]
                                     // [0x00800000]
    DWORD bSelfShadowOnly : 1;       // 0x0178 (0x0004) [0x0000000000000000]
                                     // [0x01000000]
    DWORD bNoModSelfShadow : 1;      // 0x0178 (0x0004) [0x0000000000000000]
                                     // [0x02000000]
    DWORD bAcceptsDynamicDominantLightShadows : 1;  // 0x0178 (0x0004)
                                                    // [0x0000000000000000]
                                                    // [0x04000000]
    DWORD bCastHiddenShadow : 1;      // 0x0178 (0x0004) [0x0000000000000000]
                                      // [0x08000000]
    DWORD bCastShadowAsTwoSided : 1;  // 0x0178 (0x0004) [0x0000000000000000]
                                      // [0x10000000]
    DWORD bAcceptsLights : 1;         // 0x0178 (0x0004) [0x0000000000000000]
                                      // [0x20000000]
    DWORD bAcceptsDynamicLights : 1;  // 0x0178 (0x0004) [0x0000000000000000]
                                      // [0x40000000]
    DWORD bUseOnePassLightingOnTranslucency : 1;  // 0x0178 (0x0004)
                                                  // [0x0000000000000000]
                                                  // [0x80000000]
    DWORD bUsePrecomputedShadows : 1;    // 0x017C (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bHasExplicitShadowParent : 1;  // 0x017C (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bAllowAmbientOcclusion : 1;    // 0x017C (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD
        CollideActors : 1;  // 0x017C (0x0004) [0x0000000000000000] [0x00000008]
    DWORD AlwaysCheckCollision : 1;  // 0x017C (0x0004) [0x0000000000000000]
                                     // [0x00000010]
    DWORD BlockActors : 1;  // 0x017C (0x0004) [0x0000000000000000] [0x00000020]
    DWORD BlockZeroExtent : 1;       // 0x017C (0x0004) [0x0000000000000000]
                                     // [0x00000040]
    DWORD BlockNonZeroExtent : 1;    // 0x017C (0x0004) [0x0000000000000000]
                                     // [0x00000080]
    DWORD CanBlockCamera : 1;        // 0x017C (0x0004) [0x0000000000000000]
                                     // [0x00000100]
    DWORD BlockRigidBody : 1;        // 0x017C (0x0004) [0x0000000000000000]
                                     // [0x00000200]
    DWORD bBlockFootPlacement : 1;   // 0x017C (0x0004) [0x0000000000000000]
                                     // [0x00000400]
    DWORD bDisableAllRigidBody : 1;  // 0x017C (0x0004) [0x0000000000000000]
                                     // [0x00000800]
    DWORD bSkipRBGeomCreation : 1;   // 0x017C (0x0004) [0x0000000000000000]
                                     // [0x00001000]
    DWORD bNotifyRigidBodyCollision : 1;  // 0x017C (0x0004)
                                          // [0x0000000000000000] [0x00002000]
    DWORD bFluidDrain : 1;  // 0x017C (0x0004) [0x0000000000000000] [0x00004000]
    DWORD
        bFluidTwoWay : 1;  // 0x017C (0x0004) [0x0000000000000000] [0x00008000]
    DWORD bIgnoreRadialImpulse : 1;  // 0x017C (0x0004) [0x0000000000000000]
                                     // [0x00010000]
    DWORD bIgnoreRadialForce : 1;    // 0x017C (0x0004) [0x0000000000000000]
                                     // [0x00020000]
    DWORD bIgnoreForceField : 1;     // 0x017C (0x0004) [0x0000000000000000]
                                     // [0x00040000]
    DWORD bUseCompartment : 1;       // 0x017C (0x0004) [0x0000000000000000]
                                     // [0x00080000]
    DWORD AlwaysLoadOnClient : 1;    // 0x017C (0x0004) [0x0000000000000000]
                                     // [0x00100000]
    DWORD AlwaysLoadOnServer : 1;    // 0x017C (0x0004) [0x0000000000000000]
                                     // [0x00200000]
    DWORD
        bIgnoreHiddenActorsMembership : 1;  // 0x017C (0x0004)
                                            // [0x0000000000000000] [0x00400000]
    DWORD AbsoluteTranslation : 1;  // 0x017C (0x0004) [0x0000000000000000]
                                    // [0x00800000]
    DWORD AbsoluteRotation : 1;     // 0x017C (0x0004) [0x0000000000000000]
                                    // [0x01000000]
    DWORD
        AbsoluteScale : 1;  // 0x017C (0x0004) [0x0000000000000000] [0x02000000]
    DWORD bAllowShadowFade : 1;    // 0x017C (0x0004) [0x0000000000000000]
                                   // [0x04000000]
    DWORD bSupportedOnMobile : 1;  // 0x017C (0x0004) [0x0000000000000000]
                                   // [0x08000000]
    DWORD bWasSNFiltered : 1;      // 0x017C (0x0004) [0x0000000000000000]
                                   // [0x10000000]
    TArray<int> OctreeNodes;       // 0x0180 (0x0010) [0x0000000000000000]
    int TranslucencySortPriority;  // 0x0190 (0x0004) [0x0000000000000000]
    int VisibilityId;              // 0x0194 (0x0004) [0x0000000000000000]
    struct FLightingChannelContainer
        LightingChannels;  // 0x0198 (0x0004) [0x0000000000000000]
    struct FRBCollisionChannelContainer
        RBCollideWithChannels;  // 0x019C (0x0004) [0x0000000000000000]
    class UPhysicalMaterial*
        PhysMaterialOverride;  // 0x01A0 (0x0008) [0x0000000000000000]
    class URB_BodyInstance*
        BodyInstance;                    // 0x01A8 (0x0008) [0x0000000000000000]
    struct FMatrix CachedParentToWorld;  // 0x01B0 (0x0040) [0x0000000000000000]
    struct FVector Translation;          // 0x01F0 (0x000C) [0x0000000000000000]
    struct FRotator Rotation;            // 0x01FC (0x000C) [0x0000000000000000]
    float Scale;                         // 0x0208 (0x0004) [0x0000000000000000]
    struct FVector Scale3D;              // 0x020C (0x000C) [0x0000000000000000]
    float BoundsScale;                   // 0x0218 (0x0004) [0x0000000000000000]
    float LastSubmitTime;                // 0x021C (0x0004) [0x0000000000000000]
    float LastRenderTime;                // 0x0220 (0x0004) [0x0000000000000000]
    float LastShadowRenderTime;          // 0x0224 (0x0004) [0x0000000000000000]
    float ScriptRigidBodyCollisionThreshold;  // 0x0228 (0x0004)
                                              // [0x0000000000000000]
    float FootPlacementZOffset;         // 0x022C (0x0004) [0x0000000000000000]
    float PerObjectShadowCullDistance;  // 0x0230 (0x0004) [0x0000000000000000]
    DWORD bAllowPerObjectShadows : 1;   // 0x0234 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bAllowPreshadows : 1;         // 0x0234 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD
        bAllowPerObjectShadowBatching : 1;  // 0x0234 (0x0004)
                                            // [0x0000000000000000] [0x00000004]
    DWORD
        bOverrideAutoLightingChannels : 1;  // 0x0234 (0x0004)
                                            // [0x0000000000000000] [0x00000008]
    DWORD bOverridePrecomputedShadowOcclusion : 1;  // 0x0234 (0x0004)
                                                    // [0x0000000000000000]
                                                    // [0x00000010]
    DWORD bAcceptReflections : 1;  // 0x0234 (0x0004) [0x0000000000000000]
                                   // [0x00000020]
    DWORD bAllowPersistentSplatters : 1;  // 0x0234 (0x0004)
                                          // [0x0000000000000000] [0x00000040]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[311];

        return pClassPointer;
    };

    void ClosestPointOnComponentToComponent();
    void ClosestPointOnComponentToPoint();
    void GetRotation();
    void GetPosition();
    void SetAbsolute();
    void SetScale3D();
    void SetScale();
    void SetRotation();
    void SetTranslation();
    void SetActorCollision();
    void SetTraceBlocking();
    void SetViewOwnerDepthPriorityGroup();
    void SetDepthPriorityGroup();
    void SetPerObjectShadows();
    void SetLightingChannels();
    void SetCullDistance();
    void SetLightEnvironment();
    void SetShadowParent();
    void SetIgnoreOwnerHidden();
    void SetOnlyOwnerSee();
    void SetOwnerNoSee();
    void SetHidden();
    void ShouldComponentAddToScene();
    void SetRBDominanceGroup();
    void GetRootBodyInstance();
    void SetPhysMaterialOverride();
    void InitRBPhys();
    void SetNotifyRigidBodyCollision();
    void SetRBChannel();
    void SetRBCollisionChannels();
    void SetRBCollidesWithChannel();
    void SetBlockRigidBody();
    void RigidBodyIsAwake();
    void PutRigidBodyToSleep();
    void WakeRigidBody();
    void SetRBRotation();
    void SetRBPosition();
    void RetardRBLinearVelocity();
    void SetRBAngularVelocity();
    void SetRBLinearVelocity();
    void AddTorque();
    void AddRadialForce();
    void AddForce();
    void AddRadialImpulse();
    void AddImpulse();
};

UClass* UPrimitiveComponent::pClassPointer = NULL;

// Class Engine.ArrowComponent
// 0x0014 (0x024C - 0x0238)
class UArrowComponent : public UPrimitiveComponent {
   public:
    struct FColor ArrowColor;         // 0x0238 (0x0004) [0x0000000000000000]
    float ArrowSize;                  // 0x023C (0x0004) [0x0000000000000000]
    DWORD bTreatAsASprite : 1;        // 0x0240 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    struct FName SpriteCategoryName;  // 0x0244 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[313];

        return pClassPointer;
    };
};

UClass* UArrowComponent::pClassPointer = NULL;

// Class Engine.BrushComponent
// 0x007C (0x02B4 - 0x0238)
class UBrushComponent : public UPrimitiveComponent {
   public:
    class UModel* Brush;  // 0x0238 (0x0008) [0x0000000000000000]
    struct FKAggregateGeom
        BrushAggGeom;  // 0x0240 (0x005C) [0x0000000000000000]
    struct FKCachedConvexData
        CachedPhysBrushData;         // 0x029C (0x0010) [0x0000000000000000]
    int CachedPhysBrushDataVersion;  // 0x02AC (0x0004) [0x0000000000000000]
    DWORD bBlockComplexCollisionTrace : 1;  // 0x02B0 (0x0004)
                                            // [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[315];

        return pClassPointer;
    };
};

UClass* UBrushComponent::pClassPointer = NULL;

// Class Engine.CameraConeComponent
// 0x0000 (0x0238 - 0x0238)
class UCameraConeComponent : public UPrimitiveComponent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[317];

        return pClassPointer;
    };
};

UClass* UCameraConeComponent::pClassPointer = NULL;

// Class Engine.CylinderComponent
// 0x0010 (0x0248 - 0x0238)
class UCylinderComponent : public UPrimitiveComponent {
   public:
    float CollisionHeight;              // 0x0238 (0x0004) [0x0000000000000000]
    float CollisionRadius;              // 0x023C (0x0004) [0x0000000000000000]
    struct FColor CylinderColor;        // 0x0240 (0x0004) [0x0000000000000000]
    DWORD bDrawBoundingBox : 1;         // 0x0244 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bDrawNonColliding : 1;        // 0x0244 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bAlwaysRenderIfSelected : 1;  // 0x0244 (0x0004) [0x0000000000000000]
                                        // [0x00000004]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[319];

        return pClassPointer;
    };

    void SetCylinderSize();
};

UClass* UCylinderComponent::pClassPointer = NULL;

// Class Engine.DrawBoxComponent
// 0x001C (0x0254 - 0x0238)
class UDrawBoxComponent : public UPrimitiveComponent {
   public:
    struct FColor BoxColor;        // 0x0238 (0x0004) [0x0000000000000000]
    class UMaterial* BoxMaterial;  // 0x023C (0x0008) [0x0000000000000000]
    struct FVector BoxExtent;      // 0x0244 (0x000C) [0x0000000000000000]
    DWORD
        bDrawWireBox : 1;   // 0x0250 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bDrawLitBox : 1;  // 0x0250 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bDrawOnlyIfSelected : 1;  // 0x0250 (0x0004) [0x0000000000000000]
                                    // [0x00000004]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[321];

        return pClassPointer;
    };
};

UClass* UDrawBoxComponent::pClassPointer = NULL;

// Class Engine.DrawCapsuleComponent
// 0x0018 (0x0250 - 0x0238)
class UDrawCapsuleComponent : public UPrimitiveComponent {
   public:
    struct FColor CapsuleColor;        // 0x0238 (0x0004) [0x0000000000000000]
    class UMaterial* CapsuleMaterial;  // 0x023C (0x0008) [0x0000000000000000]
    float CapsuleHeight;               // 0x0244 (0x0004) [0x0000000000000000]
    float CapsuleRadius;               // 0x0248 (0x0004) [0x0000000000000000]
    DWORD bDrawWireCapsule : 1;        // 0x024C (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bDrawLitCapsule : 1;         // 0x024C (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD bDrawOnlyIfSelected : 1;     // 0x024C (0x0004) [0x0000000000000000]
                                       // [0x00000004]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[323];

        return pClassPointer;
    };
};

UClass* UDrawCapsuleComponent::pClassPointer = NULL;

// Class Engine.DrawConeComponent
// 0x0010 (0x0248 - 0x0238)
class UDrawConeComponent : public UPrimitiveComponent {
   public:
    struct FColor ConeColor;  // 0x0238 (0x0004) [0x0000000000000000]
    float ConeRadius;         // 0x023C (0x0004) [0x0000000000000000]
    float ConeAngle;          // 0x0240 (0x0004) [0x0000000000000000]
    int ConeSides;            // 0x0244 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[325];

        return pClassPointer;
    };
};

UClass* UDrawConeComponent::pClassPointer = NULL;

// Class Engine.DrawCylinderComponent
// 0x0024 (0x025C - 0x0238)
class UDrawCylinderComponent : public UPrimitiveComponent {
   public:
    struct FColor CylinderColor;        // 0x0238 (0x0004) [0x0000000000000000]
    class UMaterial* CylinderMaterial;  // 0x023C (0x0008) [0x0000000000000000]
    float CylinderRadius;               // 0x0244 (0x0004) [0x0000000000000000]
    float CylinderTopRadius;            // 0x0248 (0x0004) [0x0000000000000000]
    float CylinderHeight;               // 0x024C (0x0004) [0x0000000000000000]
    float CylinderHeightOffset;         // 0x0250 (0x0004) [0x0000000000000000]
    int CylinderSides;                  // 0x0254 (0x0004) [0x0000000000000000]
    DWORD bDrawWireCylinder : 1;        // 0x0258 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bDrawLitCylinder : 1;         // 0x0258 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bDrawOnlyIfSelected : 1;      // 0x0258 (0x0004) [0x0000000000000000]
                                        // [0x00000004]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[327];

        return pClassPointer;
    };
};

UClass* UDrawCylinderComponent::pClassPointer = NULL;

// Class Engine.DrawFrustumComponent
// 0x001C (0x0254 - 0x0238)
class UDrawFrustumComponent : public UPrimitiveComponent {
   public:
    struct FColor FrustumColor;  // 0x0238 (0x0004) [0x0000000000000000]
    float FrustumAngle;          // 0x023C (0x0004) [0x0000000000000000]
    float FrustumAspectRatio;    // 0x0240 (0x0004) [0x0000000000000000]
    float FrustumStartDist;      // 0x0244 (0x0004) [0x0000000000000000]
    float FrustumEndDist;        // 0x0248 (0x0004) [0x0000000000000000]
    class UTexture* Texture;     // 0x024C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[329];

        return pClassPointer;
    };
};

UClass* UDrawFrustumComponent::pClassPointer = NULL;

// Class Engine.DrawQuadComponent
// 0x0010 (0x0248 - 0x0238)
class UDrawQuadComponent : public UPrimitiveComponent {
   public:
    class UTexture* Texture;  // 0x0238 (0x0008) [0x0000000000000000]
    float Width;              // 0x0240 (0x0004) [0x0000000000000000]
    float Height;             // 0x0244 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[331];

        return pClassPointer;
    };
};

UClass* UDrawQuadComponent::pClassPointer = NULL;

// Class Engine.DrawSphereComponent
// 0x0018 (0x0250 - 0x0238)
class UDrawSphereComponent : public UPrimitiveComponent {
   public:
    struct FColor SphereColor;        // 0x0238 (0x0004) [0x0000000000000000]
    class UMaterial* SphereMaterial;  // 0x023C (0x0008) [0x0000000000000000]
    float SphereRadius;               // 0x0244 (0x0004) [0x0000000000000000]
    int SphereSides;                  // 0x0248 (0x0004) [0x0000000000000000]
    DWORD bDrawWireSphere : 1;        // 0x024C (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bDrawLitSphere : 1;         // 0x024C (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bDrawOnlyIfSelected : 1;    // 0x024C (0x0004) [0x0000000000000000]
                                      // [0x00000004]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[333];

        return pClassPointer;
    };
};

UClass* UDrawSphereComponent::pClassPointer = NULL;

// Class Engine.DrawPylonRadiusComponent
// 0x0000 (0x0250 - 0x0250)
class UDrawPylonRadiusComponent : public UDrawSphereComponent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[335];

        return pClassPointer;
    };
};

UClass* UDrawPylonRadiusComponent::pClassPointer = NULL;

// Class Engine.DrawSoundRadiusComponent
// 0x0000 (0x0250 - 0x0250)
class UDrawSoundRadiusComponent : public UDrawSphereComponent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[337];

        return pClassPointer;
    };
};

UClass* UDrawSoundRadiusComponent::pClassPointer = NULL;

// Class Engine.DrawTaperedCapsuleComponent
// 0x001C (0x0254 - 0x0238)
class UDrawTaperedCapsuleComponent : public UPrimitiveComponent {
   public:
    struct FColor CapsuleColor;        // 0x0238 (0x0004) [0x0000000000000000]
    class UMaterial* CapsuleMaterial;  // 0x023C (0x0008) [0x0000000000000000]
    float CapsuleHeight;               // 0x0244 (0x0004) [0x0000000000000000]
    float CapsuleRadius;               // 0x0248 (0x0004) [0x0000000000000000]
    float CapsuleTopRadius;            // 0x024C (0x0004) [0x0000000000000000]
    DWORD bDrawWireCapsule : 1;        // 0x0250 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bDrawLitCapsule : 1;         // 0x0250 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD bDrawOnlyIfSelected : 1;     // 0x0250 (0x0004) [0x0000000000000000]
                                       // [0x00000004]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[339];

        return pClassPointer;
    };
};

UClass* UDrawTaperedCapsuleComponent::pClassPointer = NULL;

// Class Engine.LevelGridVolumeRenderingComponent
// 0x0000 (0x0238 - 0x0238)
class ULevelGridVolumeRenderingComponent : public UPrimitiveComponent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[341];

        return pClassPointer;
    };
};

UClass* ULevelGridVolumeRenderingComponent::pClassPointer = NULL;

// Class Engine.LineBatchComponent
// 0x0034 (0x026C - 0x0238)
class ULineBatchComponent : public UPrimitiveComponent {
   public:
    struct FPointer
        FPrimitiveDrawInterfaceVfTable;  // 0x0238 (0x0008) [0x0000000000000000]
    struct FPointer
        FPrimitiveDrawInterfaceView;  // 0x0240 (0x0008) [0x0000000000000000]
    TArray<struct FPointer>
        BatchedLines;  // 0x0248 (0x0010) [0x0000000000000000]
    TArray<struct FPointer>
        BatchedPoints;      // 0x0258 (0x0010) [0x0000000000000000]
    float DefaultLifeTime;  // 0x0268 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[343];

        return pClassPointer;
    };
};

UClass* ULineBatchComponent::pClassPointer = NULL;

// Class Engine.ModelComponent
// 0x0030 (0x0268 - 0x0238)
class UModelComponent : public UPrimitiveComponent {
   public:
    class UObject* Model;              // 0x0238 (0x0008) [0x0000000000000000]
    int ZoneIndex;                     // 0x0240 (0x0004) [0x0000000000000000]
    int ComponentIndex;                // 0x0244 (0x0004) [0x0000000000000000]
    TArray<struct FPointer> Nodes;     // 0x0248 (0x0010) [0x0000000000000000]
    TArray<struct FPointer> Elements;  // 0x0258 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[345];

        return pClassPointer;
    };
};

UClass* UModelComponent::pClassPointer = NULL;

// Class Engine.SpriteComponent
// 0x0028 (0x0260 - 0x0238)
class USpriteComponent : public UPrimitiveComponent {
   public:
    class UTexture2D* Sprite;         // 0x0238 (0x0008) [0x0000000000000000]
    DWORD bIsScreenSizeScaled : 1;    // 0x0240 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    float ScreenSize;                 // 0x0244 (0x0004) [0x0000000000000000]
    float U;                          // 0x0248 (0x0004) [0x0000000000000000]
    float UL;                         // 0x024C (0x0004) [0x0000000000000000]
    float V;                          // 0x0250 (0x0004) [0x0000000000000000]
    float VL;                         // 0x0254 (0x0004) [0x0000000000000000]
    struct FName SpriteCategoryName;  // 0x0258 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[347];

        return pClassPointer;
    };

    void SetSpriteAndUV();
    void SetUV();
    void SetSprite();
};

UClass* USpriteComponent::pClassPointer = NULL;

// Class Engine.RadialBlurComponent
// 0x006B (0x00F0 - 0x0085)
class URadialBlurComponent : public UActorComponent {
   public:
    class UMaterialInterface* Material;  // 0x0088 (0x0008) [0x0000000000000000]
    unsigned char DepthPriorityGroup;    // 0x0090 (0x0001) [0x0000000000000000]
    float BlurScale;                     // 0x0094 (0x0004) [0x0000000000000000]
    float BlurFalloffExponent;           // 0x0098 (0x0004) [0x0000000000000000]
    float BlurOpacity;                   // 0x009C (0x0004) [0x0000000000000000]
    float MaxCullDistance;               // 0x00A0 (0x0004) [0x0000000000000000]
    float DistanceFalloffExponent;       // 0x00A4 (0x0004) [0x0000000000000000]
    DWORD bRenderAsVelocity : 1;         // 0x00A8 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bEnabled : 1;  // 0x00A8 (0x0004) [0x0000000000000000] [0x00000002]
    unsigned char UnknownData00[0x4];  // 0x00AC (0x0004) MISSED OFFSET
    struct FMatrix LocalToWorld;       // 0x00B0 (0x0040) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[349];

        return pClassPointer;
    };

    void OnUpdatePropertyBlurOpacity();
    void OnUpdatePropertyBlurFalloffExponent();
    void OnUpdatePropertyBlurScale();
    void SetEnabled();
    void SetBlurOpacity();
    void SetBlurFalloffExponent();
    void SetBlurScale();
    void SetMaterial();
};

UClass* URadialBlurComponent::pClassPointer = NULL;

// Class Engine.SceneCaptureComponent
// 0x004B (0x00D0 - 0x0085)
class USceneCaptureComponent : public UActorComponent {
   public:
    DWORD bEnabled : 1;  // 0x0088 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bEnablePostProcess : 1;  // 0x0088 (0x0004) [0x0000000000000000]
                                   // [0x00000002]
    DWORD bEnableFog : 1;  // 0x0088 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bUseMainScenePostProcessSettings : 1;   // 0x0088 (0x0004)
                                                  // [0x0000000000000000]
                                                  // [0x00000008]
    DWORD bSkipUpdateIfTextureUsersOccluded : 1;  // 0x0088 (0x0004)
                                                  // [0x0000000000000000]
                                                  // [0x00000010]
    DWORD bSkipUpdateIfOwnerOccluded : 1;         // 0x0088 (0x0004)
                                           // [0x0000000000000000] [0x00000020]
    DWORD bSkipRenderingDepthPrepass : 1;  // 0x0088 (0x0004)
                                           // [0x0000000000000000] [0x00000040]
    struct FColor ClearColor;  // 0x008C (0x0004) [0x0000000000000000]
    unsigned char ViewMode;    // 0x0090 (0x0001) [0x0000000000000000]
    int SceneLOD;              // 0x0094 (0x0004) [0x0000000000000000]
    float FrameRate;           // 0x0098 (0x0004) [0x0000000000000000]
    class UPostProcessChain*
        PostProcess;                // 0x009C (0x0008) [0x0000000000000000]
    float MaxUpdateDist;            // 0x00A4 (0x0004) [0x0000000000000000]
    float MaxViewDistanceOverride;  // 0x00A8 (0x0004) [0x0000000000000000]
    float MaxStreamingUpdateDist;   // 0x00AC (0x0004) [0x0000000000000000]
    struct FPointer CaptureInfo;    // 0x00B0 (0x0008) [0x0000000000000000]
    struct FPointer ViewState;      // 0x00B8 (0x0008) [0x0000000000000000]
    TArray<struct FPointer>
        PostProcessProxies;  // 0x00C0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[351];

        return pClassPointer;
    };

    void SetEnabled();
    void SetFrameRate();
};

UClass* USceneCaptureComponent::pClassPointer = NULL;

// Class Engine.SceneCapture2DComponent
// 0x00A0 (0x0170 - 0x00D0)
class USceneCapture2DComponent : public USceneCaptureComponent {
   public:
    class UTextureRenderTarget2D*
        TextureTarget;                 // 0x00D0 (0x0008) [0x0000000000000000]
    float FieldOfView;                 // 0x00D8 (0x0004) [0x0000000000000000]
    float NearPlane;                   // 0x00DC (0x0004) [0x0000000000000000]
    float FarPlane;                    // 0x00E0 (0x0004) [0x0000000000000000]
    DWORD bUpdateMatrices : 1;         // 0x00E4 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    unsigned char UnknownData00[0x8];  // 0x00E8 (0x0008) MISSED OFFSET
    struct FMatrix ViewMatrix;         // 0x00F0 (0x0040) [0x0000000000000000]
    struct FMatrix ProjMatrix;         // 0x0130 (0x0040) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[353];

        return pClassPointer;
    };

    void SetView();
    void SetCaptureParameters();
};

UClass* USceneCapture2DComponent::pClassPointer = NULL;

// Class Engine.SceneCapture2DHitMaskComponent
// 0x002C (0x00FC - 0x00D0)
class USceneCapture2DHitMaskComponent : public USceneCaptureComponent {
   public:
    class UTextureRenderTarget2D*
        TextureTarget;  // 0x00D0 (0x0008) [0x0000000000000000]
    class USkeletalMeshComponent*
        SkeletalMeshComp;           // 0x00D8 (0x0008) [0x0000000000000000]
    int MaterialIndex;              // 0x00E0 (0x0004) [0x0000000000000000]
    int ForceLOD;                   // 0x00E4 (0x0004) [0x0000000000000000]
    int HitMaskCullDistance;        // 0x00E8 (0x0004) [0x0000000000000000]
    float FadingStartTimeSinceHit;  // 0x00EC (0x0004) [0x0000000000000000]
    float FadingPercentage;         // 0x00F0 (0x0004) [0x0000000000000000]
    float FadingDurationTime;       // 0x00F4 (0x0004) [0x0000000000000000]
    float FadingIntervalTime;       // 0x00F8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[355];

        return pClassPointer;
    };

    void SetFadingStartTimeSinceHit();
    void SetCaptureParameters();
    void SetCaptureTargetTexture();
};

UClass* USceneCapture2DHitMaskComponent::pClassPointer = NULL;

// Class Engine.SceneCaptureCubeMapComponent
// 0x001C (0x00EC - 0x00D0)
class USceneCaptureCubeMapComponent : public USceneCaptureComponent {
   public:
    class UTextureRenderTargetCube*
        TextureTarget;             // 0x00D0 (0x0008) [0x0000000000000000]
    float NearPlane;               // 0x00D8 (0x0004) [0x0000000000000000]
    float FarPlane;                // 0x00DC (0x0004) [0x0000000000000000]
    struct FVector WorldLocation;  // 0x00E0 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[357];

        return pClassPointer;
    };
};

UClass* USceneCaptureCubeMapComponent::pClassPointer = NULL;

// Class Engine.SceneCapturePortalComponent
// 0x0014 (0x00E4 - 0x00D0)
class USceneCapturePortalComponent : public USceneCaptureComponent {
   public:
    class UTextureRenderTarget2D*
        TextureTarget;              // 0x00D0 (0x0008) [0x0000000000000000]
    float ScaleFOV;                 // 0x00D8 (0x0004) [0x0000000000000000]
    class AActor* ViewDestination;  // 0x00DC (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[359];

        return pClassPointer;
    };

    void SetCaptureParameters();
};

UClass* USceneCapturePortalComponent::pClassPointer = NULL;

// Class Engine.SceneCaptureReflectComponent
// 0x000C (0x00DC - 0x00D0)
class USceneCaptureReflectComponent : public USceneCaptureComponent {
   public:
    class UTextureRenderTarget2D*
        TextureTarget;  // 0x00D0 (0x0008) [0x0000000000000000]
    float ScaleFOV;     // 0x00D8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[361];

        return pClassPointer;
    };
};

UClass* USceneCaptureReflectComponent::pClassPointer = NULL;

// Class Engine.WindDirectionalSourceComponent
// 0x001B (0x00A0 - 0x0085)
class UWindDirectionalSourceComponent : public UActorComponent {
   public:
    struct FPointer SceneProxy;  // 0x0088 (0x0008) [0x0000000000000000]
    float Strength;              // 0x0090 (0x0004) [0x0000000000000000]
    float Phase;                 // 0x0094 (0x0004) [0x0000000000000000]
    float Frequency;             // 0x0098 (0x0004) [0x0000000000000000]
    float Speed;                 // 0x009C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[363];

        return pClassPointer;
    };
};

UClass* UWindDirectionalSourceComponent::pClassPointer = NULL;

// Class Engine.WindPointSourceComponent
// 0x000C (0x00AC - 0x00A0)
class UWindPointSourceComponent : public UWindDirectionalSourceComponent {
   public:
    class UDrawSphereComponent*
        PreviewRadiusComponent;  // 0x00A0 (0x0008) [0x0000000000000000]
    float Radius;                // 0x00A8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[365];

        return pClassPointer;
    };
};

UClass* UWindPointSourceComponent::pClassPointer = NULL;

// Class Engine.ActorFactory
// 0x003C (0x009C - 0x0060)
class UActorFactory : public UObject {
   public:
    class UClass* GameplayActorClass;  // 0x0060 (0x0008) [0x0000000000000000]
    struct FString MenuName;           // 0x0068 (0x0010) [0x0000000000000000]
    int MenuPriority;                  // 0x0078 (0x0004) [0x0000000000000000]
    int AlternateMenuPriority;         // 0x007C (0x0004) [0x0000000000000000]
    struct FString NewActorClassName;  // 0x0080 (0x0010) [0x0000000000000000]
    class UClass* NewActorClass;       // 0x0090 (0x0008) [0x0000000000000000]
    DWORD bPlaceable : 1;  // 0x0098 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bShowInEditorQuickMenu : 1;  // 0x0098 (0x0004) [0x0000000000000000]
                                       // [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[367];

        return pClassPointer;
    };

    void eventPostCreateActor();
};

UClass* UActorFactory::pClassPointer = NULL;

// Class Engine.ActorFactoryActor
// 0x0008 (0x00A4 - 0x009C)
class UActorFactoryActor : public UActorFactory {
   public:
    class UClass* ActorClass;  // 0x009C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[369];

        return pClassPointer;
    };
};

UClass* UActorFactoryActor::pClassPointer = NULL;

// Class Engine.ActorFactoryAI
// 0x0038 (0x00D4 - 0x009C)
class UActorFactoryAI : public UActorFactory {
   public:
    class UClass* ControllerClass;    // 0x009C (0x0008) [0x0000000000000000]
    class UClass* PawnClass;          // 0x00A4 (0x0008) [0x0000000000000000]
    struct FString PawnName;          // 0x00AC (0x0010) [0x0000000000000000]
    DWORD bGiveDefaultInventory : 1;  // 0x00BC (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    TArray<class UClass*>
        InventoryList;  // 0x00C0 (0x0010) [0x0000000000000000]
    int TeamIndex;      // 0x00D0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[371];

        return pClassPointer;
    };
};

UClass* UActorFactoryAI::pClassPointer = NULL;

// Class Engine.ActorFactoryAmbientSound
// 0x0008 (0x00A4 - 0x009C)
class UActorFactoryAmbientSound : public UActorFactory {
   public:
    class USoundCue* AmbientSoundCue;  // 0x009C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[373];

        return pClassPointer;
    };
};

UClass* UActorFactoryAmbientSound::pClassPointer = NULL;

// Class Engine.ActorFactoryAmbientSoundMovable
// 0x0000 (0x00A4 - 0x00A4)
class UActorFactoryAmbientSoundMovable : public UActorFactoryAmbientSound {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[375];

        return pClassPointer;
    };
};

UClass* UActorFactoryAmbientSoundMovable::pClassPointer = NULL;

// Class Engine.ActorFactoryAmbientSoundSimple
// 0x0008 (0x00A4 - 0x009C)
class UActorFactoryAmbientSoundSimple : public UActorFactory {
   public:
    class USoundNodeWave*
        SoundNodeWave;  // 0x009C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[377];

        return pClassPointer;
    };
};

UClass* UActorFactoryAmbientSoundSimple::pClassPointer = NULL;

// Class Engine.ActorFactoryAmbientSoundNonLoop
// 0x0000 (0x00A4 - 0x00A4)
class UActorFactoryAmbientSoundNonLoop
    : public UActorFactoryAmbientSoundSimple {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[379];

        return pClassPointer;
    };
};

UClass* UActorFactoryAmbientSoundNonLoop::pClassPointer = NULL;

// Class Engine.ActorFactoryAmbientSoundSimpleToggleable
// 0x0000 (0x00A4 - 0x00A4)
class UActorFactoryAmbientSoundSimpleToggleable
    : public UActorFactoryAmbientSoundSimple {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[381];

        return pClassPointer;
    };
};

UClass* UActorFactoryAmbientSoundSimpleToggleable::pClassPointer = NULL;

// Class Engine.ActorFactoryAmbientSoundNonLoopingToggleable
// 0x0000 (0x00A4 - 0x00A4)
class UActorFactoryAmbientSoundNonLoopingToggleable
    : public UActorFactoryAmbientSoundSimpleToggleable {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[383];

        return pClassPointer;
    };
};

UClass* UActorFactoryAmbientSoundNonLoopingToggleable::pClassPointer = NULL;

// Class Engine.ActorFactoryApexDestructible
// 0x0014 (0x00B0 - 0x009C)
class UActorFactoryApexDestructible : public UActorFactory {
   public:
    DWORD bStartAwake : 1;  // 0x009C (0x0004) [0x0000000000000000] [0x00000001]
    unsigned char RBChannel;  // 0x00A0 (0x0001) [0x0000000000000000]
    struct FRBCollisionChannelContainer
        CollideWithChannels;  // 0x00A4 (0x0004) [0x0000000000000000]
    class UApexDestructibleAsset*
        DestructibleAsset;  // 0x00A8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[385];

        return pClassPointer;
    };
};

UClass* UActorFactoryApexDestructible::pClassPointer = NULL;

// Class Engine.ActorFactoryArchetype
// 0x0008 (0x00A4 - 0x009C)
class UActorFactoryArchetype : public UActorFactory {
   public:
    class AActor* ArchetypeActor;  // 0x009C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[387];

        return pClassPointer;
    };
};

UClass* UActorFactoryArchetype::pClassPointer = NULL;

// Class Engine.ActorFactoryCoverLink
// 0x0000 (0x009C - 0x009C)
class UActorFactoryCoverLink : public UActorFactory {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[389];

        return pClassPointer;
    };
};

UClass* UActorFactoryCoverLink::pClassPointer = NULL;

// Class Engine.ActorFactoryDominantDirectionalLight
// 0x0000 (0x009C - 0x009C)
class UActorFactoryDominantDirectionalLight : public UActorFactory {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[391];

        return pClassPointer;
    };
};

UClass* UActorFactoryDominantDirectionalLight::pClassPointer = NULL;

// Class Engine.ActorFactoryDominantDirectionalLightMovable
// 0x0000 (0x009C - 0x009C)
class UActorFactoryDominantDirectionalLightMovable : public UActorFactory {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[393];

        return pClassPointer;
    };
};

UClass* UActorFactoryDominantDirectionalLightMovable::pClassPointer = NULL;

// Class Engine.ActorFactoryDynamicSM
// 0x0019 (0x00B5 - 0x009C)
class UActorFactoryDynamicSM : public UActorFactory {
   public:
    class UStaticMesh* StaticMesh;  // 0x009C (0x0008) [0x0000000000000000]
    struct FVector DrawScale3D;     // 0x00A4 (0x000C) [0x0000000000000000]
    DWORD bNoEncroachCheck : 1;     // 0x00B0 (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    DWORD bNotifyRigidBodyCollision : 1;  // 0x00B0 (0x0004)
                                          // [0x0000000000000000] [0x00000002]
    DWORD bBlockRigidBody : 1;     // 0x00B0 (0x0004) [0x0000000000000000]
                                   // [0x00000004]
    DWORD bUseCompartment : 1;     // 0x00B0 (0x0004) [0x0000000000000000]
                                   // [0x00000008]
    DWORD bCastDynamicShadow : 1;  // 0x00B0 (0x0004) [0x0000000000000000]
                                   // [0x00000010]
    unsigned char CollisionType;   // 0x00B4 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[395];

        return pClassPointer;
    };
};

UClass* UActorFactoryDynamicSM::pClassPointer = NULL;

// Class Engine.ActorFactoryMover
// 0x0003 (0x00B8 - 0x00B5)
class UActorFactoryMover : public UActorFactoryDynamicSM {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[397];

        return pClassPointer;
    };
};

UClass* UActorFactoryMover::pClassPointer = NULL;

// Class Engine.ActorFactoryRigidBody
// 0x002F (0x00E4 - 0x00B5)
class UActorFactoryRigidBody : public UActorFactoryDynamicSM {
   public:
    DWORD bStartAwake : 1;  // 0x00B8 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bDamageAppliesImpulse : 1;  // 0x00B8 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bLocalSpaceInitialVelocity : 1;  // 0x00B8 (0x0004)
                                           // [0x0000000000000000] [0x00000004]
    DWORD bEnableStayUprightSpring : 1;  // 0x00B8 (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    struct FVector InitialVelocity;      // 0x00BC (0x000C) [0x0000000000000000]
    class UDistributionVector*
        AdditionalVelocity;  // 0x00C8 (0x0008) [0x0000000000000000]
    class UDistributionVector*
        InitialAngularVelocity;     // 0x00D0 (0x0008) [0x0000000000000000]
    unsigned char RBChannel;        // 0x00D8 (0x0001) [0x0000000000000000]
    float StayUprightTorqueFactor;  // 0x00DC (0x0004) [0x0000000000000000]
    float StayUprightMaxTorque;     // 0x00E0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[399];

        return pClassPointer;
    };
};

UClass* UActorFactoryRigidBody::pClassPointer = NULL;

// Class Engine.ActorFactoryEmitter
// 0x0008 (0x00A4 - 0x009C)
class UActorFactoryEmitter : public UActorFactory {
   public:
    class UParticleSystem*
        ParticleSystem;  // 0x009C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[401];

        return pClassPointer;
    };
};

UClass* UActorFactoryEmitter::pClassPointer = NULL;

// Class Engine.ActorFactoryFlex
// 0x0008 (0x00A4 - 0x009C)
class UActorFactoryFlex : public UActorFactory {
   public:
    class UStaticMesh* StaticMesh;  // 0x009C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[403];

        return pClassPointer;
    };
};

UClass* UActorFactoryFlex::pClassPointer = NULL;

// Class Engine.ActorFactoryFracturedStaticMesh
// 0x0014 (0x00B0 - 0x009C)
class UActorFactoryFracturedStaticMesh : public UActorFactory {
   public:
    class UFracturedStaticMesh*
        FracturedStaticMesh;     // 0x009C (0x0008) [0x0000000000000000]
    struct FVector DrawScale3D;  // 0x00A4 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[405];

        return pClassPointer;
    };
};

UClass* UActorFactoryFracturedStaticMesh::pClassPointer = NULL;

// Class Engine.ActorFactoryLensFlare
// 0x0008 (0x00A4 - 0x009C)
class UActorFactoryLensFlare : public UActorFactory {
   public:
    class ULensFlare* LensFlareObject;  // 0x009C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[407];

        return pClassPointer;
    };
};

UClass* UActorFactoryLensFlare::pClassPointer = NULL;

// Class Engine.ActorFactoryLight
// 0x0000 (0x009C - 0x009C)
class UActorFactoryLight : public UActorFactory {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[409];

        return pClassPointer;
    };
};

UClass* UActorFactoryLight::pClassPointer = NULL;

// Class Engine.ActorFactoryPathNode
// 0x0000 (0x009C - 0x009C)
class UActorFactoryPathNode : public UActorFactory {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[411];

        return pClassPointer;
    };
};

UClass* UActorFactoryPathNode::pClassPointer = NULL;

// Class Engine.ActorFactoryPhysicsAsset
// 0x002C (0x00C8 - 0x009C)
class UActorFactoryPhysicsAsset : public UActorFactory {
   public:
    class UPhysicsAsset* PhysicsAsset;  // 0x009C (0x0008) [0x0000000000000000]
    class USkeletalMesh* SkeletalMesh;  // 0x00A4 (0x0008) [0x0000000000000000]
    DWORD bStartAwake : 1;  // 0x00AC (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bDamageAppliesImpulse : 1;  // 0x00AC (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bNotifyRigidBodyCollision : 1;  // 0x00AC (0x0004)
                                          // [0x0000000000000000] [0x00000004]
    DWORD bUseCompartment : 1;       // 0x00AC (0x0004) [0x0000000000000000]
                                     // [0x00000008]
    DWORD bCastDynamicShadow : 1;    // 0x00AC (0x0004) [0x0000000000000000]
                                     // [0x00000010]
    struct FVector InitialVelocity;  // 0x00B0 (0x000C) [0x0000000000000000]
    struct FVector DrawScale3D;      // 0x00BC (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[413];

        return pClassPointer;
    };
};

UClass* UActorFactoryPhysicsAsset::pClassPointer = NULL;

// Class Engine.ActorFactoryPlayerStart
// 0x0000 (0x009C - 0x009C)
class UActorFactoryPlayerStart : public UActorFactory {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[415];

        return pClassPointer;
    };
};

UClass* UActorFactoryPlayerStart::pClassPointer = NULL;

// Class Engine.ActorFactoryPylon
// 0x0000 (0x009C - 0x009C)
class UActorFactoryPylon : public UActorFactory {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[417];

        return pClassPointer;
    };
};

UClass* UActorFactoryPylon::pClassPointer = NULL;

// Class Engine.ActorFactorySkeletalMesh
// 0x0018 (0x00B4 - 0x009C)
class UActorFactorySkeletalMesh : public UActorFactory {
   public:
    class USkeletalMesh* SkeletalMesh;  // 0x009C (0x0008) [0x0000000000000000]
    class UAnimSet* AnimSet;            // 0x00A4 (0x0008) [0x0000000000000000]
    struct FName AnimSequenceName;      // 0x00AC (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[419];

        return pClassPointer;
    };
};

UClass* UActorFactorySkeletalMesh::pClassPointer = NULL;

// Class Engine.ActorFactoryStaticMesh
// 0x0014 (0x00B0 - 0x009C)
class UActorFactoryStaticMesh : public UActorFactory {
   public:
    class UStaticMesh* StaticMesh;  // 0x009C (0x0008) [0x0000000000000000]
    struct FVector DrawScale3D;     // 0x00A4 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[421];

        return pClassPointer;
    };
};

UClass* UActorFactoryStaticMesh::pClassPointer = NULL;

// Class Engine.ActorFactoryTrigger
// 0x0000 (0x009C - 0x009C)
class UActorFactoryTrigger : public UActorFactory {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[423];

        return pClassPointer;
    };
};

UClass* UActorFactoryTrigger::pClassPointer = NULL;

// Class Engine.ActorFactoryVehicle
// 0x0008 (0x00A4 - 0x009C)
class UActorFactoryVehicle : public UActorFactory {
   public:
    class UClass* VehicleClass;  // 0x009C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[425];

        return pClassPointer;
    };
};

UClass* UActorFactoryVehicle::pClassPointer = NULL;

// Class Engine.AISubsystem
// 0x0004 (0x006C - 0x0068)
class UAISubsystem : public USubsystem {
   public:
    DWORD
        bImplementsNavMeshGeneration : 1;  // 0x0068 (0x0004)
                                           // [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[427];

        return pClassPointer;
    };

    void eventGetDifficultyValue();
    void ToggleNavByCover();
    void ToggleNavByComponent();
    void ToggleNavByActor();
};

UClass* UAISubsystem::pClassPointer = NULL;

// Class Engine.AkBank
// 0x0004 (0x0064 - 0x0060)
class UAkBank : public UObject {
   public:
    DWORD AutoLoad : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD GenerateDefinition : 1;  // 0x0060 (0x0004) [0x0000000000000000]
                                   // [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[429];

        return pClassPointer;
    };
};

UClass* UAkBank::pClassPointer = NULL;

// Class Engine.AkBaseSoundObject
// 0x0000 (0x0060 - 0x0060)
class UAkBaseSoundObject : public UObject {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[431];

        return pClassPointer;
    };
};

UClass* UAkBaseSoundObject::pClassPointer = NULL;

// Class Engine.AkEvent
// 0x0070 (0x00D0 - 0x0060)
class UAkEvent : public UAkBaseSoundObject {
   public:
    class UAkBank* RequiredBank;  // 0x0060 (0x0008) [0x0000000000000000]
    float MaxAudibleDistance;     // 0x0068 (0x0004) [0x0000000000000000]
    DWORD bOverrideMaxAudibleDistance : 1;  // 0x006C (0x0004)
                                            // [0x0000000000000000] [0x00000001]
    DWORD bUseListenerDistance : 1;  // 0x006C (0x0004) [0x0000000000000000]
                                     // [0x00000002]
    DWORD bUseEnvironmentReverbSwitchGroup : 1;  // 0x006C (0x0004)
                                                 // [0x0000000000000000]
                                                 // [0x00000004]
    DWORD bUseDoppler : 1;  // 0x006C (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bForceHearSoundLocational : 1;  // 0x006C (0x0004)
                                          // [0x0000000000000000] [0x00000010]
    DWORD bNeedsOcclusionUpdates : 1;  // 0x006C (0x0004) [0x0000000000000000]
                                       // [0x00000020]
    DWORD
        bIsMusicTrack : 1;  // 0x006C (0x0004) [0x0000000000000000] [0x00000040]
    DWORD bUseAdvancedSoundFunctionality : 1;  // 0x006C (0x0004)
                                               // [0x0000000000000000]
                                               // [0x00000080]
    float Duration;                   // 0x0070 (0x0004) [0x0000000000000000]
    float OcclusionUpdateInterval;    // 0x0074 (0x0004) [0x0000000000000000]
    TArray<struct FName> CustomTags;  // 0x0078 (0x0010) [0x0000000000000000]
    TArray<struct FEventSwitchInfo>
        CustomSwitches;  // 0x0088 (0x0010) [0x0000000000000000]
    TArray<struct FEventRTPCInfo>
        CustomRTPCs;            // 0x0098 (0x0010) [0x0000000000000000]
    class UAkEvent* EchoFront;  // 0x00A8 (0x0008) [0x0000000000000000]
    class UAkEvent* EchoLeft;   // 0x00B0 (0x0008) [0x0000000000000000]
    class UAkEvent* EchoRight;  // 0x00B8 (0x0008) [0x0000000000000000]
    class UAkEvent* EchoRear;   // 0x00C0 (0x0008) [0x0000000000000000]
    class UAkEvent* EchoMono;   // 0x00C8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[433];

        return pClassPointer;
    };

    void SetCustomRTPC();
};

UClass* UAkEvent::pClassPointer = NULL;

// Class Engine.SoundCue
// 0x00A8 (0x0108 - 0x0060)
class USoundCue : public UAkBaseSoundObject {
   public:
    struct FName SoundClass;       // 0x0060 (0x0008) [0x0000000000000000]
    unsigned char SoundClassName;  // 0x0068 (0x0001) [0x0000000000000000]
    DWORD bDebug : 1;  // 0x006C (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bPitchShiftWithTimeDilation : 1;  // 0x006C (0x0004)
                                            // [0x0000000000000000] [0x00000002]
    class USoundNode* FirstNode;  // 0x0070 (0x0008) [0x0000000000000000]
    unsigned char
        UnknownData00[0x48];   // 0x0078 (0x0048) UNKNOWN PROPERTY: MapProperty
                               // Engine.SoundCue.EditorData
    float MaxAudibleDistance;  // 0x00C0 (0x0004) [0x0000000000000000]
    float VolumeMultiplier;    // 0x00C4 (0x0004) [0x0000000000000000]
    float PitchMultiplier;     // 0x00C8 (0x0004) [0x0000000000000000]
    float Duration;            // 0x00CC (0x0004) [0x0000000000000000]
    class UFaceFXAnimSet*
        FaceFXAnimSetRef;            // 0x00D0 (0x0008) [0x0000000000000000]
    struct FString FaceFXGroupName;  // 0x00D8 (0x0010) [0x0000000000000000]
    struct FString FaceFXAnimName;   // 0x00E8 (0x0010) [0x0000000000000000]
    int MaxConcurrentPlayCount;      // 0x00F8 (0x0004) [0x0000000000000000]
    int CurrentPlayCount;            // 0x00FC (0x0004) [0x0000000000000000]
    struct FName SoundGroup;         // 0x0100 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[435];

        return pClassPointer;
    };

    void GetCueDuration();
};

UClass* USoundCue::pClassPointer = NULL;

// Class Engine.BookMark
// 0x0028 (0x0088 - 0x0060)
class UBookMark : public UObject {
   public:
    struct FVector Location;   // 0x0060 (0x000C) [0x0000000000000000]
    struct FRotator Rotation;  // 0x006C (0x000C) [0x0000000000000000]
    TArray<struct FString>
        HiddenLevels;  // 0x0078 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[437];

        return pClassPointer;
    };
};

UClass* UBookMark::pClassPointer = NULL;

// Class Engine.BookMark2D
// 0x000C (0x006C - 0x0060)
class UBookMark2D : public UObject {
   public:
    float Zoom2D;               // 0x0060 (0x0004) [0x0000000000000000]
    struct FIntPoint Location;  // 0x0064 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[439];

        return pClassPointer;
    };
};

UClass* UBookMark2D::pClassPointer = NULL;

// Class Engine.KismetBookMark
// 0x0010 (0x007C - 0x006C)
class UKismetBookMark : public UBookMark2D {
   public:
    struct FString
        BookMarkSequencePathName;  // 0x006C (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[441];

        return pClassPointer;
    };
};

UClass* UKismetBookMark::pClassPointer = NULL;

// Class Engine.Canvas
// 0x0068 (0x00C8 - 0x0060)
class UCanvas : public UObject {
   public:
    class UFont* Font;        // 0x0060 (0x0008) [0x0000000000000000]
    float OrgX;               // 0x0068 (0x0004) [0x0000000000000000]
    float OrgY;               // 0x006C (0x0004) [0x0000000000000000]
    float ClipX;              // 0x0070 (0x0004) [0x0000000000000000]
    float ClipY;              // 0x0074 (0x0004) [0x0000000000000000]
    float CurX;               // 0x0078 (0x0004) [0x0000000000000000]
    float CurY;               // 0x007C (0x0004) [0x0000000000000000]
    float CurZ;               // 0x0080 (0x0004) [0x0000000000000000]
    float CurYL;              // 0x0084 (0x0004) [0x0000000000000000]
    struct FColor DrawColor;  // 0x0088 (0x0004) [0x0000000000000000]
    DWORD bCenter : 1;    // 0x008C (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bNoSmooth : 1;  // 0x008C (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bStencilEnabled : 1;         // 0x008C (0x0004) [0x0000000000000000]
                                       // [0x00000004]
    int SizeX;                         // 0x0090 (0x0004) [0x0000000000000000]
    int SizeY;                         // 0x0094 (0x0004) [0x0000000000000000]
    struct FPointer Canvas;            // 0x0098 (0x0008) [0x0000000000000000]
    struct FPointer SceneView;         // 0x00A0 (0x0008) [0x0000000000000000]
    unsigned char UnknownData00[0x8];  // 0x00A8 (0x0008) MISSED OFFSET
    struct FPlane ColorModulate;       // 0x00B0 (0x0010) [0x0000000000000000]
    class UTexture2D* DefaultTexture;  // 0x00C0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[443];

        return pClassPointer;
    };

    void DrawDebugGraphElement();
    void DrawDebugGraphBackground();
    void DrawDebugGraph();
    void DrawTextureDoubleLine();
    void DrawTextureLine();
    void Draw2DLine();
    void SetDrawColorStruct();
    void EnableStencilTest();
    void SetDrawColor();
    void DrawBox();
    void DrawRect();
    void DrawIcon();
    void DrawScaledIcon();
    void MakeIcon();
    void DrawBlendedTile();
    void DrawTexture();
    void PopMaskRegion();
    void PushMaskRegion();
    void SetClip();
    void SetOrigin();
    void SetPos();
    void GetDefaultCanvasFont();
    void eventReset();
    void PopTransform();
    void PushTranslationMatrix();
    void DeProject();
    void Project();
    void DrawText();
    void TextSize();
    void StrLen();
    void CreateFontRenderInfo();
    void DrawTris();
    void DrawTileStretched();
    void DrawTimer();
    void DrawRotatedMaterialTile();
    void DrawRotatedTile();
    void DrawMaterialTile();
    void PreOptimizeDrawTiles();
    void DrawTile();
};

UClass* UCanvas::pClassPointer = NULL;

// Class Engine.Channel
// 0x0040 (0x00A0 - 0x0060)
class UChannel : public UObject {
   public:
    unsigned char UnknownData00[0x40];  // 0x0060 (0x0040) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[445];

        return pClassPointer;
    };
};

UClass* UChannel::pClassPointer = NULL;

// Class Engine.ActorChannel
// 0x0080 (0x0120 - 0x00A0)
class UActorChannel : public UChannel {
   public:
    unsigned char UnknownData00[0x80];  // 0x00A0 (0x0080) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[447];

        return pClassPointer;
    };
};

UClass* UActorChannel::pClassPointer = NULL;

// Class Engine.ControlChannel
// 0x0014 (0x00B4 - 0x00A0)
class UControlChannel : public UChannel {
   public:
    unsigned char UnknownData00[0x14];  // 0x00A0 (0x0014) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[449];

        return pClassPointer;
    };
};

UClass* UControlChannel::pClassPointer = NULL;

// Class Engine.FileChannel
// 0x0224 (0x02C4 - 0x00A0)
class UFileChannel : public UChannel {
   public:
    unsigned char UnknownData00[0x224];  // 0x00A0 (0x0224) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[451];

        return pClassPointer;
    };
};

UClass* UFileChannel::pClassPointer = NULL;

// Class Engine.VoiceChannel
// 0x0010 (0x00B0 - 0x00A0)
class UVoiceChannel : public UChannel {
   public:
    unsigned char UnknownData00[0x10];  // 0x00A0 (0x0010) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[453];

        return pClassPointer;
    };
};

UClass* UVoiceChannel::pClassPointer = NULL;

// Class Engine.Controller
// 0x01F4 (0x0438 - 0x0244)
class AController : public AActor {
   public:
    struct FPointer
        VfTable_IInterface_NavigationHandle;  // 0x0244 (0x0008)
                                              // [0x0000000000000000]
    class APawn* Pawn;  // 0x024C (0x0008) [0x0000000000150000]              (
                        // CPF_Travel | CPF_GlobalConfig )
    class APlayerReplicationInfo*
        PlayerReplicationInfo;  // 0x0254 (0x0008) [0x0000000000160000] (
                                // CPF_EditConst | CPF_GlobalConfig )
    int PlayerNum;                      // 0x025C (0x0004) [0x0000000000000000]
    class AController* NextController;  // 0x0260 (0x0008) [0x0000000000000000]
    DWORD bIsPlayer : 1;  // 0x0268 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bGodMode : 1;   // 0x0268 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD
        bDemiGodMode : 1;  // 0x0268 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bSoaking : 1;    // 0x0268 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bSlowerZAcquire : 1;    // 0x0268 (0x0004) [0x0000000000000000]
                                  // [0x00000010]
    DWORD bNotifyPostLanded : 1;  // 0x0268 (0x0004) [0x0000000000000000]
                                  // [0x00000020]
    DWORD bNotifyApex : 1;  // 0x0268 (0x0004) [0x0000000000000000] [0x00000040]
    DWORD bOverrideSearchStart : 1;  // 0x0268 (0x0004) [0x0000000000000000]
                                     // [0x00000080]
    DWORD bAdvancedTactics : 1;      // 0x0268 (0x0004) [0x0000000000000000]
                                     // [0x00000100]
    DWORD
        bCanDoSpecial : 1;  // 0x0268 (0x0004) [0x0000000000000000] [0x00000200]
    DWORD bAdjusting : 1;   // 0x0268 (0x0004) [0x0000000000000000] [0x00000400]
    DWORD bPreparingMove : 1;  // 0x0268 (0x0004) [0x0000000000000000]
                               // [0x00000800]
    DWORD
        bForceStrafe : 1;  // 0x0268 (0x0004) [0x0000000000000000] [0x00001000]
    DWORD bLOSflag : 1;    // 0x0268 (0x0004) [0x0000000000000000] [0x00002000]
    DWORD bSkipExtraLOSChecks : 1;    // 0x0268 (0x0004) [0x0000000000000000]
                                      // [0x00004000]
    DWORD bNotifyFallingHitWall : 1;  // 0x0268 (0x0004) [0x0000000000000000]
                                      // [0x00008000]
    DWORD bEarlyOutOfSighTestsForSameType : 1;  // 0x0268 (0x0004)
                                                // [0x0000000000000000]
                                                // [0x00010000]
    DWORD bReachedLatentMoveGoal : 1;  // 0x0268 (0x0004) [0x0000000000000000]
                                       // [0x00020000]
    DWORD bAdjustFromWalls : 1;        // 0x0268 (0x0004) [0x0000000000000000]
                                       // [0x00040000]
    DWORD bPreciseDestination : 1;     // 0x0268 (0x0004) [0x0000000000000000]
                                       // [0x00080000]
    DWORD
        bSeeFriendly : 1;  // 0x0268 (0x0004) [0x0000000000000000] [0x00100000]
    DWORD bUsingPathLanes : 1;  // 0x0268 (0x0004) [0x0000000000000000]
                                // [0x00200000]
    unsigned char bFire;        // 0x026C (0x0001) [0x0000000000000000]
    unsigned char bAltFire;     // 0x026D (0x0001) [0x0000000000000000]
    float MinHitWall;           // 0x0270 (0x0004) [0x0000000000000000]
    class UClass*
        NavigationHandleClass;  // 0x0274 (0x0008) [0x0000000000000000]
    class UNavigationHandle*
        NavigationHandle;                // 0x027C (0x0008) [0x0000000000000000]
    struct FVector OverrideSearchStart;  // 0x0284 (0x000C) [0x0000000000000000]
    float MoveTimer;                     // 0x0290 (0x0004) [0x0000000000000000]
    class AActor* MoveTarget;            // 0x0294 (0x0008) [0x0000000000000000]
    struct FBasedPosition
        DestinationPosition;  // 0x029C (0x0038) [0x0000000000000000]
    struct FBasedPosition
        FocalPosition;            // 0x02D4 (0x0038) [0x0000000000000000]
    class AActor* Focus;          // 0x030C (0x0008) [0x0000000000000000]
    class AActor* GoalList[0x4];  // 0x0314 (0x0020) [0x0000000000000000]
    struct FBasedPosition
        AdjustPosition;                 // 0x0334 (0x0038) [0x0000000000000000]
    class ANavigationPoint* StartSpot;  // 0x036C (0x0008) [0x0000000000000000]
    TArray<class ANavigationPoint*>
        RouteCache;                      // 0x0374 (0x0010) [0x0000000000000000]
    class UReachSpec* CurrentPath;       // 0x0384 (0x0008) [0x0000000000000000]
    class UReachSpec* NextRoutePath;     // 0x038C (0x0008) [0x0000000000000000]
    struct FVector CurrentPathDir;       // 0x0394 (0x000C) [0x0000000000000000]
    class AActor* RouteGoal;             // 0x03A0 (0x0008) [0x0000000000000000]
    float RouteDist;                     // 0x03A8 (0x0004) [0x0000000000000000]
    float LastRouteFind;                 // 0x03AC (0x0004) [0x0000000000000000]
    class AInterpActor* PendingMover;    // 0x03B0 (0x0008) [0x0000000000000000]
    class AActor* FailedMoveTarget;      // 0x03B8 (0x0008) [0x0000000000000000]
    int MoveFailureCount;                // 0x03C0 (0x0004) [0x0000000000000000]
    float GroundPitchTime;               // 0x03C4 (0x0004) [0x0000000000000000]
    class APawn* ShotTarget;             // 0x03C8 (0x0008) [0x0000000000000000]
    class AActor* LastFailedReach;       // 0x03D0 (0x0008) [0x0000000000000000]
    float FailedReachTime;               // 0x03D8 (0x0004) [0x0000000000000000]
    struct FVector FailedReachLocation;  // 0x03DC (0x000C) [0x0000000000000000]
    float SightCounter;                  // 0x03E8 (0x0004) [0x0000000000000000]
    float SightCounterInterval;          // 0x03EC (0x0004) [0x0000000000000000]
    class ANavigationPoint*
        LastNavGoalReached;             // 0x03F0 (0x0008) [0x0000000000000000]
    float InUseNodeCostMultiplier;      // 0x03F8 (0x0004) [0x0000000000000000]
    int HighJumpNodeCostModifier;       // 0x03FC (0x0004) [0x0000000000000000]
    float MaxMoveTowardPawnTargetTime;  // 0x0400 (0x0004) [0x0000000000000000]
    class APawn* Enemy;                 // 0x0404 (0x0008) [0x0000000000000000]
    TArray<struct FVisiblePortalInfo>
        VisiblePortals;                // 0x040C (0x0010) [0x0000000000000000]
    float LaneOffset;                  // 0x041C (0x0004) [0x0000000000000000]
    struct FRotator OldBasedRotation;  // 0x0420 (0x000C) [0x0000000000000000]
    struct FVector NavMeshPath_SearchExtent_Modifier;  // 0x042C (0x000C)
                                                       // [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[455];

        return pClassPointer;
    };

    void eventGeneratePathToLocation();
    void eventGeneratePathToActor();
    void eventInterpolationFinished();
    void eventInterpolationStarted();
    void InitNavigationHandle();
    void ReadyForLift();
    void SendMessage();
    void eventCurrentLevelUnloaded();
    void eventIsInCombat();
    void eventIsSpectating();
    void OnToggleHidden();
    void NotifyAddInventory();
    void OnModifyHealth();
    void NotifyCoverClaimViolation();
    void eventNotifyCoverAdjusted();
    void NotifyCoverDisabled();
    void OnSetVelocity();
    void OnSetPhysics();
    void OnToggleGodMode();
    void OnAttachToActor();
    void OnTeleport();
    void IsDead();
    void GetHumanReadableName();
    void DisplayDebug();
    void StopLatentExecution();
    void InLatentExecution();
    void eventReachedPreciseDestination();
    void eventNotifyMissedJump();
    void eventNotifyJumpApex();
    void eventNotifyBump();
    void eventNotifyFallingHitWall();
    void eventNotifyHitWall();
    void eventNotifyLanded();
    void eventNotifyHeadVolumeChange();
    void eventNotifyPhysicsVolumeChange();
    void LandingShake();
    void IsAimingAt();
    void eventGetActorEyesViewPoint();
    void eventGetPlayerViewPoint();
    void eventHandlePathObstruction();
    void UnderLift();
    void eventMoverFinished();
    void WaitForMover();
    void eventAllowDetourTo();
    void eventMayFall();
    void EndClimbLadder();
    void eventLongFall();
    void WaitForLanding();
    void PickWallAdjust();
    void eventMoveUnreachable();
    void ActorReachable();
    void PointReachable();
    void FindPathToIntercept();
    void FindRandomDest();
    void FindPathTowardNearest();
    void FindPathToward();
    void FindPathTo();
    void FinishRotation();
    void eventSetupSpecialPathAbilities();
    void MoveToward();
    void MoveToDirectNonPathPos();
    void MoveTo();
    void eventEnemyNotVisible();
    void eventSeeMonster();
    void eventSeePlayer();
    void eventHearNoise();
    void PickTarget();
    void CanSeeByPoints();
    void CanSee();
    void LineOfSightTo();
    void NotifyChangedWeapon();
    void ClientSwitchToBestWeapon();
    void SwitchToBestWeapon();
    void ReceiveProjectileWarning();
    void ReceiveWarning();
    void InstantWarnTarget();
    void GetAdjustedAimFor();
    void HandlePickup();
    void RoundHasEnded();
    void eventStopFiring();
    void FireWeaponAt();
    void eventRatePickup();
    void WarnProjExplode();
    void NotifyProjLanded();
    void NotifyKilled();
    void GameHasEnded();
    void SetCharacter();
    void ServerGivePawn();
    void ServerRestartPlayer();
    void GetTeamNum();
    void InitPlayerReplicationInfo();
    void NotifyTakeHit();
    void EnemyJustTeleported();
    void BeyondFogDistance();
    void Restart();
    void CleanupPRI();
    void eventDestroyed();
    void eventNotifyPostLanded();
    void GamePlayEndedState();
    void PawnDied();
    void eventUnPossess();
    void eventPossess();
    void OnPossess();
    void eventReplicatedEvent();
    void ClientSetRotation();
    void ClientSetLocation();
    void Reset();
    void eventPostBeginPlay();
    void eventSetSkelControlScale();
    void eventSetMorphWeight();
    void eventStopActorFaceFXAnim();
    void eventPlayActorFaceFXAnim();
    void eventFinishAnimControl();
    void eventSetAnimPosition();
    void eventBeginAnimControl();
    void eventPauseAndShowMsg();
    void eventAILog_Internal();
    void eventNotifyFailMove();
    void eventJumpedOverWall();
    void eventFailedToFindAnchor();
    void eventNotifyPathChanged();
    void GetAdjustLocation();
    void SetAdjustLocation();
    void GetDestinationPosition();
    void SetDestinationPosition();
    void GetFocalPoint();
    void SetFocalPoint();
    void RouteCache_RemoveIndex();
    void RouteCache_RemoveItem();
    void RouteCache_InsertItem();
    void RouteCache_AddItem();
    void RouteCache_Empty();
    void IsLocalController();
    void IsLocalPlayerController();
};

UClass* AController::pClassPointer = NULL;

// Class Engine.PlayerController
// 0x0338 (0x0770 - 0x0438)
class APlayerController : public AController {
   public:
    class UPlayer* Player;        // 0x0438 (0x0008) [0x0000000000000000]
    class ACamera* PlayerCamera;  // 0x0440 (0x0008) [0x0000000000000000]
    class UClass* CameraClass;    // 0x0448 (0x0008) [0x0000000000000000]
    DWORD bFrozen : 1;  // 0x0450 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD
        bPressedJump : 1;   // 0x0450 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bDoubleJump : 1;  // 0x0450 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bUpdatePosition : 1;  // 0x0450 (0x0004) [0x0000000000000000]
                                // [0x00000008]
    DWORD bUpdating : 1;  // 0x0450 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bNeverSwitchOnPickup : 1;  // 0x0450 (0x0004) [0x0000000000000000]
                                     // [0x00000020]
    DWORD
        bCheatFlying : 1;  // 0x0450 (0x0004) [0x0000000000000000] [0x00000040]
    DWORD bCameraPositionLocked : 1;  // 0x0450 (0x0004) [0x0000000000000000]
                                      // [0x00000080]
    DWORD bShortConnectTimeOut : 1;   // 0x0450 (0x0004) [0x0000000000000000]
                                      // [0x00000100]
    DWORD bPendingDestroy : 1;        // 0x0450 (0x0004) [0x0000000000000000]
                                      // [0x00000200]
    DWORD
        bWasSpeedHack : 1;  // 0x0450 (0x0004) [0x0000000000000000] [0x00000400]
    DWORD
        bWasSaturated : 1;  // 0x0450 (0x0004) [0x0000000000000000] [0x00000800]
    DWORD bAimingHelp : 1;  // 0x0450 (0x0004) [0x0000000000000000] [0x00001000]
    DWORD bCameraCut : 1;   // 0x0450 (0x0004) [0x0000000000000000] [0x00002000]
    DWORD bClientSimulatingViewTarget : 1;  // 0x0450 (0x0004)
                                            // [0x0000000000000000] [0x00004000]
    DWORD bHasVoiceHandshakeCompleted : 1;  // 0x0450 (0x0004)
                                            // [0x0000000000000000] [0x00008000]
    DWORD bCanPlayOnline : 1;  // 0x0450 (0x0004) [0x0000000000000000]
                               // [0x00010000]
    DWORD bCanShareUserCreatedContent : 1;  // 0x0450 (0x0004)
                                            // [0x0000000000000000] [0x00020000]
    DWORD bCanCommunicateVoice : 1;      // 0x0450 (0x0004) [0x0000000000000000]
                                         // [0x00040000]
    DWORD bPrivilegesInitialized : 1;    // 0x0450 (0x0004) [0x0000000000000000]
                                         // [0x00080000]
    DWORD bCinematicMode : 1;            // 0x0450 (0x0004) [0x0000000000000000]
                                         // [0x00100000]
    DWORD bInteractiveMode : 1;          // 0x0450 (0x0004) [0x0000000000000000]
                                         // [0x00200000]
    DWORD bCinemaDisableInputMove : 1;   // 0x0450 (0x0004) [0x0000000000000000]
                                         // [0x00400000]
    DWORD bCinemaDisableInputLook : 1;   // 0x0450 (0x0004) [0x0000000000000000]
                                         // [0x00800000]
    DWORD bRenderHUDFullScreen : 1;      // 0x0450 (0x0004) [0x0000000000000000]
                                         // [0x01000000]
    DWORD bIgnoreNetworkMessages : 1;    // 0x0450 (0x0004) [0x0000000000000000]
                                         // [0x02000000]
    DWORD bShowKismetDrawText : 1;       // 0x0450 (0x0004) [0x0000000000000000]
                                         // [0x04000000]
    DWORD bReplicateAllPawns : 1;        // 0x0450 (0x0004) [0x0000000000000000]
                                         // [0x08000000]
    DWORD bIsUsingStreamingVolumes : 1;  // 0x0450 (0x0004) [0x0000000000000000]
                                         // [0x10000000]
    DWORD bIsExternalUIOpen : 1;         // 0x0450 (0x0004) [0x0000000000000000]
                                         // [0x20000000]
    DWORD bIsControllerConnected : 1;    // 0x0450 (0x0004) [0x0000000000000000]
                                         // [0x40000000]
    DWORD bCheckSoundOcclusion : 1;      // 0x0450 (0x0004) [0x0000000000000000]
                                         // [0x80000000]
    DWORD bDebugCameraAnims : 1;         // 0x0454 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bBlockCameraAnimsFromOverridingPostProcess : 1;  // 0x0454 (0x0004)
                                                           // [0x0000000000000000]
                                                           // [0x00000002]
    DWORD bLogHearSoundOverflow : 1;  // 0x0454 (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    DWORD
        bCheckRelevancyThroughPortals : 1;  // 0x0454 (0x0004)
                                            // [0x0000000000000000] [0x00000008]
    DWORD bDebugClientAdjustPosition : 1;   // 0x0454 (0x0004)
                                            // [0x0000000000000000] [0x00000010]
    DWORD bDrawRelevancyChecks : 1;  // 0x0454 (0x0004) [0x0000000000000000]
                                     // [0x00000020]
    float MaxResponseTime;           // 0x0458 (0x0004) [0x0000000000000000]
    float WaitDelay;                 // 0x045C (0x0004) [0x0000000000000000]
    class APawn* AcknowledgedPawn;   // 0x0460 (0x0008) [0x0000000000000000]
    unsigned char DoubleClickDir;    // 0x0468 (0x0001) [0x0000000000000000]
    unsigned char bIgnoreMoveInput;  // 0x0469 (0x0001) [0x0000000000000000]
    unsigned char bIgnoreLookInput;  // 0x046A (0x0001) [0x0000000000000000]
    unsigned char bRun;              // 0x046B (0x0001) [0x0000000000000000]
    unsigned char bDuck;             // 0x046C (0x0001) [0x0000000000000000]
    unsigned char NetPlayerIndex;    // 0x046D (0x0001) [0x0000000000000000]
    unsigned char RelevancyCounter;  // 0x046E (0x0001) [0x0000000000000000]
    class AActor* ViewTarget;        // 0x0470 (0x0008) [0x0000000000000000]
    class APlayerReplicationInfo*
        RealViewTarget;  // 0x0478 (0x0008) [0x0000000000000000]
    class UInterpTrackInstDirector*
        ControllingDirTrackInst;  // 0x0480 (0x0008) [0x0000000000000000]
    float FOVAngle;               // 0x0488 (0x0004) [0x0000000000000000]
    float DesiredFOV;             // 0x048C (0x0004) [0x0000000000000000]
    float DefaultFOV;             // 0x0490 (0x0004) [0x0000000000000000]
    float LODDistanceFactor;      // 0x0494 (0x0004) [0x0000000000000000]
    struct FRotator
        TargetViewRotation;  // 0x0498 (0x000C) [0x0000000000170000] (
                             // CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
    float TargetEyeHeight;  // 0x04A4 (0x0004) [0x0000000000180000] (
                            // CPF_Component )
    struct FRotator
        BlendedTargetViewRotation;  // 0x04A8 (0x000C) [0x0000000000000000]
    class AHUD* myHUD;              // 0x04B4 (0x0008) [0x0000000000000000]
    class AHUD* mySecondaryHUD;     // 0x04BC (0x0008) [0x0000000000000000]
    class UClass* SavedMoveClass;   // 0x04C4 (0x0008) [0x0000000000000000]
    class USavedMove* SavedMoves;   // 0x04CC (0x0008) [0x0000000000000000]
    class USavedMove* FreeMoves;    // 0x04D4 (0x0008) [0x0000000000000000]
    class USavedMove* PendingMove;  // 0x04DC (0x0008) [0x0000000000000000]
    struct FVector LastAckedAccel;  // 0x04E4 (0x000C) [0x0000000000000000]
    float CurrentTimeStamp;         // 0x04F0 (0x0004) [0x0000000000000000]
    float LastUpdateTime;           // 0x04F4 (0x0004) [0x0000000000000000]
    float ServerTimeStamp;          // 0x04F8 (0x0004) [0x0000000000000000]
    float TimeMargin;               // 0x04FC (0x0004) [0x0000000000000000]
    float ClientUpdateTime;         // 0x0500 (0x0004) [0x0000000000000000]
    float MaxTimeMargin;            // 0x0504 (0x0004) [0x0000000000000000]
    float LastActiveTime;           // 0x0508 (0x0004) [0x0000000000000000]
    int ClientCap;                  // 0x050C (0x0004) [0x0000000000000000]
    float DynamicPingThreshold;     // 0x0510 (0x0004) [0x0000000000000000]
    float LastPingUpdate;           // 0x0514 (0x0004) [0x0000000000000000]
    float LastSpeedHackLog;         // 0x0518 (0x0004) [0x0000000000000000]
    struct FClientAdjustment
        PendingAdjustment;              // 0x051C (0x0038) [0x0000000000000000]
    int GroundPitch;                    // 0x0554 (0x0004) [0x0000000000000000]
    class UCheatManager* CheatManager;  // 0x0558 (0x0008) [0x0000000000000000]
    class UClass* CheatClass;           // 0x0560 (0x0008) [0x0000000000000000]
    class UPlayerInput* PlayerInput;    // 0x0568 (0x0008) [0x0000000000000000]
    class UClass* InputClass;           // 0x0570 (0x0008) [0x0000000000000000]
    struct FVector FailedPathStart;     // 0x0578 (0x000C) [0x0000000000000000]
    class UCylinderComponent*
        CylinderComponent;  // 0x0584 (0x0008) [0x0000000000000000]
    struct FString
        ForceFeedbackManagerClassName;  // 0x058C (0x0010) [0x0000000000000000]
    class UForceFeedbackManager*
        ForceFeedbackManager;  // 0x059C (0x0008) [0x0000000000000000]
    TArray<class UInteraction*>
        Interactions;  // 0x05A4 (0x0010) [0x0000000000000000]
    TArray<struct FUniqueNetId>
        VoiceMuteList;  // 0x05B4 (0x0010) [0x0000000000000000]
    TArray<struct FUniqueNetId>
        GameplayVoiceMuteList;  // 0x05C4 (0x0010) [0x0000000000000000]
    TArray<struct FUniqueNetId>
        VoicePacketFilter;  // 0x05D4 (0x0010) [0x0000000000000000]
    TArray<struct FConnectedPeerInfo>
        ConnectedPeers;  // 0x05E4 (0x0010) [0x0000000000000000]
    TArray<struct FUniqueNetId>
        BestNextHostPeers;  // 0x05F4 (0x0010) [0x0000000000000000]
    class UOnlineGameSearch*
        MigratedSearchToJoin;           // 0x0604 (0x0008) [0x0000000000000000]
    class UOnlineSubsystem* OnlineSub;  // 0x060C (0x0008) [0x0000000000000000]
    class UPlayfabInterface*
        PlayfabInter;  // 0x0614 (0x0008) [0x0000000000000000]
    class UOnlineVoiceInterface*
        VoiceInterface;                // 0x061C (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x8];  // 0x0624 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UUIDataStore_OnlinePlayerData*
        OnlinePlayerData;  // 0x062C (0x0008) [0x0000000000000000]
    struct FOnlineGameSearchResult
        CachedInviteResult;  // 0x0634 (0x0010) [0x0000000000000000]
    float InteractDistance;  // 0x0644 (0x0004) [0x0000000000000000]
    struct FName
        DelayedJoinSessionName;  // 0x0648 (0x0008) [0x0000000000000000]
    TArray<struct FInputMatchRequest>
        InputRequests;        // 0x0650 (0x0010) [0x0000000000000000]
    float LastBroadcastTime;  // 0x0660 (0x0004) [0x0000000000000000]
    struct FString
        LastBroadcastString[0x4];  // 0x0664 (0x0040) [0x0000000000000000]
    TArray<struct FName>
        PendingMapChangeLevelNames;  // 0x06A4 (0x0010) [0x0000000000000000]
    class ACoverReplicator*
        MyCoverReplicator;  // 0x06B4 (0x0008) [0x0000000000000000]
    TArray<struct FDebugTextInfo>
        DebugTextList;           // 0x06BC (0x0010) [0x0000000000000000]
    float SpectatorCameraSpeed;  // 0x06CC (0x0004) [0x0000000000000000]
    class UNetConnection*
        PendingSwapConnection;    // 0x06D0 (0x0008) [0x0000000000000000]
    float MinRespawnDelay;        // 0x06D8 (0x0004) [0x0000000000000000]
    int MaxConcurrentHearSounds;  // 0x06DC (0x0004) [0x0000000000000000]
    TArray<class UAudioComponent*>
        HearSoundActiveComponents;  // 0x06E0 (0x0010) [0x0000000000000000]
    TArray<class UAudioComponent*>
        HearSoundPoolComponents;         // 0x06F0 (0x0010) [0x0000000000000000]
    TArray<class AActor*> HiddenActors;  // 0x0700 (0x0010) [0x0000000000000000]
    float LastSpectatorStateSynchTime;   // 0x0710 (0x0004) [0x0000000000000000]
    TArray<struct FUniqueNetId>
        VoiceSenders;  // 0x0714 (0x0010) [0x0000000000000000]
    TArray<struct FUniqueNetId>
        VoiceReceivers;  // 0x0724 (0x0010) [0x0000000000000000]
    struct FRotator
        WeaponBufferRotation;  // 0x0734 (0x000C) [0x0000000000000000]
    struct FScriptDelegate
        __OnMissingPeersUnregistered__Delegate;  // 0x0740 (0x0010)
                                                 // [0x0000000000000000]
    unsigned char UnknownData01[0x4];  // 0x0744 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __CanUnpause__Delegate;        // 0x0750 (0x0010) [0x0000000000000000]
    unsigned char UnknownData02[0x4];  // 0x0754 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __InputMatchDelegate__Delegate;  // 0x0760 (0x0010) [0x0000000000000000]
    unsigned char UnknownData03[0x4];  // 0x0764 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[457];

        return pClassPointer;
    };

    void ClientReceiveReliableVoicePacket();
    void ServerReceiveReliableVoicePacket();
    void eventSendReliableVoicePacketToServer();
    void eventClientReplicationDebug();
    void OnLobbyStatusChanged();
    void NotifyUnsuccessfulSearch();
    void eventSetUIScale();
    void eventSetMatineeConstantCameraAnim();
    void eventNotifyDisconnect();
    void ReceivedGameClass();
    void LogOutBugItAIGoToLogFile();
    void LogOutBugItGoToLogFile();
    void DisableDebugAI();
    void ReadFriendsList();
    void OnFriendsReadComplete();
    void SetCallback();
    void DumpPeers();
    void DumpVoiceMutingState();
    void DumpOnlineSessionState();
    void DebugLogPRIs();
    void eventOnEngineInitialTick();
    void BugItStringCreator();
    void BugItAI();
    void LogLoc();
    void BugIt();
    void BugItWorker();
    void BugItGoString();
    void BugItGo();
    void HasPeerConnection();
    void OnSetSoundMode();
    void eventClientSpawnCameraLensEffect();
    void DebugCameraAnims();
    void eventClientStopCameraAnim();
    void eventClientPlayCameraAnim();
    void OnCameraShake();
    void ClientStopCameraShake();
    void ClientPlayCameraShake();
    void DoForceFeedbackForScreenShake();
    void InputMatchDelegate();
    void Sentinel_PostAcquireTravelTheWorldPoints();
    void Sentinel_PreAcquireTravelTheWorldPoints();
    void Sentinel_SetupForGamebasedTravelTheWorld();
    void OnFlyThroughHasEnded();
    void eventGetAchievementProgression();
    void GetPartyGameTypeName();
    void GetPartyMapName();
    void IsPartyLeader();
    void eventClientAddTextureStreamingLoc();
    void eventClientPrestreamTextures();
    void eventClientSetForceMipLevelsToBeResident();
    void ClientControlMovieTexture();
    void GetSplitscreenPlayerCount();
    void GetSplitscreenPlayerByIndex();
    void IsSplitscreenPlayer();
    void IsPrimaryPlayer();
    void ServerNotifyPartyHostLeaving();
    void ClientNotifyPartyHostLeaving();
    void ClientReturnToParty();
    void OnJoinTravelToSessionComplete();
    void PreJoinUpdateGameSettings();
    void ClientTravelToSession();
    void PathClear();
    void PathChild();
    void PathStep();
    void eventSoakPause();
    void IncrementNumberOfMatchesPlayed();
    void CanViewUserCreatedContent();
    void ClientEndOnlineGame();
    void ClientStartOnlineGame();
    void ServerRegisterClientStatGuid();
    void OnRegisterHostStatGuidComplete();
    void ClientRegisterHostStatGuid();
    void eventRemoveAllDebugStrings();
    void eventRemoveDebugText();
    void eventAddDebugText();
    void DrawDebugTextList();
    void OnDestroy();
    void ClientStartNetworkedVoice();
    void ClientStopNetworkedVoice();
    void ClientSetHostUniqueId();
    void ClientWriteLeaderboardStats();
    void ClientWriteOnlinePlayerScores();
    void ClientArbitratedMatchEnded();
    void NotifyNotEnoughSpaceInInvite();
    void NotifyNotAllPlayersCanJoinInvite();
    void NotifyInviteFailed();
    void OnInviteJoinComplete();
    void ModifyClientURL();
    void OnDestroyForInviteComplete();
    void OnEndForInviteComplete();
    void ClearInviteDelegates();
    void CanAllPlayersPlayOnline();
    void InviteHasEnoughSpace();
    void JoinPlayfabServer();
    void OnPlayTogetherStarted();
    void OnConnectionStatusChange();
    void OnGameInviteAccepted();
    void ServerRegisteredForArbitration();
    void OnArbitrationRegisterComplete();
    void ClientRegisterForArbitration();
    void eventClientWasKicked();
    void IsShowingSubtitles();
    void SetShowSubtitles();
    void eventNotifyDirectorControl();
    void eventServerUnmutePlayer();
    void eventServerMutePlayer();
    void GameplayUnmutePlayer();
    void GameplayMutePlayer();
    void eventClientUnmutePlayer();
    void eventClientMutePlayer();
    void ClientVoiceHandshakeComplete();
    void GetPlayerControllerFromNetId();
    void ClientSetOnlineStatus();
    void SeamlessTravelFrom();
    void SeamlessTravelTo();
    void eventGetSeamlessTravelActorList();
    void ForceDisconnect();
    void ShouldReplicateVoicePacketTo();
    void ShouldReplicateVoicePacketFrom();
    void IsPlayerMuted();
    void GetUIController();
    void SaveActorConfig();
    void SaveClassConfig();
    void ClientWaitForLevelsVisible();
    void eventClientSetBlockOnAsyncLoading();
    void eventClientFlushLevelStreaming();
    void eventClientCancelPendingMapChange();
    void eventClientCommitMapChange();
    void DelayedPrepareMapChange();
    void eventClientPrepareMapChange();
    void eventServerUpdateLevelVisibility();
    void ClientUpdateLevelStreamingStatus();
    void eventLevelStreamingStatusChanged();
    void eventClientForceGarbageCollection();
    void OnConsoleCommand();
    void ResetPlayerMovementInput();
    void eventIsLookInputIgnored();
    void IgnoreLookInput();
    void eventIsMoveInputIgnored();
    void IgnoreMoveInput();
    void ClientSetCinematicMode();
    void SetCinematicMode();
    void OnToggleCinematicMode();
    void IsForceFeedbackAllowed();
    void eventClientStopForceFeedbackWaveform();
    void eventClientPlayForceFeedbackWaveform();
    void eventPlayRumble();
    void OnForceFeedback();
    void NotifyTakeHit();
    void ShowGameState();
    void ShowPlayerState();
    void ServerRemoteEvent();
    void RE();
    void RemoteEvent();
    void ListCE();
    void ListConsoleEvents();
    void CE();
    void CauseEvent();
    void ServerCauseEvent();
    void OnToggleHUD();
    void OnSetCameraTarget();
    void ClientClearKismetText();
    void ClientDrawKismetText();
    void OnDrawText();
    void DisplayDebug();
    void ClientIgnoreLookInput();
    void ClientIgnoreMoveInput();
    void OnToggleInput();
    void eventAdjustHUDRenderSize();
    void DrawHUD();
    void CanRestartPlayer();
    void ServerViewSelf();
    void ViewAPlayer();
    void GetNextViewablePlayer();
    void ServerViewPrevPlayer();
    void ServerViewNextPlayer();
    void ServerSetSpectatorLocation();
    void IsSpectating();
    void AdjustPlayerWalkingMoveAccel();
    void CheckJumpOrDuck();
    void eventLimitViewRotation();
    void ProcessViewRotation();
    void ModifyUpdateRotation();
    void UpdateRotation();
    void ViewShake();
    void eventGetPlayerViewPoint();
    void eventSpawnPlayerCamera();
    void ServerVerifyViewTarget();
    void GetViewTarget();
    void eventClientSetViewTarget();
    void SetViewTargetWithBlend();
    void SetViewTarget();
    void IsLocalController();
    void IsLocalPlayerController();
    void eventGetFOVAngle();
    void AdjustFOV();
    void eventNotifyLanded();
    void AimHelpDot();
    void GetAdjustedAimFor();
    void eventCameraLookAtFinished();
    void AimingHelp();
    void PlayerMove();
    void eventPlayerTick();
    void NotifyChangedWeapon();
    void ClientGameEnded();
    void GameHasEnded();
    void ClientRestart();
    void EnterStartState();
    void ForceSingleNetUpdateFor();
    void HasClientLoadedCurrentWorld();
    void eventNotifyLoadedWorld();
    void eventServerNotifyLoadedWorld();
    void Restart();
    void eventClientSetProgressMessage();
    void SwitchLevel();
    void ServerChangeTeam();
    void ChangeTeam();
    void SwitchTeam();
    void ServerChangeName();
    void SetName();
    void ServerSuicide();
    void Suicide();
    void TriggerInteracted();
    void FindVehicleToDrive();
    void PerformedUseAction();
    void ServerUse();
    void Use();
    void GetTriggerUseList();
    void StopAltFire();
    void StartAltFire();
    void StopFire();
    void StartFire();
    void NextWeapon();
    void PrevWeapon();
    void ServerThrowWeapon();
    void ThrowWeapon();
    void UTrace();
    void ServerUTrace();
    void eventConditionalPause();
    void ServerPause();
    void Pause();
    void IsPaused();
    void SetPause();
    void CanUnpause();
    void ClientPauseRumble();
    void PauseRumbleForAllPlayers();
    void LocalTravel();
    void RestartLevel();
    void ServerSpeech();
    void Speech();
    void ServerRestartGame();
    void HandleWalking();
    void ServerUpdateCamera();
    void CallServerMove();
    void ReplicateMove();
    void CompressAccel();
    void GetFreeMove();
    void ClientUpdatePosition();
    void ClearAckedMoves();
    void ServerUpdatePing();
    void UpdateStateFromAdjustment();
    void LongClientAdjustPosition();
    void SkipPositionUpdateForRM();
    void UpdatePing();
    void ClientAdjustPosition();
    void ClientAckGoodMove();
    void ClientCapBandwidth();
    void ShortClientAdjustPosition();
    void VeryShortClientAdjustPosition();
    void MoveAutonomous();
    void ProcessMove();
    void ProcessDrive();
    void ServerDrive();
    void eventSendClientAdjustment();
    void ServerMove();
    void ServerMoveHandleClientError();
    void GetServerMoveDeltaTime();
    void OldServerMove();
    void DualServerMove();
    void ForceDeathUpdate();
    void UsingFirstPersonCamera();
    void eventClientSetCameraFade();
    void eventResetCameraMode();
    void SetCameraMode();
    void ClientSetCameraMode();
    void ServerCamera();
    void Camera();
    void eventPreClientTravel();
    void ServerTeamSay();
    void TeamSay();
    void ClientAdminMessage();
    void ServerSay();
    void Say();
    void AllowTextMessage();
    void ServerMutate();
    void Mutate();
    void FOV();
    void ResetFOV();
    void SetFOV();
    void FixFOV();
    void eventDestroyed();
    void CleanupPawn();
    void eventClearOnlineDelegates();
    void OnPartyMembersInfoChanged();
    void OnPartyMemberListChanged();
    void RegisterOnlineDelegates();
    void PlayBeepSound();
    void eventTeamMessage();
    void SpeakTTS();
    void TeamTalk();
    void Talk();
    void CreateTTSSoundCue();
    void AllowTTSMessageFrom();
    void CanCommunicate();
    void eventClientMessage();
    void ClientPlayActorFaceFXAnim();
    void eventKismet_ClientStopSound();
    void eventKismet_ClientPlaySound();
    void IsClosestLocalPlayerToActor();
    void eventWwiseClientHearSound();
    void eventClientHearSoundAdvancedRelevant();
    void eventClientHearSoundAdvanced();
    void eventClientHearSound();
    void GetPooledAudioComponent();
    void HearSoundFinished();
    void eventClientPlaySound();
    void eventReceiveLocalizedMessage();
    void CleanupPRI();
    void HandlePickup();
    void ClientSetSecondaryHUD();
    void ClientSetHUD();
    void PawnDied();
    void eventUnPossess();
    void ServerAcknowledgePossession();
    void AcknowledgePossession();
    void eventPossess();
    void GivePawn();
    void AskForPawn();
    void ClientGotoState();
    void SetTiltActive();
    void IsMouseAvailable();
    void IsKeyboardAvailable();
    void SetUseTiltForwardAndBack();
    void SetOnlyUseControllerTiltInput();
    void SetControllerTiltActive();
    void IsControllerTiltActive();
    void SetRumbleScale();
    void ReloadProfileSettings();
    void UnregisterStandardPlayerDataStores();
    void UnregisterPlayerDataStores();
    void RegisterStandardPlayerDataStores();
    void RegisterCustomPlayerDataStores();
    void RegisterPlayerDataStores();
    void ClientInitializeDataStores();
    void eventInitInputSystem();
    void GetOnlineSubsystem();
    void PostControllerIdChange();
    void PreControllerIdChange();
    void CleanOutSavedMoves();
    void ClientReset();
    void Reset();
    void SpawnDefaultHUD();
    void EnableCheats();
    void AddCheats();
    void eventKickWarning();
    void ServerGivePawn();
    void ServerShortTimeout();
    void ResetTimeMargin();
    void eventPreRender();
    void OnJoinMigratedGame();
    void PeerDesignatedAsClient();
    void OnUnregisterPlayerCompleteForJoinMigrate();
    void eventPeerReceivedMigratedSession();
    void TellPeerToTravelToSession();
    void TellPeerToTravel();
    void PeerTravelAsHost();
    void GetNewPeerHostURL();
    void PeerDesignatedAsHost();
    void GetCurrentSearchClass();
    void OnHostMigratedOnlineGame();
    void OnUnregisterPlayerCompleteForHostMigrate();
    void RemoveMissingPeersFromSession();
    void GetPRIFromNetId();
    void OnMissingPeersUnregistered();
    void GetRegisteredPlayersInSession();
    void NotifyHostMigrationStarted();
    void eventMigrateNewHost();
    void IsBestHostPeer();
    void eventNotifyPeerDisconnectHost();
    void ClientUpdateBestNextHosts();
    void ServerRemovePeer();
    void ServerAddPeer();
    void eventRemovePeer();
    void eventAddPeer();
    void BestNextHostSort();
    void FindConnectedPeerIndex();
    void eventReceivedPlayer();
    void eventPostBeginPlay();
    void SpawnCoverReplicator();
    void CanUnpauseControllerConnected();
    void ControllerChangedUnpause();
    void ControllerChangedPause();
    void OnControllerChanged();
    void CanUnpauseExternalUI();
    void OnExternalUIChanged();
    void OnPrivilegeLevelChecked();
    void eventCheckPrivileges();
    void ForceClearUnpauseDelegates();
    void DisableActorHeadTracking();
    void EnableActorHeadTracking();
    void eventFellOutOfWorld();
    void CleanUpAudioComponents();
    void FindStairRotation();
    void CheckSpeedHack();
    void eventServerProcessConvolve();
    void eventClientConvolve();
    void SetAudioGroupVolume();
    void SetAllowMatureLanguage();
    void PasteFromClipboard();
    void CopyToClipboard();
    void GetDefaultURL();
    void UpdateURL();
    void eventClientTravel();
    void ConsoleCommand();
    void GetServerNetworkAddress();
    void GetPlayerNetworkAddress();
    void SetNetSpeed();
};

UClass* APlayerController::pClassPointer = NULL;

// Class Engine.CheatManager
// 0x0020 (0x0080 - 0x0060)
class UCheatManager : public UObject {
   public:
    struct FString ViewingFrom;  // 0x0060 (0x0010) [0x0000000000000000]
    struct FString OwnCamera;    // 0x0070 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[459];

        return pClassPointer;
    };

    void AnalyticsEndSession();
    void AnalyticsStartSession();
    void GetAnalyticsUserId();
    void SetAnalyticsUserId();
    void SendAnalyticsCachedEvents();
    void SendAnalyticsCurrencyGivenEvent();
    void SendAnalyticsCurrencyPurchaseEvent();
    void SendAnalyticsItemPurchaseEvent();
    void SendAnalyticsUserAttributeEvent();
    void SendAnalyticsEvent();
    void OnRequestComplete();
    void TestHttp();
    void OnDeleteUserFileComplete();
    void DebugDeleteUserFile();
    void OnReadUserFileComplete();
    void DebugReadUserFile();
    void OnWriteUserFileComplete();
    void DebugWriteUserFile();
    void OnEnumerateUserFilesComplete();
    void DebugQueryUserFiles();
    void OnReceivedLocalNotificationDebug();
    void DebugNotification();
    void DrawLocationXYZ();
    void DrawLocation();
    void DumpCoverStats();
    void DebugEmsDownload();
    void DebugDeleteTitleFiles();
    void OnSaveComplete();
    void DebugSaveTitleFile();
    void OnLoadComplete();
    void OnDownloadComplete();
    void DebugDownloadTitleFile();
    void DebugIniLocPatcher();
    void ToggleAILogging();
    void VerifyNavMeshCoverRefs();
    void PrintNavMeshObstacles();
    void PrintAllPathObjectEdges();
    void NavMeshVerification();
    void DrawUnsupportingEdges();
    void VerifyNavMeshObjects();
    void LogParticleActivateSystemCalls();
    void LogPlaySoundCalls();
    void InitCheatManager();
    void VerbosePathDebug();
    void TestPylonConnectivity();
    void TestNavMeshPath();
    void SetOnlineDebugLevel();
    void DumpOnlineSessionState();
    void TestLevel();
    void StreamLevelOut();
    void OnlyLoadLevel();
    void StreamLevelIn();
    void SetLevelStreamingStatus();
    void AllWeapons();
    void Loaded();
    void ViewClass();
    void ViewBot();
    void ViewActor();
    void ViewPlayer();
    void ViewSelf();
    void RememberSpot();
    void FractureAllMeshesToMaximizeMemoryUsage();
    void FractureAllMeshes();
    void DestroyFractures();
    void SuspendAI();
    void PlayersOnly();
    void GiveWeapon();
    void Summon();
    void Avatar();
    void KillPawns();
    void KillAllPawns();
    void KillAll();
    void SetSpeed();
    void SetGravity();
    void SetJumpZ();
    void Slomo();
    void God();
    void AllAmmo();
    void Ghost();
    void Walk();
    void Fly();
    void Amphibious();
    void EndPath();
    void ChangeSize();
    void Teleport();
    void KillViewedActor();
    void WriteToLog();
    void FreezeFrame();
    void ListDynamicActors();
    void DebugPause();
    void EditAIByTrace();
    void DebugAI();
    void FXStop();
    void FXPlay();
};

UClass* UCheatManager::pClassPointer = NULL;

// Class Engine.Client
// 0x0018 (0x0078 - 0x0060)
class UClient : public UObject {
   public:
    unsigned char UnknownData00[0x8];  // 0x0060 (0x0008) MISSED OFFSET
    float MinDesiredFrameRate;         // 0x0068 (0x0004) [0x0000000000000000]
    float DisplayGamma;                // 0x006C (0x0004) [0x0000000000000000]
    float InitialButtonRepeatDelay;    // 0x0070 (0x0004) [0x0000000000000000]
    float ButtonRepeatDelay;           // 0x0074 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[461];

        return pClassPointer;
    };
};

UClass* UClient::pClassPointer = NULL;

// Class Engine.ClipPadEntry
// 0x0020 (0x0080 - 0x0060)
class UClipPadEntry : public UObject {
   public:
    struct FString Title;  // 0x0060 (0x0010) [0x0000000000000000]
    struct FString Text;   // 0x0070 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[467];

        return pClassPointer;
    };
};

UClass* UClipPadEntry::pClassPointer = NULL;

// Class Engine.CloudSaveSystem
// 0x0084 (0x00E4 - 0x0060)
class UCloudSaveSystem : public UObject {
   public:
    class UCloudSaveSystemKVSInterface*
        KeyValueStore;                 // 0x0060 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x8];  // 0x0068 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UCloudSaveSystemDataBlobStoreInterface*
        DataBlobStore;                 // 0x0070 (0x0010) [0x0000000000000000]
    unsigned char UnknownData01[0x8];  // 0x0078 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    TArray<struct FGetSaveDataCallbackStruct>
        OnGetSaveDataCallbacks;  // 0x0080 (0x0010) [0x0000000000000000]
    TArray<struct FSetSaveDataCallbackStruct>
        OnSetSaveDataCallbacks;  // 0x0090 (0x0010) [0x0000000000000000]
    struct FScriptDelegate
        DeleteSaveDataCallback;        // 0x00A0 (0x0010) [0x0000000000000000]
    unsigned char UnknownData02[0x4];  // 0x00A4 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    int ActiveSlotForDelete;           // 0x00B0 (0x0004) [0x0000000000000000]
    TArray<struct FSaveSlotOperation>
        ActiveSaveSlotOperations;  // 0x00B4 (0x0010) [0x0000000000000000]
    struct FScriptDelegate
        __OnGetSaveDataCallback__Delegate;  // 0x00C4 (0x0010)
                                            // [0x0000000000000000]
    unsigned char UnknownData03[0x4];  // 0x00C8 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __SaveSystemCallback__Delegate;  // 0x00D4 (0x0010) [0x0000000000000000]
    unsigned char UnknownData04[0x4];  // 0x00D8 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[469];

        return pClassPointer;
    };

    void GetKeyValue();
    void GetDataStoreIDAndBlobNameForSaveSlot();
    void SetKeyValue();
    void InternalSetSaveSlotKeyValues();
    void SetSaveSlotKeyValues();
    void OnDeleteSaveDataComplete();
    void DeleteSaveData();
    void OnSetSaveDataComplete();
    void SetSaveData();
    void OnGetSaveDataComplete();
    void GetSaveData();
    void Init();
    void DeserializeObject();
    void SerializeObject();
    void AreAnySlotOperationsActive();
    void IsDeleteOperationActive();
    void IsOperationActiveForSlot();
    void WriteNumSaveSlots();
    void DoesSaveSlotKeyValueDataAlreadyExist();
    void GetNumberOfSaveSlots();
    void SaveSystemCallback();
    void OnGetSaveDataCallback();
};

UClass* UCloudSaveSystem::pClassPointer = NULL;

// Class Engine.CodecMovie
// 0x0004 (0x0064 - 0x0060)
class UCodecMovie : public UObject {
   public:
    float PlaybackDuration;  // 0x0060 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[471];

        return pClassPointer;
    };
};

UClass* UCodecMovie::pClassPointer = NULL;

// Class Engine.CodecMovieBink
// 0x0038 (0x009C - 0x0064)
class UCodecMovieBink : public UCodecMovie {
   public:
    unsigned char UnknownData00[0x38];  // 0x0064 (0x0038) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[473];

        return pClassPointer;
    };
};

UClass* UCodecMovieBink::pClassPointer = NULL;

// Class Engine.CodecMovieFallback
// 0x0004 (0x0068 - 0x0064)
class UCodecMovieFallback : public UCodecMovie {
   public:
    float CurrentTime;  // 0x0064 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[475];

        return pClassPointer;
    };
};

UClass* UCodecMovieFallback::pClassPointer = NULL;

// Class Engine.CurveEdPresetCurve
// 0x0020 (0x0080 - 0x0060)
class UCurveEdPresetCurve : public UObject {
   public:
    struct FString CurveName;  // 0x0060 (0x0010) [0x0000000000000000]
    TArray<struct FPresetGeneratedPoint>
        Points;  // 0x0070 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[477];

        return pClassPointer;
    };
};

UClass* UCurveEdPresetCurve::pClassPointer = NULL;

// Class Engine.CustomPropertyItemHandler
// 0x0000 (0x0060 - 0x0060)
class UCustomPropertyItemHandler : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[479];

        return pClassPointer;
    };
};

UClass* UCustomPropertyItemHandler::pClassPointer = NULL;

// Class Engine.DamageType
// 0x0030 (0x0090 - 0x0060)
class UDamageType : public UObject {
   public:
    DWORD bArmorStops : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bCausedByWorld : 1;          // 0x0060 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD bExtraMomentumZ : 1;         // 0x0060 (0x0004) [0x0000000000000000]
                                       // [0x00000004]
    DWORD bCausesFracture : 1;         // 0x0060 (0x0004) [0x0000000000000000]
                                       // [0x00000008]
    DWORD bRadialDamageVelChange : 1;  // 0x0060 (0x0004) [0x0000000000000000]
                                       // [0x00000010]
    float KDamageImpulse;              // 0x0064 (0x0004) [0x0000000000000000]
    float KDeathVel;                   // 0x0068 (0x0004) [0x0000000000000000]
    float KDeathUpKick;                // 0x006C (0x0004) [0x0000000000000000]
    float RadialDamageImpulse;         // 0x0070 (0x0004) [0x0000000000000000]
    float VehicleDamageScaling;        // 0x0074 (0x0004) [0x0000000000000000]
    float VehicleMomentumScaling;      // 0x0078 (0x0004) [0x0000000000000000]
    class UForceFeedbackWaveform*
        DamagedFFWaveform;  // 0x007C (0x0008) [0x0000000000000000]
    class UForceFeedbackWaveform*
        KilledFFWaveform;       // 0x0084 (0x0008) [0x0000000000000000]
    float FracturedMeshDamage;  // 0x008C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[481];

        return pClassPointer;
    };

    void VehicleDamageScalingFor();
};

UClass* UDamageType::pClassPointer = NULL;

// Class Engine.KillZDamageType
// 0x0000 (0x0090 - 0x0090)
class UKillZDamageType : public UDamageType {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[483];

        return pClassPointer;
    };
};

UClass* UKillZDamageType::pClassPointer = NULL;

// Class Engine.DistributionFloatConstant
// 0x0004 (0x0080 - 0x007C)
class UDistributionFloatConstant : public UDistributionFloat {
   public:
    float Constant;  // 0x007C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[485];

        return pClassPointer;
    };
};

UClass* UDistributionFloatConstant::pClassPointer = NULL;

// Class Engine.DistributionFloatParameterBase
// 0x0019 (0x0099 - 0x0080)
class UDistributionFloatParameterBase : public UDistributionFloatConstant {
   public:
    struct FName ParameterName;  // 0x0080 (0x0008) [0x0000000000000000]
    float MinInput;              // 0x0088 (0x0004) [0x0000000000000000]
    float MaxInput;              // 0x008C (0x0004) [0x0000000000000000]
    float MinOutput;             // 0x0090 (0x0004) [0x0000000000000000]
    float MaxOutput;             // 0x0094 (0x0004) [0x0000000000000000]
    unsigned char ParamMode;     // 0x0098 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[487];

        return pClassPointer;
    };
};

UClass* UDistributionFloatParameterBase::pClassPointer = NULL;

// Class Engine.DistributionFloatConstantCurve
// 0x0014 (0x0090 - 0x007C)
class UDistributionFloatConstantCurve : public UDistributionFloat {
   public:
    struct FInterpCurveFloat
        ConstantCurve;  // 0x007C (0x0014) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[489];

        return pClassPointer;
    };
};

UClass* UDistributionFloatConstantCurve::pClassPointer = NULL;

// Class Engine.DistributionFloatUniform
// 0x0008 (0x0084 - 0x007C)
class UDistributionFloatUniform : public UDistributionFloat {
   public:
    float Min;  // 0x007C (0x0004) [0x0000000000000000]
    float Max;  // 0x0080 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[491];

        return pClassPointer;
    };
};

UClass* UDistributionFloatUniform::pClassPointer = NULL;

// Class Engine.DistributionFloatUniformCurve
// 0x0014 (0x0090 - 0x007C)
class UDistributionFloatUniformCurve : public UDistributionFloat {
   public:
    struct FInterpCurveVector2D
        ConstantCurve;  // 0x007C (0x0014) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[493];

        return pClassPointer;
    };
};

UClass* UDistributionFloatUniformCurve::pClassPointer = NULL;

// Class Engine.DistributionFloatUniformRange
// 0x0014 (0x0090 - 0x007C)
class UDistributionFloatUniformRange : public UDistributionFloat {
   public:
    float MaxHigh;  // 0x007C (0x0004) [0x0000000000000000]
    float MaxLow;   // 0x0080 (0x0004) [0x0000000000000000]
    float MinHigh;  // 0x0084 (0x0004) [0x0000000000000000]
    float MinLow;   // 0x0088 (0x0004) [0x0000000000000000]
    DWORD
        bMirrorMaxMin : 1;  // 0x008C (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[495];

        return pClassPointer;
    };
};

UClass* UDistributionFloatUniformRange::pClassPointer = NULL;

// Class Engine.DistributionVectorConstant
// 0x0011 (0x008D - 0x007C)
class UDistributionVectorConstant : public UDistributionVector {
   public:
    struct FVector Constant;  // 0x007C (0x000C) [0x0000000000000000]
    DWORD bLockAxes : 1;  // 0x0088 (0x0004) [0x0000000000000000] [0x00000001]
    unsigned char LockedAxes;  // 0x008C (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[497];

        return pClassPointer;
    };
};

UClass* UDistributionVectorConstant::pClassPointer = NULL;

// Class Engine.DistributionVectorParameterBase
// 0x003E (0x00CB - 0x008D)
class UDistributionVectorParameterBase : public UDistributionVectorConstant {
   public:
    struct FName ParameterName;     // 0x0090 (0x0008) [0x0000000000000000]
    struct FVector MinInput;        // 0x0098 (0x000C) [0x0000000000000000]
    struct FVector MaxInput;        // 0x00A4 (0x000C) [0x0000000000000000]
    struct FVector MinOutput;       // 0x00B0 (0x000C) [0x0000000000000000]
    struct FVector MaxOutput;       // 0x00BC (0x000C) [0x0000000000000000]
    unsigned char ParamModes[0x3];  // 0x00C8 (0x0003) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[499];

        return pClassPointer;
    };
};

UClass* UDistributionVectorParameterBase::pClassPointer = NULL;

// Class Engine.DistributionVectorConstantCurve
// 0x0019 (0x0095 - 0x007C)
class UDistributionVectorConstantCurve : public UDistributionVector {
   public:
    struct FInterpCurveVector
        ConstantCurve;    // 0x007C (0x0014) [0x0000000000000000]
    DWORD bLockAxes : 1;  // 0x0090 (0x0004) [0x0000000000000000] [0x00000001]
    unsigned char LockedAxes;  // 0x0094 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[501];

        return pClassPointer;
    };
};

UClass* UDistributionVectorConstantCurve::pClassPointer = NULL;

// Class Engine.DistributionVectorUniform
// 0x0020 (0x009C - 0x007C)
class UDistributionVectorUniform : public UDistributionVector {
   public:
    struct FVector Max;   // 0x007C (0x000C) [0x0000000000000000]
    struct FVector Min;   // 0x0088 (0x000C) [0x0000000000000000]
    DWORD bLockAxes : 1;  // 0x0094 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD
        bUseExtremes : 1;  // 0x0094 (0x0004) [0x0000000000000000] [0x00000002]
    unsigned char LockedAxes;        // 0x0098 (0x0001) [0x0000000000000000]
    unsigned char MirrorFlags[0x3];  // 0x0099 (0x0003) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[503];

        return pClassPointer;
    };
};

UClass* UDistributionVectorUniform::pClassPointer = NULL;

// Class Engine.DistributionVectorUniformCurve
// 0x001D (0x0099 - 0x007C)
class UDistributionVectorUniformCurve : public UDistributionVector {
   public:
    struct FInterpCurveTwoVectors
        ConstantCurve;     // 0x007C (0x0014) [0x0000000000000000]
    DWORD bLockAxes1 : 1;  // 0x0090 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bLockAxes2 : 1;  // 0x0090 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD
        bUseExtremes : 1;  // 0x0090 (0x0004) [0x0000000000000000] [0x00000004]
    unsigned char LockedAxes[0x2];   // 0x0094 (0x0002) [0x0000000000000000]
    unsigned char MirrorFlags[0x3];  // 0x0096 (0x0003) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[505];

        return pClassPointer;
    };
};

UClass* UDistributionVectorUniformCurve::pClassPointer = NULL;

// Class Engine.DistributionVectorUniformRange
// 0x0030 (0x00AC - 0x007C)
class UDistributionVectorUniformRange : public UDistributionVector {
   public:
    struct FVector MaxHigh;  // 0x007C (0x000C) [0x0000000000000000]
    struct FVector MaxLow;   // 0x0088 (0x000C) [0x0000000000000000]
    struct FVector MinHigh;  // 0x0094 (0x000C) [0x0000000000000000]
    struct FVector MinLow;   // 0x00A0 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[507];

        return pClassPointer;
    };
};

UClass* UDistributionVectorUniformRange::pClassPointer = NULL;

// Class Engine.Download
// 0x0A44 (0x0AA4 - 0x0060)
class UDownload : public UObject {
   public:
    unsigned char UnknownData00[0xA44];  // 0x0060 (0x0A44) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[509];

        return pClassPointer;
    };
};

UClass* UDownload::pClassPointer = NULL;

// Class Engine.ChannelDownload
// 0x0008 (0x0AAC - 0x0AA4)
class UChannelDownload : public UDownload {
   public:
    unsigned char UnknownData00[0x8];  // 0x0AA4 (0x0008) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[511];

        return pClassPointer;
    };
};

UClass* UChannelDownload::pClassPointer = NULL;

// Class Engine.EdCoordSystem
// 0x0050 (0x00B0 - 0x0060)
class UEdCoordSystem : public UObject {
   public:
    struct FMatrix M;     // 0x0060 (0x0040) [0x0000000000000000]
    struct FString Desc;  // 0x00A0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[513];

        return pClassPointer;
    };
};

UClass* UEdCoordSystem::pClassPointer = NULL;

// Class Engine.EditorLinkSelectionInterface
// 0x0000 (0x0060 - 0x0060)
class UEditorLinkSelectionInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[515];

        return pClassPointer;
    };
};

UClass* UEditorLinkSelectionInterface::pClassPointer = NULL;

// Class Engine.EngineTypes
// 0x0000 (0x0060 - 0x0060)
class UEngineTypes : public UObject {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[517];

        return pClassPointer;
    };
};

UClass* UEngineTypes::pClassPointer = NULL;

// Class Engine.FaceFXAnimSet
// 0x0054 (0x00B4 - 0x0060)
class UFaceFXAnimSet : public UObject {
   public:
    class UFaceFXAsset*
        DefaultFaceFXAsset;  // 0x0060 (0x0008) [0x0000000000000000]
    struct FPointer
        InternalFaceFXAnimSet;  // 0x0068 (0x0008) [0x0000000000000000]
    TArray<unsigned char>
        RawFaceFXAnimSetBytes;  // 0x0070 (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        RawFaceFXMiniSessionBytes;  // 0x0080 (0x0010) [0x0000000000000000]
    TArray<class USoundCue*>
        ReferencedSoundCues;  // 0x0090 (0x0010) [0x0000000000000000]
    TArray<class UAkEvent*>
        ReferencedAkEvents;  // 0x00A0 (0x0010) [0x0000000000000000]
    int NumLoadErrors;       // 0x00B0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[519];

        return pClassPointer;
    };
};

UClass* UFaceFXAnimSet::pClassPointer = NULL;

// Class Engine.FaceFXAsset
// 0x0074 (0x00D4 - 0x0060)
class UFaceFXAsset : public UObject {
   public:
    class USkeletalMesh*
        DefaultSkelMesh;          // 0x0060 (0x0008) [0x0000000000000000]
    struct FPointer FaceFXActor;  // 0x0068 (0x0008) [0x0000000000000000]
    TArray<unsigned char>
        RawFaceFXActorBytes;  // 0x0070 (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        RawFaceFXSessionBytes;  // 0x0080 (0x0010) [0x0000000000000000]
    TArray<class UMorphTargetSet*>
        PreviewMorphSets;  // 0x0090 (0x0010) [0x0000000000000000]
    TArray<class UFaceFXAnimSet*>
        MountedFaceFXAnimSets;  // 0x00A0 (0x0010) [0x0000000000000000]
    TArray<class USoundCue*>
        ReferencedSoundCues;  // 0x00B0 (0x0010) [0x0000000000000000]
    TArray<class UAkEvent*>
        ReferencedAkEvents;  // 0x00C0 (0x0010) [0x0000000000000000]
    int NumLoadErrors;       // 0x00D0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[521];

        return pClassPointer;
    };

    void UnmountFaceFXAnimSet();
    void MountFaceFXAnimSet();
};

UClass* UFaceFXAsset::pClassPointer = NULL;

// Class Engine.Font
// 0x0140 (0x01A0 - 0x0060)
class UFont : public UObject {
   public:
    TArray<struct FFontCharacter>
        Characters;                      // 0x0060 (0x0010) [0x0000000000000000]
    TArray<class UTexture2D*> Textures;  // 0x0070 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x48];   // 0x0080 (0x0048) UNKNOWN PROPERTY:
                                         // MapProperty Engine.Font.CharRemap
    int IsRemapped;                      // 0x00C8 (0x0004) [0x0000000000000000]
    float EmScale;                       // 0x00CC (0x0004) [0x0000000000000000]
    float Ascent;                        // 0x00D0 (0x0004) [0x0000000000000000]
    float Descent;                       // 0x00D4 (0x0004) [0x0000000000000000]
    float Leading;                       // 0x00D8 (0x0004) [0x0000000000000000]
    int Kerning;                         // 0x00DC (0x0004) [0x0000000000000000]
    struct FFontImportOptionsData
        ImportOptions;          // 0x00E0 (0x00A8) [0x0000000000000000]
    int NumCharacters;          // 0x0188 (0x0004) [0x0000000000000000]
    TArray<int> MaxCharHeight;  // 0x018C (0x0010) [0x0000000000000000]
    float ScalingFactor;        // 0x019C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[523];

        return pClassPointer;
    };

    void GetStringHeightAndWidth();
    void GetMaxCharHeight();
    void GetAuthoredViewportHeight();
    void GetScalingFactor();
    void GetResolutionPageIndex();
};

UClass* UFont::pClassPointer = NULL;

// Class Engine.MultiFont
// 0x0010 (0x01B0 - 0x01A0)
class UMultiFont : public UFont {
   public:
    TArray<float> ResolutionTestTable;  // 0x01A0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[525];

        return pClassPointer;
    };

    void GetResolutionTestTableIndex();
};

UClass* UMultiFont::pClassPointer = NULL;

// Class Engine.FontImportOptions
// 0x00A8 (0x0108 - 0x0060)
class UFontImportOptions : public UObject {
   public:
    struct FFontImportOptionsData Data;  // 0x0060 (0x00A8) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[527];

        return pClassPointer;
    };
};

UClass* UFontImportOptions::pClassPointer = NULL;

// Class Engine.ForceFeedbackManager
// 0x0028 (0x0088 - 0x0060)
class UForceFeedbackManager : public UObject {
   public:
    DWORD bAllowsForceFeedback : 1;  // 0x0060 (0x0004) [0x0000000000000000]
                                     // [0x00000001]
    DWORD bIsPaused : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000002]
    class UForceFeedbackWaveform*
        FFWaveform;                    // 0x0064 (0x0008) [0x0000000000000000]
    int CurrentSample;                 // 0x006C (0x0004) [0x0000000000000000]
    float ElapsedTime;                 // 0x0070 (0x0004) [0x0000000000000000]
    int NextSample;                    // 0x0074 (0x0004) [0x0000000000000000]
    float NextElapsedTime;             // 0x0078 (0x0004) [0x0000000000000000]
    float ScaleAllWaveformsBy;         // 0x007C (0x0004) [0x0000000000000000]
    class AActor* WaveformInstigator;  // 0x0080 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[529];

        return pClassPointer;
    };

    void PauseWaveform();
    void StopForceFeedbackWaveform();
    void PlayForceFeedbackWaveform();
};

UClass* UForceFeedbackManager::pClassPointer = NULL;

// Class Engine.ForceFeedbackWaveform
// 0x001C (0x007C - 0x0060)
class UForceFeedbackWaveform : public UObject {
   public:
    DWORD bIsLooping : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000001]
    TArray<struct FWaveformSample>
        Samples;                         // 0x0064 (0x0010) [0x0000000000000000]
    float WaveformFalloffStartDistance;  // 0x0074 (0x0004) [0x0000000000000000]
    float MaxWaveformDistance;           // 0x0078 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[531];

        return pClassPointer;
    };
};

UClass* UForceFeedbackWaveform::pClassPointer = NULL;

// Class Engine.GamePadLightbarSubsystem
// 0x0080 (0x00E0 - 0x0060)
class UGamePadLightbarSubsystem : public UObject {
   public:
    unsigned char CurrentLightBarState;  // 0x0060 (0x0001) [0x0000000000000000]
    struct FLinearColor CurrentColor;    // 0x0064 (0x0010) [0x0000000000000000]
    struct FLinearColor OriginalColor;   // 0x0074 (0x0010) [0x0000000000000000]
    struct FLinearColor TargetColor;     // 0x0084 (0x0010) [0x0000000000000000]
    float LerpTimeRemaining;             // 0x0094 (0x0004) [0x0000000000000000]
    float TotalLerpTime;                 // 0x0098 (0x0004) [0x0000000000000000]
    struct FColor DefaultColor;          // 0x009C (0x0004) [0x0000000000000000]
    TArray<struct FColorDefinition>
        ColorDefinitions;  // 0x00A0 (0x0010) [0x0000000000000000]
    TArray<struct FLerpToInstruction>
        LerpToInstructions;  // 0x00B0 (0x0010) [0x0000000000000000]
    TArray<struct FSetAndLerpInstruction>
        SetAndLerpInstructions;  // 0x00C0 (0x0010) [0x0000000000000000]
    TArray<struct FPulseInstruction>
        PulseInstructions;  // 0x00D0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[533];

        return pClassPointer;
    };

    void ResetState();
    void SetPulsingFromDef();
    void SetPulsing();
    void SetPadColorAndLerpFromDef();
    void SetPadColorAndLerp();
    void BeginLerpFromDef();
    void BeginLerp();
    void SetPadColorFromDef();
    void SetPadColor();
};

UClass* UGamePadLightbarSubsystem::pClassPointer = NULL;

// Class Engine.GameplayEvents
// 0x0160 (0x01C0 - 0x0060)
class UGameplayEvents : public UObject {
   public:
    struct FPointer Archive;       // 0x0060 (0x0008) [0x0000000000000000]
    struct FString StatsFileName;  // 0x0068 (0x0010) [0x0000000000000000]
    struct FGameplayEventsHeader
        Header;  // 0x0078 (0x0030) [0x0000000000000000]
    struct FGameSessionInformation
        CurrentSessionInfo;  // 0x00A8 (0x0088) [0x0000000000000000]
    TArray<struct FPlayerInformation>
        PlayerList;  // 0x0130 (0x0010) [0x0000000000000000]
    TArray<struct FTeamInformation>
        TeamList;  // 0x0140 (0x0010) [0x0000000000000000]
    TArray<struct FGameplayEventMetaData>
        SupportedEvents;  // 0x0150 (0x0010) [0x0000000000000000]
    TArray<struct FWeaponClassEventData>
        WeaponClassArray;  // 0x0160 (0x0010) [0x0000000000000000]
    TArray<struct FDamageClassEventData>
        DamageClassArray;  // 0x0170 (0x0010) [0x0000000000000000]
    TArray<struct FProjectileClassEventData>
        ProjectileClassArray;  // 0x0180 (0x0010) [0x0000000000000000]
    TArray<struct FPawnClassEventData>
        PawnClassArray;                 // 0x0190 (0x0010) [0x0000000000000000]
    TArray<struct FString> ActorArray;  // 0x01A0 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        SoundCueArray;  // 0x01B0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[535];

        return pClassPointer;
    };

    void eventGetFilename();
    void CloseStatsFile();
    void OpenStatsFile();
};

UClass* UGameplayEvents::pClassPointer = NULL;

// Class Engine.GameplayEventsReader
// 0x0010 (0x01D0 - 0x01C0)
class UGameplayEventsReader : public UGameplayEvents {
   public:
    TArray<class UGameplayEventsHandler*>
        RegisteredHandlers;  // 0x01C0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[537];

        return pClassPointer;
    };

    void GetSessionDuration();
    void GetSessionEnd();
    void GetSessionStart();
    void GetSessionTimestamp();
    void GetPlatform();
    void GetTitleID();
    void GetSessionID();
    void ProcessStreamEnd();
    void ProcessStream();
    void ProcessStreamStart();
    void eventUnregisterHandler();
    void eventRegisterHandler();
    void SerializeHeader();
    void CloseStatsFile();
    void OpenStatsFile();
};

UClass* UGameplayEventsReader::pClassPointer = NULL;

// Class Engine.GameplayEventsWriterBase
// 0x0008 (0x01C8 - 0x01C0)
class UGameplayEventsWriterBase : public UGameplayEvents {
   public:
    class AGameInfo* Game;  // 0x01C0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[539];

        return pClassPointer;
    };

    void RecordCoverLinkFireLinks();
    void RecordAIPathFail();
    void LogSystemPollEvents();
    void LogProjectileIntEvent();
    void LogDamageEvent();
    void LogWeaponIntEvent();
    void LogPlayerPlayerEvent();
    void LogPlayerKillDeath();
    void LogAllPlayerPositionsEvent();
    void LogPlayerLoginChange();
    void LogPlayerSpawnEvent();
    void LogPlayerStringEvent();
    void LogPlayerFloatEvent();
    void LogPlayerIntEvent();
    void LogTeamStringEvent();
    void LogTeamFloatEvent();
    void LogTeamIntEvent();
    void LogGamePositionEvent();
    void LogGameFloatEvent();
    void LogGameStringEvent();
    void LogGameIntEvent();
    void EndLogging();
    void ResetLogging();
    void StartLogging();
    void eventGetPlaylistId();
    void eventGetGameTypeId();
    void Poll();
    void eventStopPolling();
    void eventStartPolling();
    void IsSessionInProgress();
};

UClass* UGameplayEventsWriterBase::pClassPointer = NULL;

// Class Engine.GameplayEventsUploadAnalytics
// 0x0000 (0x01C8 - 0x01C8)
class UGameplayEventsUploadAnalytics : public UGameplayEventsWriterBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[541];

        return pClassPointer;
    };

    void RecordCoverLinkFireLinks();
    void RecordAIPathFail();
    void GetGenericParamListEntry();
    void LogProjectileIntEvent();
    void LogDamageEvent();
    void LogWeaponIntEvent();
    void LogPlayerPlayerEvent();
    void LogPlayerKillDeath();
    void LogAllPlayerPositionsEvent();
    void LogPlayerLoginChange();
    void LogPlayerSpawnEvent();
    void LogPlayerStringEvent();
    void LogPlayerFloatEvent();
    void LogPlayerIntEvent();
    void LogTeamStringEvent();
    void LogTeamFloatEvent();
    void LogTeamIntEvent();
    void LogGamePositionEvent();
    void LogGameFloatEvent();
    void LogGameStringEvent();
    void LogGameIntEvent();
    void EndLogging();
    void ResetLogging();
    void StartLogging();
};

UClass* UGameplayEventsUploadAnalytics::pClassPointer = NULL;

// Class Engine.GameplayEventsWriter
// 0x0000 (0x01C8 - 0x01C8)
class UGameplayEventsWriter : public UGameplayEventsWriterBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[543];

        return pClassPointer;
    };

    void RecordCoverLinkFireLinks();
    void RecordAIPathFail();
    void GetGenericParamListEntry();
    void LogSystemPollEvents();
    void LogProjectileIntEvent();
    void LogDamageEvent();
    void LogWeaponIntEvent();
    void LogPlayerPlayerEvent();
    void LogPlayerKillDeath();
    void LogAllPlayerPositionsEvent();
    void LogPlayerLoginChange();
    void LogPlayerSpawnEvent();
    void LogPlayerStringEvent();
    void LogPlayerFloatEvent();
    void LogPlayerIntEvent();
    void LogTeamStringEvent();
    void LogTeamFloatEvent();
    void LogTeamIntEvent();
    void LogGamePositionEvent();
    void LogGameFloatEvent();
    void LogGameStringEvent();
    void LogGameIntEvent();
    void EndLogging();
    void ResetLogging();
    void StartLogging();
    void SerializeFooter();
    void SerializeHeader();
    void CloseStatsFile();
    void OpenStatsFile();
    void ResolvePlayerIndex();
};

UClass* UGameplayEventsWriter::pClassPointer = NULL;

// Class Engine.GameplayEventsHandler
// 0x0028 (0x0088 - 0x0060)
class UGameplayEventsHandler : public UObject {
   public:
    TArray<int> EventIDFilter;  // 0x0060 (0x0010) [0x0000000000000000]
    TArray<struct FGameStatGroup>
        GroupFilter;  // 0x0070 (0x0010) [0x0000000000000000]
    class UGameplayEventsReader*
        Reader;  // 0x0080 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[545];

        return pClassPointer;
    };

    void RemoveFilter();
    void AddFilter();
    void eventResolveGroupFilters();
    void eventPostProcessStream();
    void eventPreProcessStream();
    void SetReader();
};

UClass* UGameplayEventsHandler::pClassPointer = NULL;

// Class Engine.GenericParamListStatEntry
// 0x0010 (0x0070 - 0x0060)
class UGenericParamListStatEntry : public UObject {
   public:
    struct FPointer StatEvent;  // 0x0060 (0x0008) [0x0000000000000000]
    class UGameplayEventsWriter*
        Writer;  // 0x0068 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[547];

        return pClassPointer;
    };

    void CommitToDisk();
    void GetString();
    void GetVector();
    void GetInt();
    void GetFloat();
    void AddString();
    void AddVector();
    void AddInt();
    void AddFloat();
};

UClass* UGenericParamListStatEntry::pClassPointer = NULL;

// Class Engine.GuidCache
// 0x0058 (0x00B8 - 0x0060)
class UGuidCache : public UObject {
   public:
    unsigned char UnknownData00[0x58];  // 0x0060 (0x0058) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[549];

        return pClassPointer;
    };
};

UClass* UGuidCache::pClassPointer = NULL;

// Class Engine.HttpBaseInterface
// 0x0000 (0x0060 - 0x0060)
class UHttpBaseInterface : public UObject {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[551];

        return pClassPointer;
    };

    void GetContent();
    void GetURL();
    void GetContentLength();
    void GetContentType();
    void GetURLParameter();
    void GetHeaders();
    void GetHeader();
};

UClass* UHttpBaseInterface::pClassPointer = NULL;

// Class Engine.HttpRequestInterface
// 0x0010 (0x0070 - 0x0060)
class UHttpRequestInterface : public UHttpBaseInterface {
   public:
    struct FScriptDelegate
        __OnProcessRequestComplete__Delegate;  // 0x0060 (0x0010)
                                               // [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x0064 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[553];

        return pClassPointer;
    };

    void SetProcessRequestCompleteDelegate();
    void OnProcessRequestComplete();
    void ProcessRequest();
    void SetHeader();
    void SetContentAsString();
    void SetContent();
    void SetURL();
    void SetVerb();
    void GetVerb();
};

UClass* UHttpRequestInterface::pClassPointer = NULL;

// Class Engine.HttpResponseInterface
// 0x0000 (0x0060 - 0x0060)
class UHttpResponseInterface : public UHttpBaseInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[555];

        return pClassPointer;
    };

    void GetContentAsString();
    void GetResponseCode();
};

UClass* UHttpResponseInterface::pClassPointer = NULL;

// Class Engine.IniLocPatcher
// 0x0078 (0x00D8 - 0x0060)
class UIniLocPatcher : public UObject {
   public:
    TArray<struct FIniLocFileEntry>
        Files;                      // 0x0060 (0x0010) [0x0000000000000000]
    DWORD bRequestEmsFileList : 1;  // 0x0070 (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    int MaxCachedFileAge;           // 0x0074 (0x0004) [0x0000000000000000]
    class UOnlineTitleFileInterface*
        TitleFileInterface;            // 0x0078 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x8];  // 0x0080 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UOnlineTitleFileCacheInterface*
        TitleFileCacheInterface;       // 0x0088 (0x0010) [0x0000000000000000]
    unsigned char UnknownData01[0x8];  // 0x0090 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    TArray<struct FScriptDelegate>
        ReadTitleFileCompleteDelegates;  // 0x0098 (0x0010) [0x0000000000000000]
    TArray<struct FScriptDelegate>
        AllTitleFilesCompletedDelegates;  // 0x00A8 (0x0010)
                                          // [0x0000000000000000]
    struct FScriptDelegate
        __OnReadTitleFileComplete__Delegate;  // 0x00B8 (0x0010)
                                              // [0x0000000000000000]
    unsigned char UnknownData02[0x4];  // 0x00BC (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __OnAllTitleFilesCompleted__Delegate;  // 0x00C8 (0x0010)
                                               // [0x0000000000000000]
    unsigned char UnknownData03[0x4];  // 0x00CC (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[557];

        return pClassPointer;
    };

    void UpdateLocFileName();
    void ClearCachedFiles();
    void ClearAllTitleFilesCompletedDelegate();
    void AddAllTitleFilesCompletedDelegate();
    void ClearReadFileDelegate();
    void AddReadFileDelegate();
    void AddFileToDownload();
    void ProcessIniLocFile();
    void CheckForAllFilesComplete();
    void TriggerDownloadCompleteDelegates();
    void OnFileCacheSaveComplete();
    void OnFileCacheLoadComplete();
    void OnDownloadFileComplete();
    void StartLoadingFiles();
    void OnRequestTitleFileListComplete();
    void DownloadFiles();
    void Init();
    void OnAllTitleFilesCompleted();
    void OnReadTitleFileComplete();
};

UClass* UIniLocPatcher::pClassPointer = NULL;

// Class Engine.Interface_NavigationHandle
// 0x0000 (0x0060 - 0x0060)
class UInterface_NavigationHandle : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[559];

        return pClassPointer;
    };

    void eventNotifyPathChanged();
};

UClass* UInterface_NavigationHandle::pClassPointer = NULL;

// Class Engine.Interface_Speaker
// 0x0000 (0x0060 - 0x0060)
class UInterface_Speaker : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[561];

        return pClassPointer;
    };

    void eventSpeak();
};

UClass* UInterface_Speaker::pClassPointer = NULL;

// Class Engine.InterpCurveEdSetup
// 0x0014 (0x0074 - 0x0060)
class UInterpCurveEdSetup : public UObject {
   public:
    TArray<struct FCurveEdTab> Tabs;  // 0x0060 (0x0010) [0x0000000000000000]
    int ActiveTab;                    // 0x0070 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[563];

        return pClassPointer;
    };
};

UClass* UInterpCurveEdSetup::pClassPointer = NULL;

// Class Engine.InterpTrack
// 0x0060 (0x00C0 - 0x0060)
class UInterpTrack : public UObject {
   public:
    struct FPointer VfTable_FInterpEdInputInterface;  // 0x0060 (0x0008)
                                                      // [0x0000000000000000]
    struct FPointer CurveEdVTable;  // 0x0068 (0x0008) [0x0000000000000000]
    TArray<class UInterpTrack*>
        SubTracks;  // 0x0070 (0x0010) [0x0000000000000000]
    TArray<struct FSubTrackGroup>
        SubTrackGroups;  // 0x0080 (0x0010) [0x0000000000000000]
    TArray<struct FSupportedSubTrackInfo>
        SupportedSubTracks;         // 0x0090 (0x0010) [0x0000000000000000]
    class UClass* TrackInstClass;   // 0x00A0 (0x0008) [0x0000000000000000]
    unsigned char ActiveCondition;  // 0x00A8 (0x0001) [0x0000000000000000]
    struct FString TrackTitle;      // 0x00AC (0x0010) [0x0000000000000000]
    DWORD
        bOnePerGroup : 1;  // 0x00BC (0x0004) [0x0000000000000000] [0x00000001]
    DWORD
        bDirGroupOnly : 1;  // 0x00BC (0x0004) [0x0000000000000000] [0x00000002]
    DWORD
        bDisableTrack : 1;  // 0x00BC (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bIsAnimControlTrack : 1;  // 0x00BC (0x0004) [0x0000000000000000]
                                    // [0x00000008]
    DWORD
        bSubTrackOnly : 1;  // 0x00BC (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bVisible : 1;     // 0x00BC (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bIsSelected : 1;  // 0x00BC (0x0004) [0x0000000000000000] [0x00000040]
    DWORD
        bIsRecording : 1;  // 0x00BC (0x0004) [0x0000000000000000] [0x00000080]
    DWORD
        bIsCollapsed : 1;  // 0x00BC (0x0004) [0x0000000000000000] [0x00000100]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[565];

        return pClassPointer;
    };
};

UClass* UInterpTrack::pClassPointer = NULL;

// Class Engine.JsonObject
// 0x00B0 (0x0110 - 0x0060)
class UJsonObject : public UObject {
   public:
    struct FMap_Mirror ValueMap;        // 0x0060 (0x0048) [0x0000000000000000]
    struct FMap_Mirror ObjectMap;       // 0x00A8 (0x0048) [0x0000000000000000]
    TArray<struct FString> ValueArray;  // 0x00F0 (0x0010) [0x0000000000000000]
    TArray<class UJsonObject*>
        ObjectArray;  // 0x0100 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[567];

        return pClassPointer;
    };

    void DecodeJson();
    void EncodeJson();
    void eventSetBoolValue();
    void eventSetFloatValue();
    void eventSetIntValue();
    void SetStringValue();
    void SetObject();
    void eventGetBoolValue();
    void eventGetFloatValue();
    void eventGetIntValue();
    void HasKey();
    void GetStringValue();
    void GetObject();
};

UClass* UJsonObject::pClassPointer = NULL;

// Class Engine.KMeshProps
// 0x0068 (0x00C8 - 0x0060)
class UKMeshProps : public UObject {
   public:
    struct FVector COMNudge;         // 0x0060 (0x000C) [0x0000000000000000]
    struct FKAggregateGeom AggGeom;  // 0x006C (0x005C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[569];

        return pClassPointer;
    };
};

UClass* UKMeshProps::pClassPointer = NULL;

// Class Engine.LevelBase
// 0x0080 (0x00E0 - 0x0060)
class ULevelBase : public UObject {
   public:
    unsigned char UnknownData00[0x80];  // 0x0060 (0x0080) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[571];

        return pClassPointer;
    };
};

UClass* ULevelBase::pClassPointer = NULL;

// Class Engine.Level
// 0x04E0 (0x05C0 - 0x00E0)
class ULevel : public ULevelBase {
   public:
    unsigned char UnknownData00[0x108];  // 0x00E0 (0x0108) MISSED OFFSET
    float LightmapTotalSize;             // 0x01E8 (0x0004) [0x0000000000000000]
    float ShadowmapTotalSize;            // 0x01EC (0x0004) [0x0000000000000000]
    unsigned char UnknownData01[0x3D0];  // 0x01F0 (0x03D0) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[573];

        return pClassPointer;
    };
};

UClass* ULevel::pClassPointer = NULL;

// Class Engine.PendingLevel
// 0x004C (0x012C - 0x00E0)
class UPendingLevel : public ULevelBase {
   public:
    unsigned char UnknownData00[0x4C];  // 0x00E0 (0x004C) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[577];

        return pClassPointer;
    };
};

UClass* UPendingLevel::pClassPointer = NULL;

// Class Engine.DemoPlayPendingLevel
// 0x0000 (0x012C - 0x012C)
class UDemoPlayPendingLevel : public UPendingLevel {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[579];

        return pClassPointer;
    };
};

UClass* UDemoPlayPendingLevel::pClassPointer = NULL;

// Class Engine.NetPendingLevel
// 0x0000 (0x012C - 0x012C)
class UNetPendingLevel : public UPendingLevel {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[581];

        return pClassPointer;
    };
};

UClass* UNetPendingLevel::pClassPointer = NULL;

// Class Engine.LevelStreaming
// 0x00B0 (0x0110 - 0x0060)
class ULevelStreaming : public UObject {
   public:
    struct FName PackageName;          // 0x0060 (0x0008) [0x0000000000000000]
    class ULevel* LoadedLevel;         // 0x0068 (0x0008) [0x0000000000000000]
    struct FVector Offset;             // 0x0070 (0x000C) [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x007C (0x0004) MISSED OFFSET
    struct FMatrix LevelTransform;     // 0x0080 (0x0040) [0x0000000000000000]
    struct FVector OldOffset;          // 0x00C0 (0x000C) [0x0000000000000000]
    DWORD bIsVisible : 1;  // 0x00CC (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bHasLoadRequestPending : 1;    // 0x00CC (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bHasUnloadRequestPending : 1;  // 0x00CC (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD bShouldBeVisibleInEditor : 1;  // 0x00CC (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    DWORD bBoundingBoxVisible : 1;       // 0x00CC (0x0004) [0x0000000000000000]
                                         // [0x00000010]
    DWORD bLocked : 1;  // 0x00CC (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bIsFullyStatic : 1;         // 0x00CC (0x0004) [0x0000000000000000]
                                      // [0x00000040]
    DWORD bShouldBeLoaded : 1;        // 0x00CC (0x0004) [0x0000000000000000]
                                      // [0x00000080]
    DWORD bShouldBeVisible : 1;       // 0x00CC (0x0004) [0x0000000000000000]
                                      // [0x00000100]
    DWORD bShouldBlockOnLoad : 1;     // 0x00CC (0x0004) [0x0000000000000000]
                                      // [0x00000200]
    DWORD bDrawOnLevelStatusMap : 1;  // 0x00CC (0x0004) [0x0000000000000000]
                                      // [0x00000400]
    DWORD
        bIsRequestingUnloadAndRemoval : 1;  // 0x00CC (0x0004)
                                            // [0x0000000000000000] [0x00000800]
    struct FColor DrawColor;  // 0x00D0 (0x0004) [0x0000000000000000]
    TArray<class ALevelStreamingVolume*>
        EditorStreamingVolumes;  // 0x00D4 (0x0010) [0x0000000000000000]
    float MinTimeBetweenVolumeUnloadRequests;  // 0x00E4 (0x0004)
                                               // [0x0000000000000000]
    float LastVolumeUnloadRequestTime;  // 0x00E8 (0x0004) [0x0000000000000000]
    TArray<struct FString> Keywords;    // 0x00EC (0x0010) [0x0000000000000000]
    class ALevelGridVolume*
        EditorGridVolume;   // 0x00FC (0x0008) [0x0000000000000000]
    int GridPosition[0x3];  // 0x0104 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[583];

        return pClassPointer;
    };
};

UClass* ULevelStreaming::pClassPointer = NULL;

// Class Engine.LevelStreamingAlwaysLoaded
// 0x0004 (0x0114 - 0x0110)
class ULevelStreamingAlwaysLoaded : public ULevelStreaming {
   public:
    DWORD
        bIsProceduralBuildingLODLevel : 1;  // 0x0110 (0x0004)
                                            // [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[585];

        return pClassPointer;
    };
};

UClass* ULevelStreamingAlwaysLoaded::pClassPointer = NULL;

// Class Engine.LevelStreamingDistance
// 0x0010 (0x0120 - 0x0110)
class ULevelStreamingDistance : public ULevelStreaming {
   public:
    struct FVector Origin;  // 0x0110 (0x000C) [0x0000000000000000]
    float MaxDistance;      // 0x011C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[587];

        return pClassPointer;
    };
};

UClass* ULevelStreamingDistance::pClassPointer = NULL;

// Class Engine.LevelStreamingKismet
// 0x0000 (0x0110 - 0x0110)
class ULevelStreamingKismet : public ULevelStreaming {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[589];

        return pClassPointer;
    };
};

UClass* ULevelStreamingKismet::pClassPointer = NULL;

// Class Engine.LevelStreamingPersistent
// 0x0000 (0x0110 - 0x0110)
class ULevelStreamingPersistent : public ULevelStreaming {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[591];

        return pClassPointer;
    };
};

UClass* ULevelStreamingPersistent::pClassPointer = NULL;

// Class Engine.LightmappedSurfaceCollection
// 0x0018 (0x0078 - 0x0060)
class ULightmappedSurfaceCollection : public UObject {
   public:
    class UModel* SourceModel;  // 0x0060 (0x0008) [0x0000000000000000]
    TArray<int> Surfaces;       // 0x0068 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[593];

        return pClassPointer;
    };
};

UClass* ULightmappedSurfaceCollection::pClassPointer = NULL;

// Class Engine.LightmassLevelSettings
// 0x0030 (0x0090 - 0x0060)
class ULightmassLevelSettings : public UObject {
   public:
    int NumIndirectLightingBounces;  // 0x0060 (0x0004) [0x0000000000000000]
    struct FColor EnvironmentColor;  // 0x0064 (0x0004) [0x0000000000000000]
    float EnvironmentIntensity;      // 0x0068 (0x0004) [0x0000000000000000]
    float EmissiveBoost;             // 0x006C (0x0004) [0x0000000000000000]
    float DiffuseBoost;              // 0x0070 (0x0004) [0x0000000000000000]
    float SpecularBoost;             // 0x0074 (0x0004) [0x0000000000000000]
    DWORD bUseAmbientOcclusion : 1;  // 0x0078 (0x0004) [0x0000000000000000]
                                     // [0x00000001]
    DWORD bVisualizeAmbientOcclusion : 1;  // 0x0078 (0x0004)
                                           // [0x0000000000000000] [0x00000002]
    float DirectIlluminationOcclusionFraction;    // 0x007C (0x0004)
                                                  // [0x0000000000000000]
    float IndirectIlluminationOcclusionFraction;  // 0x0080 (0x0004)
                                                  // [0x0000000000000000]
    float OcclusionExponent;             // 0x0084 (0x0004) [0x0000000000000000]
    float FullyOccludedSamplesFraction;  // 0x0088 (0x0004) [0x0000000000000000]
    float MaxOcclusionDistance;          // 0x008C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[595];

        return pClassPointer;
    };
};

UClass* ULightmassLevelSettings::pClassPointer = NULL;

// Class Engine.LightmassPrimitiveSettingsObject
// 0x001C (0x007C - 0x0060)
class ULightmassPrimitiveSettingsObject : public UObject {
   public:
    struct FLightmassPrimitiveSettings
        LightmassSettings;  // 0x0060 (0x001C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[597];

        return pClassPointer;
    };
};

UClass* ULightmassPrimitiveSettingsObject::pClassPointer = NULL;

// Class Engine.MapInfo
// 0x0004 (0x0064 - 0x0060)
class UMapInfo : public UObject {
   public:
    DWORD bDefaultPawnsToOutdoor : 1;  // 0x0060 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bUseFlexTriangleCollision : 1;  // 0x0060 (0x0004)
                                          // [0x0000000000000000] [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[599];

        return pClassPointer;
    };
};

UClass* UMapInfo::pClassPointer = NULL;

// Class Engine.Model
// 0x0C28 (0x0C88 - 0x0060)
class UModel : public UObject {
   public:
    unsigned char UnknownData00[0xC28];  // 0x0060 (0x0C28) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[601];

        return pClassPointer;
    };
};

UClass* UModel::pClassPointer = NULL;

// Class Engine.MusicTrackDataStructures
// 0x0000 (0x0060 - 0x0060)
class UMusicTrackDataStructures : public UObject {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[603];

        return pClassPointer;
    };
};

UClass* UMusicTrackDataStructures::pClassPointer = NULL;

// Class Engine.NavigationMeshBase
// 0x0310 (0x0370 - 0x0060)
class UNavigationMeshBase : public UObject {
   public:
    unsigned char UnknownData00[0x310];  // 0x0060 (0x0310) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[605];

        return pClassPointer;
    };
};

UClass* UNavigationMeshBase::pClassPointer = NULL;

// Class Engine.NetDriver
// 0x0190 (0x01F8 - 0x0068)
class UNetDriver : public USubsystem {
   public:
    unsigned char UnknownData00[0x34];  // 0x0068 (0x0034) MISSED OFFSET
    float ConnectionTimeout;            // 0x009C (0x0004) [0x0000000000000000]
    float InitialConnectTimeout;        // 0x00A0 (0x0004) [0x0000000000000000]
    float KeepAliveTime;                // 0x00A4 (0x0004) [0x0000000000000000]
    float RelevantTimeout;              // 0x00A8 (0x0004) [0x0000000000000000]
    float SpawnPrioritySeconds;         // 0x00AC (0x0004) [0x0000000000000000]
    float ServerTravelPause;            // 0x00B0 (0x0004) [0x0000000000000000]
    int MaxClientRate;                  // 0x00B4 (0x0004) [0x0000000000000000]
    int MaxInternetClientRate;          // 0x00B8 (0x0004) [0x0000000000000000]
    int NetServerMaxTickRate;           // 0x00BC (0x0004) [0x0000000000000000]
    int NetServerLobbyTickRate;         // 0x00C0 (0x0004) [0x0000000000000000]
    DWORD bClampListenServerTickRate : 1;  // 0x00C4 (0x0004)
                                           // [0x0000000000000000] [0x00000001]
    DWORD AllowDownloads : 1;           // 0x00C8 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD AllowPeerConnections : 1;     // 0x00CC (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD AllowPeerVoice : 1;           // 0x00D0 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    unsigned char UnknownData01[0x20];  // 0x00D4 (0x0020) MISSED OFFSET
    int MaxDownloadSize;                // 0x00F4 (0x0004) [0x0000000000000000]
    TArray<struct FString>
        DownloadManagers;               // 0x00F8 (0x0010) [0x0000000000000000]
    unsigned char UnknownData02[0x9C];  // 0x0108 (0x009C) MISSED OFFSET
    struct FString
        NetConnectionClassName;         // 0x01A4 (0x0010) [0x0000000000000000]
    unsigned char UnknownData03[0x44];  // 0x01B4 (0x0044) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[607];

        return pClassPointer;
    };
};

UClass* UNetDriver::pClassPointer = NULL;

// Class Engine.DemoRecDriver
// 0x00F8 (0x02F0 - 0x01F8)
class UDemoRecDriver : public UNetDriver {
   public:
    unsigned char UnknownData00[0x2C];  // 0x01F8 (0x002C) MISSED OFFSET
    struct FString DemoSpectatorClass;  // 0x0224 (0x0010) [0x0000000000000000]
    unsigned char UnknownData01[0xA8];  // 0x0234 (0x00A8) MISSED OFFSET
    int MaxRewindPoints;                // 0x02DC (0x0004) [0x0000000000000000]
    unsigned char UnknownData02[0x4];   // 0x02E0 (0x0004) MISSED OFFSET
    float RewindPointInterval;          // 0x02E4 (0x0004) [0x0000000000000000]
    int NumRecentRewindPoints;          // 0x02E8 (0x0004) [0x0000000000000000]
    unsigned char UnknownData03[0x4];   // 0x02EC (0x0004) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[627];

        return pClassPointer;
    };
};

UClass* UDemoRecDriver::pClassPointer = NULL;

// Class Engine.ObjectReferencer
// 0x0010 (0x0070 - 0x0060)
class UObjectReferencer : public UObject {
   public:
    TArray<class UObject*>
        ReferencedObjects;  // 0x0060 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[633];

        return pClassPointer;
    };
};

UClass* UObjectReferencer::pClassPointer = NULL;

// Class Engine.OnlineAuthInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineAuthInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[635];

        return pClassPointer;
    };

    void GetServerAddr();
    void GetServerUniqueId();
    void FindLocalServerAuthSession();
    void FindServerAuthSession();
    void FindLocalClientAuthSession();
    void FindClientAuthSession();
    void AllLocalServerAuthSessions();
    void AllServerAuthSessions();
    void AllLocalClientAuthSessions();
    void AllClientAuthSessions();
    void EndAllRemoteServerAuthSessions();
    void EndAllLocalServerAuthSessions();
    void EndRemoteServerAuthSession();
    void EndLocalServerAuthSession();
    void VerifyServerAuthSession();
    void CreateServerAuthSession();
    void EndAllRemoteClientAuthSessions();
    void EndAllLocalClientAuthSessions();
    void EndRemoteClientAuthSession();
    void EndLocalClientAuthSession();
    void VerifyClientAuthSession();
    void CreateClientAuthSession();
    void SendServerAuthRetryRequest();
    void SendClientAuthEndSessionRequest();
    void SendServerAuthResponse();
    void SendClientAuthResponse();
    void SendServerAuthRequest();
    void SendClientAuthRequest();
    void ClearServerConnectionCloseDelegate();
    void AddServerConnectionCloseDelegate();
    void OnServerConnectionClose();
    void ClearClientConnectionCloseDelegate();
    void AddClientConnectionCloseDelegate();
    void OnClientConnectionClose();
    void ClearServerAuthRetryRequestDelegate();
    void AddServerAuthRetryRequestDelegate();
    void OnServerAuthRetryRequest();
    void ClearClientAuthEndSessionRequestDelegate();
    void AddClientAuthEndSessionRequestDelegate();
    void OnClientAuthEndSessionRequest();
    void ClearServerAuthCompleteDelegate();
    void AddServerAuthCompleteDelegate();
    void OnServerAuthComplete();
    void ClearClientAuthCompleteDelegate();
    void AddClientAuthCompleteDelegate();
    void OnClientAuthComplete();
    void ClearServerAuthResponseDelegate();
    void AddServerAuthResponseDelegate();
    void OnServerAuthResponse();
    void ClearClientAuthResponseDelegate();
    void AddClientAuthResponseDelegate();
    void OnClientAuthResponse();
    void ClearServerAuthRequestDelegate();
    void AddServerAuthRequestDelegate();
    void OnServerAuthRequest();
    void ClearClientAuthRequestDelegate();
    void AddClientAuthRequestDelegate();
    void OnClientAuthRequest();
    void ClearAuthReadyDelegate();
    void AddAuthReadyDelegate();
    void OnAuthReady();
    void IsReady();
};

UClass* UOnlineAuthInterface::pClassPointer = NULL;

// Class Engine.OnlineGameInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineGameInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[637];

        return pClassPointer;
    };

    void RunBandwidthTest();
    void IsAllowedToNetworkHost();
    void ClearGetRoomIdFromTitleServiceDelegate();
    void AddGetRoomIdFromTitleServiceDelegate();
    void GetRoomIdFromSessionId();
    void GetRoomIdFromTitleService();
    void OnGetRoomIdFromTitleService();
    void GetRoomId();
    void ClearGetNumberOfCurrentPlayersCompleteDelegate();
    void AddGetNumberOfCurrentPlayersCompleteDelegate();
    void OnGetNumberOfCurrentPlayersComplete();
    void GetNumberOfCurrentPlayersCached();
    void SendPlayerList();
    void RetrieveGameSettingsForIP();
    void ClearOnRetrieveGameSettingsForIPDelegate();
    void AddOnRetrieveGameSettingsForIPDelegate();
    void OnRetrievedGameSettingsForIP();
    void GetNumberOfCurrentPlayers();
    void ClearJoinMigratedOnlineGameCompleteDelegate();
    void AddJoinMigratedOnlineGameCompleteDelegate();
    void OnJoinMigratedOnlineGameComplete();
    void JoinMigratedOnlineGame();
    void ClearMigrateOnlineGameCompleteDelegate();
    void AddMigrateOnlineGameCompleteDelegate();
    void OnMigrateOnlineGameComplete();
    void MigrateOnlineGame();
    void ClearRecalculateSkillRatingCompleteDelegate();
    void AddRecalculateSkillRatingCompleteDelegate();
    void OnRecalculateSkillRatingComplete();
    void RecalculateSkillRating();
    void SetPendingMembersToInvite();
    void ResetPendingMembersToInvite();
    void GetPendingMembersToInvite();
    void ClearPlayTogetherStartedDelegate();
    void AddPlayTogetherStartedDelegate();
    void OnPlayTogetherStarted();
    void AcceptGameInvite();
    void ClearGameInviteAcceptedDelegate();
    void AddGameInviteAcceptedDelegate();
    void OnGameInviteAccepted();
    void GetArbitratedPlayers();
    void ClearArbitrationRegistrationCompleteDelegate();
    void AddArbitrationRegistrationCompleteDelegate();
    void OnArbitrationRegistrationComplete();
    void RegisterForArbitration();
    void ClearEndOnlineGameCompleteDelegate();
    void AddEndOnlineGameCompleteDelegate();
    void OnEndOnlineGameComplete();
    void EndOnlineGame();
    void ClearStartOnlineGameCompleteDelegate();
    void AddStartOnlineGameCompleteDelegate();
    void OnStartOnlineGameComplete();
    void StartOnlineGame();
    void ClearUnregisterPlayerCompleteDelegate();
    void AddUnregisterPlayerCompleteDelegate();
    void OnUnregisterPlayerComplete();
    void UnregisterPlayers();
    void UnregisterPlayer();
    void ClearRegisterPlayerCompleteDelegate();
    void AddRegisterPlayerCompleteDelegate();
    void OnRegisterPlayerComplete();
    void RegisterPlayers();
    void RegisterPlayer();
    void GetResolvedConnectString();
    void ClearQuerySessionsForUserCompleteDelegate();
    void AddQuerySessionsForUserCompleteDelegate();
    void OnQuerySessionsForUserComplete();
    void QuerySessionsByKeyword();
    void QuerySessionsForUser();
    void LeaveAllOnlineSessions();
    void LeaveOnlineSession();
    void ClearMatchStatusChangedDelegate();
    void AddMatchStatusChangedDelegate();
    void OnMatchStatusChanged();
    void ClearGamePlayersChangedDelegate();
    void AddGamePlayersChangedDelegate();
    void OnGamePlayersChanged();
    void ClearUpdateSessionPropertiesCompleteDelegate();
    void AddUpdateSessionPropertiesCompleteDelegate();
    void OnUpdateSessionPropertiesComplete();
    void UpdateSessionProperties();
    void DeleteCustomMemberProperty();
    void SetCustomMemberProperty();
    void DeleteCustomSessionProperty();
    void SetCustomSessionProperty();
    void ClearDeleteMatchTicketCompleteDelegate();
    void AddDeleteMatchTicketCompleteDelegate();
    void OnDeleteMatchTicketComplete();
    void DeleteMatchTicketWithHopper();
    void DeleteMatchTicket();
    void ClearQueryMatchmakingForSessionCompleteDelegate();
    void AddQueryMatchmakingForSessionCompleteDelegate();
    void OnQueryMatchmakingForSessionComplete();
    void QueryMatchmakingForSessionWithHopper();
    void QueryMatchmakingForSession();
    void ClearMultiplayerSessionChangeDelegate();
    void AddMultiplayerSessionChangeDelegate();
    void OnMultiplayerSessionChange();
    void ClearJoinOnlineGameCompleteDelegate();
    void AddJoinOnlineGameCompleteDelegate();
    void OnJoinOnlineGameComplete();
    void IsCurrentRoomOwner();
    void SetRankedReadyStatus();
    void IsJoinOperationInProgress();
    void JoinOnlineGameByMatchingParams();
    void JoinOnlineGameBySessionHandle();
    void JoinOnlineGame();
    void QueryNonAdvertisedData();
    void FreeSearchResults();
    void GetGameSearch();
    void BindSessionGuidToSearch();
    void BindPlatformSpecificSessionToSearch();
    void ReadSessionGuidBySessionName();
    void ReadPlatformSpecificSessionInfoBySessionName();
    void ReadPlatformSpecificSessionInfo();
    void ClearQosStatusChangedDelegate();
    void AddQosStatusChangedDelegate();
    void OnQosStatusChanged();
    void ClearCancelFindOnlineGamesCompleteDelegate();
    void AddCancelFindOnlineGamesCompleteDelegate();
    void OnCancelFindOnlineGamesComplete();
    void CancelFindOnlineGames();
    void ClearFindOnlineGamesCompleteDelegate();
    void AddFindOnlineGamesCompleteDelegate();
    void OnFindOnlineGamesComplete();
    void FindOnlineGames();
    void ClearDestroyOnlineGameCompleteDelegate();
    void AddDestroyOnlineGameCompleteDelegate();
    void OnDestroyOnlineGameComplete();
    void DestroyOnlineGame();
    void GetGameSettings();
    void ClearUpdateOnlineGameCompleteDelegate();
    void AddUpdateOnlineGameCompleteDelegate();
    void OnUpdateOnlineGameComplete();
    void UpdateOnlineGame();
    void ClearCreateOnlineGameCompleteDelegate();
    void AddCreateOnlineGameCompleteDelegate();
    void OnCreateOnlineGameComplete();
    void CreateOnlineGame();
    void GetGameServerRemoteAddress();
    void ClearOnlineDelegates();
    void RemoveSearchResultFromFavorites();
    void ClearGetPlayerListCompleteDelegate();
    void AddGetPlayerListCompleteDelegate();
    void OnGetPlayerListComplete();
    void IsSearchResultInFavoritesList();
    void AddSearchResultToFavorites();
    void SetMatchmakingTypeMode();
};

UClass* UOnlineGameInterface::pClassPointer = NULL;

// Class Engine.OnlineMatchmakingStats
// 0x0000 (0x0060 - 0x0060)
class UOnlineMatchmakingStats : public UObject {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[639];

        return pClassPointer;
    };

    void StopTimer();
    void StartTimer();
};

UClass* UOnlineMatchmakingStats::pClassPointer = NULL;

// Class Engine.OnlinePlayerStorage
// 0x0034 (0x0094 - 0x0060)
class UOnlinePlayerStorage : public UObject {
   public:
    int VersionNumber;       // 0x0060 (0x0004) [0x0000000000000000]
    int VersionSettingsId;   // 0x0064 (0x0004) [0x0000000000000000]
    int SaveCountSettingId;  // 0x0068 (0x0004) [0x0000000000000000]
    TArray<struct FOnlineProfileSetting>
        ProfileSettings;  // 0x006C (0x0010) [0x0000000000000000]
    TArray<struct FSettingsPropertyPropertyMetaData>
        ProfileMappings;       // 0x007C (0x0010) [0x0000000000000000]
    unsigned char AsyncState;  // 0x008C (0x0001) [0x0000000000000000]
    int DeviceID;              // 0x0090 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[641];

        return pClassPointer;
    };

    void SetDefaultVersionNumber();
    void GetVersionNumber();
    void AppendVersionToSettings();
    void eventSetToDefaults();
    void AddSettingFloat();
    void AddSettingInt();
    void GetRangedProfileSettingValue();
    void SetRangedProfileSettingValue();
    void GetProfileSettingRange();
    void GetProfileSettingMappingIds();
    void GetProfileSettingMappingType();
    void SetProfileSettingValueFloat();
    void SetProfileSettingValueInt();
    void SetProfileSettingValueId();
    void GetProfileSettingValueFloat();
    void GetProfileSettingValueInt();
    void GetProfileSettingValueFromListIndex();
    void GetProfileSettingValueId();
    void SetProfileSettingValue();
    void SetProfileSettingValueByName();
    void GetProfileSettingValueByName();
    void GetProfileSettingValues();
    void GetProfileSettingValueName();
    void GetProfileSettingValue();
    void IsProfileSettingIdMapped();
    void FindDefaultProfileMappingIndexByName();
    void FindProfileMappingIndexByName();
    void FindProfileMappingIndex();
    void FindProfileSettingIndex();
    void GetProfileSettingColumnHeader();
    void GetProfileSettingName();
    void GetProfileSettingId();
};

UClass* UOnlinePlayerStorage::pClassPointer = NULL;

// Class Engine.OnlineProfileSettings
// 0x0030 (0x00C4 - 0x0094)
class UOnlineProfileSettings : public UOnlinePlayerStorage {
   public:
    TArray<int> ProfileSettingIds;  // 0x0094 (0x0010) [0x0000000000000000]
    TArray<struct FOnlineProfileSetting>
        DefaultSettings;  // 0x00A4 (0x0010) [0x0000000000000000]
    TArray<struct FIdToStringMapping>
        OwnerMappings;  // 0x00B4 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[643];

        return pClassPointer;
    };

    void ExpandExtraFromProfileSettings();
    void FlattenExtraToProfileSettings();
    void eventModifyAvailableProfileSettings();
    void AppendVersionToReadIds();
    void eventSetToDefaults();
    void GetProfileSettingDefaultFloat();
    void GetProfileSettingDefaultInt();
    void GetProfileSettingDefaultId();
};

UClass* UOnlineProfileSettings::pClassPointer = NULL;

// Class Engine.OnlineStats
// 0x0010 (0x0070 - 0x0060)
class UOnlineStats : public UObject {
   public:
    TArray<struct FStringIdToStringMapping>
        ViewIdMappings;  // 0x0060 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[645];

        return pClassPointer;
    };

    void GetViewName();
    void GetViewId();
};

UClass* UOnlineStats::pClassPointer = NULL;

// Class Engine.OnlineStatsRead
// 0x0050 (0x00C0 - 0x0070)
class UOnlineStatsRead : public UOnlineStats {
   public:
    int ViewId;             // 0x0070 (0x0004) [0x0000000000000000]
    int SortColumnId;       // 0x0074 (0x0004) [0x0000000000000000]
    TArray<int> ColumnIds;  // 0x0078 (0x0010) [0x0000000000000000]
    int TotalRowsInView;    // 0x0088 (0x0004) [0x0000000000000000]
    TArray<struct FOnlineStatsRow>
        Rows;  // 0x008C (0x0010) [0x0000000000000000]
    TArray<struct FColumnMetaData>
        ColumnMappings;       // 0x009C (0x0010) [0x0000000000000000]
    struct FString ViewName;  // 0x00AC (0x0010) [0x0000000000000000]
    int TitleId;              // 0x00BC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[647];

        return pClassPointer;
    };

    void GetRankForPlayer();
    void AddPlayer();
    void IsStatZero();
    void GetStatValueForPlayerAsString();
    void SetFloatStatValueForPlayer();
    void GetFloatStatValueForPlayer();
    void SetIntStatValueForPlayer();
    void GetIntStatValueForPlayer();
    void eventOnReadComplete();
};

UClass* UOnlineStatsRead::pClassPointer = NULL;

// Class Engine.OnlineStatsWrite
// 0x0054 (0x00C4 - 0x0070)
class UOnlineStatsWrite : public UOnlineStats {
   public:
    TArray<struct FStringIdToStringMapping>
        StatMappings;  // 0x0070 (0x0010) [0x0000000000000000]
    TArray<struct FSettingsProperty>
        Properties;                 // 0x0080 (0x0010) [0x0000000000000000]
    TArray<int> ViewIds;            // 0x0090 (0x0010) [0x0000000000000000]
    TArray<int> ArbitratedViewIds;  // 0x00A0 (0x0010) [0x0000000000000000]
    int RatingId;                   // 0x00B0 (0x0004) [0x0000000000000000]
    struct FScriptDelegate
        __OnStatsWriteComplete__Delegate;  // 0x00B4 (0x0010)
                                           // [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x00B8 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[649];

        return pClassPointer;
    };

    void DecrementIntStat();
    void DecrementFloatStat();
    void IncrementIntStat();
    void IncrementFloatStat();
    void SetIntStat();
    void SetFloatStat();
    void GetStatName();
    void GetStatId();
    void OnStatsWriteComplete();
};

UClass* UOnlineStatsWrite::pClassPointer = NULL;

// Class Engine.OnlineSubsystem
// 0x0284 (0x02E4 - 0x0060)
class UOnlineSubsystem : public UObject {
   public:
    struct FPointer
        VfTable_FTickableObject;  // 0x0060 (0x0008) [0x0000000000000000]
    class UOnlineAccountInterface*
        AccountInterface;              // 0x0068 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x8];  // 0x0070 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UOnlinePlayerInterface*
        PlayerInterface;               // 0x0078 (0x0010) [0x0000000000000000]
    unsigned char UnknownData01[0x8];  // 0x0080 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UOnlinePlayerInterfaceEx*
        PlayerInterfaceEx;             // 0x0088 (0x0010) [0x0000000000000000]
    unsigned char UnknownData02[0x8];  // 0x0090 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UOnlineMarketplaceInterface*
        MarketplaceInterface;          // 0x0098 (0x0010) [0x0000000000000000]
    unsigned char UnknownData03[0x8];  // 0x00A0 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UOnlineSystemInterface*
        SystemInterface;               // 0x00A8 (0x0010) [0x0000000000000000]
    unsigned char UnknownData04[0x8];  // 0x00B0 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UOnlineGameInterface*
        GameInterface;                 // 0x00B8 (0x0010) [0x0000000000000000]
    unsigned char UnknownData05[0x8];  // 0x00C0 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UOnlineContentInterface*
        ContentInterface;              // 0x00C8 (0x0010) [0x0000000000000000]
    unsigned char UnknownData06[0x8];  // 0x00D0 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UOnlineVoiceInterface*
        VoiceInterface;                // 0x00D8 (0x0010) [0x0000000000000000]
    unsigned char UnknownData07[0x8];  // 0x00E0 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UOnlineStatsInterface*
        StatsInterface;                // 0x00E8 (0x0010) [0x0000000000000000]
    unsigned char UnknownData08[0x8];  // 0x00F0 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UOnlineNewsInterface*
        NewsInterface;                 // 0x00F8 (0x0010) [0x0000000000000000]
    unsigned char UnknownData09[0x8];  // 0x0100 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UOnlinePartyChatInterface*
        PartyChatInterface;            // 0x0108 (0x0010) [0x0000000000000000]
    unsigned char UnknownData10[0x8];  // 0x0110 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UOnlinePartyInterface*
        PartyInterface;                // 0x0118 (0x0010) [0x0000000000000000]
    unsigned char UnknownData11[0x8];  // 0x0120 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UOnlineTitleFileInterface*
        TitleFileInterface;            // 0x0128 (0x0010) [0x0000000000000000]
    unsigned char UnknownData12[0x8];  // 0x0130 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UOnlineTitleFileCacheInterface*
        TitleFileCacheInterface;       // 0x0138 (0x0010) [0x0000000000000000]
    unsigned char UnknownData13[0x8];  // 0x0140 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UUserCloudFileInterface*
        UserCloudInterface;            // 0x0148 (0x0010) [0x0000000000000000]
    unsigned char UnknownData14[0x8];  // 0x0150 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class USharedCloudFileInterface*
        SharedCloudInterface;          // 0x0158 (0x0010) [0x0000000000000000]
    unsigned char UnknownData15[0x8];  // 0x0160 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UOnlineSocialInterface*
        SocialInterface;               // 0x0168 (0x0010) [0x0000000000000000]
    unsigned char UnknownData16[0x8];  // 0x0170 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UOnlineAuthInterface*
        AuthInterface;                 // 0x0178 (0x0010) [0x0000000000000000]
    unsigned char UnknownData17[0x8];  // 0x0180 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    TArray<struct FScriptDelegate>
        ReadInventoryCompleteDelegates;  // 0x0188 (0x0010) [0x0000000000000000]
    DWORD bInventoryReady : 1;           // 0x0198 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bUseBuildIdOverride : 1;       // 0x0198 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    TArray<struct FScriptDelegate>
        PingRegionsCompleteDelegates;  // 0x019C (0x0010) [0x0000000000000000]
    class UOnlineGameDVRInterface*
        GameDVRInterface;              // 0x01AC (0x0010) [0x0000000000000000]
    unsigned char UnknownData18[0x8];  // 0x01B4 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UOnlineCommunityContentInterface*
        CommunityContentInterface;     // 0x01BC (0x0010) [0x0000000000000000]
    unsigned char UnknownData19[0x8];  // 0x01C4 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FUniqueNetId
        LoggedInPlayerNetId;  // 0x01CC (0x0008) [0x0000000000000000]
    TArray<struct FNamedInterface>
        NamedInterfaces;  // 0x01D4 (0x0010) [0x0000000000000000]
    TArray<struct FNamedInterfaceDef>
        NamedInterfaceDefs;  // 0x01E4 (0x0010) [0x0000000000000000]
    TArray<struct FNamedSession>
        Sessions;  // 0x01F4 (0x0010) [0x0000000000000000]
    TArray<struct FSessionMemberInfo>
        PartyMemberList;  // 0x0204 (0x0010) [0x0000000000000000]
    TArray<struct FSessionMemberInfo>
        GameMemberList;   // 0x0214 (0x0010) [0x0000000000000000]
    int BuildIdOverride;  // 0x0224 (0x0004) [0x0000000000000000]
    struct FString
        IniLocPatcherClassName;     // 0x0228 (0x0010) [0x0000000000000000]
    class UIniLocPatcher* Patcher;  // 0x0238 (0x0008) [0x0000000000000000]
    float AsyncMinCompletionTime;   // 0x0240 (0x0004) [0x0000000000000000]
    struct FString
        DefaultSessionTemplateName;  // 0x0244 (0x0010) [0x0000000000000000]
    struct FString
        PartySessionTemplateName;  // 0x0254 (0x0010) [0x0000000000000000]
    TArray<struct FCurrentInventoryEntry>
        CurrentInventory;  // 0x0264 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        OwnedEntitlementIds;  // 0x0274 (0x0010) [0x0000000000000000]
    TArray<struct FItemProperties>
        ItemPropertiesList;  // 0x0284 (0x0010) [0x0000000000000000]
    TArray<struct FExchangeRuleSets>
        ExchangeRuleSetList;  // 0x0294 (0x0010) [0x0000000000000000]
    struct FScriptDelegate
        __OnInventoryReadComplete__Delegate;  // 0x02A4 (0x0010)
                                              // [0x0000000000000000]
    unsigned char UnknownData20[0x4];  // 0x02A8 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __OnPingRegionsComplete__Delegate;  // 0x02B4 (0x0010)
                                            // [0x0000000000000000]
    unsigned char UnknownData21[0x4];  // 0x02B8 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __OnReadOnlineAvatarComplete__Delegate;  // 0x02C4 (0x0010)
                                                 // [0x0000000000000000]
    unsigned char UnknownData22[0x4];  // 0x02C8 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __OnReadOnlineAvatarByNameComplete__Delegate;  // 0x02D4 (0x0010)
                                                       // [0x0000000000000000]
    unsigned char UnknownData23[0x4];  // 0x02D8 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[651];

        return pClassPointer;
    };

    void SetCachedProfile();
    void ActivateGamepad();
    void ManuallyActivateUser();
    void HasChatRestriction();
    void CancelRegionPing();
    void StartRegionPingAndSelectDefaultRegion();
    void SetSharedPassword();
    void CheckPlayerGroup();
    void GetPlayerGroups();
    void GetUGCInterface();
    void GetNATType();
    void GetLoginStatus();
    void UniqueNetIdToPlayerName();
    void UniqueNetIdToInt64();
    void Int64ToUniqueNetId();
    void GetUniquePlayerId();
    void ShowVoIPConfigUI();
    void RemoveFriend();
    void AddFriend();
    void IsFriend();
    void ResetStats();
    void ReadOnlineAvatarByName();
    void ReadOnlineAvatar();
    void OnReadOnlineAvatarByNameComplete();
    void OnReadOnlineAvatarComplete();
    void RegisterLocalTalker();
    void GetLobbyInterface();
    void SetDebugSpewLevel();
    void DumpVoiceRegistration();
    void DumpNetIds();
    void DumpSessionState();
    void DumpGameSettings();
    void IsInSession();
    void GetNumSupportedLogins();
    void GetBuildUniqueId();
    void eventGetPlayerUniqueNetIdFromIndex();
    void StringToUniqueNetIdDec();
    void StringToUniqueNetId();
    void UniqueNetIdToString();
    void eventRaiseEvent();
    void eventGetNamedInterface();
    void eventSetNamedInterface();
    void eventSetCommunityContentInterface();
    void eventSetGameDVRInterface();
    void eventSetSharedCloudInterface();
    void eventSetUserCloudInterface();
    void eventSetAuthInterface();
    void eventSetSocialInterface();
    void eventSetTitleFileCacheInterface();
    void eventSetTitleFileInterface();
    void eventSetPartyInterface();
    void eventSetPartyChatInterface();
    void eventSetNewsInterface();
    void eventSetStatsInterface();
    void eventSetVoiceInterface();
    void eventSetContentInterface();
    void eventSetGameInterface();
    void eventSetSystemInterface();
    void eventSetMarketplaceInterface();
    void eventSetPlayerInterfaceEx();
    void eventSetPlayerInterface();
    void eventSetAccountInterface();
    void eventExit();
    void eventPostInit();
    void eventInit();
    void ClearAllInventoryReadCompleteDelegates();
    void ClearOnInventoryReadCompleteDelegate();
    void AddOnInventoryReadCompleteDelegate();
    void OnPingRegionsComplete();
    void OnInventoryReadComplete();
    void ExchangeDuplicates();
    void Exchange();
    void HasKeyForItem();
    void ExchangeReady();
    void ClearInFlight();
    void ClearNewlyAdded();
    void IsExchangeable();
    void OpenGameStorePage();
    void OpenURL();
    void OpenItemPurchaseOverlay();
    void OpenMarketPlaceSearch();
};

UClass* UOnlineSubsystem::pClassPointer = NULL;

// Class Engine.PackageMapLevel
// 0x0008 (0x0108 - 0x0100)
class UPackageMapLevel : public UPackageMap {
   public:
    unsigned char UnknownData00[0x8];  // 0x0100 (0x0008) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[653];

        return pClassPointer;
    };
};

UClass* UPackageMapLevel::pClassPointer = NULL;

// Class Engine.PackageMapSeekFree
// 0x0000 (0x0108 - 0x0108)
class UPackageMapSeekFree : public UPackageMapLevel {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[655];

        return pClassPointer;
    };
};

UClass* UPackageMapSeekFree::pClassPointer = NULL;

// Class Engine.PatchScriptCommandlet
// 0x0008 (0x00BC - 0x00B4)
class UPatchScriptCommandlet : public UCommandlet {
   public:
    unsigned char UnknownData00[0x8];  // 0x00B4 (0x0008) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[657];

        return pClassPointer;
    };
};

UClass* UPatchScriptCommandlet::pClassPointer = NULL;

// Class Engine.PlatformInterfaceBase
// 0x0020 (0x0080 - 0x0060)
class UPlatformInterfaceBase : public UObject {
   public:
    TArray<struct FDelegateArray>
        AllDelegates;  // 0x0060 (0x0010) [0x0000000000000000]
    struct FScriptDelegate
        __PlatformInterfaceDelegate__Delegate;  // 0x0070 (0x0010)
                                                // [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x0074 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[659];

        return pClassPointer;
    };

    void ClearDelegate();
    void AddDelegate();
    void GetInAppMessageInterface();
    void GetAppNotificationsInterface();
    void GetTwitterIntegration();
    void GetAnalyticEventsInterface();
    void GetMicroTransactionInterface();
    void GetInGameAdManager();
    void GetFacebookIntegration();
    void GetLocalStorageInterface();
    void GetCloudStorageInterface();
    void CallDelegates();
    void PlatformInterfaceDelegate();
};

UClass* UPlatformInterfaceBase::pClassPointer = NULL;

// Class Engine.MicroTransactionBase
// 0x0030 (0x00B0 - 0x0080)
class UMicroTransactionBase : public UPlatformInterfaceBase {
   public:
    TArray<struct FPurchaseInfo>
        AvailableProducts;             // 0x0080 (0x0010) [0x0000000000000000]
    struct FString LastError;          // 0x0090 (0x0010) [0x0000000000000000]
    struct FString LastErrorSolution;  // 0x00A0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[661];

        return pClassPointer;
    };

    void eventGetProductIndex();
    void eventBeginPurchase();
    void eventIsAllowedToMakePurchases();
    void eventQueryForAvailablePurchases();
    void eventInit();
};

UClass* UMicroTransactionBase::pClassPointer = NULL;

// Class Engine.MicroTransactionProxy
// 0x0000 (0x00B0 - 0x00B0)
class UMicroTransactionProxy : public UMicroTransactionBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[663];

        return pClassPointer;
    };
};

UClass* UMicroTransactionProxy::pClassPointer = NULL;

// Class Engine.Player
// 0x002C (0x008C - 0x0060)
class UPlayer : public UObject {
   public:
    struct FPointer VfTable_FExec;    // 0x0060 (0x0008) [0x0000000000000000]
    class APlayerController* Actor;   // 0x0068 (0x0008) [0x0000000000000000]
    int CurrentNetSpeed;              // 0x0070 (0x0004) [0x0000000000000000]
    int ConfiguredInternetSpeed;      // 0x0074 (0x0004) [0x0000000000000000]
    int ConfiguredLanSpeed;           // 0x0078 (0x0004) [0x0000000000000000]
    float PP_DesaturationMultiplier;  // 0x007C (0x0004) [0x0000000000000000]
    float PP_HighlightsMultiplier;    // 0x0080 (0x0004) [0x0000000000000000]
    float PP_MidTonesMultiplier;      // 0x0084 (0x0004) [0x0000000000000000]
    float PP_ShadowsMultiplier;       // 0x0088 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[665];

        return pClassPointer;
    };

    void SwitchController();
};

UClass* UPlayer::pClassPointer = NULL;

// Class Engine.LocalPlayer
// 0x0520 (0x05AC - 0x008C)
class ULocalPlayer : public UPlayer {
   public:
    struct FPointer
        VfTable_FObserverInterface;  // 0x008C (0x0008) [0x0000000000000000]
    int ControllerId;                // 0x0094 (0x0004) [0x0000000000000000]
    class UGameViewportClient*
        ViewportClient;       // 0x0098 (0x0008) [0x0000000000000000]
    struct FVector2D Origin;  // 0x00A0 (0x0008) [0x0000000000000000]
    struct FVector2D Size;    // 0x00A8 (0x0008) [0x0000000000000000]
    class UPostProcessChain*
        PlayerPostProcess;  // 0x00B0 (0x0008) [0x0000000000000000]
    TArray<class UPostProcessChain*>
        PlayerPostProcessChains;  // 0x00B8 (0x0010) [0x0000000000000000]
    DWORD
        bForceDefaultPostProcessChain : 1;  // 0x00C8 (0x0004)
                                            // [0x0000000000000000] [0x00000001]
    DWORD bWantToResetToMapDefaultPP : 1;   // 0x00C8 (0x0004)
                                            // [0x0000000000000000] [0x00000002]
    DWORD bSentSplitJoin : 1;      // 0x00C8 (0x0004) [0x0000000000000000]
                                   // [0x00000004]
    DWORD bPendingServerAuth : 1;  // 0x00C8 (0x0004) [0x0000000000000000]
                                   // [0x00000008]
    struct FPointer ViewState;     // 0x00CC (0x0008) [0x0000000000000000]
    struct FPointer ViewState2;    // 0x00D4 (0x0008) [0x0000000000000000]
    struct FSynchronizedActorVisibilityHistory
        ActorVisibilityHistory;       // 0x00DC (0x0010) [0x0000000000000000]
    struct FVector LastViewLocation;  // 0x00EC (0x000C) [0x0000000000000000]
    struct FCurrentPostProcessVolumeInfo
        CurrentPPInfo;  // 0x00F8 (0x0230) [0x0000000000000000]
    struct FCurrentPostProcessVolumeInfo
        LevelPPInfo;  // 0x0328 (0x0230) [0x0000000000000000]
    TArray<struct FPostProcessSettingsOverride>
        ActivePPOverrides;  // 0x0558 (0x0010) [0x0000000000000000]
    unsigned char
        AspectRatioAxisConstraint;  // 0x0568 (0x0001) [0x0000000000000000]
    struct FString LastMap;         // 0x056C (0x0010) [0x0000000000000000]
    class UTranslationContext*
        TagContext;  // 0x057C (0x0008) [0x0000000000000000]
    class UOnlineAuthInterface*
        CachedAuthInt;                 // 0x0584 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x8];  // 0x058C (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    float ServerAuthTimestamp;         // 0x0594 (0x0004) [0x0000000000000000]
    int ServerAuthTimeout;             // 0x0598 (0x0004) [0x0000000000000000]
    int ServerAuthRetryCount;          // 0x059C (0x0004) [0x0000000000000000]
    int MaxServerAuthRetryCount;       // 0x05A0 (0x0004) [0x0000000000000000]
    struct FUniqueNetId ServerAuthUID;  // 0x05A4 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[667];

        return pClassPointer;
    };

    void Cleanup();
    void eventExit();
    void eventNotifyServerConnectionClose();
    void eventViewportClosed();
    void StaticOnServerConnectionClose();
    void OnServerConnectionClose();
    void ServerAuthFailure();
    void eventServerAuthTimedOut();
    void OnServerAuthComplete();
    void ProcessServerAuthResponse();
    void ProcessClientAuthEndSessionRequest();
    void ProcessClientAuthRequest();
    void eventNotifyServerConnectionOpen();
    void eventGetNickname();
    void eventGetUniqueNetId();
    void FastProject();
    void FastDeProject();
    void Project();
    void DeProject();
    void TouchPlayerPostProcessChain();
    void GetPostProcessChain();
    void RemoveAllPostProcessingChains();
    void RemovePostProcessingChain();
    void InsertPostProcessingChain();
    void GetTranslationContext();
    void SetControllerId();
    void ClearPostProcessSettingsOverride();
    void OverridePostProcessSettingsCurve();
    void OverridePostProcessSettings();
    void GetActorVisibility();
    void SendSplitJoin();
    void SpawnPlayActor();
};

UClass* ULocalPlayer::pClassPointer = NULL;

// Class Engine.NetConnection
// 0xB050 (0xB0DC - 0x008C)
class UNetConnection : public UPlayer {
   public:
    unsigned char UnknownData00[0xAFF8];  // 0x008C (0xAFF8) MISSED OFFSET
    TArray<class UChildConnection*>
        Children;                       // 0xB084 (0x0010) [0x0000000000000000]
    unsigned char UnknownData01[0x48];  // 0xB094 (0x0048) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[669];

        return pClassPointer;
    };
};

UClass* UNetConnection::pClassPointer = NULL;

// Class Engine.ChildConnection
// 0x0008 (0xB0E4 - 0xB0DC)
class UChildConnection : public UNetConnection {
   public:
    class UNetConnection* Parent;  // 0xB0DC (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[673];

        return pClassPointer;
    };
};

UClass* UChildConnection::pClassPointer = NULL;

// Class Engine.DemoRecConnection
// 0x0000 (0xB0DC - 0xB0DC)
class UDemoRecConnection : public UNetConnection {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[676];

        return pClassPointer;
    };
};

UClass* UDemoRecConnection::pClassPointer = NULL;

// Class Engine.PlayfabInterface
// 0x0260 (0x02C0 - 0x0060)
class UPlayfabInterface : public UObject {
   public:
    struct FPointer
        VfTable_FTickableObject;  // 0x0060 (0x0008) [0x0000000000000000]
    class UOnlineGameSearch*
        PendingGameSearch;               // 0x0068 (0x0008) [0x0000000000000000]
    struct FString CachedPlayfabId;      // 0x0070 (0x0010) [0x0000000000000000]
    struct FString CachedSessionTicket;  // 0x0080 (0x0010) [0x0000000000000000]
    struct FString CachedAuthCode;       // 0x0090 (0x0010) [0x0000000000000000]
    struct FString
        CachedAuthForEntitlements;    // 0x00A0 (0x0010) [0x0000000000000000]
    DWORD bLoginProcessFinished : 1;  // 0x00B0 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bLaunchedByPlayfab : 1;     // 0x00B0 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD
        bCloudServer : 1;  // 0x00B0 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bServerAllocated : 1;     // 0x00B0 (0x0004) [0x0000000000000000]
                                    // [0x00000008]
    DWORD bServerDeallocated : 1;   // 0x00B0 (0x0004) [0x0000000000000000]
                                    // [0x00000010]
    int LastAuthRefreshTime;        // 0x00B4 (0x0004) [0x0000000000000000]
    int SecondsForAuthRefreshTime;  // 0x00B8 (0x0004) [0x0000000000000000]
    struct FString CatalogName;     // 0x00BC (0x0010) [0x0000000000000000]
    TArray<struct FRegionDefinition>
        KnownRegions;               // 0x00CC (0x0010) [0x0000000000000000]
    struct FString CurrRegionName;  // 0x00DC (0x0010) [0x0000000000000000]
    int PlayfabNPServiceLabel;      // 0x00EC (0x0004) [0x0000000000000000]
    struct FMap_Mirror TitleData;   // 0x00F0 (0x0048) [0x0000000000000000]
    struct FString CachedLobbyId;   // 0x0138 (0x0010) [0x0000000000000000]
    struct FString CachedServerId;  // 0x0148 (0x0010) [0x0000000000000000]
    float
        ElapsedTimeSinceLastHeartBeat;  // 0x0158 (0x0004) [0x0000000000000000]
    float HeartbeatInterval;            // 0x015C (0x0004) [0x0000000000000000]
    class UOnlineGameSettings*
        CachedGameSettings;              // 0x0160 (0x0008) [0x0000000000000000]
    float CountdownToReregister;         // 0x0168 (0x0004) [0x0000000000000000]
    float ReregisterInterval;            // 0x016C (0x0004) [0x0000000000000000]
    struct FString AllocateAPIEndpoint;  // 0x0170 (0x0010) [0x0000000000000000]
    struct FString
        DeallocateAPIEndpoint;           // 0x0180 (0x0010) [0x0000000000000000]
    struct FQWord DeallocatedTimeStamp;  // 0x0190 (0x0008) [0x0000000000000000]
    float TimeSinceLastDeallocationUpdate;  // 0x0198 (0x0004)
                                            // [0x0000000000000000]
    float DeallocateTimeUpdateInterval;  // 0x019C (0x0004) [0x0000000000000000]
    TArray<struct FScriptDelegate>
        FindOnlineGamesCompleteDelegates;  // 0x01A0 (0x0010)
                                           // [0x0000000000000000]
    TArray<struct FScriptDelegate>
        OnQueryServerInfoCompleteDelegates;  // 0x01B0 (0x0010)
                                             // [0x0000000000000000]
    TArray<struct FScriptDelegate>
        LoginCompleteDelegates;  // 0x01C0 (0x0010) [0x0000000000000000]
    TArray<struct FScriptDelegate>
        RegionQueryCompleteDelegates;  // 0x01D0 (0x0010) [0x0000000000000000]
    TArray<struct FScriptDelegate>
        ServerStartedDelegates;  // 0x01E0 (0x0010) [0x0000000000000000]
    TArray<struct FScriptDelegate>
        InventoryReadDelegates;  // 0x01F0 (0x0010) [0x0000000000000000]
    TArray<struct FScriptDelegate>
        TitleDataReadDelegates;  // 0x0200 (0x0010) [0x0000000000000000]
    TArray<struct FScriptDelegate>
        StoreDataReadDelegates;  // 0x0210 (0x0010) [0x0000000000000000]
    TArray<struct FScriptDelegate>
        CloudScriptExecutionCompleteDelegates;  // 0x0220 (0x0010)
                                                // [0x0000000000000000]
    struct FScriptDelegate
        __OnLoginComplete__Delegate;   // 0x0230 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x0234 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __OnStoreDataRead__Delegate;   // 0x0240 (0x0010) [0x0000000000000000]
    unsigned char UnknownData01[0x4];  // 0x0244 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __OnInventoryRead__Delegate;   // 0x0250 (0x0010) [0x0000000000000000]
    unsigned char UnknownData02[0x4];  // 0x0254 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __OnTitleDataRead__Delegate;   // 0x0260 (0x0010) [0x0000000000000000]
    unsigned char UnknownData03[0x4];  // 0x0264 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __OnFindOnlineGamesComplete__Delegate;  // 0x0270 (0x0010)
                                                // [0x0000000000000000]
    unsigned char UnknownData04[0x4];  // 0x0274 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __OnQueryServerInfoComplete__Delegate;  // 0x0280 (0x0010)
                                                // [0x0000000000000000]
    unsigned char UnknownData05[0x4];  // 0x0284 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __OnRegionQueryComplete__Delegate;  // 0x0290 (0x0010)
                                            // [0x0000000000000000]
    unsigned char UnknownData06[0x4];  // 0x0294 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __OnServerStarted__Delegate;   // 0x02A0 (0x0010) [0x0000000000000000]
    unsigned char UnknownData07[0x4];  // 0x02A4 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __OnCloudScriptExecutionComplete__Delegate;  // 0x02B0 (0x0010)
                                                     // [0x0000000000000000]
    unsigned char UnknownData08[0x4];  // 0x02B4 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[678];

        return pClassPointer;
    };

    void OnlineServiceAuthComplete();
    void OnTokenAndSignatureRetrieved();
    void eventAuthWithOnlineService();
    void eventGetGameSettings();
    void CreateGameSettings();
    void ServerDeallocate();
    void ServerAllocate();
    void ServerGrantItemsForUser();
    void ServerRemoveVirtualCurrencyForUser();
    void ServerAddVirtualCurrencyForUser();
    void ServerRetrieveInternalUserData();
    void ServerUpdateInternalUserData();
    void ServerSetOpenStatus();
    void ServerRegisterGame();
    void ServerUpdateOnlineGame();
    void ServerNotifyPlayerLeft();
    void ServerNotifyPlayerJoined();
    void ServerValidatePlayer();
    void eventGetProfileSettings();
    void GetLocalizedRegionName();
    void GetLocalizedRegionList();
    void SetIndexForCurrentRegion();
    void GetIndexForCurrentRegion();
    void eventGetServerId();
    void eventIsCloudServer();
    void GetCachedLobbyId();
    void IsRegisteredWithPlayfab();
    void ClearOnCloudScriptExecutionCompleteDelegate();
    void AddOnCloudScriptExecutionCompleteDelegate();
    void OnCloudScriptExecutionComplete();
    void ExecuteCloudScript();
    void ClearOnServerStartedDelegate();
    void AddOnServerStartedDelegate();
    void OnServerStarted();
    void StartNewServerInstance();
    void ClearRegionQueryCompleteDelegate();
    void AddRegionQueryCompleteDelegate();
    void QueryAvailableRegions();
    void OnRegionQueryComplete();
    void ClearQueryServerInfoCompleteDelegate();
    void AddQueryServerInfoCompleteDelegate();
    void OnQueryServerInfoComplete();
    void QueryServerInfo();
    void CancelGameSearch();
    void ClearFindOnlineGamesCompleteDelegate();
    void AddFindOnlineGamesCompleteDelegate();
    void OnFindOnlineGamesComplete();
    void FindOnlineGames();
    void ConsumeEntitlements();
    void UnlockContainer();
    void GetTitleDataForKey();
    void ClearTitleDataReadCompleteDelegate();
    void AddTitleDataReadCompleteDelegate();
    void OnTitleDataRead();
    void ReadTitleData();
    void ClearInventoryReadCompleteDelegate();
    void AddInventoryReadCompleteDelegate();
    void OnInventoryRead();
    void ReadInventory();
    void ClearStoreDataReadCompleteDelegate();
    void AddStoreDataReadCompleteDelegate();
    void OnStoreDataRead();
    void ReadStoreData();
    void Logout();
    void SetDefaultRegion();
    void GetRegionIndex();
    void ClearOnLoginCompleteDelegate();
    void AddOnLoginCompleteDelegate();
    void OnLoginComplete();
    void Login();
};

UClass* UPlayfabInterface::pClassPointer = NULL;

// Class Engine.Polys
// 0x0018 (0x0078 - 0x0060)
class UPolys : public UObject {
   public:
    unsigned char UnknownData00[0x18];  // 0x0060 (0x0018) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[680];

        return pClassPointer;
    };
};

UClass* UPolys::pClassPointer = NULL;

// Class Engine.PostProcessChain
// 0x0010 (0x0070 - 0x0060)
class UPostProcessChain : public UObject {
   public:
    TArray<class UPostProcessEffect*>
        Effects;  // 0x0060 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[682];

        return pClassPointer;
    };

    void FindPostProcessEffect();
};

UClass* UPostProcessChain::pClassPointer = NULL;

// Class Engine.PostProcessEffect
// 0x0025 (0x0085 - 0x0060)
class UPostProcessEffect : public UObject {
   public:
    DWORD
        bShowInEditor : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bShowInGame : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bUseWorldSettings : 1;     // 0x0060 (0x0004) [0x0000000000000000]
                                     // [0x00000004]
    DWORD bAffectsLightingOnly : 1;  // 0x0060 (0x0004) [0x0000000000000000]
                                     // [0x00000008]
    struct FName EffectName;         // 0x0064 (0x0008) [0x0000000000000000]
    int NodePosY;                    // 0x006C (0x0004) [0x0000000000000000]
    int NodePosX;                    // 0x0070 (0x0004) [0x0000000000000000]
    int DrawWidth;                   // 0x0074 (0x0004) [0x0000000000000000]
    int DrawHeight;                  // 0x0078 (0x0004) [0x0000000000000000]
    int OutDrawY;                    // 0x007C (0x0004) [0x0000000000000000]
    int InDrawY;                     // 0x0080 (0x0004) [0x0000000000000000]
    unsigned char SceneDPG;          // 0x0084 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[684];

        return pClassPointer;
    };
};

UClass* UPostProcessEffect::pClassPointer = NULL;

// Class Engine.AmbientOcclusionEffect
// 0x007F (0x0104 - 0x0085)
class UAmbientOcclusionEffect : public UPostProcessEffect {
   public:
    struct FLinearColor OcclusionColor;  // 0x0088 (0x0010) [0x0000000000000000]
    float OcclusionPower;                // 0x0098 (0x0004) [0x0000000000000000]
    float OcclusionScale;                // 0x009C (0x0004) [0x0000000000000000]
    float OcclusionBias;                 // 0x00A0 (0x0004) [0x0000000000000000]
    float MinOcclusion;                  // 0x00A4 (0x0004) [0x0000000000000000]
    DWORD SSAO2 : 1;  // 0x00A8 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bAngleBasedSSAO : 1;  // 0x00A8 (0x0004) [0x0000000000000000]
                                // [0x00000002]
    DWORD HBAO_EnableDepthThreshold : 1;  // 0x00A8 (0x0004)
                                          // [0x0000000000000000] [0x00000004]
    DWORD HBAO_EnableBlur : 1;           // 0x00A8 (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    float OcclusionRadius;               // 0x00AC (0x0004) [0x0000000000000000]
    float OcclusionAttenuation;          // 0x00B0 (0x0004) [0x0000000000000000]
    unsigned char OcclusionQuality;      // 0x00B4 (0x0001) [0x0000000000000000]
    unsigned char HBAO_BlurRadius;       // 0x00B5 (0x0001) [0x0000000000000000]
    float OcclusionFadeoutMinDistance;   // 0x00B8 (0x0004) [0x0000000000000000]
    float OcclusionFadeoutMaxDistance;   // 0x00BC (0x0004) [0x0000000000000000]
    float HaloDistanceThreshold;         // 0x00C0 (0x0004) [0x0000000000000000]
    float HaloDistanceScale;             // 0x00C4 (0x0004) [0x0000000000000000]
    float HaloOcclusion;                 // 0x00C8 (0x0004) [0x0000000000000000]
    float EdgeDistanceThreshold;         // 0x00CC (0x0004) [0x0000000000000000]
    float EdgeDistanceScale;             // 0x00D0 (0x0004) [0x0000000000000000]
    float FilterDistanceScale;           // 0x00D4 (0x0004) [0x0000000000000000]
    int FilterSize;                      // 0x00D8 (0x0004) [0x0000000000000000]
    float HistoryConvergenceTime;        // 0x00DC (0x0004) [0x0000000000000000]
    float HistoryWeightConvergenceTime;  // 0x00E0 (0x0004) [0x0000000000000000]
    float HBAO_Radius;                   // 0x00E4 (0x0004) [0x0000000000000000]
    float HBAO_Bias;                     // 0x00E8 (0x0004) [0x0000000000000000]
    float HBAO_DetailAO;                 // 0x00EC (0x0004) [0x0000000000000000]
    float HBAO_CoarseAO;                 // 0x00F0 (0x0004) [0x0000000000000000]
    float HBAO_PowerExponent;            // 0x00F4 (0x0004) [0x0000000000000000]
    float HBAO_MaxViewDepth;             // 0x00F8 (0x0004) [0x0000000000000000]
    float HBAO_Sharpness;                // 0x00FC (0x0004) [0x0000000000000000]
    float HBAO_BlurSharpness;            // 0x0100 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[686];

        return pClassPointer;
    };
};

UClass* UAmbientOcclusionEffect::pClassPointer = NULL;

// Class Engine.BlurEffect
// 0x0007 (0x008C - 0x0085)
class UBlurEffect : public UPostProcessEffect {
   public:
    int BlurKernelSize;  // 0x0088 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[688];

        return pClassPointer;
    };
};

UClass* UBlurEffect::pClassPointer = NULL;

// Class Engine.DOFEffect
// 0x002F (0x00B4 - 0x0085)
class UDOFEffect : public UPostProcessEffect {
   public:
    float FalloffExponent;         // 0x0088 (0x0004) [0x0000000000000000]
    float BlurKernelSize;          // 0x008C (0x0004) [0x0000000000000000]
    float MaxNearBlurAmount;       // 0x0090 (0x0004) [0x0000000000000000]
    float MinBlurAmount;           // 0x0094 (0x0004) [0x0000000000000000]
    float MaxFarBlurAmount;        // 0x0098 (0x0004) [0x0000000000000000]
    unsigned char FocusType;       // 0x009C (0x0001) [0x0000000000000000]
    float FocusInnerRadius;        // 0x00A0 (0x0004) [0x0000000000000000]
    float FocusDistance;           // 0x00A4 (0x0004) [0x0000000000000000]
    struct FVector FocusPosition;  // 0x00A8 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[690];

        return pClassPointer;
    };
};

UClass* UDOFEffect::pClassPointer = NULL;

// Class Engine.DOFAndBloomEffect
// 0x0038 (0x00EC - 0x00B4)
class UDOFAndBloomEffect : public UDOFEffect {
   public:
    float BloomScale;                   // 0x00B4 (0x0004) [0x0000000000000000]
    float BloomThreshold;               // 0x00B8 (0x0004) [0x0000000000000000]
    struct FColor BloomTint;            // 0x00BC (0x0004) [0x0000000000000000]
    float BloomScreenBlendThreshold;    // 0x00C0 (0x0004) [0x0000000000000000]
    float SceneMultiplier;              // 0x00C4 (0x0004) [0x0000000000000000]
    float BlurBloomKernelSize;          // 0x00C8 (0x0004) [0x0000000000000000]
    DWORD bEnableReferenceDOF : 1;      // 0x00CC (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    float BloomIntensity;               // 0x00D0 (0x0004) [0x0000000000000000]
    float BloomWidth;                   // 0x00D4 (0x0004) [0x0000000000000000]
    float Exposure;                     // 0x00D8 (0x0004) [0x0000000000000000]
    float BloomThreshold2;              // 0x00DC (0x0004) [0x0000000000000000]
    unsigned char DepthOfFieldType;     // 0x00E0 (0x0001) [0x0000000000000000]
    unsigned char DepthOfFieldQuality;  // 0x00E1 (0x0001) [0x0000000000000000]
    class UTexture2D* BokehTexture;     // 0x00E4 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[692];

        return pClassPointer;
    };
};

UClass* UDOFAndBloomEffect::pClassPointer = NULL;

// Class Engine.DOFBloomMotionBlurEffect
// 0x0014 (0x0100 - 0x00EC)
class UDOFBloomMotionBlurEffect : public UDOFAndBloomEffect {
   public:
    float MaxVelocity;                 // 0x00EC (0x0004) [0x0000000000000000]
    float MotionBlurAmount;            // 0x00F0 (0x0004) [0x0000000000000000]
    DWORD FullMotionBlur : 1;          // 0x00F4 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    float CameraRotationThreshold;     // 0x00F8 (0x0004) [0x0000000000000000]
    float CameraTranslationThreshold;  // 0x00FC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[694];

        return pClassPointer;
    };
};

UClass* UDOFBloomMotionBlurEffect::pClassPointer = NULL;

// Class Engine.UberPostProcessEffect
// 0x0094 (0x0194 - 0x0100)
class UUberPostProcessEffect : public UDOFBloomMotionBlurEffect {
   public:
    struct FVector SceneShadows;         // 0x0100 (0x000C) [0x0000000000000000]
    struct FVector SceneHighLights;      // 0x010C (0x000C) [0x0000000000000000]
    struct FVector SceneMidTones;        // 0x0118 (0x000C) [0x0000000000000000]
    float SceneDesaturation;             // 0x0124 (0x0004) [0x0000000000000000]
    struct FVector SceneColorize;        // 0x0128 (0x000C) [0x0000000000000000]
    unsigned char TonemapperType;        // 0x0134 (0x0001) [0x0000000000000000]
    unsigned char PostProcessAAType;     // 0x0135 (0x0001) [0x0000000000000000]
    float TonemapperRange;               // 0x0138 (0x0004) [0x0000000000000000]
    float TonemapperToeFactor;           // 0x013C (0x0004) [0x0000000000000000]
    float TonemapperScale;               // 0x0140 (0x0004) [0x0000000000000000]
    float MotionBlurSoftEdgeKernelSize;  // 0x0144 (0x0004) [0x0000000000000000]
    DWORD bEnableImageGrain : 1;         // 0x0148 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bScaleEffectsWithViewSize : 1;  // 0x0148 (0x0004)
                                          // [0x0000000000000000] [0x00000002]
    DWORD bEnableHDRTonemapper : 1;  // 0x0148 (0x0004) [0x0000000000000000]
                                     // [0x00000004]
    float SceneImageGrainScale;      // 0x014C (0x0004) [0x0000000000000000]
    float BloomWeightSmall;          // 0x0150 (0x0004) [0x0000000000000000]
    float BloomWeightMedium;         // 0x0154 (0x0004) [0x0000000000000000]
    float BloomWeightLarge;          // 0x0158 (0x0004) [0x0000000000000000]
    float BloomSizeScaleSmall;       // 0x015C (0x0004) [0x0000000000000000]
    float BloomSizeScaleMedium;      // 0x0160 (0x0004) [0x0000000000000000]
    float BloomSizeScaleLarge;       // 0x0164 (0x0004) [0x0000000000000000]
    float EdgeDetectionThreshold;    // 0x0168 (0x0004) [0x0000000000000000]
    struct FLUTBlender
        PreviousLUTBlender;         // 0x016C (0x0024) [0x0000000000000000]
    float SceneHDRTonemapperScale;  // 0x0190 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[696];

        return pClassPointer;
    };
};

UClass* UUberPostProcessEffect::pClassPointer = NULL;

// Class Engine.MaterialEffect
// 0x000B (0x0090 - 0x0085)
class UMaterialEffect : public UPostProcessEffect {
   public:
    class UMaterialInterface* Material;  // 0x0088 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[698];

        return pClassPointer;
    };
};

UClass* UMaterialEffect::pClassPointer = NULL;

// Class Engine.MotionBlurEffect
// 0x0017 (0x009C - 0x0085)
class UMotionBlurEffect : public UPostProcessEffect {
   public:
    float MaxVelocity;                 // 0x0088 (0x0004) [0x0000000000000000]
    float MotionBlurAmount;            // 0x008C (0x0004) [0x0000000000000000]
    DWORD FullMotionBlur : 1;          // 0x0090 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    float CameraRotationThreshold;     // 0x0094 (0x0004) [0x0000000000000000]
    float CameraTranslationThreshold;  // 0x0098 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[700];

        return pClassPointer;
    };
};

UClass* UMotionBlurEffect::pClassPointer = NULL;

// Class Engine.TWPostProcessEffect
// 0x00B3 (0x0138 - 0x0085)
class UTWPostProcessEffect : public UPostProcessEffect {
   public:
    float DOF_FocalDistance;             // 0x0088 (0x0004) [0x0000000000000000]
    float DOF_SharpRadius;               // 0x008C (0x0004) [0x0000000000000000]
    float DOF_FocalRadius;               // 0x0090 (0x0004) [0x0000000000000000]
    float DOF_MinBlurSize;               // 0x0094 (0x0004) [0x0000000000000000]
    float DOF_MaxNearBlurSize;           // 0x0098 (0x0004) [0x0000000000000000]
    float DOF_MaxFarBlurSize;            // 0x009C (0x0004) [0x0000000000000000]
    float DOF_ExpFalloff;                // 0x00A0 (0x0004) [0x0000000000000000]
    float DOF_FG_SharpRadius;            // 0x00A4 (0x0004) [0x0000000000000000]
    float DOF_FG_FocalRadius;            // 0x00A8 (0x0004) [0x0000000000000000]
    float DOF_FG_MinBlurSize;            // 0x00AC (0x0004) [0x0000000000000000]
    float DOF_FG_MaxNearBlurSize;        // 0x00B0 (0x0004) [0x0000000000000000]
    float DOF_FG_ExpFalloff;             // 0x00B4 (0x0004) [0x0000000000000000]
    DWORD MB_TileMaxEnabled : 1;         // 0x00B8 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    float Bloom_Intensity;               // 0x00BC (0x0004) [0x0000000000000000]
    float Bloom_Width;                   // 0x00C0 (0x0004) [0x0000000000000000]
    float Bloom_Exposure;                // 0x00C4 (0x0004) [0x0000000000000000]
    float Bloom_Threshold;               // 0x00C8 (0x0004) [0x0000000000000000]
    struct FColor Bloom_Tint;            // 0x00CC (0x0004) [0x0000000000000000]
    float Bloom_ScreenBlendThreshold;    // 0x00D0 (0x0004) [0x0000000000000000]
    struct FVector SceneShadows;         // 0x00D4 (0x000C) [0x0000000000000000]
    struct FVector SceneHighLights;      // 0x00E0 (0x000C) [0x0000000000000000]
    struct FVector SceneMidTones;        // 0x00EC (0x000C) [0x0000000000000000]
    float SceneDesaturation;             // 0x00F8 (0x0004) [0x0000000000000000]
    struct FVector SceneColorize;        // 0x00FC (0x000C) [0x0000000000000000]
    unsigned char TonemapperType;        // 0x0108 (0x0001) [0x0000000000000000]
    unsigned char PostProcessAAType;     // 0x0109 (0x0001) [0x0000000000000000]
    float TonemapperRange;               // 0x010C (0x0004) [0x0000000000000000]
    float TonemapperToeFactor;           // 0x0110 (0x0004) [0x0000000000000000]
    float TonemapperScale;               // 0x0114 (0x0004) [0x0000000000000000]
    float NoiseIntensity;                // 0x0118 (0x0004) [0x0000000000000000]
    float EdgeDetectionThreshold;        // 0x011C (0x0004) [0x0000000000000000]
    float Fog_Start_Distance;            // 0x0120 (0x0004) [0x0000000000000000]
    float Fog_MaxStrength_Distance;      // 0x0124 (0x0004) [0x0000000000000000]
    float Fog_AnimationCutoff_Distance;  // 0x0128 (0x0004) [0x0000000000000000]
    float Fog_Intensity;                 // 0x012C (0x0004) [0x0000000000000000]
    float Fog_MinAmount;                 // 0x0130 (0x0004) [0x0000000000000000]
    struct FColor Fog_Color;             // 0x0134 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[702];

        return pClassPointer;
    };
};

UClass* UTWPostProcessEffect::pClassPointer = NULL;

// Class Engine.PrimitiveComponentFactory
// 0x0004 (0x0064 - 0x0060)
class UPrimitiveComponentFactory : public UObject {
   public:
    DWORD
        CollideActors : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD BlockActors : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD BlockZeroExtent : 1;     // 0x0060 (0x0004) [0x0000000000000000]
                                   // [0x00000004]
    DWORD BlockNonZeroExtent : 1;  // 0x0060 (0x0004) [0x0000000000000000]
                                   // [0x00000008]
    DWORD BlockRigidBody : 1;      // 0x0060 (0x0004) [0x0000000000000000]
                                   // [0x00000010]
    DWORD HiddenGame : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000020]
    DWORD
        HiddenEditor : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000040]
    DWORD CastShadow : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000080]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[704];

        return pClassPointer;
    };
};

UClass* UPrimitiveComponentFactory::pClassPointer = NULL;

// Class Engine.MeshComponentFactory
// 0x0010 (0x0074 - 0x0064)
class UMeshComponentFactory : public UPrimitiveComponentFactory {
   public:
    TArray<class UMaterialInterface*>
        Materials;  // 0x0064 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[706];

        return pClassPointer;
    };
};

UClass* UMeshComponentFactory::pClassPointer = NULL;

// Class Engine.StaticMeshComponentFactory
// 0x0008 (0x007C - 0x0074)
class UStaticMeshComponentFactory : public UMeshComponentFactory {
   public:
    class UStaticMesh* StaticMesh;  // 0x0074 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[708];

        return pClassPointer;
    };
};

UClass* UStaticMeshComponentFactory::pClassPointer = NULL;

// Class Engine.ReachSpec
// 0x0068 (0x00C8 - 0x0060)
class UReachSpec : public UObject {
   public:
    struct FPointer NavOctreeObject;   // 0x0060 (0x0008) [0x0000000000000000]
    int Distance;                      // 0x0068 (0x0004) [0x0000000000000000]
    struct FVector Direction;          // 0x006C (0x000C) [0x0000000000000000]
    class ANavigationPoint* Start;     // 0x0078 (0x0008) [0x0000000000000000]
    struct FActorReference End;        // 0x0080 (0x0018) [0x0000000000000000]
    int CollisionRadius;               // 0x0098 (0x0004) [0x0000000000000000]
    int CollisionHeight;               // 0x009C (0x0004) [0x0000000000000000]
    DWORD bManuallyForced : 1;         // 0x00A0 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bAddToNavigationOctree : 1;  // 0x00A0 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD bCanCutCorners : 1;          // 0x00A0 (0x0004) [0x0000000000000000]
                                       // [0x00000004]
    DWORD bCheckForObstructions : 1;   // 0x00A0 (0x0004) [0x0000000000000000]
                                       // [0x00000008]
    DWORD bSkipPrune : 1;  // 0x00A0 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bDisabled : 1;   // 0x00A0 (0x0004) [0x0000000000000000] [0x00000020]
    int reachFlags;        // 0x00A4 (0x0004) [0x0000000000000000]
    int MaxLandingVelocity;        // 0x00A8 (0x0004) [0x0000000000000000]
    unsigned char bPruned;         // 0x00AC (0x0001) [0x0000000000000000]
    unsigned char PathColorIndex;  // 0x00AD (0x0001) [0x0000000000000000]
    TArray<class UClass*>
        PruneSpecList;        // 0x00B0 (0x0010) [0x0000000000000000]
    class AActor* BlockedBy;  // 0x00C0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[710];

        return pClassPointer;
    };

    void GetCostFor();
    void IsBlockedFor();
    void GetDirection();
    void GetEnd();
    void CostFor();
};

UClass* UReachSpec::pClassPointer = NULL;

// Class Engine.AdvancedReachSpec
// 0x0000 (0x00C8 - 0x00C8)
class UAdvancedReachSpec : public UReachSpec {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[712];

        return pClassPointer;
    };
};

UClass* UAdvancedReachSpec::pClassPointer = NULL;

// Class Engine.CeilingReachSpec
// 0x0000 (0x00C8 - 0x00C8)
class UCeilingReachSpec : public UReachSpec {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[714];

        return pClassPointer;
    };
};

UClass* UCeilingReachSpec::pClassPointer = NULL;

// Class Engine.ForcedReachSpec
// 0x0000 (0x00C8 - 0x00C8)
class UForcedReachSpec : public UReachSpec {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[716];

        return pClassPointer;
    };
};

UClass* UForcedReachSpec::pClassPointer = NULL;

// Class Engine.CoverSlipReachSpec
// 0x0001 (0x00C9 - 0x00C8)
class UCoverSlipReachSpec : public UForcedReachSpec {
   public:
    unsigned char SpecDirection;  // 0x00C8 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[718];

        return pClassPointer;
    };
};

UClass* UCoverSlipReachSpec::pClassPointer = NULL;

// Class Engine.FloorToCeilingReachSpec
// 0x0000 (0x00C8 - 0x00C8)
class UFloorToCeilingReachSpec : public UForcedReachSpec {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[720];

        return pClassPointer;
    };
};

UClass* UFloorToCeilingReachSpec::pClassPointer = NULL;

// Class Engine.MantleReachSpec
// 0x0004 (0x00CC - 0x00C8)
class UMantleReachSpec : public UForcedReachSpec {
   public:
    DWORD bClimbUp : 1;  // 0x00C8 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[722];

        return pClassPointer;
    };
};

UClass* UMantleReachSpec::pClassPointer = NULL;

// Class Engine.SlotToSlotReachSpec
// 0x0001 (0x00C9 - 0x00C8)
class USlotToSlotReachSpec : public UForcedReachSpec {
   public:
    unsigned char SpecDirection;  // 0x00C8 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[724];

        return pClassPointer;
    };
};

UClass* USlotToSlotReachSpec::pClassPointer = NULL;

// Class Engine.SwatTurnReachSpec
// 0x0001 (0x00C9 - 0x00C8)
class USwatTurnReachSpec : public UForcedReachSpec {
   public:
    unsigned char SpecDirection;  // 0x00C8 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[726];

        return pClassPointer;
    };
};

UClass* USwatTurnReachSpec::pClassPointer = NULL;

// Class Engine.WallTransReachSpec
// 0x0000 (0x00C8 - 0x00C8)
class UWallTransReachSpec : public UForcedReachSpec {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[728];

        return pClassPointer;
    };
};

UClass* UWallTransReachSpec::pClassPointer = NULL;

// Class Engine.LadderReachSpec
// 0x0000 (0x00C8 - 0x00C8)
class ULadderReachSpec : public UReachSpec {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[730];

        return pClassPointer;
    };
};

UClass* ULadderReachSpec::pClassPointer = NULL;

// Class Engine.ProscribedReachSpec
// 0x0000 (0x00C8 - 0x00C8)
class UProscribedReachSpec : public UReachSpec {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[732];

        return pClassPointer;
    };
};

UClass* UProscribedReachSpec::pClassPointer = NULL;

// Class Engine.TeleportReachSpec
// 0x0000 (0x00C8 - 0x00C8)
class UTeleportReachSpec : public UReachSpec {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[734];

        return pClassPointer;
    };
};

UClass* UTeleportReachSpec::pClassPointer = NULL;

// Class Engine.SavedMove
// 0x00C4 (0x0124 - 0x0060)
class USavedMove : public UObject {
   public:
    class USavedMove* NextMove;  // 0x0060 (0x0008) [0x0000000000000000]
    float TimeStamp;             // 0x0068 (0x0004) [0x0000000000000000]
    float Delta;                 // 0x006C (0x0004) [0x0000000000000000]
    DWORD bRun : 1;   // 0x0070 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bDuck : 1;  // 0x0070 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD
        bPressedJump : 1;   // 0x0070 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bDoubleJump : 1;  // 0x0070 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bPreciseDestination : 1;  // 0x0070 (0x0004) [0x0000000000000000]
                                    // [0x00000010]
    DWORD bForceRMVelocity : 1;     // 0x0070 (0x0004) [0x0000000000000000]
                                    // [0x00000020]
    DWORD bForceMaxAccel : 1;       // 0x0070 (0x0004) [0x0000000000000000]
                                    // [0x00000040]
    DWORD bRootMotionFromInterpCurve : 1;  // 0x0070 (0x0004)
                                           // [0x0000000000000000] [0x00000080]
    unsigned char DoubleClickMove;  // 0x0074 (0x0001) [0x0000000000000000]
    unsigned char SavedPhysics;     // 0x0075 (0x0001) [0x0000000000000000]
    unsigned char RootMotionMode;   // 0x0076 (0x0001) [0x0000000000000000]
    struct FVector StartLocation;   // 0x0078 (0x000C) [0x0000000000000000]
    struct FVector
        StartRelativeLocation;     // 0x0084 (0x000C) [0x0000000000000000]
    struct FVector StartVelocity;  // 0x0090 (0x000C) [0x0000000000000000]
    struct FVector StartFloor;     // 0x009C (0x000C) [0x0000000000000000]
    struct FVector SavedLocation;  // 0x00A8 (0x000C) [0x0000000000000000]
    struct FVector SavedVelocity;  // 0x00B4 (0x000C) [0x0000000000000000]
    struct FVector
        SavedRelativeLocation;          // 0x00C0 (0x000C) [0x0000000000000000]
    struct FVector RMVelocity;          // 0x00CC (0x000C) [0x0000000000000000]
    struct FVector Acceleration;        // 0x00D8 (0x000C) [0x0000000000000000]
    struct FRotator Rotation;           // 0x00E4 (0x000C) [0x0000000000000000]
    class AActor* StartBase;            // 0x00F0 (0x0008) [0x0000000000000000]
    class AActor* EndBase;              // 0x00F8 (0x0008) [0x0000000000000000]
    float CustomTimeDilation;           // 0x0100 (0x0004) [0x0000000000000000]
    float AccelDotThreshold;            // 0x0104 (0x0004) [0x0000000000000000]
    float RootMotionInterpCurrentTime;  // 0x0108 (0x0004) [0x0000000000000000]
    struct FVector
        RootMotionInterpCurveLastValue;  // 0x010C (0x000C) [0x0000000000000000]
    struct FRotator
        WeaponBufferRotation;  // 0x0118 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[736];

        return pClassPointer;
    };

    void GetDebugString();
    void SetFlags();
    void CompressedFlags();
    void ResetMoveFor();
    void PrepMoveFor();
    void SetMoveFor();
    void CanCombineWith();
    void SetInitialPosition();
    void GetStartLocation();
    void IsImportantMove();
    void PostUpdate();
    void Clear();
};

UClass* USavedMove::pClassPointer = NULL;

// Class Engine.SaveGameSummary
// 0x0018 (0x0078 - 0x0060)
class USaveGameSummary : public UObject {
   public:
    struct FName BaseLevel;      // 0x0060 (0x0008) [0x0000000000000000]
    struct FString Description;  // 0x0068 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[738];

        return pClassPointer;
    };
};

UClass* USaveGameSummary::pClassPointer = NULL;

// Class Engine.ScriptViewportClient
// 0x0008 (0x0068 - 0x0060)
class UScriptViewportClient : public UObject {
   public:
    struct FPointer
        VfTable_FViewportClient;  // 0x0060 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[740];

        return pClassPointer;
    };
};

UClass* UScriptViewportClient::pClassPointer = NULL;

// Class Engine.GameViewportClient
// 0x0138 (0x01A0 - 0x0068)
class UGameViewportClient : public UScriptViewportClient {
   public:
    struct FPointer VfTable_FExec;  // 0x0068 (0x0008) [0x0000000000000000]
    struct FPointer Viewport;       // 0x0070 (0x0008) [0x0000000000000000]
    struct FPointer ViewportFrame;  // 0x0078 (0x0008) [0x0000000000000000]
    TArray<class UInteraction*>
        GlobalInteractions;              // 0x0080 (0x0010) [0x0000000000000000]
    class UClass* UIControllerClass;     // 0x0090 (0x0008) [0x0000000000000000]
    class UUIInteraction* UIController;  // 0x0098 (0x0008) [0x0000000000000000]
    class UConsole* ViewportConsole;     // 0x00A0 (0x0008) [0x0000000000000000]
    struct FExportShowFlags_Mirror
        ShowFlags;                     // 0x00A8 (0x0010) [0x0000000000000000]
    struct FString LoadingMessage;     // 0x00B8 (0x0010) [0x0000000000000000]
    struct FString SavingMessage;      // 0x00C8 (0x0010) [0x0000000000000000]
    struct FString ConnectingMessage;  // 0x00D8 (0x0010) [0x0000000000000000]
    struct FString PausedMessage;      // 0x00E8 (0x0010) [0x0000000000000000]
    struct FString PrecachingMessage;  // 0x00F8 (0x0010) [0x0000000000000000]
    DWORD bShowTitleSafeZone : 1;      // 0x0108 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bDisplayHardwareMouseCursor : 1;  // 0x0108 (0x0004)
                                            // [0x0000000000000000] [0x00000002]
    DWORD bOverrideDiffuseAndSpecular : 1;  // 0x0108 (0x0004)
                                            // [0x0000000000000000] [0x00000004]
    DWORD bIsPlayInEditorViewport : 1;  // 0x0108 (0x0004) [0x0000000000000000]
                                        // [0x00000008]
    DWORD bShowSystemMouseCursor : 1;   // 0x0108 (0x0004) [0x0000000000000000]
                                        // [0x00000010]
    DWORD bDisableWorldRendering : 1;   // 0x0108 (0x0004) [0x0000000000000000]
                                        // [0x00000020]
    DWORD bCapturedWorldRendering : 1;  // 0x0108 (0x0004) [0x0000000000000000]
                                        // [0x00000040]
    DWORD
        bDebugNoGFxUI : 1;  // 0x0108 (0x0004) [0x0000000000000000] [0x00000080]
    DWORD bAllowInputFromMultipleControllers : 1;  // 0x0108 (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00000100]
    DWORD
        bNeedsNewGamepadPairingForControllerDisconnect : 1;  // 0x0108 (0x0004)
                                                             // [0x0000000000000000]
                                                             // [0x00000200]
    DWORD bNeedsNewGamepadPairingForNewProfile : 1;  // 0x0108 (0x0004)
                                                     // [0x0000000000000000]
                                                     // [0x00000400]
    struct FTitleSafeZoneArea
        TitleSafeZone;  // 0x010C (0x0010) [0x0000000000000000]
    TArray<struct FSplitscreenData>
        SplitscreenInfo;  // 0x011C (0x0010) [0x0000000000000000]
    unsigned char
        DesiredSplitscreenType;  // 0x012C (0x0001) [0x0000000000000000]
    unsigned char
        ActiveSplitscreenType;         // 0x012D (0x0001) [0x0000000000000000]
    unsigned char Default2PSplitType;  // 0x012E (0x0001) [0x0000000000000000]
    unsigned char Default3PSplitType;  // 0x012F (0x0001) [0x0000000000000000]
    struct FString
        ProgressMessage[0x2];  // 0x0130 (0x0020) [0x0000000000000000]
    float ProgressTimeOut;     // 0x0150 (0x0004) [0x0000000000000000]
    float ProgressFadeTime;    // 0x0154 (0x0004) [0x0000000000000000]
    TArray<struct FDebugDisplayProperty>
        DebugProperties;  // 0x0158 (0x0010) [0x0000000000000000]
    struct FPointer
        ScaleformInteraction;  // 0x0168 (0x0008) [0x0000000000000000]
    struct FScriptDelegate
        __HandleInputKey__Delegate;    // 0x0170 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x0174 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __HandleInputAxis__Delegate;   // 0x0180 (0x0010) [0x0000000000000000]
    unsigned char UnknownData01[0x4];  // 0x0184 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __HandleInputChar__Delegate;   // 0x0190 (0x0010) [0x0000000000000000]
    unsigned char UnknownData02[0x4];  // 0x0194 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[742];

        return pClassPointer;
    };

    void eventSetHardwareMouseCursorVisibility();
    void DebugSetUISystemEnabled();
    void IsScaleformEnabled();
    void DisableScaleform();
    void EnableScaleform();
    void BecomePrimaryPlayer();
    void OnPrimaryPlayerSwitch();
    void FixupOwnerReferences();
    void GetPlayerOwner();
    void ClearProgressMessages();
    void SetProgressTime();
    void NotifyConnectionError();
    void eventSetProgressMessage();
    void RemoveLocalPlayer();
    void AddLocalPlayer();
    void NotifyPlayerRemoved();
    void NotifyPlayerAdded();
    void DrawTransitionMessage();
    void DrawTransition();
    void DisplayProgressMessage();
    void eventPostRender();
    void DrawTitleSafeArea();
    void eventTick();
    void CalculateDeadZoneForAllSides();
    void CalculateSafeZoneValues();
    void GetPixelSizeOfScreen();
    void HasRightSafeZone();
    void HasLeftSafeZone();
    void HasBottomSafeZone();
    void HasTopSafeZone();
    void ConvertLocalPlayerToGamePlayerIndex();
    void eventGetSubtitleRegion();
    void eventLayoutPlayers();
    void UpdateActiveSplitscreenType();
    void GetSplitscreenConfiguration();
    void SetSplitscreenConfiguration();
    void eventGameSessionEnded();
    void eventInsertInteraction();
    void CreateInitialPlayer();
    void eventInit();
    void eventFindPlayerByControllerId();
    void eventRemovePlayer();
    void eventCreatePlayer();
    void SetMouse();
    void ForceUpdateMouseCursor();
    void NotifySplitscreenLayoutChanged();
    void SetCustomInteractionObject();
    void GetCustomInteractionClass();
    void GetNumCustomInteractions();
    void ShouldForceFullscreenViewport();
    void GetMousePosition();
    void IsFullScreenViewport();
    void GetViewportSize();
    void ConsoleCommand();
    void HandleInputChar();
    void HandleInputAxis();
    void HandleInputKey();
};

UClass* UGameViewportClient::pClassPointer = NULL;

// Class Engine.Selection
// 0x002C (0x008C - 0x0060)
class USelection : public UObject {
   public:
    unsigned char UnknownData00[0x2C];  // 0x0060 (0x002C) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[744];

        return pClassPointer;
    };
};

UClass* USelection::pClassPointer = NULL;

// Class Engine.ServerCommandlet
// 0x0000 (0x00B4 - 0x00B4)
class UServerCommandlet : public UCommandlet {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[746];

        return pClassPointer;
    };
};

UClass* UServerCommandlet::pClassPointer = NULL;

// Class Engine.Settings
// 0x0040 (0x00A0 - 0x0060)
class USettings : public UObject {
   public:
    TArray<struct FLocalizedStringSetting>
        LocalizedSettings;  // 0x0060 (0x0010) [0x0000000000000000]
    TArray<struct FSettingsProperty>
        Properties;  // 0x0070 (0x0010) [0x0000000000000000]
    TArray<struct FLocalizedStringSettingMetaData>
        LocalizedSettingsMappings;  // 0x0080 (0x0010) [0x0000000000000000]
    TArray<struct FSettingsPropertyPropertyMetaData>
        PropertyMappings;  // 0x0090 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[748];

        return pClassPointer;
    };

    void UpdateFromURL();
    void BuildURL();
    void AppendContextsToURL();
    void AppendPropertiesToURL();
    void AppendDataBindingsToURL();
    void GetQoSAdvertisedStringSettings();
    void GetQoSAdvertisedProperties();
    void GetRangedPropertyValue();
    void SetRangedPropertyValue();
    void GetPropertyRange();
    void GetPropertyMappingType();
    void HasStringSetting();
    void HasProperty();
    void UpdateProperties();
    void UpdateStringSettings();
    void GetPropertyType();
    void GetPropertyValueId();
    void SetPropertyValueId();
    void GetStringProperty();
    void SetStringProperty();
    void GetIntProperty();
    void SetIntProperty();
    void GetFloatProperty();
    void SetFloatProperty();
    void SetPropertyFromStringByName();
    void GetPropertyAsStringByName();
    void GetPropertyAsString();
    void GetPropertyColumnHeader();
    void GetPropertyName();
    void GetPropertyId();
    void SetStringSettingValueFromStringByName();
    void GetStringSettingValueNameByName();
    void GetStringSettingValueName();
    void IsWildcardStringSetting();
    void GetStringSettingColumnHeader();
    void GetStringSettingName();
    void GetStringSettingId();
    void GetStringSettingValueByName();
    void SetStringSettingValueByName();
    void GetStringSettingValueNames();
    void IncrementStringSettingValue();
    void GetStringSettingValue();
    void SetStringSettingValue();
    void GetSettingsDataDateTime();
    void GetSettingsDataBlob();
    void GetSettingsDataInt();
    void GetSettingsDataFloat();
    void EmptySettingsData();
    void SetSettingsData();
    void SetSettingsDataBlob();
    void SetSettingsDataDateTime();
    void SetSettingsDataInt();
    void SetSettingsDataFloat();
};

UClass* USettings::pClassPointer = NULL;

// Class Engine.OnlineGameSearch
// 0x00CC (0x016C - 0x00A0)
class UOnlineGameSearch : public USettings {
   public:
    int MaxSearchResults;  // 0x00A0 (0x0004) [0x0000000000000000]
    struct FLocalizedStringSetting
        Query;              // 0x00A4 (0x000C) [0x0000000000000000]
    DWORD bIsLanQuery : 1;  // 0x00B0 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bUsesArbitration : 1;       // 0x00B0 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bIsSearchInProgress : 1;    // 0x00B0 (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    class UClass* GameSettingsClass;  // 0x00B4 (0x0008) [0x0000000000000000]
    TArray<struct FOnlineGameSearchResult>
        Results;  // 0x00BC (0x0010) [0x0000000000000000]
    struct FOverrideSkill
        ManualSkillOverride;  // 0x00CC (0x0034) [0x0000000000000000]
    TArray<struct FNamedObjectProperty>
        NamedProperties;  // 0x0100 (0x0010) [0x0000000000000000]
    struct FOnlineGameSearchQuery
        FilterQuery;  // 0x0110 (0x0020) [0x0000000000000000]
    TArray<struct FString>
        MasterServerSearchKeys;  // 0x0130 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        MasterServerSearchValues;  // 0x0140 (0x0010) [0x0000000000000000]
    struct FString
        AdditionalSearchCriteria;  // 0x0150 (0x0010) [0x0000000000000000]
    int PingBucketSize;            // 0x0160 (0x0004) [0x0000000000000000]
    int NumPingProbes;             // 0x0164 (0x0004) [0x0000000000000000]
    int MaxPingBytes;              // 0x0168 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[750];

        return pClassPointer;
    };

    void GetGametagStringBool();
    void GetGametagString();
    void AddGametagFilter();
    void TestAddBoolGametagFilter();
    void TestAddServerFilter();
    void AddServerFilter();
    void ClearServerFilters();
    void eventGetNamedProperty();
    void eventSetNamedProperty();
    void eventSortSearchResults();
    void SetSkillOverride();
};

UClass* UOnlineGameSearch::pClassPointer = NULL;

// Class Engine.OnlineGameSettings
// 0x00F8 (0x0198 - 0x00A0)
class UOnlineGameSettings : public USettings {
   public:
    int NumPublicConnections;            // 0x00A0 (0x0004) [0x0000000000000000]
    int NumPrivateConnections;           // 0x00A4 (0x0004) [0x0000000000000000]
    int NumOpenPublicConnections;        // 0x00A8 (0x0004) [0x0000000000000000]
    int NumOpenPrivateConnections;       // 0x00AC (0x0004) [0x0000000000000000]
    struct FQWord ServerNonce;           // 0x00B0 (0x0008) [0x0000000000000000]
    struct FString JoinString;           // 0x00B8 (0x0010) [0x0000000000000000]
    struct FString ServiceConfigId;      // 0x00C8 (0x0010) [0x0000000000000000]
    struct FString SessionTemplateName;  // 0x00D8 (0x0010) [0x0000000000000000]
    struct FString MatchHopperName;      // 0x00E8 (0x0010) [0x0000000000000000]
    struct FString SessionGuid;          // 0x00F8 (0x0010) [0x0000000000000000]
    struct FString SessionHandle;        // 0x0108 (0x0010) [0x0000000000000000]
    TArray<struct FUniqueNetId>
        ReservedMembers;         // 0x0118 (0x0010) [0x0000000000000000]
    DWORD bShouldAdvertise : 1;  // 0x0128 (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    DWORD bIsLanMatch : 1;  // 0x0128 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bUsesStats : 1;   // 0x0128 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bAllowJoinInProgress : 1;  // 0x0128 (0x0004) [0x0000000000000000]
                                     // [0x00000008]
    DWORD
        bAllowInvites : 1;  // 0x0128 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD
        bUsesPresence : 1;  // 0x0128 (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bAllowJoinViaPresence : 1;  // 0x0128 (0x0004) [0x0000000000000000]
                                      // [0x00000040]
    DWORD bAllowJoinViaPresenceFriendsOnly : 1;  // 0x0128 (0x0004)
                                                 // [0x0000000000000000]
                                                 // [0x00000080]
    DWORD bUsesArbitration : 1;     // 0x0128 (0x0004) [0x0000000000000000]
                                    // [0x00000100]
    DWORD bAntiCheatProtected : 1;  // 0x0128 (0x0004) [0x0000000000000000]
                                    // [0x00000200]
    DWORD bWasFromInvite : 1;       // 0x0128 (0x0004) [0x0000000000000000]
                                    // [0x00000400]
    DWORD
        bIsDedicated : 1;  // 0x0128 (0x0004) [0x0000000000000000] [0x00000800]
    DWORD bHasSkillUpdateInProgress : 1;  // 0x0128 (0x0004)
                                          // [0x0000000000000000] [0x00001000]
    DWORD bShouldShrinkArbitratedSessions : 1;  // 0x0128 (0x0004)
                                                // [0x0000000000000000]
                                                // [0x00002000]
    DWORD bRequiresPassword : 1;  // 0x0128 (0x0004) [0x0000000000000000]
                                  // [0x00004000]
    DWORD
        bCloudServer : 1;  // 0x0128 (0x0004) [0x0000000000000000] [0x00008000]
    struct FString OwningPlayerName;     // 0x012C (0x0010) [0x0000000000000000]
    struct FUniqueNetId OwningPlayerId;  // 0x013C (0x0008) [0x0000000000000000]
    int PingInMs;                        // 0x0144 (0x0004) [0x0000000000000000]
    float MatchQuality;                  // 0x0148 (0x0004) [0x0000000000000000]
    unsigned char GameState;             // 0x014C (0x0001) [0x0000000000000000]
    int BuildUniqueId;                   // 0x0150 (0x0004) [0x0000000000000000]
    struct FString LobbyId;              // 0x0154 (0x0010) [0x0000000000000000]
    int GfxID;                           // 0x0164 (0x0004) [0x0000000000000000]
    int ElementIdx;                      // 0x0168 (0x0004) [0x0000000000000000]
    int SecondsDeallocated;              // 0x016C (0x0004) [0x0000000000000000]
    int SecondsDeallocatedBucket;        // 0x0170 (0x0004) [0x0000000000000000]
    int SecondsDeallocatedBucketSize;    // 0x0174 (0x0004) [0x0000000000000000]
    struct FString Region;               // 0x0178 (0x0010) [0x0000000000000000]
    TArray<struct FPlayerResult>
        PlayersInGame;  // 0x0188 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[752];

        return pClassPointer;
    };
};

UClass* UOnlineGameSettings::pClassPointer = NULL;

// Class Engine.ShaderCache
// 0x005C (0x00BC - 0x0060)
class UShaderCache : public UObject {
   public:
    unsigned char UnknownData00[0x5C];  // 0x0060 (0x005C) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[754];

        return pClassPointer;
    };
};

UClass* UShaderCache::pClassPointer = NULL;

// Class Engine.ShadowMap1D
// 0x005C (0x00BC - 0x0060)
class UShadowMap1D : public UObject {
   public:
    unsigned char UnknownData00[0x5C];  // 0x0060 (0x005C) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[756];

        return pClassPointer;
    };
};

UClass* UShadowMap1D::pClassPointer = NULL;

// Class Engine.ShadowMap2D
// 0x0038 (0x0098 - 0x0060)
class UShadowMap2D : public UObject {
   public:
    class UShadowMapTexture2D* Texture;  // 0x0060 (0x0008) [0x0000000000000000]
    struct FVector2D CoordinateScale;    // 0x0068 (0x0008) [0x0000000000000000]
    struct FVector2D CoordinateBias;     // 0x0070 (0x0008) [0x0000000000000000]
    struct FGuid LightGuid;              // 0x0078 (0x0010) [0x0000000000000000]
    DWORD bIsShadowFactorTexture : 1;    // 0x0088 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    class UInstancedStaticMeshComponent*
        Component;      // 0x008C (0x0008) [0x0000000000000000]
    int InstanceIndex;  // 0x0094 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[758];

        return pClassPointer;
    };
};

UClass* UShadowMap2D::pClassPointer = NULL;

// Class Engine.SmokeTestCommandlet
// 0x0000 (0x00B4 - 0x00B4)
class USmokeTestCommandlet : public UCommandlet {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[760];

        return pClassPointer;
    };
};

UClass* USmokeTestCommandlet::pClassPointer = NULL;

// Class Engine.SpeechRecognition
// 0x00B0 (0x0110 - 0x0060)
class USpeechRecognition : public UObject {
   public:
    struct FString Language;     // 0x0060 (0x0010) [0x0000000000000000]
    float ConfidenceThreshhold;  // 0x0070 (0x0004) [0x0000000000000000]
    TArray<struct FRecogVocabulary>
        Vocabularies;                 // 0x0074 (0x0010) [0x0000000000000000]
    TArray<unsigned char> VoiceData;  // 0x0084 (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        WorkingVoiceData;            // 0x0094 (0x0010) [0x0000000000000000]
    TArray<unsigned char> UserData;  // 0x00A4 (0x0010) [0x0000000000000000]
    struct FRecogUserData
        InstanceData[0x4];  // 0x00B4 (0x0050) [0x0000000000000000]
    DWORD bDirty : 1;       // 0x0104 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD
        bInitialised : 1;  // 0x0104 (0x0004) [0x0000000000000000] [0x00000002]
    struct FPointer FnxVoiceData;  // 0x0108 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[762];

        return pClassPointer;
    };
};

UClass* USpeechRecognition::pClassPointer = NULL;

// Class Engine.StaticMesh
// 0x01C0 (0x0220 - 0x0060)
class UStaticMesh : public UObject {
   public:
    unsigned char UnknownData00[0x10];  // 0x0060 (0x0010) MISSED OFFSET
    TArray<struct FStaticMeshLODInfo>
        LODInfo;                        // 0x0070 (0x0010) [0x0000000000000000]
    float LODDistanceRatio;             // 0x0080 (0x0004) [0x0000000000000000]
    float LODMaxRange;                  // 0x0084 (0x0004) [0x0000000000000000]
    class UFlexAsset* FlexAsset;        // 0x0088 (0x0008) [0x0000000000000000]
    unsigned char UnknownData01[0x10];  // 0x0090 (0x0010) MISSED OFFSET
    int LightMapResolution;             // 0x00A0 (0x0004) [0x0000000000000000]
    int LightMapCoordinateIndex;        // 0x00A4 (0x0004) [0x0000000000000000]
    int SplatterMapCoordinateIndex_[TW];  // 0x00A8 (0x0004)
                                          // [0x0000000000000000]
    unsigned char UnknownData02[0x5C];    // 0x00AC (0x005C) MISSED OFFSET
    class URB_BodySetup* BodySetup;     // 0x0108 (0x0008) [0x0000000000000000]
    unsigned char UnknownData03[0x4C];  // 0x0110 (0x004C) MISSED OFFSET
    DWORD UseSimpleLineCollision : 1;   // 0x015C (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD UseSimpleBoxCollision : 1;    // 0x0160 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD UseSimpleRigidBodyCollision : 1;  // 0x0164 (0x0004)
                                            // [0x0000000000000000] [0x00000001]
    DWORD UseFullPrecisionUVs : 1;  // 0x0168 (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    DWORD bUsedForInstancing : 1;   // 0x016C (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    DWORD
        bIgnoreForVisibilityCollision : 1;  // 0x0170 (0x0004)
                                            // [0x0000000000000000] [0x00000001]
    int ConsolePreallocateInstanceCount;    // 0x0174 (0x0004)
                                            // [0x0000000000000000]
    DWORD bUseMaximumStreamingTexelRatio : 1;  // 0x0178 (0x0004)
                                               // [0x0000000000000000]
                                               // [0x00000001]
    DWORD bPartitionForEdgeGeometry : 1;       // 0x017C (0x0004)
                                          // [0x0000000000000000] [0x00000001]
    DWORD bCanBecomeDynamic : 1;       // 0x0180 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    unsigned char UnknownData04[0x4];  // 0x0184 (0x0004) MISSED OFFSET
    DWORD bStripComplexCollisionForConsole : 1;    // 0x0188 (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00000001]
    DWORD bPerLODStaticLightingForInstancing : 1;  // 0x018C (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00000001]
    float StreamingDistanceMultiplier;  // 0x0190 (0x0004) [0x0000000000000000]
    unsigned char UnknownData05[0x28];  // 0x0194 (0x0028) MISSED OFFSET
    class UInstancedFoliageSettings*
        FoliageDefaultSettings;          // 0x01BC (0x0008) [0x0000000000000000]
    struct FString SourceFilePath;       // 0x01C4 (0x0010) [0x0000000000000000]
    struct FString SourceFileTimestamp;  // 0x01D4 (0x0010) [0x0000000000000000]
    unsigned char UnknownData06[0x1C];   // 0x01E4 (0x001C) MISSED OFFSET
    unsigned char FlexCollision;         // 0x0200 (0x0001) [0x0000000000000000]
    unsigned char UnknownData07[0x1F];   // 0x0201 (0x001F) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[764];

        return pClassPointer;
    };
};

UClass* UStaticMesh::pClassPointer = NULL;

// Class Engine.Surface
// 0x0000 (0x0060 - 0x0060)
class USurface : public UObject {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[786];

        return pClassPointer;
    };

    void GetSurfaceHeight();
    void GetSurfaceWidth();
};

UClass* USurface::pClassPointer = NULL;

// Class Engine.MaterialInterface
// 0x0204 (0x0264 - 0x0060)
class UMaterialInterface : public USurface {
   public:
    struct FRenderCommandFence_Mirror
        ParentRefFence;  // 0x0060 (0x0004) [0x0000000000000000]
    struct FLightmassMaterialInterfaceSettings
        LightmassSettings;         // 0x0064 (0x001C) [0x0000000000000000]
    struct FString PreviewMesh;    // 0x0080 (0x0010) [0x0000000000000000]
    struct FGuid LightingGuid;     // 0x0090 (0x0010) [0x0000000000000000]
    DWORD bHasQualitySwitch : 1;   // 0x00A0 (0x0004) [0x0000000000000000]
                                   // [0x00000001]
    DWORD bAutoFlattenMobile : 1;  // 0x00A0 (0x0004) [0x0000000000000000]
                                   // [0x00000002]
    DWORD bAutoFlattenMobileNormalTexture : 1;  // 0x00A0 (0x0004)
                                                // [0x0000000000000000]
                                                // [0x00000004]
    DWORD bMobileAllowFog : 1;           // 0x00A0 (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    DWORD bGenerateSubUV : 1;            // 0x00A0 (0x0004) [0x0000000000000000]
                                         // [0x00000010]
    DWORD bUseMobileSpecular : 1;        // 0x00A0 (0x0004) [0x0000000000000000]
                                         // [0x00000020]
    DWORD bUseMobileVertexSpecular : 1;  // 0x00A0 (0x0004) [0x0000000000000000]
                                         // [0x00000040]
    DWORD bUseMobilePixelSpecular : 1;   // 0x00A0 (0x0004) [0x0000000000000000]
                                         // [0x00000080]
    DWORD bUseMobileBumpOffset : 1;      // 0x00A0 (0x0004) [0x0000000000000000]
                                         // [0x00000100]
    DWORD bLockColorBlending : 1;        // 0x00A0 (0x0004) [0x0000000000000000]
                                         // [0x00000200]
    DWORD bUseMobileUniformColorMultiply : 1;  // 0x00A0 (0x0004)
                                               // [0x0000000000000000]
                                               // [0x00000400]
    DWORD
        bUseMobileVertexColorMultiply : 1;  // 0x00A0 (0x0004)
                                            // [0x0000000000000000] [0x00000800]
    DWORD bUseMobileDetailNormal : 1;   // 0x00A0 (0x0004) [0x0000000000000000]
                                        // [0x00001000]
    DWORD bBaseTextureTransformed : 1;  // 0x00A0 (0x0004) [0x0000000000000000]
                                        // [0x00002000]
    DWORD bEmissiveTextureTransformed : 1;  // 0x00A0 (0x0004)
                                            // [0x0000000000000000] [0x00004000]
    DWORD bNormalTextureTransformed : 1;    // 0x00A0 (0x0004)
                                            // [0x0000000000000000] [0x00008000]
    DWORD bMaskTextureTransformed : 1;  // 0x00A0 (0x0004) [0x0000000000000000]
                                        // [0x00010000]
    DWORD bDetailTextureTransformed : 1;  // 0x00A0 (0x0004)
                                          // [0x0000000000000000] [0x00020000]
    DWORD
        bUseMobileWaveVertexMovement : 1;  // 0x00A0 (0x0004)
                                           // [0x0000000000000000] [0x00040000]
    DWORD bMobileEnableBounceLight : 1;  // 0x00A0 (0x0004) [0x0000000000000000]
                                         // [0x00080000]
    DWORD bUseMobileLandscapeMonochromeLayerBlending : 1;  // 0x00A0 (0x0004)
                                                           // [0x0000000000000000]
                                                           // [0x00100000]
    struct FColor
        FlattenBackgroundColor;         // 0x00A4 (0x0004) [0x0000000000000000]
    class UTexture* MobileBaseTexture;  // 0x00A8 (0x0008) [0x0000000000000000]
    class UTexture* FlattenedTexture;   // 0x00B0 (0x0008) [0x0000000000000000]
    unsigned char MobileBaseTextureTexCoordsSource;  // 0x00B8 (0x0001)
                                                     // [0x0000000000000000]
    unsigned char
        MobileAmbientOcclusionSource;  // 0x00B9 (0x0001) [0x0000000000000000]
    unsigned char MobileSpecularMask;  // 0x00BA (0x0001) [0x0000000000000000]
    unsigned char
        MobileEmissiveColorSource;  // 0x00BB (0x0001) [0x0000000000000000]
    unsigned char
        MobileEmissiveMaskSource;  // 0x00BC (0x0001) [0x0000000000000000]
    unsigned char
        MobileEnvironmentMaskSource;  // 0x00BD (0x0001) [0x0000000000000000]
    unsigned char
        MobileEnvironmentBlendMode;  // 0x00BE (0x0001) [0x0000000000000000]
    unsigned char
        MobileRimLightingMaskSource;  // 0x00BF (0x0001) [0x0000000000000000]
    unsigned char MobileMaskTextureTexCoordsSource;  // 0x00C0 (0x0001)
                                                     // [0x0000000000000000]
    unsigned char
        MobileAlphaValueSource;  // 0x00C1 (0x0001) [0x0000000000000000]
    unsigned char MobileDetailTextureTexCoordsSource;  // 0x00C2 (0x0001)
                                                       // [0x0000000000000000]
    unsigned char
        MobileTextureBlendFactorSource;  // 0x00C3 (0x0001) [0x0000000000000000]
    unsigned char
        MobileColorMultiplySource;  // 0x00C4 (0x0001) [0x0000000000000000]
    class UTexture*
        MobileNormalTexture;       // 0x00C8 (0x0008) [0x0000000000000000]
    float SubUVFrameRate;          // 0x00D0 (0x0004) [0x0000000000000000]
    int SubUVFrameCountAlongAxes;  // 0x00D4 (0x0004) [0x0000000000000000]
    float SubUVFrameSize;          // 0x00D8 (0x0004) [0x0000000000000000]
    struct FLinearColor
        MobileSpecularColor;    // 0x00DC (0x0010) [0x0000000000000000]
    float MobileSpecularPower;  // 0x00EC (0x0004) [0x0000000000000000]
    class UTexture*
        MobileEmissiveTexture;  // 0x00F0 (0x0008) [0x0000000000000000]
    struct FLinearColor
        MobileEmissiveColor;  // 0x00F8 (0x0010) [0x0000000000000000]
    class UTexture*
        MobileEnvironmentTexture;   // 0x0108 (0x0008) [0x0000000000000000]
    float MobileEnvironmentAmount;  // 0x0110 (0x0004) [0x0000000000000000]
    struct FLinearColor
        MobileEnvironmentColor;  // 0x0114 (0x0010) [0x0000000000000000]
    float
        MobileEnvironmentFresnelAmount;  // 0x0124 (0x0004) [0x0000000000000000]
    float MobileEnvironmentFresnelExponent;  // 0x0128 (0x0004)
                                             // [0x0000000000000000]
    float MobileRimLightingStrength;  // 0x012C (0x0004) [0x0000000000000000]
    float MobileRimLightingExponent;  // 0x0130 (0x0004) [0x0000000000000000]
    struct FLinearColor
        MobileRimLightingColor;  // 0x0134 (0x0010) [0x0000000000000000]
    float
        MobileBumpOffsetReferencePlane;  // 0x0144 (0x0004) [0x0000000000000000]
    float MobileBumpOffsetHeightRatio;   // 0x0148 (0x0004) [0x0000000000000000]
    class UTexture* MobileMaskTexture;   // 0x014C (0x0008) [0x0000000000000000]
    float MobileOpacityMultiplier;       // 0x0154 (0x0004) [0x0000000000000000]
    class UTexture*
        MobileDetailTexture;  // 0x0158 (0x0008) [0x0000000000000000]
    class UTexture*
        MobileDetailTexture2;  // 0x0160 (0x0008) [0x0000000000000000]
    class UTexture*
        MobileDetailTexture3;  // 0x0168 (0x0008) [0x0000000000000000]
    struct FLinearColor
        DefaultUniformColor;  // 0x0170 (0x0010) [0x0000000000000000]
    struct FLinearColor
        MobileDefaultUniformColor;      // 0x0180 (0x0010) [0x0000000000000000]
    float TransformCenterX;             // 0x0190 (0x0004) [0x0000000000000000]
    float MobileTransformCenterX;       // 0x0194 (0x0004) [0x0000000000000000]
    float TransformCenterY;             // 0x0198 (0x0004) [0x0000000000000000]
    float MobileTransformCenterY;       // 0x019C (0x0004) [0x0000000000000000]
    float PannerSpeedX;                 // 0x01A0 (0x0004) [0x0000000000000000]
    float MobilePannerSpeedX;           // 0x01A4 (0x0004) [0x0000000000000000]
    float PannerSpeedY;                 // 0x01A8 (0x0004) [0x0000000000000000]
    float MobilePannerSpeedY;           // 0x01AC (0x0004) [0x0000000000000000]
    float RotateSpeed;                  // 0x01B0 (0x0004) [0x0000000000000000]
    float MobileRotateSpeed;            // 0x01B4 (0x0004) [0x0000000000000000]
    float FixedScaleX;                  // 0x01B8 (0x0004) [0x0000000000000000]
    float MobileFixedScaleX;            // 0x01BC (0x0004) [0x0000000000000000]
    float FixedScaleY;                  // 0x01C0 (0x0004) [0x0000000000000000]
    float MobileFixedScaleY;            // 0x01C4 (0x0004) [0x0000000000000000]
    float SineScaleX;                   // 0x01C8 (0x0004) [0x0000000000000000]
    float MobileSineScaleX;             // 0x01CC (0x0004) [0x0000000000000000]
    float SineScaleY;                   // 0x01D0 (0x0004) [0x0000000000000000]
    float MobileSineScaleY;             // 0x01D4 (0x0004) [0x0000000000000000]
    float SineScaleFrequencyMultipler;  // 0x01D8 (0x0004) [0x0000000000000000]
    float MobileSineScaleFrequencyMultipler;  // 0x01DC (0x0004)
                                              // [0x0000000000000000]
    float FixedOffsetX;        // 0x01E0 (0x0004) [0x0000000000000000]
    float MobileFixedOffsetX;  // 0x01E4 (0x0004) [0x0000000000000000]
    float FixedOffsetY;        // 0x01E8 (0x0004) [0x0000000000000000]
    float MobileFixedOffsetY;  // 0x01EC (0x0004) [0x0000000000000000]
    float MobileTangentVertexFrequencyMultiplier;  // 0x01F0 (0x0004)
                                                   // [0x0000000000000000]
    float MobileVerticalFrequencyMultiplier;       // 0x01F4 (0x0004)
                                                   // [0x0000000000000000]
    float MobileMaxVertexMovementAmplitude;        // 0x01F8 (0x0004)
                                                   // [0x0000000000000000]
    float
        MobileSwayFrequencyMultiplier;  // 0x01FC (0x0004) [0x0000000000000000]
    float MobileSwayMaxAngle;           // 0x0200 (0x0004) [0x0000000000000000]
    struct FVector MobileDirectionalLightDirection;  // 0x0204 (0x000C)
                                                     // [0x0000000000000000]
    float MobileDirectionalLightBrightness;          // 0x0210 (0x0004)
                                                     // [0x0000000000000000]
    struct FColor
        MobileDirectionalLightColor;  // 0x0214 (0x0004) [0x0000000000000000]
    struct FVector
        MobileBounceLightDirection;     // 0x0218 (0x000C) [0x0000000000000000]
    float MobileBounceLightBrightness;  // 0x0224 (0x0004) [0x0000000000000000]
    struct FColor
        MobileBounceLightColor;         // 0x0228 (0x0004) [0x0000000000000000]
    float MobileSkyLightBrightness;     // 0x022C (0x0004) [0x0000000000000000]
    struct FColor MobileSkyLightColor;  // 0x0230 (0x0004) [0x0000000000000000]
    struct FName
        MobileLandscapeLayerNames[0x4];  // 0x0234 (0x0020) [0x0000000000000000]
    struct FColor
        MobileLandscapeMonochomeLayerColors[0x4];  // 0x0254 (0x0010)
                                                   // [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[788];

        return pClassPointer;
    };

    void SetForceMipLevelsToBeResident();
    void GetMobileVectorParameterValue();
    void GetMobileTextureParameterValue();
    void GetMobileScalarParameterValue();
    void GetGroupName();
    void GetLinearColorCurveParameterValue();
    void GetLinearColorParameterValue();
    void GetVectorCurveParameterValue();
    void GetVectorParameterValue();
    void GetTextureParameterValue();
    void GetScalarCurveParameterValue();
    void GetScalarParameterValue();
    void GetFontParameterValue();
    void GetParameterDesc();
    void GetPhysicalMaterial();
    void GetMaterial();
};

UClass* UMaterialInterface::pClassPointer = NULL;

// Class Engine.RB_BodySetup
// 0x0060 (0x0128 - 0x00C8)
class URB_BodySetup : public UKMeshProps {
   public:
    unsigned char SleepFamily;  // 0x00C8 (0x0001) [0x0000000000000000]
    struct FName BoneName;      // 0x00CC (0x0008) [0x0000000000000000]
    DWORD bFixed : 1;  // 0x00D4 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD
        bNoCollision : 1;  // 0x00D4 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bBlockZeroExtent : 1;     // 0x00D4 (0x0004) [0x0000000000000000]
                                    // [0x00000004]
    DWORD bBlockNonZeroExtent : 1;  // 0x00D4 (0x0004) [0x0000000000000000]
                                    // [0x00000008]
    DWORD bEnableContinuousCollisionDetection : 1;  // 0x00D4 (0x0004)
                                                    // [0x0000000000000000]
                                                    // [0x00000010]
    DWORD bAlwaysFullAnimWeight : 1;  // 0x00D4 (0x0004) [0x0000000000000000]
                                      // [0x00000020]
    DWORD bConsiderForBounds : 1;     // 0x00D4 (0x0004) [0x0000000000000000]
                                      // [0x00000040]
    class UPhysicalMaterial*
        PhysMaterial;  // 0x00D8 (0x0008) [0x0000000000000000]
    float MassScale;   // 0x00E0 (0x0004) [0x0000000000000000]
    TArray<struct FPointer>
        CollisionGeom;  // 0x00E4 (0x0010) [0x0000000000000000]
    TArray<struct FVector>
        CollisionGeomScale3D;  // 0x00F4 (0x0010) [0x0000000000000000]
    TArray<struct FVector>
        PreCachedPhysScale;  // 0x0104 (0x0010) [0x0000000000000000]
    struct FKCachedConvexData
        PreCachedPhysData;         // 0x0114 (0x0010) [0x0000000000000000]
    int PreCachedPhysDataVersion;  // 0x0124 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[798];

        return pClassPointer;
    };
};

UClass* URB_BodySetup::pClassPointer = NULL;

// Class Engine.InstancedFoliageSettings
// 0x0068 (0x00C8 - 0x0060)
class UInstancedFoliageSettings : public UObject {
   public:
    float Density;         // 0x0060 (0x0004) [0x0000000000000000]
    float Radius;          // 0x0064 (0x0004) [0x0000000000000000]
    float ScaleMinX;       // 0x0068 (0x0004) [0x0000000000000000]
    float ScaleMinY;       // 0x006C (0x0004) [0x0000000000000000]
    float ScaleMinZ;       // 0x0070 (0x0004) [0x0000000000000000]
    float ScaleMaxX;       // 0x0074 (0x0004) [0x0000000000000000]
    float ScaleMaxY;       // 0x0078 (0x0004) [0x0000000000000000]
    float ScaleMaxZ;       // 0x007C (0x0004) [0x0000000000000000]
    DWORD LockScaleX : 1;  // 0x0080 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD LockScaleY : 1;  // 0x0080 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD LockScaleZ : 1;  // 0x0080 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD
        AlignToNormal : 1;  // 0x0080 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD RandomYaw : 1;    // 0x0080 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD
        UniformScale : 1;  // 0x0080 (0x0004) [0x0000000000000000] [0x00000020]
    DWORD ReapplyDensity : 1;  // 0x0080 (0x0004) [0x0000000000000000]
                               // [0x00000040]
    DWORD
        ReapplyRadius : 1;  // 0x0080 (0x0004) [0x0000000000000000] [0x00000080]
    DWORD ReapplyAlignToNormal : 1;  // 0x0080 (0x0004) [0x0000000000000000]
                                     // [0x00000100]
    DWORD ReapplyRandomYaw : 1;      // 0x0080 (0x0004) [0x0000000000000000]
                                     // [0x00000200]
    DWORD
        ReapplyScaleX : 1;  // 0x0080 (0x0004) [0x0000000000000000] [0x00000400]
    DWORD
        ReapplyScaleY : 1;  // 0x0080 (0x0004) [0x0000000000000000] [0x00000800]
    DWORD
        ReapplyScaleZ : 1;  // 0x0080 (0x0004) [0x0000000000000000] [0x00001000]
    DWORD ReapplyRandomPitchAngle : 1;  // 0x0080 (0x0004) [0x0000000000000000]
                                        // [0x00002000]
    DWORD ReapplyGroundSlope : 1;       // 0x0080 (0x0004) [0x0000000000000000]
                                        // [0x00004000]
    DWORD
        ReapplyHeight : 1;  // 0x0080 (0x0004) [0x0000000000000000] [0x00008000]
    DWORD ReapplyLandscapeLayer : 1;  // 0x0080 (0x0004) [0x0000000000000000]
                                      // [0x00010000]
    DWORD ReapplyZOffset : 1;         // 0x0080 (0x0004) [0x0000000000000000]
                                      // [0x00020000]
    DWORD CastShadow : 1;  // 0x0080 (0x0004) [0x0000000000000000] [0x00040000]
    DWORD bCastDynamicShadow : 1;  // 0x0080 (0x0004) [0x0000000000000000]
                                   // [0x00080000]
    DWORD bCastStaticShadow : 1;   // 0x0080 (0x0004) [0x0000000000000000]
                                   // [0x00100000]
    DWORD bSelfShadowOnly : 1;     // 0x0080 (0x0004) [0x0000000000000000]
                                   // [0x00200000]
    DWORD bNoModSelfShadow : 1;    // 0x0080 (0x0004) [0x0000000000000000]
                                   // [0x00400000]
    DWORD bAcceptsDynamicDominantLightShadows : 1;  // 0x0080 (0x0004)
                                                    // [0x0000000000000000]
                                                    // [0x00800000]
    DWORD bCastHiddenShadow : 1;      // 0x0080 (0x0004) [0x0000000000000000]
                                      // [0x01000000]
    DWORD bCastShadowAsTwoSided : 1;  // 0x0080 (0x0004) [0x0000000000000000]
                                      // [0x02000000]
    DWORD bAcceptsLights : 1;         // 0x0080 (0x0004) [0x0000000000000000]
                                      // [0x04000000]
    DWORD bAcceptsDynamicLights : 1;  // 0x0080 (0x0004) [0x0000000000000000]
                                      // [0x08000000]
    DWORD bUseOnePassLightingOnTranslucency : 1;  // 0x0080 (0x0004)
                                                  // [0x0000000000000000]
                                                  // [0x10000000]
    DWORD bUsePrecomputedShadows : 1;  // 0x0080 (0x0004) [0x0000000000000000]
                                       // [0x20000000]
    DWORD bCollideActors : 1;          // 0x0080 (0x0004) [0x0000000000000000]
                                       // [0x40000000]
    DWORD
        bBlockActors : 1;  // 0x0080 (0x0004) [0x0000000000000000] [0x80000000]
    DWORD bBlockNonZeroExtent : 1;  // 0x0084 (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    DWORD bBlockZeroExtent : 1;     // 0x0084 (0x0004) [0x0000000000000000]
                                    // [0x00000002]
    DWORD IsSelected : 1;   // 0x0084 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD ShowNothing : 1;  // 0x0084 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD ShowPaintSettings : 1;     // 0x0084 (0x0004) [0x0000000000000000]
                                     // [0x00000010]
    DWORD ShowInstanceSettings : 1;  // 0x0084 (0x0004) [0x0000000000000000]
                                     // [0x00000020]
    float AlignMaxAngle;             // 0x0088 (0x0004) [0x0000000000000000]
    float RandomPitchAngle;          // 0x008C (0x0004) [0x0000000000000000]
    float GroundSlope;               // 0x0090 (0x0004) [0x0000000000000000]
    float HeightMin;                 // 0x0094 (0x0004) [0x0000000000000000]
    float HeightMax;                 // 0x0098 (0x0004) [0x0000000000000000]
    struct FName LandscapeLayer;     // 0x009C (0x0008) [0x0000000000000000]
    float ZOffsetMin;                // 0x00A4 (0x0004) [0x0000000000000000]
    float ZOffsetMax;                // 0x00A8 (0x0004) [0x0000000000000000]
    int MaxInstancesPerCluster;      // 0x00AC (0x0004) [0x0000000000000000]
    float MaxClusterRadius;          // 0x00B0 (0x0004) [0x0000000000000000]
    float ReapplyDensityAmount;      // 0x00B4 (0x0004) [0x0000000000000000]
    int StartCullDistance;           // 0x00B8 (0x0004) [0x0000000000000000]
    int EndCullDistance;             // 0x00BC (0x0004) [0x0000000000000000]
    unsigned char CullOption;        // 0x00C0 (0x0001) [0x0000000000000000]
    unsigned char DetailMode;        // 0x00C1 (0x0001) [0x0000000000000000]
    int DisplayOrder;                // 0x00C4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[801];

        return pClassPointer;
    };
};

UClass* UInstancedFoliageSettings::pClassPointer = NULL;

// Class Engine.FlexAsset
// 0x00C0 (0x0120 - 0x0060)
class UFlexAsset : public UObject {
   public:
    unsigned char Type;  // 0x0060 (0x0001) [0x0000000000000000]
    class UFlexContainer*
        FlexAssetContainerTemplate;  // 0x0064 (0x0008) [0x0000000000000000]
    int FlexAssetPhaseId;            // 0x006C (0x0004) [0x0000000000000000]
    DWORD bFlexAssetAutoAssignPhase : 1;  // 0x0070 (0x0004)
                                          // [0x0000000000000000] [0x00000001]
    DWORD bEnableInflatable : 1;        // 0x0070 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    float Mass;                         // 0x0074 (0x0004) [0x0000000000000000]
    float StretchStiffness;             // 0x0078 (0x0004) [0x0000000000000000]
    float BendStiffness;                // 0x007C (0x0004) [0x0000000000000000]
    float TetherStiffness;              // 0x0080 (0x0004) [0x0000000000000000]
    float TetherGive;                   // 0x0084 (0x0004) [0x0000000000000000]
    float OverPressure;                 // 0x0088 (0x0004) [0x0000000000000000]
    float RigidStiffness;               // 0x008C (0x0004) [0x0000000000000000]
    float RigidSamplingDistance;        // 0x0090 (0x0004) [0x0000000000000000]
    struct FVector RigidCenter;         // 0x0094 (0x000C) [0x0000000000000000]
    float InflatableStiffness;          // 0x00A0 (0x0004) [0x0000000000000000]
    float InflatableVolume;             // 0x00A4 (0x0004) [0x0000000000000000]
    TArray<struct FVector4> Particles;  // 0x00A8 (0x0010) [0x0000000000000000]
    TArray<int> Phases;                 // 0x00B8 (0x0010) [0x0000000000000000]
    TArray<int> SpringIndices;          // 0x00C8 (0x0010) [0x0000000000000000]
    TArray<float> SpringCoefficients;   // 0x00D8 (0x0010) [0x0000000000000000]
    TArray<float> SpringRestLengths;    // 0x00E8 (0x0010) [0x0000000000000000]
    TArray<int> Triangles;              // 0x00F8 (0x0010) [0x0000000000000000]
    TArray<int> VertexToParticleMap;    // 0x0108 (0x0010) [0x0000000000000000]
    struct FPointer Object;             // 0x0118 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[806];

        return pClassPointer;
    };
};

UClass* UFlexAsset::pClassPointer = NULL;

// Class Engine.FracturedStaticMesh
// 0x00F0 (0x0310 - 0x0220)
class UFracturedStaticMesh : public UStaticMesh {
   public:
    unsigned char UnknownData00[0x8];    // 0x0220 (0x0008) MISSED OFFSET
    class UStaticMesh* SourceCoreMesh;   // 0x0228 (0x0008) [0x0000000000000000]
    float CoreMeshScale;                 // 0x0230 (0x0004) [0x0000000000000000]
    unsigned char UnknownData01[0x30];   // 0x0234 (0x0030) MISSED OFFSET
    DWORD bSliceUsingCoreCollision : 1;  // 0x0264 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    class UParticleSystem*
        FragmentDestroyEffect;  // 0x0268 (0x0008) [0x0000000000000000]
    TArray<class UParticleSystem*>
        FragmentDestroyEffects;        // 0x0270 (0x0010) [0x0000000000000000]
    float FragmentDestroyEffectScale;  // 0x0280 (0x0004) [0x0000000000000000]
    float FragmentHealthScale;         // 0x0284 (0x0004) [0x0000000000000000]
    float FragmentMinHealth;           // 0x0288 (0x0004) [0x0000000000000000]
    float FragmentMaxHealth;           // 0x028C (0x0004) [0x0000000000000000]
    DWORD bUniformFragmentHealth : 1;  // 0x0290 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    float ChunkLinVel;                 // 0x0294 (0x0004) [0x0000000000000000]
    float ChunkAngVel;                 // 0x0298 (0x0004) [0x0000000000000000]
    float ChunkLinHorizontalScale;     // 0x029C (0x0004) [0x0000000000000000]
    float ExplosionVelScale;           // 0x02A0 (0x0004) [0x0000000000000000]
    DWORD bCompositeChunksExplodeOnImpact : 1;  // 0x02A4 (0x0004)
                                                // [0x0000000000000000]
                                                // [0x00000001]
    DWORD bFixIsolatedChunks : 1;  // 0x02A8 (0x0004) [0x0000000000000000]
                                   // [0x00000001]
    DWORD bAlwaysBreakOffIsolatedIslands : 1;  // 0x02AC (0x0004)
                                               // [0x0000000000000000]
                                               // [0x00000001]
    DWORD bSpawnPhysicsChunks : 1;  // 0x02B0 (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    float ChanceOfPhysicsChunk;     // 0x02B4 (0x0004) [0x0000000000000000]
    float
        ExplosionChanceOfPhysicsChunk;  // 0x02B8 (0x0004) [0x0000000000000000]
    float NormalPhysicsChunkScaleMin;   // 0x02BC (0x0004) [0x0000000000000000]
    float NormalPhysicsChunkScaleMax;   // 0x02C0 (0x0004) [0x0000000000000000]
    float
        ExplosionPhysicsChunkScaleMin;  // 0x02C4 (0x0004) [0x0000000000000000]
    float
        ExplosionPhysicsChunkScaleMax;  // 0x02C8 (0x0004) [0x0000000000000000]
    float MinConnectionSupportArea;     // 0x02CC (0x0004) [0x0000000000000000]
    class UMaterialInterface*
        DynamicOutsideMaterial;  // 0x02D0 (0x0008) [0x0000000000000000]
    class UMaterialInterface*
        LoseChunkOutsideMaterial;       // 0x02D8 (0x0008) [0x0000000000000000]
    int OutsideMaterialIndex;           // 0x02E0 (0x0004) [0x0000000000000000]
    unsigned char UnknownData02[0x2C];  // 0x02E4 (0x002C) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[810];

        return pClassPointer;
    };
};

UClass* UFracturedStaticMesh::pClassPointer = NULL;

// Class Engine.ParticleSystem
// 0x0130 (0x0190 - 0x0060)
class UParticleSystem : public UObject {
   public:
    unsigned char SystemUpdateMode;  // 0x0060 (0x0001) [0x0000000000000000]
    unsigned char LODMethod;         // 0x0061 (0x0001) [0x0000000000000000]
    unsigned char
        OcclusionBoundsMethod;           // 0x0062 (0x0001) [0x0000000000000000]
    unsigned char MinimumPhysXLevelExt;  // 0x0063 (0x0001) [0x0000000000000000]
    unsigned char
        MinimumPhysXLevelOverride;  // 0x0064 (0x0001) [0x0000000000000000]
    float UpdateTime_FPS;           // 0x0068 (0x0004) [0x0000000000000000]
    float UpdateTime_Delta;         // 0x006C (0x0004) [0x0000000000000000]
    float WarmupTime;               // 0x0070 (0x0004) [0x0000000000000000]
    float WarmupTickRate;           // 0x0074 (0x0004) [0x0000000000000000]
    TArray<class UParticleEmitter*>
        Emitters;  // 0x0078 (0x0010) [0x0000000000000000]
    class UParticleSystemComponent*
        PreviewComponent;            // 0x0088 (0x0008) [0x0000000000000000]
    struct FRotator ThumbnailAngle;  // 0x0090 (0x000C) [0x0000000000000000]
    float ThumbnailDistance;         // 0x009C (0x0004) [0x0000000000000000]
    float ThumbnailWarmup;           // 0x00A0 (0x0004) [0x0000000000000000]
    DWORD bLit : 1;  // 0x00A4 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bOrientZAxisTowardCamera : 1;  // 0x00A4 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bRegenerateLODDuplicate : 1;   // 0x00A4 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD
        bUseFixedRelativeBoundingBox : 1;  // 0x00A4 (0x0004)
                                           // [0x0000000000000000] [0x00000008]
    DWORD bShouldResetPeakCounts : 1;  // 0x00A4 (0x0004) [0x0000000000000000]
                                       // [0x00000010]
    DWORD bHasPhysics : 1;  // 0x00A4 (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bUseRealtimeThumbnail : 1;    // 0x00A4 (0x0004) [0x0000000000000000]
                                        // [0x00000040]
    DWORD ThumbnailImageOutOfDate : 1;  // 0x00A4 (0x0004) [0x0000000000000000]
                                        // [0x00000080]
    DWORD bSkipSpawnCountCheck : 1;     // 0x00A4 (0x0004) [0x0000000000000000]
                                        // [0x00000100]
    DWORD bUseDelayRange : 1;           // 0x00A4 (0x0004) [0x0000000000000000]
                                        // [0x00000200]
    class UInterpCurveEdSetup*
        CurveEdSetup;            // 0x00A8 (0x0008) [0x0000000000000000]
    float LODDistanceCheckTime;  // 0x00B0 (0x0004) [0x0000000000000000]
    TArray<float> LODDistances;  // 0x00B4 (0x0010) [0x0000000000000000]
    int EditorLODSetting;        // 0x00C4 (0x0004) [0x0000000000000000]
    TArray<struct FParticleSystemLOD>
        LODSettings;  // 0x00C8 (0x0010) [0x0000000000000000]
    struct FBox
        FixedRelativeBoundingBox;       // 0x00D8 (0x001C) [0x0000000000000000]
    float SecondsBeforeInactive;        // 0x00F4 (0x0004) [0x0000000000000000]
    struct FString FloorMesh;           // 0x00F8 (0x0010) [0x0000000000000000]
    struct FVector FloorPosition;       // 0x0108 (0x000C) [0x0000000000000000]
    struct FRotator FloorRotation;      // 0x0114 (0x000C) [0x0000000000000000]
    float FloorScale;                   // 0x0120 (0x0004) [0x0000000000000000]
    struct FVector FloorScale3D;        // 0x0124 (0x000C) [0x0000000000000000]
    struct FColor BackgroundColor;      // 0x0130 (0x0004) [0x0000000000000000]
    class UTexture2D* ThumbnailImage;   // 0x0134 (0x0008) [0x0000000000000000]
    float Delay;                        // 0x013C (0x0004) [0x0000000000000000]
    float DelayLow;                     // 0x0140 (0x0004) [0x0000000000000000]
    struct FVector MacroUVPosition;     // 0x0144 (0x000C) [0x0000000000000000]
    float MacroUVRadius;                // 0x0150 (0x0004) [0x0000000000000000]
    struct FBox CustomOcclusionBounds;  // 0x0154 (0x001C) [0x0000000000000000]
    TArray<struct FLODSoloTrack>
        SoloTracking;  // 0x0170 (0x0010) [0x0000000000000000]
    class UParticleSystem*
        PhysxParticleSystemExtRef;  // 0x0180 (0x0008) [0x0000000000000000]
    class UParticleSystem*
        PhysxParticleSystemRef;  // 0x0188 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[813];

        return pClassPointer;
    };

    void GetMaxLifespan();
    void SetLODDistance();
    void SetCurrentLODMethod();
    void GetLODDistance();
    void GetLODLevelCount();
    void GetCurrentLODMethod();
    void EffectiveParticleSystemAfterPhysXExtension();
    void EffectiveParticleSystemAfterPhysXOverride();
};

UClass* UParticleSystem::pClassPointer = NULL;

// Class Engine.Texture
// 0x00D0 (0x0130 - 0x0060)
class UTexture : public USurface {
   public:
    DWORD SRGB : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD RGBE : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bIsSourceArtUncompressed : 1;  // 0x0060 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD CompressionNoAlpha : 1;        // 0x0060 (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    DWORD CompressionNone : 1;           // 0x0060 (0x0004) [0x0000000000000000]
                                         // [0x00000010]
    DWORD CompressionNoMipmaps : 1;      // 0x0060 (0x0004) [0x0000000000000000]
                                         // [0x00000020]
    DWORD CompressionFullDynamicRange : 1;  // 0x0060 (0x0004)
                                            // [0x0000000000000000] [0x00000040]
    DWORD DeferCompression : 1;  // 0x0060 (0x0004) [0x0000000000000000]
                                 // [0x00000080]
    DWORD NeverStream : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000100]
    DWORD bDitherMipMapAlpha : 1;  // 0x0060 (0x0004) [0x0000000000000000]
                                   // [0x00000200]
    DWORD bPreserveBorderR : 1;    // 0x0060 (0x0004) [0x0000000000000000]
                                   // [0x00000400]
    DWORD bPreserveBorderG : 1;    // 0x0060 (0x0004) [0x0000000000000000]
                                   // [0x00000800]
    DWORD bPreserveBorderB : 1;    // 0x0060 (0x0004) [0x0000000000000000]
                                   // [0x00001000]
    DWORD bPreserveBorderA : 1;    // 0x0060 (0x0004) [0x0000000000000000]
                                   // [0x00002000]
    DWORD bNoTiling : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00004000]
    DWORD
        bForcePVRTC4 : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00008000]
    DWORD bAsyncResourceReleaseHasBeenStarted : 1;  // 0x0060 (0x0004)
                                                    // [0x0000000000000000]
                                                    // [0x00010000]
    DWORD bUseCinematicMipLevels : 1;  // 0x0060 (0x0004) [0x0000000000000000]
                                       // [0x00020000]
    float UnpackMin[0x4];              // 0x0064 (0x0010) [0x0000000000000000]
    float UnpackMax[0x4];              // 0x0074 (0x0010) [0x0000000000000000]
    struct FUntypedBulkData_Mirror
        SourceArt;                       // 0x0084 (0x0040) [0x0000000000000000]
    unsigned char CompressionSettings;   // 0x00C4 (0x0001) [0x0000000000000000]
    unsigned char Filter;                // 0x00C5 (0x0001) [0x0000000000000000]
    unsigned char LODGroup;              // 0x00C6 (0x0001) [0x0000000000000000]
    unsigned char CachedLODGroup;        // 0x00C7 (0x0001) [0x0000000000000000]
    unsigned char MipGenSettings;        // 0x00C8 (0x0001) [0x0000000000000000]
    int LODBias;                         // 0x00CC (0x0004) [0x0000000000000000]
    int CachedCombinedLODBias;           // 0x00D0 (0x0004) [0x0000000000000000]
    int NumCinematicMipLevels;           // 0x00D4 (0x0004) [0x0000000000000000]
    struct FString SourceFilePath;       // 0x00D8 (0x0010) [0x0000000000000000]
    struct FString SourceFileTimestamp;  // 0x00E8 (0x0010) [0x0000000000000000]
    struct FPointer Resource;            // 0x00F8 (0x0008) [0x0000000000000000]
    struct FGuid LightingGuid;           // 0x0100 (0x0010) [0x0000000000000000]
    float AdjustBrightness;              // 0x0110 (0x0004) [0x0000000000000000]
    float AdjustBrightnessCurve;         // 0x0114 (0x0004) [0x0000000000000000]
    float AdjustVibrance;                // 0x0118 (0x0004) [0x0000000000000000]
    float AdjustSaturation;              // 0x011C (0x0004) [0x0000000000000000]
    float AdjustRGBCurve;                // 0x0120 (0x0004) [0x0000000000000000]
    float AdjustHue;                     // 0x0124 (0x0004) [0x0000000000000000]
    int InternalFormatLODBias;           // 0x0128 (0x0004) [0x0000000000000000]
    int RequiredCreationFlags;           // 0x012C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[843];

        return pClassPointer;
    };
};

UClass* UTexture::pClassPointer = NULL;

// Class Engine.Texture2D
// 0x0110 (0x0240 - 0x0130)
class UTexture2D : public UTexture {
   public:
    struct FIndirectArray_Mirror Mips;  // 0x0130 (0x0010) [0x0000000000000000]
    struct FIndirectArray_Mirror
        CachedPVRTCMips;  // 0x0140 (0x0010) [0x0000000000000000]
    struct FIndirectArray_Mirror
        CachedATITCMips;  // 0x0150 (0x0010) [0x0000000000000000]
    struct FIndirectArray_Mirror
        CachedETCMips;                 // 0x0160 (0x0010) [0x0000000000000000]
    int CachedFlashMipsMaxResolution;  // 0x0170 (0x0004) [0x0000000000000000]
    struct FUntypedBulkData_Mirror
        CachedFlashMips;     // 0x0174 (0x0040) [0x0000000000000000]
    int SizeX;               // 0x01B4 (0x0004) [0x0000000000000000]
    int SizeY;               // 0x01B8 (0x0004) [0x0000000000000000]
    int OriginalSizeX;       // 0x01BC (0x0004) [0x0000000000000000]
    int OriginalSizeY;       // 0x01C0 (0x0004) [0x0000000000000000]
    unsigned char Format;    // 0x01C4 (0x0001) [0x0000000000000000]
    unsigned char AddressX;  // 0x01C5 (0x0001) [0x0000000000000000]
    unsigned char AddressY;  // 0x01C6 (0x0001) [0x0000000000000000]
    DWORD
        bIsEditorOnly : 1;  // 0x01C8 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD
        bIsStreamable : 1;  // 0x01C8 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bHasCancelationPending : 1;  // 0x01C8 (0x0004) [0x0000000000000000]
                                       // [0x00000004]
    DWORD bHasBeenLoadedFromPersistentArchive : 1;  // 0x01C8 (0x0004)
                                                    // [0x0000000000000000]
                                                    // [0x00000008]
    DWORD bForceMiplevelsToBeResident : 1;          // 0x01C8 (0x0004)
                                            // [0x0000000000000000] [0x00000010]
    DWORD bGlobalForceMipLevelsToBeResident : 1;  // 0x01C8 (0x0004)
                                                  // [0x0000000000000000]
                                                  // [0x00000020]
    DWORD bIsCompositingSource : 1;     // 0x01C8 (0x0004) [0x0000000000000000]
                                        // [0x00000040]
    DWORD bHasBeenPaintedInEditor : 1;  // 0x01C8 (0x0004) [0x0000000000000000]
                                        // [0x00000080]
    float ForceMipLevelsToBeResidentTimestamp;  // 0x01CC (0x0004)
                                                // [0x0000000000000000]
    struct FName TextureFileCacheName;  // 0x01D0 (0x0008) [0x0000000000000000]
    struct FGuid TextureFileCacheGuid;  // 0x01D8 (0x0010) [0x0000000000000000]
    int RequestedMips;                  // 0x01E8 (0x0004) [0x0000000000000000]
    int ResidentMips;                   // 0x01EC (0x0004) [0x0000000000000000]
    int MipsToRemoveOnCompress;         // 0x01F0 (0x0004) [0x0000000000000000]
    struct FPointer
        ReleaseTexture2DFence;  // 0x01F4 (0x0008) [0x0000000000000000]
    struct FThreadSafeCounter
        PendingMipChangeRequestStatus;  // 0x01FC (0x0004) [0x0000000000000000]
    TArray<unsigned char>
        SystemMemoryData;  // 0x0200 (0x0010) [0x0000000000000000]
    struct FTextureLinkedListMirror
        StreamableTexturesLink;   // 0x0210 (0x0018) [0x0000000000000000]
    int StreamingIndex;           // 0x0228 (0x0004) [0x0000000000000000]
    int MipTailBaseIdx;           // 0x022C (0x0004) [0x0000000000000000]
    struct FPointer ResourceMem;  // 0x0230 (0x0008) [0x0000000000000000]
    int FirstResourceMemMip;      // 0x0238 (0x0004) [0x0000000000000000]
    float Timer;                  // 0x023C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[845];

        return pClassPointer;
    };

    void Create();
    void SetForceMipLevelsToBeResident();
};

UClass* UTexture2D::pClassPointer = NULL;

// Class Engine.LightMapTexture2D
// 0x0004 (0x0244 - 0x0240)
class ULightMapTexture2D : public UTexture2D {
   public:
    unsigned char UnknownData00[0x4];  // 0x0240 (0x0004) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[847];

        return pClassPointer;
    };
};

UClass* ULightMapTexture2D::pClassPointer = NULL;

// Class Engine.ShadowMapTexture2D
// 0x0004 (0x0244 - 0x0240)
class UShadowMapTexture2D : public UTexture2D {
   public:
    int ShadowmapFlags;  // 0x0240 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[849];

        return pClassPointer;
    };
};

UClass* UShadowMapTexture2D::pClassPointer = NULL;

// Class Engine.TWSplatterMapTexture2D
// 0x0014 (0x0254 - 0x0240)
class UTWSplatterMapTexture2D : public UTexture2D {
   public:
    TArray<unsigned char>
        SystemMemoryCache;  // 0x0240 (0x0010) [0x0000000000000000]
    DWORD bDirty : 1;       // 0x0250 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[851];

        return pClassPointer;
    };
};

UClass* UTWSplatterMapTexture2D::pClassPointer = NULL;

// Class Engine.TranslationContext
// 0x0010 (0x0070 - 0x0060)
class UTranslationContext : public UObject {
   public:
    TArray<class UTranslatorTag*>
        TranslatorTags;  // 0x0060 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[853];

        return pClassPointer;
    };

    void RegisterTranslatorTag();
};

UClass* UTranslationContext::pClassPointer = NULL;

// Class Engine.TranslatorTag
// 0x0008 (0x0068 - 0x0060)
class UTranslatorTag : public UObject {
   public:
    struct FName Tag;  // 0x0060 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[855];

        return pClassPointer;
    };

    void Translate();
};

UClass* UTranslatorTag::pClassPointer = NULL;

// Class Engine.StringsTag
// 0x0000 (0x0068 - 0x0068)
class UStringsTag : public UTranslatorTag {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[857];

        return pClassPointer;
    };

    void Translate();
};

UClass* UStringsTag::pClassPointer = NULL;

// Class Engine.TWFixupSplattermapUVCommandlet
// 0x0000 (0x00B4 - 0x00B4)
class UTWFixupSplattermapUVCommandlet : public UCommandlet {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[859];

        return pClassPointer;
    };

    void eventMain();
};

UClass* UTWFixupSplattermapUVCommandlet::pClassPointer = NULL;

// Class Engine.TWGenerateLightmapUVCommandlet
// 0x0010 (0x00C4 - 0x00B4)
class UTWGenerateLightmapUVCommandlet : public UCommandlet {
   public:
    int LightmapUVChannel;         // 0x00B4 (0x0004) [0x0000000000000000]
    float MinChartSpacingPercent;  // 0x00B8 (0x0004) [0x0000000000000000]
    float BorderSpacingPercent;    // 0x00BC (0x0004) [0x0000000000000000]
    DWORD bUseMaxStretch : 1;      // 0x00C0 (0x0004) [0x0000000000000000]
                                   // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[861];

        return pClassPointer;
    };

    void eventMain();
};

UClass* UTWGenerateLightmapUVCommandlet::pClassPointer = NULL;

// Class Engine.TWOnlineLobby
// 0x0000 (0x0060 - 0x0060)
class UTWOnlineLobby : public UObject {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[863];

        return pClassPointer;
    };

    void LobbyInvite();
    void GetLobbyFromCommandline();
    void GetCurrentLobbyId();
    void MakeLobby();
    void GetCurrentPartySize();
    void GetCurrentLobby();
    void LobbyMessage();
    void SendInviteToUsers();
    void ShowLobbyInviteInterface();
    void SetVisibility();
    void GetLobbyData();
    void SetLobbyData();
    void GetFriendNickname();
    void GetMyId();
    void GetLobbyAdmin();
    void QuitLobby();
    void IsLobbyOwner();
    void IsInLobby();
    void GetLobbyURLString();
    void SetServerPassword();
    void LobbyJoinServer();
    void LobbyJoinGame();
};

UClass* UTWOnlineLobby::pClassPointer = NULL;

// Class Engine.TWOnlineUGCInterface
// 0x0010 (0x0070 - 0x0060)
class UTWOnlineUGCInterface : public UObject {
   public:
    struct FScriptDelegate
        __UGCDownloadProgressDelegate__Delegate;  // 0x0060 (0x0010)
                                                  // [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x0064 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[865];

        return pClassPointer;
    };

    void GetUGCForPackage();
    void ClearUGCDownloadProgressDelegate();
    void SetUGCDownloadProgressDelegate();
    void UGCDownloadProgressDelegate();
    void EnumerateWorkshopFiles();
};

UClass* UTWOnlineUGCInterface::pClassPointer = NULL;

// Class Engine.TWSplatterMap2D
// 0x0018 (0x0078 - 0x0060)
class UTWSplatterMap2D : public UObject {
   public:
    class UTWSplatterMapTexture2D*
        Texture;                       // 0x0060 (0x0008) [0x0000000000000000]
    struct FVector2D CoordinateScale;  // 0x0068 (0x0008) [0x0000000000000000]
    struct FVector2D CoordinateBias;   // 0x0070 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[867];

        return pClassPointer;
    };
};

UClass* UTWSplatterMap2D::pClassPointer = NULL;

// Class Engine.UIRoot
// 0x0010 (0x0070 - 0x0060)
class UUIRoot : public UObject {
   public:
    TArray<struct FString>
        BadCapsLocContexts;  // 0x0060 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[869];

        return pClassPointer;
    };

    void SafeCaps();
    void GetOnlinePlayerInterfaceEx();
    void GetOnlinePlayerInterface();
    void GetOnlineGameInterface();
    void StaticResolveDataStore();
    void GetSceneClient();
    void GetCurrentUIController();
    void GetInputPlatformType();
};

UClass* UUIRoot::pClassPointer = NULL;

// Class Engine.Interaction
// 0x0040 (0x00B0 - 0x0070)
class UInteraction : public UUIRoot {
   public:
    struct FScriptDelegate
        __OnReceivedNativeInputKey__Delegate;  // 0x0070 (0x0010)
                                               // [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x0074 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __OnReceivedNativeInputAxis__Delegate;  // 0x0080 (0x0010)
                                                // [0x0000000000000000]
    unsigned char UnknownData01[0x4];  // 0x0084 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __OnReceivedNativeInputChar__Delegate;  // 0x0090 (0x0010)
                                                // [0x0000000000000000]
    unsigned char UnknownData02[0x4];  // 0x0094 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __OnInitialize__Delegate;      // 0x00A0 (0x0010) [0x0000000000000000]
    unsigned char UnknownData03[0x4];  // 0x00A4 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[871];

        return pClassPointer;
    };

    void NotifyPlayerRemoved();
    void NotifyPlayerAdded();
    void NotifyGameSessionEnded();
    void Initialized();
    void OnInitialize();
    void Init();
    void eventPostRender();
    void eventTick();
    void OnReceivedNativeInputChar();
    void OnReceivedNativeInputAxis();
    void OnReceivedNativeInputKey();
};

UClass* UInteraction::pClassPointer = NULL;

// Class Engine.UIInteraction
// 0x02B4 (0x0364 - 0x00B0)
class UUIInteraction : public UInteraction {
   public:
    struct FPointer VfTable_FExec;  // 0x00B0 (0x0008) [0x0000000000000000]
    struct FPointer
        VfTable_FGlobalDataStoreClientManager;  // 0x00B8 (0x0008)
                                                // [0x0000000000000000]
    struct FPointer
        VfTable_FCallbackEventDevice;  // 0x00C0 (0x0008) [0x0000000000000000]
    class UUIManager* UIManager;       // 0x00C8 (0x0008) [0x0000000000000000]
    class UClass* UIManagerClass;      // 0x00D0 (0x0008) [0x0000000000000000]
    class UClass* SceneClientClass;    // 0x00D8 (0x0008) [0x0000000000000000]
    class UGameUISceneClient*
        SceneClient;  // 0x00E0 (0x0008) [0x0000000000000000]
    TArray<struct FName>
        SupportedDoubleClickKeys;  // 0x00E8 (0x0010) [0x0000000000000000]
    class UDataStoreClient*
        DataStoreManager;  // 0x00F8 (0x0008) [0x0000000000000000]
    DWORD
        bProcessInput : 1;  // 0x0100 (0x0004) [0x0000000000000000] [0x00000001]
    float UIJoystickDeadZone;         // 0x0104 (0x0004) [0x0000000000000000]
    float UIAxisMultiplier;           // 0x0108 (0x0004) [0x0000000000000000]
    float AxisRepeatDelay;            // 0x010C (0x0004) [0x0000000000000000]
    float MouseButtonRepeatDelay;     // 0x0110 (0x0004) [0x0000000000000000]
    float DoubleClickTriggerSeconds;  // 0x0114 (0x0004) [0x0000000000000000]
    int DoubleClickPixelTolerance;    // 0x0118 (0x0004) [0x0000000000000000]
    struct FUIKeyRepeatData
        MouseButtonRepeatInfo;  // 0x011C (0x0010) [0x0000000000000000]
    TArray<struct FUIAxisEmulationDefinition>
        ConfiguredAxisEmulationDefinitions;  // 0x012C (0x0010)
                                             // [0x0000000000000000]
    unsigned char
        UnknownData00[0x48];  // 0x013C (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.UIInteraction.AxisEmulationDefinitions
    struct FUIAxisEmulationData
        AxisInputEmulation[0x18];  // 0x0184 (0x01E0) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[873];

        return pClassPointer;
    };

    void NotifyGameSessionEnded();
    void eventGetNATType();
    void GetConnectedGamepadCount();
    void IsGamepadConnected();
    void GetNumGuestsLoggedIn();
    void GetLoggedInPlayerCount();
    void eventIsLoggedIn();
    void eventHasLinkConnection();
    void GetLowestLoginStatusOfControllers();
    void eventGetLoginStatus();
    void NotifyPlayerRemoved();
    void NotifyPlayerAdded();
    void GetLocalPlayer();
    void GetDataStoreClient();
    void GetPlayerControllerId();
    void GetPlayerIndex();
    void GetPlayerCount();
};

UClass* UUIInteraction::pClassPointer = NULL;

// Class Engine.UIManager
// 0x0000 (0x0060 - 0x0060)
class UUIManager : public UObject {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[875];

        return pClassPointer;
    };

    void FindLocalPlayerIndex();
    void NotifyPlayerRemoved();
    void NotifyPlayerAdded();
    void eventPauseGame();
    void CanUnpauseInternalUI();
    void GetUIManager();
};

UClass* UUIManager::pClassPointer = NULL;

// Class Engine.WaveFormBase
// 0x0008 (0x0068 - 0x0060)
class UWaveFormBase : public UObject {
   public:
    class UForceFeedbackWaveform*
        TheWaveForm;  // 0x0060 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[877];

        return pClassPointer;
    };
};

UClass* UWaveFormBase::pClassPointer = NULL;

// Class Engine.World
// 0x0368 (0x03C8 - 0x0060)
class UWorld : public UObject {
   public:
    unsigned char UnknownData00[0x368];  // 0x0060 (0x0368) MISSED OFFSET

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[879];

        return pClassPointer;
    };
};

UClass* UWorld::pClassPointer = NULL;

// Class Engine.EnvironmentVolume
// 0x0014 (0x0294 - 0x0280)
class AEnvironmentVolume : public AVolume {
   public:
    struct FPointer
        VfTable_IInterface_NavMeshPathObstacle;  // 0x0280 (0x0008)
                                                 // [0x0000000000000000]
    struct FPointer
        VfTable_IInterface_NavMeshPathObject;  // 0x0288 (0x0008)
                                               // [0x0000000000000000]
    DWORD
        bSplitNavMesh : 1;  // 0x0290 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[881];

        return pClassPointer;
    };

    void SetSplitNavMesh();
};

UClass* AEnvironmentVolume::pClassPointer = NULL;

// Class Engine.TestSplittingVolume
// 0x0008 (0x0288 - 0x0280)
class ATestSplittingVolume : public AVolume {
   public:
    struct FPointer
        VfTable_IInterface_NavMeshPathObject;  // 0x0280 (0x0008)
                                               // [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[883];

        return pClassPointer;
    };
};

UClass* ATestSplittingVolume::pClassPointer = NULL;

// Class Engine.AIController
// 0x0024 (0x045C - 0x0438)
class AAIController : public AController {
   public:
    float Skill;                       // 0x0438 (0x0004) [0x0000000000000000]
    class AActor* ScriptedMoveTarget;  // 0x043C (0x0008) [0x0000000000000000]
    class ARoute* ScriptedRoute;       // 0x0444 (0x0008) [0x0000000000000000]
    DWORD bReverseScriptedRoute : 1;   // 0x044C (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    int ScriptedRouteIndex;            // 0x0450 (0x0004) [0x0000000000000000]
    class AActor* ScriptedFocus;       // 0x0454 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[885];

        return pClassPointer;
    };

    void CanFireWeapon();
    void NotifyWeaponFinishedFiring();
    void NotifyWeaponFired();
    void OnAIMoveToActor();
    void eventGetPlayerViewPoint();
    void eventSetTeam();
    void DisplayDebug();
    void Reset();
    void eventAILog_Internal();
    void eventPreBeginPlay();
};

UClass* AAIController::pClassPointer = NULL;

// Class Engine.CrowdAgentBase
// 0x0008 (0x024C - 0x0244)
class ACrowdAgentBase : public AActor {
   public:
    struct FPointer
        VfTable_IInterface_NavigationHandle;  // 0x0244 (0x0008)
                                              // [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[887];

        return pClassPointer;
    };

    void eventNotifyPathChanged();
};

UClass* ACrowdAgentBase::pClassPointer = NULL;

// Class Engine.CrowdPopulationManagerBase
// 0x0000 (0x0244 - 0x0244)
class ACrowdPopulationManagerBase : public AActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[889];

        return pClassPointer;
    };
};

UClass* ACrowdPopulationManagerBase::pClassPointer = NULL;

// Class Engine.PathTargetPoint
// 0x0000 (0x024C - 0x024C)
class APathTargetPoint : public AKeypoint {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[891];

        return pClassPointer;
    };

    void ShouldBeHiddenBySHOW_NavigationNodes();
};

UClass* APathTargetPoint::pClassPointer = NULL;

// Class Engine.NavMeshObstacle
// 0x000C (0x0250 - 0x0244)
class ANavMeshObstacle : public AActor {
   public:
    struct FPointer
        VfTable_IInterface_NavMeshPathObstacle;  // 0x0244 (0x0008)
                                                 // [0x0000000000000000]
    DWORD bEnabled : 1;  // 0x024C (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bPreserveInternalGeo : 1;  // 0x024C (0x0004) [0x0000000000000000]
                                     // [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[893];

        return pClassPointer;
    };

    void ApplyCheckpointRecord();
    void CreateCheckpointRecord();
    void SetEnabled();
    void OnToggle();
    void PostBeginPlay();
    void UnRegisterObstacle();
    void RegisterObstacle();
    void eventGetObstacleBoudingShape();
};

UClass* ANavMeshObstacle::pClassPointer = NULL;

// Class Engine.PylonSeed
// 0x0008 (0x024C - 0x0244)
class APylonSeed : public AActor {
   public:
    struct FPointer
        VfTable_IInterface_NavMeshPathObject;  // 0x0244 (0x0008)
                                               // [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[895];

        return pClassPointer;
    };
};

UClass* APylonSeed::pClassPointer = NULL;

// Class Engine.CoverGroupRenderingComponent
// 0x0000 (0x0238 - 0x0238)
class UCoverGroupRenderingComponent : public UPrimitiveComponent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[897];

        return pClassPointer;
    };
};

UClass* UCoverGroupRenderingComponent::pClassPointer = NULL;

// Class Engine.MeshComponent
// 0x0010 (0x0248 - 0x0238)
class UMeshComponent : public UPrimitiveComponent {
   public:
    TArray<class UMaterialInterface*>
        Materials;  // 0x0238 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[899];

        return pClassPointer;
    };

    void CreateAndSetMaterialInstanceTimeVarying();
    void CreateAndSetMaterialInstanceConstant();
    void PrestreamTextures();
    void GetNumElements();
    void SetMaterial();
    void GetMaterial();
};

UClass* UMeshComponent::pClassPointer = NULL;

// Class Engine.StaticMeshComponent
// 0x0094 (0x02DC - 0x0248)
class UStaticMeshComponent : public UMeshComponent {
   public:
    int ForcedLodModel;             // 0x0248 (0x0004) [0x0000000000000000]
    int PreviousLODLevel;           // 0x024C (0x0004) [0x0000000000000000]
    class UStaticMesh* StaticMesh;  // 0x0250 (0x0008) [0x0000000000000000]
    struct FColor WireframeColor;   // 0x0258 (0x0004) [0x0000000000000000]
    DWORD bIgnoreInstanceForTextureStreaming : 1;  // 0x025C (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00000001]
    DWORD bOverrideLightMapResolution : 1;         // 0x025C (0x0004)
                                            // [0x0000000000000000] [0x00000002]
    int LightmapRes;                    // 0x0260 (0x0004) [0x0000000000000000]
    DWORD bOverrideLightMapRes : 1;     // 0x0264 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    int OverriddenLightMapResolution;   // 0x0268 (0x0004) [0x0000000000000000]
    int OverriddenLightMapRes;          // 0x026C (0x0004) [0x0000000000000000]
    int SplatterMapRes;                 // 0x0270 (0x0004) [0x0000000000000000]
    DWORD bOverrideSplatterMapRes : 1;  // 0x0274 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    int OverriddenSplatterMapRes;       // 0x0278 (0x0004) [0x0000000000000000]
    float OverriddenLODMaxRange;        // 0x027C (0x0004) [0x0000000000000000]
    float StreamingDistanceMultiplier;  // 0x0280 (0x0004) [0x0000000000000000]
    int SubDivisionStepSize;            // 0x0284 (0x0004) [0x0000000000000000]
    DWORD bUseSubDivisions : 1;         // 0x0288 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bForceStaticDecals : 1;       // 0x0288 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD
        bCanHighlightSelectedSections : 1;  // 0x0288 (0x0004)
                                            // [0x0000000000000000] [0x00000004]
    DWORD bUseSimpleLightmapModifications : 1;          // 0x0288 (0x0004)
                                                        // [0x0000000000000000]
                                                        // [0x00000008]
    class UTexture* SimpleLightmapModificationTexture;  // 0x028C (0x0008)
                                                        // [0x0000000000000000]
    unsigned char SimpleLightmapModificationFunction;   // 0x0294 (0x0001)
                                                        // [0x0000000000000000]
    DWORD bNeverBecomeDynamic : 1;  // 0x0298 (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    DWORD
        bOverrideVisibilityCollision : 1;  // 0x0298 (0x0004)
                                           // [0x0000000000000000] [0x00000002]
    TArray<struct FGuid>
        IrrelevantLights;  // 0x029C (0x0010) [0x0000000000000000]
    TArray<struct FStaticMeshComponentLODInfo>
        LODData;                      // 0x02AC (0x0010) [0x0000000000000000]
    int VertexPositionVersionNumber;  // 0x02BC (0x0004) [0x0000000000000000]
    struct FLightmassPrimitiveSettings
        LightmassSettings;  // 0x02C0 (0x001C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[901];

        return pClassPointer;
    };

    void CanBecomeDynamic();
    void SetForceStaticDecals();
    void DisableRBCollisionWithSMC();
    void SetStaticMesh();
};

UClass* UStaticMeshComponent::pClassPointer = NULL;

// Class Engine.CoverMeshComponent
// 0x0038 (0x0314 - 0x02DC)
class UCoverMeshComponent : public UStaticMeshComponent {
   public:
    TArray<struct FCoverMeshes> Meshes;  // 0x02DC (0x0010) [0x0000000000000000]
    struct FVector LocationOffset;       // 0x02EC (0x000C) [0x0000000000000000]
    class UStaticMesh* AutoAdjustOn;     // 0x02F8 (0x0008) [0x0000000000000000]
    class UStaticMesh* AutoAdjustOff;    // 0x0300 (0x0008) [0x0000000000000000]
    class UStaticMesh* Disabled;         // 0x0308 (0x0008) [0x0000000000000000]
    DWORD bShowWhenNotSelected : 1;      // 0x0310 (0x0004) [0x0000000000000000]
                                         // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[903];

        return pClassPointer;
    };
};

UClass* UCoverMeshComponent::pClassPointer = NULL;

// Class Engine.NavMeshRenderingComponent
// 0x0000 (0x0238 - 0x0238)
class UNavMeshRenderingComponent : public UPrimitiveComponent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[905];

        return pClassPointer;
    };
};

UClass* UNavMeshRenderingComponent::pClassPointer = NULL;

// Class Engine.PathRenderingComponent
// 0x0000 (0x0238 - 0x0238)
class UPathRenderingComponent : public UPrimitiveComponent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[907];

        return pClassPointer;
    };
};

UClass* UPathRenderingComponent::pClassPointer = NULL;

// Class Engine.RouteRenderingComponent
// 0x0000 (0x0238 - 0x0238)
class URouteRenderingComponent : public UPrimitiveComponent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[909];

        return pClassPointer;
    };
};

UClass* URouteRenderingComponent::pClassPointer = NULL;

// Class Engine.AICommandBase
// 0x0000 (0x0060 - 0x0060)
class UAICommandBase : public UObject {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[911];

        return pClassPointer;
    };

    void eventGetUtility();
};

UClass* UAICommandBase::pClassPointer = NULL;

// Class Engine.AutoNavMeshPathObstacleUnregister
// 0x0010 (0x0070 - 0x0060)
class UAutoNavMeshPathObstacleUnregister : public UObject {
   public:
    class UInterface_NavMeshPathObstacle*
        PathObstacleRef;               // 0x0060 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x8];  // 0x0068 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[913];

        return pClassPointer;
    };
};

UClass* UAutoNavMeshPathObstacleUnregister::pClassPointer = NULL;

// Class Engine.Interface_NavMeshPathObject
// 0x0000 (0x0060 - 0x0060)
class UInterface_NavMeshPathObject : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[915];

        return pClassPointer;
    };
};

UClass* UInterface_NavMeshPathObject::pClassPointer = NULL;

// Class Engine.Interface_NavMeshPathSwitch
// 0x0000 (0x0060 - 0x0060)
class UInterface_NavMeshPathSwitch : public UInterface_NavMeshPathObject {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[917];

        return pClassPointer;
    };

    void eventAIActivateSwitch();
};

UClass* UInterface_NavMeshPathSwitch::pClassPointer = NULL;

// Class Engine.Interface_NavMeshPathObstacle
// 0x0000 (0x0060 - 0x0060)
class UInterface_NavMeshPathObstacle : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[919];

        return pClassPointer;
    };
};

UClass* UInterface_NavMeshPathObstacle::pClassPointer = NULL;

// Class Engine.Interface_PylonGeometryProvider
// 0x0000 (0x0060 - 0x0060)
class UInterface_PylonGeometryProvider : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[921];

        return pClassPointer;
    };
};

UClass* UInterface_PylonGeometryProvider::pClassPointer = NULL;

// Class Engine.Interface_RVO
// 0x0000 (0x0060 - 0x0060)
class UInterface_RVO : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[923];

        return pClassPointer;
    };
};

UClass* UInterface_RVO::pClassPointer = NULL;

// Class Engine.NavigationHandle
// 0x0140 (0x01A0 - 0x0060)
class UNavigationHandle : public UObject {
   public:
    class APylon* AnchorPylon;    // 0x0060 (0x0008) [0x0000000000000000]
    struct FPointer AnchorPoly;   // 0x0068 (0x0008) [0x0000000000000000]
    struct FPathStore PathCache;  // 0x0070 (0x0010) [0x0000000000000000]
    struct FPointer
        BestUnfinishedPathPoint;       // 0x0080 (0x0008) [0x0000000000000000]
    struct FPointer CurrentEdge;       // 0x0088 (0x0008) [0x0000000000000000]
    struct FPointer SubGoal_DestPoly;  // 0x0090 (0x0008) [0x0000000000000000]
    struct FBasedPosition
        FinalDestination;              // 0x0098 (0x0038) [0x0000000000000000]
    DWORD bSkipRouteCacheUpdates : 1;  // 0x00D0 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bUseORforEvaluateGoal : 1;   // 0x00D0 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD
        bDebugConstraintsAndGoalEvals : 1;  // 0x00D0 (0x0004)
                                            // [0x0000000000000000] [0x00000004]
    DWORD bUltraVerbosePathDebugging : 1;   // 0x00D0 (0x0004)
                                            // [0x0000000000000000] [0x00000008]
    DWORD bVisualPathDebugging : 1;  // 0x00D0 (0x0004) [0x0000000000000000]
                                     // [0x00000010]
    DWORD bDebug_Breadcrumbs : 1;    // 0x00D0 (0x0004) [0x0000000000000000]
                                     // [0x00000020]
    class UNavMeshPathConstraint*
        PathConstraintList;  // 0x00D4 (0x0008) [0x0000000000000000]
    class UNavMeshPathGoalEvaluator*
        PathGoalList;  // 0x00DC (0x0008) [0x0000000000000000]
    struct FNavMeshPathParams
        CachedPathParams;              // 0x00E4 (0x0034) [0x0000000000000000]
    unsigned char LastPathError;       // 0x0118 (0x0001) [0x0000000000000000]
    float LastPathFailTime;            // 0x011C (0x0004) [0x0000000000000000]
    struct FVector Breadcrumbs[0xA];   // 0x0120 (0x0078) [0x0000000000000000]
    int BreadCrumbMostRecentIdx;       // 0x0198 (0x0004) [0x0000000000000000]
    float BreadCrumbDistanceInterval;  // 0x019C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[925];

        return pClassPointer;
    };

    void DrawBreadCrumbs();
    void StaticGetValidatedAnchorPosition();
    void GetValidatedAnchorPosition();
    void GetAllCoverSlotsInRadius();
    void PopulatePathfindingParamCache();
    void MoveToDesiredHeightAboveMesh();
    void CopyMovePointsFromPathCache();
    void CalculatePathDistance();
    void GetFirstMoveLocation();
    void IsAnchorInescapable();
    void LimitPathCacheDistance();
    void GetValidPositionsForBox();
    void GetAllPolyCentersWithinBounds();
    void GetCurrentEdgeType();
    void ClearCurrentEdge();
    void GetCurrentEdgeDebugText();
    void PrintPathCacheDebugText();
    void DrawPathCache();
    void ActorReachable();
    void PointReachable();
    void PointCheck();
    void LineCheck();
    void ObstaclePointCheck();
    void ObstacleLineCheck();
    void SuggestMovePreparation();
    void FindPath();
    void ComputeValidFinalDestination();
    void SetFinalDestination();
    void GetNextMoveLocation();
    void GetPylonFromPos();
    void FindPylon();
    void GetBestUnfinishedPathPoint();
    void PathCache_RemoveIndex();
    void PathCache_GetGoalPoint();
    void PathCache_Empty();
    void GetPathCacheLength();
    void CreatePathGoalEvaluator();
    void CreatePathConstraint();
    void DoesPylonAHaveAPathToPylonB();
    void BuildFromPylonAToPylonB();
    void AddGoalEvaluator();
    void AddPathConstraint();
    void ClearConstraints();
    void GetNextBreadCrumb();
    void UpdateBreadCrumbs();
    void CopyPathStoreToPathCache();
};

UClass* UNavigationHandle::pClassPointer = NULL;

// Class Engine.NavMeshGoal_Filter
// 0x000C (0x006C - 0x0060)
class UNavMeshGoal_Filter : public UObject {
   public:
    DWORD bShowDebug : 1;   // 0x0060 (0x0004) [0x0000000000000000] [0x00000001]
    int NumNodesThrownOut;  // 0x0064 (0x0004) [0x0000000000000000]
    int NumNodesProcessed;  // 0x0068 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[927];

        return pClassPointer;
    };

    void eventGetDumpString();
};

UClass* UNavMeshGoal_Filter::pClassPointer = NULL;

// Class Engine.NavMeshGoalFilter_MinPathDistance
// 0x0004 (0x0070 - 0x006C)
class UNavMeshGoalFilter_MinPathDistance : public UNavMeshGoal_Filter {
   public:
    int MinDistancePathShouldBe;  // 0x006C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[929];

        return pClassPointer;
    };

    void MustBeLongerPathThan();
};

UClass* UNavMeshGoalFilter_MinPathDistance::pClassPointer = NULL;

// Class Engine.NavMeshGoalFilter_NotNearOtherAI
// 0x0004 (0x0070 - 0x006C)
class UNavMeshGoalFilter_NotNearOtherAI : public UNavMeshGoal_Filter {
   public:
    float DistanceToCheck;  // 0x006C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[931];

        return pClassPointer;
    };

    void NotNearOtherAI();
};

UClass* UNavMeshGoalFilter_NotNearOtherAI::pClassPointer = NULL;

// Class Engine.NavMeshGoalFilter_OutOfViewFrom
// 0x0014 (0x0080 - 0x006C)
class UNavMeshGoalFilter_OutOfViewFrom : public UNavMeshGoal_Filter {
   public:
    struct FPointer GoalPoly;          // 0x006C (0x0008) [0x0000000000000000]
    struct FVector OutOfViewLocation;  // 0x0074 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[933];

        return pClassPointer;
    };

    void MustBeHiddenFromThisPoint();
};

UClass* UNavMeshGoalFilter_OutOfViewFrom::pClassPointer = NULL;

// Class Engine.NavMeshGoalFilter_OutSideOfDotProductWedge
// 0x001C (0x0088 - 0x006C)
class UNavMeshGoalFilter_OutSideOfDotProductWedge : public UNavMeshGoal_Filter {
   public:
    struct FVector Location;  // 0x006C (0x000C) [0x0000000000000000]
    struct FVector Rotation;  // 0x0078 (0x000C) [0x0000000000000000]
    float Epsilon;            // 0x0084 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[935];

        return pClassPointer;
    };

    void OutsideOfDotProductWedge();
};

UClass* UNavMeshGoalFilter_OutSideOfDotProductWedge::pClassPointer = NULL;

// Class Engine.NavMeshGoalFilter_PolyEncompassesAI
// 0x000C (0x0078 - 0x006C)
class UNavMeshGoalFilter_PolyEncompassesAI : public UNavMeshGoal_Filter {
   public:
    struct FVector
        OverrideExtentToCheck;  // 0x006C (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[937];

        return pClassPointer;
    };

    void MakeSureAIFits();
};

UClass* UNavMeshGoalFilter_PolyEncompassesAI::pClassPointer = NULL;

// Class Engine.NavMeshPathConstraint
// 0x0018 (0x0078 - 0x0060)
class UNavMeshPathConstraint : public UObject {
   public:
    class UNavMeshPathConstraint*
        NextConstraint;        // 0x0060 (0x0008) [0x0000000000000000]
    int NumNodesProcessed;     // 0x0068 (0x0004) [0x0000000000000000]
    int NumThrownOutNodes;     // 0x006C (0x0004) [0x0000000000000000]
    float AddedDirectCost;     // 0x0070 (0x0004) [0x0000000000000000]
    float AddedHeuristicCost;  // 0x0074 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[939];

        return pClassPointer;
    };

    void eventGetDumpString();
    void eventRecycle();
};

UClass* UNavMeshPathConstraint::pClassPointer = NULL;

// Class Engine.NavMeshPath_AlongLine
// 0x000C (0x0084 - 0x0078)
class UNavMeshPath_AlongLine : public UNavMeshPathConstraint {
   public:
    struct FVector Direction;  // 0x0078 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[941];

        return pClassPointer;
    };

    void Recycle();
    void AlongLine();
};

UClass* UNavMeshPath_AlongLine::pClassPointer = NULL;

// Class Engine.NavMeshPath_EnforceTwoWayEdges
// 0x0000 (0x0078 - 0x0078)
class UNavMeshPath_EnforceTwoWayEdges : public UNavMeshPathConstraint {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[943];

        return pClassPointer;
    };

    void EnforceTwoWayEdges();
};

UClass* UNavMeshPath_EnforceTwoWayEdges::pClassPointer = NULL;

// Class Engine.NavMeshPath_MinDistBetweenSpecsOfType
// 0x0018 (0x0090 - 0x0078)
class UNavMeshPath_MinDistBetweenSpecsOfType : public UNavMeshPathConstraint {
   public:
    float MinDistBetweenEdgeTypes;  // 0x0078 (0x0004) [0x0000000000000000]
    struct FVector InitLocation;    // 0x007C (0x000C) [0x0000000000000000]
    unsigned char EdgeType;         // 0x0088 (0x0001) [0x0000000000000000]
    float Penalty;                  // 0x008C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[945];

        return pClassPointer;
    };

    void Recycle();
    void EnforceMinDist();
};

UClass* UNavMeshPath_MinDistBetweenSpecsOfType::pClassPointer = NULL;

// Class Engine.NavMeshPath_SameCoverLink
// 0x0008 (0x0080 - 0x0078)
class UNavMeshPath_SameCoverLink : public UNavMeshPathConstraint {
   public:
    class ACoverLink* TestLink;  // 0x0078 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[947];

        return pClassPointer;
    };

    void Recycle();
    void SameCoverLink();
};

UClass* UNavMeshPath_SameCoverLink::pClassPointer = NULL;

// Class Engine.NavMeshPath_Toward
// 0x001C (0x0094 - 0x0078)
class UNavMeshPath_Toward : public UNavMeshPathConstraint {
   public:
    DWORD bBiasAgainstHighLevelPath : 1;  // 0x0078 (0x0004)
                                          // [0x0000000000000000] [0x00000001]
    float OutOfHighLevelPathBias;  // 0x007C (0x0004) [0x0000000000000000]
    class AActor* GoalActor;       // 0x0080 (0x0008) [0x0000000000000000]
    struct FVector GoalPoint;      // 0x0088 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[949];

        return pClassPointer;
    };

    void Recycle();
    void TowardPoint();
    void TowardGoal();
};

UClass* UNavMeshPath_Toward::pClassPointer = NULL;

// Class Engine.NavMeshPath_WithinDistanceEnvelope
// 0x001C (0x0094 - 0x0078)
class UNavMeshPath_WithinDistanceEnvelope : public UNavMeshPathConstraint {
   public:
    float MaxDistance;  // 0x0078 (0x0004) [0x0000000000000000]
    float MinDistance;  // 0x007C (0x0004) [0x0000000000000000]
    DWORD bSoft : 1;    // 0x0080 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bOnlyThrowOutNodesThatLeaveEnvelope : 1;  // 0x0080 (0x0004)
                                                    // [0x0000000000000000]
                                                    // [0x00000002]
    float SoftStartPenalty;            // 0x0084 (0x0004) [0x0000000000000000]
    struct FVector EnvelopeTestPoint;  // 0x0088 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[951];

        return pClassPointer;
    };

    void Recycle();
    void StayWithinEnvelopeToLoc();
};

UClass* UNavMeshPath_WithinDistanceEnvelope::pClassPointer = NULL;

// Class Engine.NavMeshPath_WithinTraversalDist
// 0x000C (0x0084 - 0x0078)
class UNavMeshPath_WithinTraversalDist : public UNavMeshPathConstraint {
   public:
    float MaxTraversalDist;  // 0x0078 (0x0004) [0x0000000000000000]
    DWORD bSoft : 1;  // 0x007C (0x0004) [0x0000000000000000] [0x00000001]
    float SoftStartPenalty;  // 0x0080 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[953];

        return pClassPointer;
    };

    void Recycle();
    void DontExceedMaxDist();
};

UClass* UNavMeshPath_WithinTraversalDist::pClassPointer = NULL;

// Class Engine.NavMeshPathGoalEvaluator
// 0x001C (0x007C - 0x0060)
class UNavMeshPathGoalEvaluator : public UObject {
   public:
    class UNavMeshPathGoalEvaluator*
        NextEvaluator;                  // 0x0060 (0x0008) [0x0000000000000000]
    int MaxPathVisits;                  // 0x0068 (0x0004) [0x0000000000000000]
    DWORD bAlwaysCallEvaluateGoal : 1;  // 0x006C (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bDoPartialAStar : 1;          // 0x006C (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    int NumNodesThrownOut;              // 0x0070 (0x0004) [0x0000000000000000]
    int NumNodesProcessed;              // 0x0074 (0x0004) [0x0000000000000000]
    int MaxOpenListSize;                // 0x0078 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[955];

        return pClassPointer;
    };

    void eventGetDumpString();
    void eventRecycle();
};

UClass* UNavMeshPathGoalEvaluator::pClassPointer = NULL;

// Class Engine.NavMeshGoal_At
// 0x0028 (0x00A4 - 0x007C)
class UNavMeshGoal_At : public UNavMeshPathGoalEvaluator {
   public:
    struct FVector Goal;  // 0x007C (0x000C) [0x0000000000000000]
    float GoalDist;       // 0x0088 (0x0004) [0x0000000000000000]
    DWORD
        bKeepPartial : 1;  // 0x008C (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bWeightPartialByDist : 1;     // 0x008C (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bGoalInSamePolyAsAnchor : 1;  // 0x008C (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    float PartialDistSq;                // 0x0090 (0x0004) [0x0000000000000000]
    struct FPointer GoalPoly;           // 0x0094 (0x0008) [0x0000000000000000]
    struct FPointer PartialGoal;        // 0x009C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[957];

        return pClassPointer;
    };

    void Recycle();
    void AtLocation();
    void AtActor();
    void RecycleNative();
};

UClass* UNavMeshGoal_At::pClassPointer = NULL;

// Class Engine.NavMeshGoal_ClosestActorInList
// 0x0060 (0x00DC - 0x007C)
class UNavMeshGoal_ClosestActorInList : public UNavMeshPathGoalEvaluator {
   public:
    TArray<struct FBiasedGoalActor>
        GoalList;  // 0x007C (0x0010) [0x0000000000000000]
    struct FMultiMap_Mirror
        PolyToGoalActorMap;            // 0x008C (0x0048) [0x0000000000000000]
    struct FPointer CachedAnchorPoly;  // 0x00D4 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[959];

        return pClassPointer;
    };

    void RecycleInternal();
    void eventRecycle();
    void ClosestActorInList();
};

UClass* UNavMeshGoal_ClosestActorInList::pClassPointer = NULL;

// Class Engine.NavMeshGoal_GenericFilterContainer
// 0x0030 (0x00AC - 0x007C)
class UNavMeshGoal_GenericFilterContainer : public UNavMeshPathGoalEvaluator {
   public:
    TArray<class UNavMeshGoal_Filter*>
        GoalFilters;                 // 0x007C (0x0010) [0x0000000000000000]
    struct FPointer SuccessfulGoal;  // 0x008C (0x0008) [0x0000000000000000]
    class UNavigationHandle*
        MyNavigationHandle;  // 0x0094 (0x0008) [0x0000000000000000]
    TArray<struct FVector>
        SeedLocations;  // 0x009C (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[961];

        return pClassPointer;
    };

    void Recycle();
    void GetGoalPoint();
    void GetFilterOfType();
    void CreateAndAddFilterToNavHandleFromSeedList();
    void CreateAndAddFilterToNavHandle();
};

UClass* UNavMeshGoal_GenericFilterContainer::pClassPointer = NULL;

// Class Engine.NavMeshGoal_Null
// 0x0008 (0x0084 - 0x007C)
class UNavMeshGoal_Null : public UNavMeshPathGoalEvaluator {
   public:
    struct FPointer PartialGoal;  // 0x007C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[963];

        return pClassPointer;
    };

    void Recycle();
    void RecycleNative();
    void GoUntilBust();
};

UClass* UNavMeshGoal_Null::pClassPointer = NULL;

// Class Engine.NavMeshGoal_PolyEncompassesAI
// 0x000C (0x0088 - 0x007C)
class UNavMeshGoal_PolyEncompassesAI : public UNavMeshPathGoalEvaluator {
   public:
    struct FVector
        OverrideExtentToCheck;  // 0x007C (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[965];

        return pClassPointer;
    };

    void Recycle();
    void MakeSureAIFits();
};

UClass* UNavMeshGoal_PolyEncompassesAI::pClassPointer = NULL;

// Class Engine.NavMeshGoal_Random
// 0x0010 (0x008C - 0x007C)
class UNavMeshGoal_Random : public UNavMeshPathGoalEvaluator {
   public:
    int MinDist;                  // 0x007C (0x0004) [0x0000000000000000]
    float BestRating;             // 0x0080 (0x0004) [0x0000000000000000]
    struct FPointer PartialGoal;  // 0x0084 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[967];

        return pClassPointer;
    };

    void Recycle();
    void RecycleNative();
    void FindRandom();
};

UClass* UNavMeshGoal_Random::pClassPointer = NULL;

// Class Engine.NavMeshGoal_WithinDistanceEnvelope
// 0x0018 (0x0094 - 0x007C)
class UNavMeshGoal_WithinDistanceEnvelope : public UNavMeshPathGoalEvaluator {
   public:
    float MaxDistance;                 // 0x007C (0x0004) [0x0000000000000000]
    float MinDistance;                 // 0x0080 (0x0004) [0x0000000000000000]
    float MinTraversalDist;            // 0x0084 (0x0004) [0x0000000000000000]
    struct FVector EnvelopeTestPoint;  // 0x0088 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[969];

        return pClassPointer;
    };

    void Recycle();
    void GoalWithinEnvelopeToLoc();
};

UClass* UNavMeshGoal_WithinDistanceEnvelope::pClassPointer = NULL;

// Class Engine.PathConstraint
// 0x000C (0x006C - 0x0060)
class UPathConstraint : public UObject {
   public:
    int CacheIdx;  // 0x0060 (0x0004) [0x0000000000000000]
    class UPathConstraint*
        NextConstraint;  // 0x0064 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[971];

        return pClassPointer;
    };

    void eventGetDumpString();
    void eventRecycle();
};

UClass* UPathConstraint::pClassPointer = NULL;

// Class Engine.Path_AlongLine
// 0x000C (0x0078 - 0x006C)
class UPath_AlongLine : public UPathConstraint {
   public:
    struct FVector Direction;  // 0x006C (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[973];

        return pClassPointer;
    };

    void Recycle();
    void AlongLine();
};

UClass* UPath_AlongLine::pClassPointer = NULL;

// Class Engine.Path_AvoidInEscapableNodes
// 0x0010 (0x007C - 0x006C)
class UPath_AvoidInEscapableNodes : public UPathConstraint {
   public:
    int Radius;        // 0x006C (0x0004) [0x0000000000000000]
    int Height;        // 0x0070 (0x0004) [0x0000000000000000]
    int MaxFallSpeed;  // 0x0074 (0x0004) [0x0000000000000000]
    int MoveFlags;     // 0x0078 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[975];

        return pClassPointer;
    };

    void Recycle();
    void DontGetStuck();
    void CachePawnReacFlags();
};

UClass* UPath_AvoidInEscapableNodes::pClassPointer = NULL;

// Class Engine.Path_MinDistBetweenSpecsOfType
// 0x0018 (0x0084 - 0x006C)
class UPath_MinDistBetweenSpecsOfType : public UPathConstraint {
   public:
    float MinDistBetweenSpecTypes;  // 0x006C (0x0004) [0x0000000000000000]
    struct FVector InitLocation;    // 0x0070 (0x000C) [0x0000000000000000]
    class UClass* ReachSpecClass;   // 0x007C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[977];

        return pClassPointer;
    };

    void Recycle();
    void EnforceMinDist();
};

UClass* UPath_MinDistBetweenSpecsOfType::pClassPointer = NULL;

// Class Engine.Path_TowardGoal
// 0x0008 (0x0074 - 0x006C)
class UPath_TowardGoal : public UPathConstraint {
   public:
    class AActor* GoalActor;  // 0x006C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[979];

        return pClassPointer;
    };

    void Recycle();
    void TowardGoal();
};

UClass* UPath_TowardGoal::pClassPointer = NULL;

// Class Engine.Path_TowardPoint
// 0x000C (0x0078 - 0x006C)
class UPath_TowardPoint : public UPathConstraint {
   public:
    struct FVector GoalPoint;  // 0x006C (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[981];

        return pClassPointer;
    };

    void Recycle();
    void TowardPoint();
};

UClass* UPath_TowardPoint::pClassPointer = NULL;

// Class Engine.Path_WithinDistanceEnvelope
// 0x001C (0x0088 - 0x006C)
class UPath_WithinDistanceEnvelope : public UPathConstraint {
   public:
    float MaxDistance;  // 0x006C (0x0004) [0x0000000000000000]
    float MinDistance;  // 0x0070 (0x0004) [0x0000000000000000]
    DWORD bSoft : 1;    // 0x0074 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bOnlyThrowOutNodesThatLeaveEnvelope : 1;  // 0x0074 (0x0004)
                                                    // [0x0000000000000000]
                                                    // [0x00000002]
    float SoftStartPenalty;            // 0x0078 (0x0004) [0x0000000000000000]
    struct FVector EnvelopeTestPoint;  // 0x007C (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[983];

        return pClassPointer;
    };

    void Recycle();
    void StayWithinEnvelopeToLoc();
};

UClass* UPath_WithinDistanceEnvelope::pClassPointer = NULL;

// Class Engine.Path_WithinTraversalDist
// 0x000C (0x0078 - 0x006C)
class UPath_WithinTraversalDist : public UPathConstraint {
   public:
    float MaxTraversalDist;  // 0x006C (0x0004) [0x0000000000000000]
    DWORD bSoft : 1;  // 0x0070 (0x0004) [0x0000000000000000] [0x00000001]
    float SoftStartPenalty;  // 0x0074 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[985];

        return pClassPointer;
    };

    void Recycle();
    void DontExceedMaxDist();
};

UClass* UPath_WithinTraversalDist::pClassPointer = NULL;

// Class Engine.PathGoalEvaluator
// 0x001C (0x007C - 0x0060)
class UPathGoalEvaluator : public UObject {
   public:
    class UPathGoalEvaluator*
        NextEvaluator;  // 0x0060 (0x0008) [0x0000000000000000]
    class ANavigationPoint*
        GeneratedGoal;  // 0x0068 (0x0008) [0x0000000000000000]
    int MaxPathVisits;  // 0x0070 (0x0004) [0x0000000000000000]
    int CacheIdx;       // 0x0074 (0x0004) [0x0000000000000000]
    DWORD bDebug : 1;   // 0x0078 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[987];

        return pClassPointer;
    };

    void eventGetDumpString();
    void eventRecycle();
};

UClass* UPathGoalEvaluator::pClassPointer = NULL;

// Class Engine.Goal_AtActor
// 0x0010 (0x008C - 0x007C)
class UGoal_AtActor : public UPathGoalEvaluator {
   public:
    class AActor* GoalActor;  // 0x007C (0x0008) [0x0000000000000000]
    float GoalDist;           // 0x0084 (0x0004) [0x0000000000000000]
    DWORD
        bKeepPartial : 1;  // 0x0088 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[989];

        return pClassPointer;
    };

    void Recycle();
    void AtActor();
};

UClass* UGoal_AtActor::pClassPointer = NULL;

// Class Engine.Goal_Null
// 0x0000 (0x007C - 0x007C)
class UGoal_Null : public UPathGoalEvaluator {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[991];

        return pClassPointer;
    };

    void Recycle();
    void GoUntilBust();
};

UClass* UGoal_Null::pClassPointer = NULL;

// Class Engine.SkeletalMeshActor
// 0x0060 (0x02A4 - 0x0244)
class ASkeletalMeshActor : public AActor {
   public:
    DWORD bDamageAppliesImpulse : 1;    // 0x0244 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bShouldDoAnimNotifies : 1;    // 0x0244 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bForceSaveInCheckpoint : 1;   // 0x0244 (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    DWORD bCollideActors_OldValue : 1;  // 0x0244 (0x0004) [0x0000000000000000]
                                        // [0x00000008]
    DWORD bShouldShadowParentAllAttachedActors : 1;  // 0x0244 (0x0004)
                                                     // [0x0000000000000000]
                                                     // [0x00000010]
    class USkeletalMeshComponent*
        SkeletalMeshComponent;  // 0x0248 (0x0008) [0x0000000000000000]
    class ULightEnvironmentComponent*
        LightEnvironment;  // 0x0250 (0x0008) [0x0000000000000000]
    class UAudioComponent*
        FacialAudioComp;  // 0x0258 (0x0008) [0x0000000000000000]
    class USkeletalMesh*
        ReplicatedMesh;  // 0x0260 (0x0008) [0x0000000000150000]              (
                         // CPF_Travel | CPF_GlobalConfig )
    class UMaterialInterface*
        ReplicatedMaterial0;  // 0x0268 (0x0008) [0x0000000000160000] (
                              // CPF_EditConst | CPF_GlobalConfig )
    class UMaterialInterface*
        ReplicatedMaterial1;  // 0x0270 (0x0008) [0x0000000000170000] (
                              // CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
    TArray<struct FSkelMeshActorControlTarget>
        ControlTargets;  // 0x0278 (0x0010) [0x0000000000000000]
    TArray<class UInterpGroup*>
        InterpGroupList;            // 0x0288 (0x0010) [0x0000000000000000]
    struct FName SavedAnimSeqName;  // 0x0298 (0x0008) [0x0000000000000000]
    float SavedCurrentTime;         // 0x02A0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[993];

        return pClassPointer;
    };

    void eventCreateForceField();
    void SkelMeshActorOnParticleSystemFinished();
    void eventPlayParticleEffect();
    void ApplyCheckpointRecord();
    void CreateCheckpointRecord();
    void ShouldSaveForCheckpoint();
    void eventTakeDamage();
    void DoKismetAttachment();
    void eventOnSetSkelControlTarget();
    void eventOnUpdatePhysBonesFromAnim();
    void eventOnSetMesh();
    void IsActorPlayingFaceFXAnim();
    void eventGetActorFaceFXAsset();
    void OnPlayFaceFXAnim();
    void eventGetFaceFXAudioComponent();
    void eventStopActorFaceFXAnim();
    void eventPlayActorFaceFXAnim();
    void MAT_FinishAnimControl();
    void eventFinishAnimControl();
    void eventSetAnimPosition();
    void MAT_BeginAnimControl();
    void eventBeginAnimControl();
    void OnSetMaterial();
    void OnToggle();
    void eventReplicatedEvent();
    void UpdateAnimSetList();
    void eventDestroyed();
    void eventPostBeginPlay();
};

UClass* ASkeletalMeshActor::pClassPointer = NULL;

// Class Engine.SkeletalMeshActorBasedOnExtremeContent
// 0x0020 (0x02C4 - 0x02A4)
class ASkeletalMeshActorBasedOnExtremeContent : public ASkeletalMeshActor {
   public:
    TArray<struct FSkelMaterialSetterDatum>
        ExtremeContent;  // 0x02A4 (0x0010) [0x0000000000000000]
    TArray<struct FSkelMaterialSetterDatum>
        NonExtremeContent;  // 0x02B4 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[995];

        return pClassPointer;
    };

    void SetMaterialBasedOnExtremeContent();
    void eventPostBeginPlay();
};

UClass* ASkeletalMeshActorBasedOnExtremeContent::pClassPointer = NULL;

// Class Engine.SkeletalMeshActorSpawnable
// 0x0000 (0x02A4 - 0x02A4)
class ASkeletalMeshActorSpawnable : public ASkeletalMeshActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[997];

        return pClassPointer;
    };
};

UClass* ASkeletalMeshActorSpawnable::pClassPointer = NULL;

// Class Engine.SkeletalMeshCinematicActor
// 0x0000 (0x02A4 - 0x02A4)
class ASkeletalMeshCinematicActor : public ASkeletalMeshActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[999];

        return pClassPointer;
    };
};

UClass* ASkeletalMeshCinematicActor::pClassPointer = NULL;

// Class Engine.SkeletalMeshActorMAT
// 0x0010 (0x02B4 - 0x02A4)
class ASkeletalMeshActorMAT : public ASkeletalMeshCinematicActor {
   public:
    TArray<class UAnimNodeSlot*>
        SlotNodes;  // 0x02A4 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1001];

        return pClassPointer;
    };

    void eventSetSkelControlScale();
    void eventSetMorphWeight();
    void eventFinishAnimControl();
    void MAT_SetAnimPosition();
    void eventSetAnimPosition();
    void ClearAnimNodes();
    void CacheAnimNodes();
    void eventPostInitAnimTree();
    void eventDestroyed();
    void MAT_SetSkelControlStrength();
    void MAT_SetSkelControlScale();
    void MAT_SetMorphWeight();
    void MAT_SetAnimWeights();
};

UClass* ASkeletalMeshActorMAT::pClassPointer = NULL;

// Class Engine.HeadTrackingComponent
// 0x00BF (0x0144 - 0x0085)
class UHeadTrackingComponent : public UActorComponent {
   public:
    TArray<struct FName>
        TrackControllerName;        // 0x0088 (0x0010) [0x0000000000000000]
    float LookAtActorRadius;        // 0x0098 (0x0004) [0x0000000000000000]
    DWORD bDisableBeyondLimit : 1;  // 0x009C (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    float MaxLookAtTime;            // 0x00A0 (0x0004) [0x0000000000000000]
    float MinLookAtTime;            // 0x00A4 (0x0004) [0x0000000000000000]
    float MaxInterestTime;          // 0x00A8 (0x0004) [0x0000000000000000]
    TArray<class UClass*>
        ActorClassesToLookAt;  // 0x00AC (0x0010) [0x0000000000000000]
    TArray<struct FName>
        TargetBoneNames;  // 0x00BC (0x0010) [0x0000000000000000]
    unsigned char
        UnknownData00[0x48];  // 0x00CC (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.HeadTrackingComponent.CurrentActorMap
    class USkeletalMeshComponent*
        SkeletalMeshComp;  // 0x0114 (0x0008) [0x0000000000000000]
    TArray<class USkelControlLookAt*>
        TrackControls;                 // 0x011C (0x0010) [0x0000000000000000]
    struct FVector RootMeshLocation;   // 0x012C (0x000C) [0x0000000000000000]
    struct FRotator RootMeshRotation;  // 0x0138 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1003];

        return pClassPointer;
    };
};

UClass* UHeadTrackingComponent::pClassPointer = NULL;

// Class Engine.AnimationCompressionAlgorithm
// 0x0016 (0x0076 - 0x0060)
class UAnimationCompressionAlgorithm : public UObject {
   public:
    struct FString Description;  // 0x0060 (0x0010) [0x0000000000000000]
    DWORD bNeedsSkeleton : 1;    // 0x0070 (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    unsigned char
        TranslationCompressionFormat;  // 0x0074 (0x0001) [0x0000000000000000]
    unsigned char
        RotationCompressionFormat;  // 0x0075 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1005];

        return pClassPointer;
    };
};

UClass* UAnimationCompressionAlgorithm::pClassPointer = NULL;

// Class Engine.AnimationCompressionAlgorithm_Automatic
// 0x000A (0x0080 - 0x0076)
class UAnimationCompressionAlgorithm_Automatic
    : public UAnimationCompressionAlgorithm {
   public:
    float MaxEndEffectorError;  // 0x0078 (0x0004) [0x0000000000000000]
    DWORD bTryFixedBitwiseCompression : 1;  // 0x007C (0x0004)
                                            // [0x0000000000000000] [0x00000001]
    DWORD bTryPerTrackBitwiseCompression : 1;   // 0x007C (0x0004)
                                                // [0x0000000000000000]
                                                // [0x00000002]
    DWORD bTryLinearKeyRemovalCompression : 1;  // 0x007C (0x0004)
                                                // [0x0000000000000000]
                                                // [0x00000004]
    DWORD bTryIntervalKeyRemoval : 1;  // 0x007C (0x0004) [0x0000000000000000]
                                       // [0x00000008]
    DWORD
        bRunCurrentDefaultCompressor : 1;  // 0x007C (0x0004)
                                           // [0x0000000000000000] [0x00000010]
    DWORD bAutoReplaceIfExistingErrorTooGreat : 1;  // 0x007C (0x0004)
                                                    // [0x0000000000000000]
                                                    // [0x00000020]
    DWORD bRaiseMaxErrorToExisting : 1;  // 0x007C (0x0004) [0x0000000000000000]
                                         // [0x00000040]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1007];

        return pClassPointer;
    };
};

UClass* UAnimationCompressionAlgorithm_Automatic::pClassPointer = NULL;

// Class Engine.AnimationCompressionAlgorithm_BitwiseCompressOnly
// 0x0002 (0x0078 - 0x0076)
class UAnimationCompressionAlgorithm_BitwiseCompressOnly
    : public UAnimationCompressionAlgorithm {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1009];

        return pClassPointer;
    };
};

UClass* UAnimationCompressionAlgorithm_BitwiseCompressOnly::pClassPointer =
    NULL;

// Class Engine.AnimationCompressionAlgorithm_LeastDestructive
// 0x0002 (0x0078 - 0x0076)
class UAnimationCompressionAlgorithm_LeastDestructive
    : public UAnimationCompressionAlgorithm {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1011];

        return pClassPointer;
    };
};

UClass* UAnimationCompressionAlgorithm_LeastDestructive::pClassPointer = NULL;

// Class Engine.AnimationCompressionAlgorithm_RemoveEverySecondKey
// 0x000A (0x0080 - 0x0076)
class UAnimationCompressionAlgorithm_RemoveEverySecondKey
    : public UAnimationCompressionAlgorithm {
   public:
    int MinKeys;                  // 0x0078 (0x0004) [0x0000000000000000]
    DWORD bStartAtSecondKey : 1;  // 0x007C (0x0004) [0x0000000000000000]
                                  // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1013];

        return pClassPointer;
    };
};

UClass* UAnimationCompressionAlgorithm_RemoveEverySecondKey::pClassPointer =
    NULL;

// Class Engine.AnimationCompressionAlgorithm_RemoveLinearKeys
// 0x001E (0x0094 - 0x0076)
class UAnimationCompressionAlgorithm_RemoveLinearKeys
    : public UAnimationCompressionAlgorithm {
   public:
    float MaxPosDiff;          // 0x0078 (0x0004) [0x0000000000000000]
    float MaxAngleDiff;        // 0x007C (0x0004) [0x0000000000000000]
    float MaxEffectorDiff;     // 0x0080 (0x0004) [0x0000000000000000]
    float MinEffectorDiff;     // 0x0084 (0x0004) [0x0000000000000000]
    float EffectorDiffSocket;  // 0x0088 (0x0004) [0x0000000000000000]
    float ParentKeyScale;      // 0x008C (0x0004) [0x0000000000000000]
    DWORD bRetarget : 1;  // 0x0090 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bActuallyFilterLinearKeys : 1;  // 0x0090 (0x0004)
                                          // [0x0000000000000000] [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1015];

        return pClassPointer;
    };
};

UClass* UAnimationCompressionAlgorithm_RemoveLinearKeys::pClassPointer = NULL;

// Class Engine.AnimationCompressionAlgorithm_PerTrackCompression
// 0x005C (0x00F0 - 0x0094)
class UAnimationCompressionAlgorithm_PerTrackCompression
    : public UAnimationCompressionAlgorithm_RemoveLinearKeys {
   public:
    float MaxZeroingThreshold;  // 0x0094 (0x0004) [0x0000000000000000]
    float MaxPosDiffBitwise;    // 0x0098 (0x0004) [0x0000000000000000]
    float MaxAngleDiffBitwise;  // 0x009C (0x0004) [0x0000000000000000]
    TArray<unsigned char>
        AllowedRotationFormats;  // 0x00A0 (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        AllowedTranslationFormats;  // 0x00B0 (0x0010) [0x0000000000000000]
    DWORD bResampleAnimation : 1;   // 0x00C0 (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    DWORD bUseAdaptiveError : 1;    // 0x00C0 (0x0004) [0x0000000000000000]
                                    // [0x00000002]
    DWORD bUseOverrideForEndEffectors : 1;  // 0x00C0 (0x0004)
                                            // [0x0000000000000000] [0x00000004]
    DWORD bUseAdaptiveError2 : 1;       // 0x00C0 (0x0004) [0x0000000000000000]
                                        // [0x00000008]
    float ResampledFramerate;           // 0x00C4 (0x0004) [0x0000000000000000]
    int MinKeysForResampling;           // 0x00C8 (0x0004) [0x0000000000000000]
    int TrackHeightBias;                // 0x00CC (0x0004) [0x0000000000000000]
    float ParentingDivisor;             // 0x00D0 (0x0004) [0x0000000000000000]
    float ParentingDivisorExponent;     // 0x00D4 (0x0004) [0x0000000000000000]
    float RotationErrorSourceRatio;     // 0x00D8 (0x0004) [0x0000000000000000]
    float TranslationErrorSourceRatio;  // 0x00DC (0x0004) [0x0000000000000000]
    float MaxErrorPerTrackRatio;        // 0x00E0 (0x0004) [0x0000000000000000]
    float PerturbationProbeSize;        // 0x00E4 (0x0004) [0x0000000000000000]
    struct FPointer
        PerReductionCachedData;  // 0x00E8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1017];

        return pClassPointer;
    };
};

UClass* UAnimationCompressionAlgorithm_PerTrackCompression::pClassPointer =
    NULL;

// Class Engine.AnimationCompressionAlgorithm_RemoveTrivialKeys
// 0x000A (0x0080 - 0x0076)
class UAnimationCompressionAlgorithm_RemoveTrivialKeys
    : public UAnimationCompressionAlgorithm {
   public:
    float MaxPosDiff;    // 0x0078 (0x0004) [0x0000000000000000]
    float MaxAngleDiff;  // 0x007C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1019];

        return pClassPointer;
    };
};

UClass* UAnimationCompressionAlgorithm_RemoveTrivialKeys::pClassPointer = NULL;

// Class Engine.AnimationCompressionAlgorithm_RevertToRaw
// 0x0002 (0x0078 - 0x0076)
class UAnimationCompressionAlgorithm_RevertToRaw
    : public UAnimationCompressionAlgorithm {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1021];

        return pClassPointer;
    };
};

UClass* UAnimationCompressionAlgorithm_RevertToRaw::pClassPointer = NULL;

// Class Engine.AnimMetaData
// 0x0000 (0x0060 - 0x0060)
class UAnimMetaData : public UObject {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1023];

        return pClassPointer;
    };
};

UClass* UAnimMetaData::pClassPointer = NULL;

// Class Engine.AnimMetaData_SkelControl
// 0x001C (0x007C - 0x0060)
class UAnimMetaData_SkelControl : public UAnimMetaData {
   public:
    TArray<struct FName>
        SkelControlNameList;  // 0x0060 (0x0010) [0x0000000000000000]
    DWORD bFullControlOverController : 1;  // 0x0070 (0x0004)
                                           // [0x0000000000000000] [0x00000001]
    struct FName SkelControlName;  // 0x0074 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1025];

        return pClassPointer;
    };
};

UClass* UAnimMetaData_SkelControl::pClassPointer = NULL;

// Class Engine.AnimMetaData_SkelControlKeyFrame
// 0x0010 (0x008C - 0x007C)
class UAnimMetaData_SkelControlKeyFrame : public UAnimMetaData_SkelControl {
   public:
    TArray<struct FTimeModifier>
        KeyFrames;  // 0x007C (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1027];

        return pClassPointer;
    };
};

UClass* UAnimMetaData_SkelControlKeyFrame::pClassPointer = NULL;

// Class Engine.AnimNotify
// 0x0004 (0x0064 - 0x0060)
class UAnimNotify : public UObject {
   public:
    struct FColor NotifyColor;  // 0x0060 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1029];

        return pClassPointer;
    };

    void FindNextNotifyOfClass();
};

UClass* UAnimNotify::pClassPointer = NULL;

// Class Engine.AnimNotify_AkEvent
// 0x0018 (0x007C - 0x0064)
class UAnimNotify_AkEvent : public UAnimNotify {
   public:
    class UAkEvent* AkEvent;  // 0x0064 (0x0008) [0x0000000000000000]
    DWORD
        bFollowActor : 1;  // 0x006C (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bIgnoreIfActorHidden : 1;  // 0x006C (0x0004) [0x0000000000000000]
                                     // [0x00000002]
    DWORD bIgnoreIfActorDead : 1;    // 0x006C (0x0004) [0x0000000000000000]
                                     // [0x00000004]
    struct FName BoneName;           // 0x0070 (0x0008) [0x0000000000000000]
    float PercentToPlay;             // 0x0078 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1031];

        return pClassPointer;
    };
};

UClass* UAnimNotify_AkEvent::pClassPointer = NULL;

// Class Engine.AnimNotify_CameraEffect
// 0x0008 (0x006C - 0x0064)
class UAnimNotify_CameraEffect : public UAnimNotify {
   public:
    class UClass* CameraLensEffect;  // 0x0064 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1033];

        return pClassPointer;
    };
};

UClass* UAnimNotify_CameraEffect::pClassPointer = NULL;

// Class Engine.AnimNotify_ClothingMaxDistanceScale
// 0x0010 (0x0074 - 0x0064)
class UAnimNotify_ClothingMaxDistanceScale : public UAnimNotify {
   public:
    float StartScale;         // 0x0064 (0x0004) [0x0000000000000000]
    float EndScale;           // 0x0068 (0x0004) [0x0000000000000000]
    unsigned char ScaleMode;  // 0x006C (0x0001) [0x0000000000000000]
    float Duration;           // 0x0070 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1035];

        return pClassPointer;
    };
};

UClass* UAnimNotify_ClothingMaxDistanceScale::pClassPointer = NULL;

// Class Engine.AnimNotify_Footstep
// 0x0004 (0x0068 - 0x0064)
class UAnimNotify_Footstep : public UAnimNotify {
   public:
    int FootDown;  // 0x0064 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1037];

        return pClassPointer;
    };
};

UClass* UAnimNotify_Footstep::pClassPointer = NULL;

// Class Engine.AnimNotify_ForceField
// 0x001C (0x0080 - 0x0064)
class UAnimNotify_ForceField : public UAnimNotify {
   public:
    class UNxForceFieldComponent*
        ForceFieldComponent;  // 0x0064 (0x0008) [0x0000000000000000]
    DWORD bAttach : 1;  // 0x006C (0x0004) [0x0000000000000000] [0x00000001]
    struct FName SocketName;  // 0x0070 (0x0008) [0x0000000000000000]
    struct FName BoneName;    // 0x0078 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1039];

        return pClassPointer;
    };
};

UClass* UAnimNotify_ForceField::pClassPointer = NULL;

// Class Engine.AnimNotify_Kismet
// 0x0008 (0x006C - 0x0064)
class UAnimNotify_Kismet : public UAnimNotify {
   public:
    struct FName NotifyName;  // 0x0064 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1041];

        return pClassPointer;
    };
};

UClass* UAnimNotify_Kismet::pClassPointer = NULL;

// Class Engine.AnimNotify_PlayParticleEffect
// 0x002C (0x0090 - 0x0064)
class UAnimNotify_PlayParticleEffect : public UAnimNotify {
   public:
    class UParticleSystem* PSTemplate;  // 0x0064 (0x0008) [0x0000000000000000]
    DWORD bIsExtremeContent : 1;        // 0x006C (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bAttach : 1;   // 0x006C (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bPreview : 1;  // 0x006C (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bSkipIfOwnerIsHidden : 1;  // 0x006C (0x0004) [0x0000000000000000]
                                     // [0x00000008]
    class UParticleSystem*
        PSNonExtremeContentTemplate;  // 0x0070 (0x0008) [0x0000000000000000]
    struct FName SocketName;          // 0x0078 (0x0008) [0x0000000000000000]
    struct FName BoneName;            // 0x0080 (0x0008) [0x0000000000000000]
    struct FName
        BoneSocketModuleActorName;  // 0x0088 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1043];

        return pClassPointer;
    };
};

UClass* UAnimNotify_PlayParticleEffect::pClassPointer = NULL;

// Class Engine.AnimNotify_Rumble
// 0x0018 (0x007C - 0x0064)
class UAnimNotify_Rumble : public UAnimNotify {
   public:
    class UClass* PredefinedWaveForm;  // 0x0064 (0x0008) [0x0000000000000000]
    class UForceFeedbackWaveform*
        WaveForm;                    // 0x006C (0x0008) [0x0000000000000000]
    DWORD bCheckForBasedPlayer : 1;  // 0x0074 (0x0004) [0x0000000000000000]
                                     // [0x00000001]
    float EffectRadius;              // 0x0078 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1045];

        return pClassPointer;
    };
};

UClass* UAnimNotify_Rumble::pClassPointer = NULL;

// Class Engine.AnimNotify_Script
// 0x0018 (0x007C - 0x0064)
class UAnimNotify_Script : public UAnimNotify {
   public:
    struct FName NotifyName;      // 0x0064 (0x0008) [0x0000000000000000]
    struct FName NotifyTickName;  // 0x006C (0x0008) [0x0000000000000000]
    struct FName NotifyEndName;   // 0x0074 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1047];

        return pClassPointer;
    };
};

UClass* UAnimNotify_Script::pClassPointer = NULL;

// Class Engine.AnimNotify_Scripted
// 0x0000 (0x0064 - 0x0064)
class UAnimNotify_Scripted : public UAnimNotify {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1049];

        return pClassPointer;
    };

    void eventNotifyEnd();
    void eventNotify();
};

UClass* UAnimNotify_Scripted::pClassPointer = NULL;

// Class Engine.AnimNotify_PawnMaterialParam
// 0x0010 (0x0074 - 0x0064)
class UAnimNotify_PawnMaterialParam : public UAnimNotify_Scripted {
   public:
    TArray<struct FScalarParameterInterpStruct>
        ScalarParameterInterpArray;  // 0x0064 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1051];

        return pClassPointer;
    };

    void eventNotify();
};

UClass* UAnimNotify_PawnMaterialParam::pClassPointer = NULL;

// Class Engine.AnimNotify_ViewShake
// 0x0054 (0x00B8 - 0x0064)
class UAnimNotify_ViewShake : public UAnimNotify_Scripted {
   public:
    float Duration;                    // 0x0064 (0x0004) [0x0000000000000000]
    struct FVector RotAmplitude;       // 0x0068 (0x000C) [0x0000000000000000]
    struct FVector RotFrequency;       // 0x0074 (0x000C) [0x0000000000000000]
    struct FVector LocAmplitude;       // 0x0080 (0x000C) [0x0000000000000000]
    struct FVector LocFrequency;       // 0x008C (0x000C) [0x0000000000000000]
    float FOVAmplitude;                // 0x0098 (0x0004) [0x0000000000000000]
    float FOVFrequency;                // 0x009C (0x0004) [0x0000000000000000]
    DWORD bDoControllerVibration : 1;  // 0x00A0 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bUseBoneLocation : 1;        // 0x00A0 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    float ShakeRadius;                 // 0x00A4 (0x0004) [0x0000000000000000]
    struct FName BoneName;             // 0x00A8 (0x0008) [0x0000000000000000]
    class UCameraShake* ShakeParams;   // 0x00B0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1053];

        return pClassPointer;
    };

    void eventNotify();
};

UClass* UAnimNotify_ViewShake::pClassPointer = NULL;

// Class Engine.AnimNotify_Sound
// 0x0020 (0x0084 - 0x0064)
class UAnimNotify_Sound : public UAnimNotify {
   public:
    class USoundCue* SoundCue;  // 0x0064 (0x0008) [0x0000000000000000]
    DWORD
        bFollowActor : 1;  // 0x006C (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bIgnoreIfActorHidden : 1;  // 0x006C (0x0004) [0x0000000000000000]
                                     // [0x00000002]
    struct FName BoneName;           // 0x0070 (0x0008) [0x0000000000000000]
    float PercentToPlay;             // 0x0078 (0x0004) [0x0000000000000000]
    float VolumeMultiplier;          // 0x007C (0x0004) [0x0000000000000000]
    float PitchMultiplier;           // 0x0080 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1055];

        return pClassPointer;
    };
};

UClass* UAnimNotify_Sound::pClassPointer = NULL;

// Class Engine.AnimNotify_Trails
// 0x006C (0x00D0 - 0x0064)
class UAnimNotify_Trails : public UAnimNotify {
   public:
    class UParticleSystem* PSTemplate;  // 0x0064 (0x0008) [0x0000000000000000]
    class USkeletalMesh*
        SampledSkeletalMesh;      // 0x006C (0x0008) [0x0000000000000000]
    DWORD bIsExtremeContent : 1;  // 0x0074 (0x0004) [0x0000000000000000]
                                  // [0x00000001]
    DWORD bPreview : 1;  // 0x0074 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bPreviewForceExplicit : 1;   // 0x0074 (0x0004) [0x0000000000000000]
                                       // [0x00000004]
    DWORD bSkipIfOwnerIsHidden : 1;    // 0x0074 (0x0004) [0x0000000000000000]
                                       // [0x00000008]
    DWORD bResampleRequired : 1;       // 0x0074 (0x0004) [0x0000000000000000]
                                       // [0x00000010]
    struct FName FirstEdgeSocketName;  // 0x0078 (0x0008) [0x0000000000000000]
    struct FName
        ControlPointSocketName;         // 0x0080 (0x0008) [0x0000000000000000]
    struct FName SecondEdgeSocketName;  // 0x0088 (0x0008) [0x0000000000000000]
    float LastStartTime;                // 0x0090 (0x0004) [0x0000000000000000]
    float EndTime;                      // 0x0094 (0x0004) [0x0000000000000000]
    float SampleTimeStep;               // 0x0098 (0x0004) [0x0000000000000000]
    TArray<struct FTrailSamplePoint>
        TrailSampleData;     // 0x009C (0x0010) [0x0000000000000000]
    float SamplesPerSecond;  // 0x00AC (0x0004) [0x0000000000000000]
    TArray<struct FTrailSample>
        TrailSampledData;  // 0x00B0 (0x0010) [0x0000000000000000]
    float CurrentTime;     // 0x00C0 (0x0004) [0x0000000000000000]
    float TimeStep;        // 0x00C4 (0x0004) [0x0000000000000000]
    class UAnimNodeSequence*
        AnimNodeSeq;  // 0x00C8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1057];

        return pClassPointer;
    };

    void GetNumSteps();
};

UClass* UAnimNotify_Trails::pClassPointer = NULL;

// Class Engine.AnimObject
// 0x002C (0x008C - 0x0060)
class UAnimObject : public UObject {
   public:
    int DrawWidth;                // 0x0060 (0x0004) [0x0000000000000000]
    int DrawHeight;               // 0x0064 (0x0004) [0x0000000000000000]
    int NodePosX;                 // 0x0068 (0x0004) [0x0000000000000000]
    int NodePosY;                 // 0x006C (0x0004) [0x0000000000000000]
    int OutDrawY;                 // 0x0070 (0x0004) [0x0000000000000000]
    struct FString CategoryDesc;  // 0x0074 (0x0010) [0x0000000000000000]
    class USkeletalMeshComponent*
        SkelComponent;  // 0x0084 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1059];

        return pClassPointer;
    };
};

UClass* UAnimObject::pClassPointer = NULL;

// Class Engine.AnimNode
// 0x009C (0x0128 - 0x008C)
class UAnimNode : public UAnimObject {
   public:
    DWORD bRelevant : 1;  // 0x008C (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bJustBecameRelevant : 1;     // 0x008C (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD bTickDuringPausedAnims : 1;  // 0x008C (0x0004) [0x0000000000000000]
                                       // [0x00000004]
    DWORD bEditorOnly : 1;  // 0x008C (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bDisableCaching : 1;         // 0x008C (0x0004) [0x0000000000000000]
                                       // [0x00000010]
    DWORD bCallScriptEventOnInit : 1;  // 0x008C (0x0004) [0x0000000000000000]
                                       // [0x00000020]
    DWORD bCallScriptEventOnBecomeRelevant : 1;  // 0x008C (0x0004)
                                                 // [0x0000000000000000]
                                                 // [0x00000040]
    DWORD bCallScriptEventOnCeaseRelevant : 1;   // 0x008C (0x0004)
                                                 // [0x0000000000000000]
                                                 // [0x00000080]
    int NodeTickTag;         // 0x0090 (0x0004) [0x0000000000000000]
    int NodeInitTag;         // 0x0094 (0x0004) [0x0000000000000000]
    int NodeEndEventTick;    // 0x0098 (0x0004) [0x0000000000000000]
    int TickArrayIndex;      // 0x009C (0x0004) [0x0000000000000000]
    int NodeCachedAtomsTag;  // 0x00A0 (0x0004) [0x0000000000000000]
    float NodeTotalWeight;   // 0x00A4 (0x0004) [0x0000000000000000]
    TArray<class UAnimNodeBlendBase*>
        ParentNodes;        // 0x00A8 (0x0010) [0x0000000000000000]
    struct FName NodeName;  // 0x00B8 (0x0008) [0x0000000000000000]
    TArray<struct FBoneAtom>
        CachedBoneAtoms;  // 0x00C0 (0x0010) [0x0000000000000000]
    unsigned char
        CachedNumDesiredBones;         // 0x00D0 (0x0001) [0x0000000000000000]
    unsigned char UnknownData00[0xF];  // 0x00D1 (0x000F) MISSED OFFSET
    struct FBoneAtom
        CachedRootMotionDelta;  // 0x00E0 (0x0020) [0x0000000000000000]
    int bCachedHasRootMotion;   // 0x0100 (0x0004) [0x0000000000000000]
    TArray<struct FCurveKey>
        CachedCurveKeys;  // 0x0104 (0x0010) [0x0000000000000000]
    int SearchTag;        // 0x0114 (0x0004) [0x0000000000000000]
    TArray<struct FCurveKey>
        LastUpdatedAnimMorphKeys;  // 0x0118 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1061];

        return pClassPointer;
    };

    void ReplayAnim();
    void StopAnim();
    void PlayAnim();
    void FindAnimNode();
    void eventOnCeaseRelevant();
    void eventOnBecomeRelevant();
    void eventOnInit();
};

UClass* UAnimNode::pClassPointer = NULL;

// Class Engine.AnimNodeBlendBase
// 0x0015 (0x013D - 0x0128)
class UAnimNodeBlendBase : public UAnimNode {
   public:
    TArray<struct FAnimBlendChild>
        Children;               // 0x0128 (0x0010) [0x0000000000000000]
    DWORD bFixNumChildren : 1;  // 0x0138 (0x0004) [0x0000000000000000]
                                // [0x00000001]
    unsigned char BlendType;    // 0x013C (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1063];

        return pClassPointer;
    };

    void ReplayAnim();
    void StopAnim();
    void PlayAnim();
};

UClass* UAnimNodeBlendBase::pClassPointer = NULL;

// Class Engine.AnimNode_MultiBlendPerBone
// 0x001C (0x0159 - 0x013D)
class UAnimNode_MultiBlendPerBone : public UAnimNodeBlendBase {
   public:
    class APawn* PawnOwner;  // 0x0140 (0x0008) [0x0000000000000000]
    TArray<struct FPerBoneMaskInfo>
        MaskList;                     // 0x0148 (0x0010) [0x0000000000000000]
    unsigned char RotationBlendType;  // 0x0158 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1065];

        return pClassPointer;
    };

    void SetMaskWeight();
};

UClass* UAnimNode_MultiBlendPerBone::pClassPointer = NULL;

// Class Engine.AnimNodeAimOffset
// 0x005B (0x0198 - 0x013D)
class UAnimNodeAimOffset : public UAnimNodeBlendBase {
   public:
    struct FVector2D Aim;          // 0x0140 (0x0008) [0x0000000000000000]
    struct FVector2D AngleOffset;  // 0x0148 (0x0008) [0x0000000000000000]
    DWORD
        bForceAimDir : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bBakeFromAnimations : 1;  // 0x0150 (0x0004) [0x0000000000000000]
                                    // [0x00000002]
    DWORD bPassThroughWhenNotRendered : 1;  // 0x0150 (0x0004)
                                            // [0x0000000000000000] [0x00000004]
    DWORD bSynchronizeNodesInEditor : 1;    // 0x0150 (0x0004)
                                            // [0x0000000000000000] [0x00000008]
    int PassThroughAtOrAboveLOD;  // 0x0154 (0x0004) [0x0000000000000000]
    unsigned char ForcedAimDir;   // 0x0158 (0x0001) [0x0000000000000000]
    TArray<unsigned char>
        RequiredBones;  // 0x015C (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        AimCpntIndexLUT;  // 0x016C (0x0010) [0x0000000000000000]
    class UAnimNodeAimOffset*
        TemplateNode;  // 0x017C (0x0008) [0x0000000000000000]
    TArray<struct FAimOffsetProfile>
        Profiles;             // 0x0184 (0x0010) [0x0000000000000000]
    int CurrentProfileIndex;  // 0x0194 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1067];

        return pClassPointer;
    };

    void SetActiveProfileByIndex();
    void SetActiveProfileByName();
};

UClass* UAnimNodeAimOffset::pClassPointer = NULL;

// Class Engine.AnimNodeBlend
// 0x0013 (0x0150 - 0x013D)
class UAnimNodeBlend : public UAnimNodeBlendBase {
   public:
    float Child2Weight;        // 0x0140 (0x0004) [0x0000000000000000]
    float Child2WeightTarget;  // 0x0144 (0x0004) [0x0000000000000000]
    float BlendTimeToGo;       // 0x0148 (0x0004) [0x0000000000000000]
    DWORD bSkipBlendWhenNotRendered : 1;  // 0x014C (0x0004)
                                          // [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1069];

        return pClassPointer;
    };

    void SetBlendTarget();
};

UClass* UAnimNodeBlend::pClassPointer = NULL;

// Class Engine.AnimNodeAdditiveBlending
// 0x0004 (0x0154 - 0x0150)
class UAnimNodeAdditiveBlending : public UAnimNodeBlend {
   public:
    DWORD bPassThroughWhenNotRendered : 1;  // 0x0150 (0x0004)
                                            // [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1071];

        return pClassPointer;
    };

    void SetBlendTarget();
};

UClass* UAnimNodeAdditiveBlending::pClassPointer = NULL;

// Class Engine.AnimNodeBlendPerBone
// 0x0034 (0x0184 - 0x0150)
class UAnimNodeBlendPerBone : public UAnimNodeBlend {
   public:
    DWORD bForceLocalSpaceBlend : 1;  // 0x0150 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    TArray<struct FName>
        BranchStartBoneName;            // 0x0154 (0x0010) [0x0000000000000000]
    TArray<float> Child2PerBoneWeight;  // 0x0164 (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        LocalToCompReqBones;  // 0x0174 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1073];

        return pClassPointer;
    };

    void SetBlendTarget();
};

UClass* UAnimNodeBlendPerBone::pClassPointer = NULL;

// Class Engine.AnimNodeCrossfader
// 0x0010 (0x0160 - 0x0150)
class UAnimNodeCrossfader : public UAnimNodeBlend {
   public:
    struct FName DefaultAnimSeqName;   // 0x0150 (0x0008) [0x0000000000000000]
    DWORD bDontBlendOutOneShot : 1;    // 0x0158 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    float PendingBlendOutTimeOneShot;  // 0x015C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1075];

        return pClassPointer;
    };

    void GetActiveChild();
    void GetAnimName();
    void BlendToLoopingAnim();
    void PlayOneShotAnim();
};

UClass* UAnimNodeCrossfader::pClassPointer = NULL;

// Class Engine.AnimNodePlayCustomAnim
// 0x0008 (0x0158 - 0x0150)
class UAnimNodePlayCustomAnim : public UAnimNodeBlend {
   public:
    DWORD bIsPlayingCustomAnim : 1;   // 0x0150 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    float CustomPendingBlendOutTime;  // 0x0154 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1077];

        return pClassPointer;
    };

    void SetRootBoneAxisOption();
    void GetCustomAnimNodeSeq();
    void SetActorAnimEndNotification();
    void SetCustomAnim();
    void StopCustomAnim();
    void PlayCustomAnimByDuration();
    void PlayCustomAnim();
};

UClass* UAnimNodePlayCustomAnim::pClassPointer = NULL;

// Class Engine.AnimNodeBlendDirectional
// 0x001F (0x015C - 0x013D)
class UAnimNodeBlendDirectional : public UAnimNodeBlendBase {
   public:
    float DirDegreesPerSecond;       // 0x0140 (0x0004) [0x0000000000000000]
    float DirAngle;                  // 0x0144 (0x0004) [0x0000000000000000]
    int SingleAnimAtOrAboveLOD;      // 0x0148 (0x0004) [0x0000000000000000]
    struct FRotator RotationOffset;  // 0x014C (0x000C) [0x0000000000000000]
    DWORD bUseAcceleration : 1;      // 0x0158 (0x0004) [0x0000000000000000]
                                     // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1079];

        return pClassPointer;
    };
};

UClass* UAnimNodeBlendDirectional::pClassPointer = NULL;

// Class Engine.AnimNodeBlendList
// 0x0027 (0x0164 - 0x013D)
class UAnimNodeBlendList : public UAnimNodeBlendBase {
   public:
    TArray<float> TargetWeight;  // 0x0140 (0x0010) [0x0000000000000000]
    float BlendTimeToGo;         // 0x0150 (0x0004) [0x0000000000000000]
    int ActiveChildIndex;        // 0x0154 (0x0004) [0x0000000000000000]
    DWORD bPlayActiveChild : 1;  // 0x0158 (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    DWORD bForceChildFullWeightWhenBecomingRelevant : 1;  // 0x0158 (0x0004)
                                                          // [0x0000000000000000]
                                                          // [0x00000002]
    DWORD bSkipBlendWhenNotRendered : 1;  // 0x0158 (0x0004)
                                          // [0x0000000000000000] [0x00000004]
    float SliderPosition;        // 0x015C (0x0004) [0x0000000000000000]
    int EditorActiveChildIndex;  // 0x0160 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1081];

        return pClassPointer;
    };

    void SetActiveChild();
};

UClass* UAnimNodeBlendList::pClassPointer = NULL;

// Class Engine.AnimNodeBlendByBase
// 0x0020 (0x0184 - 0x0164)
class UAnimNodeBlendByBase : public UAnimNodeBlendList {
   public:
    unsigned char Type;        // 0x0164 (0x0001) [0x0000000000000000]
    struct FName ActorTag;     // 0x0168 (0x0008) [0x0000000000000000]
    class UClass* ActorClass;  // 0x0170 (0x0008) [0x0000000000000000]
    float BlendTime;           // 0x0178 (0x0004) [0x0000000000000000]
    class AActor* CachedBase;  // 0x017C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1083];

        return pClassPointer;
    };
};

UClass* UAnimNodeBlendByBase::pClassPointer = NULL;

// Class Engine.AnimNodeBlendByPhysics
// 0x0000 (0x0164 - 0x0164)
class UAnimNodeBlendByPhysics : public UAnimNodeBlendList {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1085];

        return pClassPointer;
    };
};

UClass* UAnimNodeBlendByPhysics::pClassPointer = NULL;

// Class Engine.AnimNodeBlendByPosture
// 0x0000 (0x0164 - 0x0164)
class UAnimNodeBlendByPosture : public UAnimNodeBlendList {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1087];

        return pClassPointer;
    };
};

UClass* UAnimNodeBlendByPosture::pClassPointer = NULL;

// Class Engine.AnimNodeBlendByProperty
// 0x0048 (0x01AC - 0x0164)
class UAnimNodeBlendByProperty : public UAnimNodeBlendList {
   public:
    struct FName PropertyName;  // 0x0164 (0x0008) [0x0000000000000000]
    DWORD bUseOwnersBase : 1;   // 0x016C (0x0004) [0x0000000000000000]
                                // [0x00000001]
    DWORD
        bForceUpdate : 1;  // 0x016C (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bUseSpecificBlendTimes : 1;  // 0x016C (0x0004) [0x0000000000000000]
                                       // [0x00000004]
    DWORD bSynchronizeNodesInEditor : 1;  // 0x016C (0x0004)
                                          // [0x0000000000000000] [0x00000008]
    struct FName CachedPropertyName;  // 0x0170 (0x0008) [0x0000000000000000]
    struct FPointer
        CachedFloatProperty;             // 0x0178 (0x0008) [0x0000000000000000]
    struct FPointer CachedBoolProperty;  // 0x0180 (0x0008) [0x0000000000000000]
    struct FPointer CachedByteProperty;  // 0x0188 (0x0008) [0x0000000000000000]
    class AActor* CachedOwner;           // 0x0190 (0x0008) [0x0000000000000000]
    float BlendTime;                     // 0x0198 (0x0004) [0x0000000000000000]
    float FloatPropMin;                  // 0x019C (0x0004) [0x0000000000000000]
    float FloatPropMax;                  // 0x01A0 (0x0004) [0x0000000000000000]
    float BlendToChild1Time;             // 0x01A4 (0x0004) [0x0000000000000000]
    float BlendToChild2Time;             // 0x01A8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1089];

        return pClassPointer;
    };
};

UClass* UAnimNodeBlendByProperty::pClassPointer = NULL;

// Class Engine.AnimNodeBlendBySpeed
// 0x0034 (0x0198 - 0x0164)
class UAnimNodeBlendBySpeed : public UAnimNodeBlendList {
   public:
    float Speed;                 // 0x0164 (0x0004) [0x0000000000000000]
    int LastChannel;             // 0x0168 (0x0004) [0x0000000000000000]
    float BlendUpTime;           // 0x016C (0x0004) [0x0000000000000000]
    float BlendDownTime;         // 0x0170 (0x0004) [0x0000000000000000]
    float BlendDownPerc;         // 0x0174 (0x0004) [0x0000000000000000]
    TArray<float> Constraints;   // 0x0178 (0x0010) [0x0000000000000000]
    DWORD bUseAcceleration : 1;  // 0x0188 (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    float BlendUpDelay;          // 0x018C (0x0004) [0x0000000000000000]
    float BlendDownDelay;        // 0x0190 (0x0004) [0x0000000000000000]
    float BlendDelayRemaining;   // 0x0194 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1091];

        return pClassPointer;
    };
};

UClass* UAnimNodeBlendBySpeed::pClassPointer = NULL;

// Class Engine.AnimNodeRandom
// 0x0020 (0x0184 - 0x0164)
class UAnimNodeRandom : public UAnimNodeBlendList {
   public:
    TArray<struct FRandomAnimInfo>
        RandomInfo;  // 0x0164 (0x0010) [0x0000000000000000]
    class UAnimNodeSequence*
        PlayingSeqNode;                  // 0x0174 (0x0008) [0x0000000000000000]
    int PendingChildIndex;               // 0x017C (0x0004) [0x0000000000000000]
    DWORD bPickedPendingChildIndex : 1;  // 0x0180 (0x0004) [0x0000000000000000]
                                         // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1093];

        return pClassPointer;
    };
};

UClass* UAnimNodeRandom::pClassPointer = NULL;

// Class Engine.AnimNodeBlendMultiBone
// 0x0023 (0x0160 - 0x013D)
class UAnimNodeBlendMultiBone : public UAnimNodeBlendBase {
   public:
    TArray<struct FChildBoneBlendInfo>
        BlendTargetList;  // 0x0140 (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        SourceRequiredBones;  // 0x0150 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1095];

        return pClassPointer;
    };

    void SetTargetStartBone();
};

UClass* UAnimNodeBlendMultiBone::pClassPointer = NULL;

// Class Engine.AnimNodeMirror
// 0x0007 (0x0144 - 0x013D)
class UAnimNodeMirror : public UAnimNodeBlendBase {
   public:
    DWORD bEnableMirroring : 1;  // 0x0140 (0x0004) [0x0000000000000000]
                                 // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1097];

        return pClassPointer;
    };
};

UClass* UAnimNodeMirror::pClassPointer = NULL;

// Class Engine.AnimNodeScalePlayRate
// 0x0007 (0x0144 - 0x013D)
class UAnimNodeScalePlayRate : public UAnimNodeBlendBase {
   public:
    float ScaleByValue;  // 0x0140 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1099];

        return pClassPointer;
    };
};

UClass* UAnimNodeScalePlayRate::pClassPointer = NULL;

// Class Engine.AnimNodeScaleRateBySpeed
// 0x0004 (0x0148 - 0x0144)
class UAnimNodeScaleRateBySpeed : public UAnimNodeScalePlayRate {
   public:
    float BaseSpeed;  // 0x0144 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1101];

        return pClassPointer;
    };
};

UClass* UAnimNodeScaleRateBySpeed::pClassPointer = NULL;

// Class Engine.AnimNodeSlot
// 0x0027 (0x0164 - 0x013D)
class UAnimNodeSlot : public UAnimNodeBlendBase {
   public:
    DWORD bIsPlayingCustomAnim : 1;  // 0x0140 (0x0004) [0x0000000000000000]
                                     // [0x00000001]
    DWORD bEarlyAnimEndNotify : 1;   // 0x0140 (0x0004) [0x0000000000000000]
                                     // [0x00000002]
    DWORD bSkipBlendWhenNotRendered : 1;  // 0x0140 (0x0004)
                                          // [0x0000000000000000] [0x00000004]
    DWORD bAdditiveAnimationsOverrideSource : 1;  // 0x0140 (0x0004)
                                                  // [0x0000000000000000]
                                                  // [0x00000008]
    DWORD bIsBeingUsedByInterpGroup : 1;          // 0x0140 (0x0004)
                                          // [0x0000000000000000] [0x00000010]
    DWORD bDontAddToAlwaysTickArray : 1;  // 0x0140 (0x0004)
                                          // [0x0000000000000000] [0x00000020]
    DWORD bNoNotifies : 1;  // 0x0140 (0x0004) [0x0000000000000000] [0x00000040]
    float PendingBlendOutTime;   // 0x0144 (0x0004) [0x0000000000000000]
    int CustomChildIndex;        // 0x0148 (0x0004) [0x0000000000000000]
    int TargetChildIndex;        // 0x014C (0x0004) [0x0000000000000000]
    TArray<float> TargetWeight;  // 0x0150 (0x0010) [0x0000000000000000]
    float BlendTimeToGo;         // 0x0160 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1103];

        return pClassPointer;
    };

    void TickChildWeights();
    void SetRootBoneRotationOption();
    void SetRootBoneAxisOption();
    void GetCustomAnimNodeSeq();
    void SetNotifyWeightThreshold();
    void SetActorAnimEndNotification();
    void SetCustomAnim();
    void SetAllowPauseAnims();
    void StopCustomAnim();
    void GetPlayedAnimation();
    void PlayCustomAnimByDuration();
    void PlayCustomAnim();
};

UClass* UAnimNodeSlot::pClassPointer = NULL;

// Class Engine.AnimNodeSynch
// 0x0013 (0x0150 - 0x013D)
class UAnimNodeSynch : public UAnimNodeBlendBase {
   public:
    TArray<struct FSynchGroup> Groups;  // 0x0140 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1105];

        return pClassPointer;
    };

    void SetGroupRateScale();
    void GetRelativePosition();
    void ForceRelativePosition();
    void GetMasterNodeOfGroup();
    void RemoveNodeFromGroup();
    void AddNodeToGroup();
};

UClass* UAnimNodeSynch::pClassPointer = NULL;

// Class Engine.AnimTree
// 0x014F (0x028C - 0x013D)
class UAnimTree : public UAnimNodeBlendBase {
   public:
    class UAnimTree* AnimTreeTemplate;  // 0x0140 (0x0008) [0x0000000000000000]
    DWORD bEnablePooling : 1;           // 0x0148 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD
        bUseSavedPose : 1;  // 0x0148 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD
        bBeingEdited : 1;  // 0x0148 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bParentNodeArrayBuilt : 1;  // 0x0148 (0x0004) [0x0000000000000000]
                                      // [0x00000008]
    DWORD bRebuildAnimTickArray : 1;  // 0x0148 (0x0004) [0x0000000000000000]
                                      // [0x00000010]
    TArray<struct FAnimGroup>
        AnimGroups;  // 0x014C (0x0010) [0x0000000000000000]
    TArray<struct FName>
        PrioritizedSkelBranches;  // 0x015C (0x0010) [0x0000000000000000]
    TArray<struct FName>
        ComposePrePassBoneNames;  // 0x016C (0x0010) [0x0000000000000000]
    TArray<struct FName>
        ComposePostPassBoneNames;  // 0x017C (0x0010) [0x0000000000000000]
    TArray<class UMorphNodeBase*>
        RootMorphNodes;  // 0x018C (0x0010) [0x0000000000000000]
    TArray<struct FSkelControlListHead>
        SkelControlLists;                // 0x019C (0x0010) [0x0000000000000000]
    TArray<struct FBoneAtom> SavedPose;  // 0x01AC (0x0010) [0x0000000000000000]
    int MorphConnDrawY;                  // 0x01BC (0x0004) [0x0000000000000000]
    float PreviewPlayRate;               // 0x01C0 (0x0004) [0x0000000000000000]
    class USkeletalMesh*
        PreviewSkelMesh;  // 0x01C4 (0x0008) [0x0000000000000000]
    class USkeletalMesh*
        SocketSkelMesh;  // 0x01CC (0x0008) [0x0000000000000000]
    class UStaticMesh*
        SocketStaticMesh;     // 0x01D4 (0x0008) [0x0000000000000000]
    struct FName SocketName;  // 0x01DC (0x0008) [0x0000000000000000]
    TArray<class UAnimSet*>
        PreviewAnimSets;  // 0x01E4 (0x0010) [0x0000000000000000]
    TArray<class UMorphTargetSet*>
        PreviewMorphSets;  // 0x01F4 (0x0010) [0x0000000000000000]
    TArray<struct FPreviewSkelMeshStruct>
        PreviewMeshList;   // 0x0204 (0x0010) [0x0000000000000000]
    int PreviewMeshIndex;  // 0x0214 (0x0004) [0x0000000000000000]
    TArray<struct FPreviewSocketStruct>
        PreviewSocketList;   // 0x0218 (0x0010) [0x0000000000000000]
    int PreviewSocketIndex;  // 0x0228 (0x0004) [0x0000000000000000]
    TArray<struct FPreviewAnimSetsStruct>
        PreviewAnimSetList;          // 0x022C (0x0010) [0x0000000000000000]
    int PreviewAnimSetListIndex;     // 0x023C (0x0004) [0x0000000000000000]
    int PreviewAnimSetIndex;         // 0x0240 (0x0004) [0x0000000000000000]
    struct FVector PreviewCamPos;    // 0x0244 (0x000C) [0x0000000000000000]
    struct FRotator PreviewCamRot;   // 0x0250 (0x000C) [0x0000000000000000]
    struct FVector PreviewFloorPos;  // 0x025C (0x000C) [0x0000000000000000]
    int PreviewFloorYaw;             // 0x0268 (0x0004) [0x0000000000000000]
    TArray<class UAnimNodeFrame*>
        AnimNodeFrames;  // 0x026C (0x0010) [0x0000000000000000]
    TArray<class UAnimNode*>
        AnimTickArray;  // 0x027C (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1107];

        return pClassPointer;
    };

    void GetGroupIndex();
    void GetGroupRateScale();
    void SetGroupRateScale();
    void GetGroupRelativePosition();
    void ForceGroupRelativePosition();
    void GetGroupNotifyMaster();
    void GetGroupSynchMaster();
    void SetAnimGroupForNode();
    void SetUseSavedPose();
    void FindMorphNode();
    void FindSkelControl();
};

UClass* UAnimTree::pClassPointer = NULL;

// Class Engine.AnimNodeSequence
// 0x0070 (0x0198 - 0x0128)
class UAnimNodeSequence : public UAnimNode {
   public:
    struct FName AnimSeqName;  // 0x0128 (0x0008) [0x0000000000000000]
    float Rate;                // 0x0130 (0x0004) [0x0000000000000000]
    DWORD bPlaying : 1;  // 0x0134 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bLooping : 1;  // 0x0134 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bCauseActorAnimEnd : 1;    // 0x0134 (0x0004) [0x0000000000000000]
                                     // [0x00000004]
    DWORD bCauseActorAnimPlay : 1;   // 0x0134 (0x0004) [0x0000000000000000]
                                     // [0x00000008]
    DWORD bZeroRootRotation : 1;     // 0x0134 (0x0004) [0x0000000000000000]
                                     // [0x00000010]
    DWORD bZeroRootTranslation : 1;  // 0x0134 (0x0004) [0x0000000000000000]
                                     // [0x00000020]
    DWORD bDisableWarningWhenAnimNotFound : 1;  // 0x0134 (0x0004)
                                                // [0x0000000000000000]
                                                // [0x00000040]
    DWORD bNoNotifies : 1;  // 0x0134 (0x0004) [0x0000000000000000] [0x00000080]
    DWORD bForceRefposeWhenNotPlaying : 1;  // 0x0134 (0x0004)
                                            // [0x0000000000000000] [0x00000100]
    DWORD bIsIssuingNotifies : 1;  // 0x0134 (0x0004) [0x0000000000000000]
                                   // [0x00000200]
    DWORD bForceAlwaysSlave : 1;   // 0x0134 (0x0004) [0x0000000000000000]
                                   // [0x00000400]
    DWORD
        bSynchronize : 1;  // 0x0134 (0x0004) [0x0000000000000000] [0x00000800]
    DWORD
        bReverseSync : 1;  // 0x0134 (0x0004) [0x0000000000000000] [0x00001000]
    DWORD bShowTimeLineSlider : 1;  // 0x0134 (0x0004) [0x0000000000000000]
                                    // [0x00002000]
    DWORD bLoopCameraAnim : 1;      // 0x0134 (0x0004) [0x0000000000000000]
                                    // [0x00004000]
    DWORD bRandomizeCameraAnimLoopStartTime : 1;         // 0x0134 (0x0004)
                                                         // [0x0000000000000000]
                                                         // [0x00008000]
    DWORD bEditorOnlyAddRefPoseToAdditiveAnimation : 1;  // 0x0134 (0x0004)
                                                         // [0x0000000000000000]
                                                         // [0x00010000]
    DWORD bCheckForFinishAnimEarly : 1;  // 0x0134 (0x0004) [0x0000000000000000]
                                         // [0x00020000]
    DWORD
        bBlendingOut : 1;  // 0x0134 (0x0004) [0x0000000000000000] [0x00040000]
    float CurrentTime;     // 0x0138 (0x0004) [0x0000000000000000]
    float PreviousTime;    // 0x013C (0x0004) [0x0000000000000000]
    float EndTime;         // 0x0140 (0x0004) [0x0000000000000000]
    class UAnimSequence* AnimSeq;   // 0x0144 (0x0008) [0x0000000000000000]
    int AnimLinkupIndex;            // 0x014C (0x0004) [0x0000000000000000]
    float NotifyWeightThreshold;    // 0x0150 (0x0004) [0x0000000000000000]
    struct FName SynchGroupName;    // 0x0154 (0x0008) [0x0000000000000000]
    float SynchPosOffset;           // 0x015C (0x0004) [0x0000000000000000]
    class UCameraAnim* CameraAnim;  // 0x0160 (0x0008) [0x0000000000000000]
    class UCameraAnimInst*
        ActiveCameraAnimInstance;       // 0x0168 (0x0008) [0x0000000000000000]
    float CameraAnimScale;              // 0x0170 (0x0004) [0x0000000000000000]
    float CameraAnimPlayRate;           // 0x0174 (0x0004) [0x0000000000000000]
    float CameraAnimBlendInTime;        // 0x0178 (0x0004) [0x0000000000000000]
    float CameraAnimBlendOutTime;       // 0x017C (0x0004) [0x0000000000000000]
    unsigned char RootBoneOption[0x3];  // 0x0180 (0x0003) [0x0000000000000000]
    unsigned char
        RootRotationOption[0x3];  // 0x0183 (0x0003) [0x0000000000000000]
    TArray<class USkelControlBase*>
        MetaDataSkelControlList;  // 0x0188 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1109];

        return pClassPointer;
    };

    void SetRootBoneRotationOption();
    void SetRootBoneAxisOption();
    void GetTimeLeft();
    void GetAnimPlaybackLength();
    void GetGlobalPlayRate();
    void GetGroupRelativePosition();
    void FindGroupPosition();
    void FindGroupRelativePosition();
    void GetNormalizedPosition();
    void SetPosition();
    void ReplayAnim();
    void StopAnim();
    void PlayAnim();
    void SetAnim();
};

UClass* UAnimNodeSequence::pClassPointer = NULL;

// Class Engine.AnimNodeSequenceBlendBase
// 0x0010 (0x01A8 - 0x0198)
class UAnimNodeSequenceBlendBase : public UAnimNodeSequence {
   public:
    TArray<struct FAnimBlendInfo>
        Anims;  // 0x0198 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1111];

        return pClassPointer;
    };
};

UClass* UAnimNodeSequenceBlendBase::pClassPointer = NULL;

// Class Engine.AnimNodeSequenceBlendByAim
// 0x0070 (0x0218 - 0x01A8)
class UAnimNodeSequenceBlendByAim : public UAnimNodeSequenceBlendBase {
   public:
    struct FVector2D Aim;              // 0x01A8 (0x0008) [0x0000000000000000]
    struct FVector2D PreviousAim;      // 0x01B0 (0x0008) [0x0000000000000000]
    struct FVector2D HorizontalRange;  // 0x01B8 (0x0008) [0x0000000000000000]
    struct FVector2D VerticalRange;    // 0x01C0 (0x0008) [0x0000000000000000]
    struct FVector2D AngleOffset;      // 0x01C8 (0x0008) [0x0000000000000000]
    struct FName AnimName_LU;          // 0x01D0 (0x0008) [0x0000000000000000]
    struct FName AnimName_LC;          // 0x01D8 (0x0008) [0x0000000000000000]
    struct FName AnimName_LD;          // 0x01E0 (0x0008) [0x0000000000000000]
    struct FName AnimName_CU;          // 0x01E8 (0x0008) [0x0000000000000000]
    struct FName AnimName_CC;          // 0x01F0 (0x0008) [0x0000000000000000]
    struct FName AnimName_CD;          // 0x01F8 (0x0008) [0x0000000000000000]
    struct FName AnimName_RU;          // 0x0200 (0x0008) [0x0000000000000000]
    struct FName AnimName_RC;          // 0x0208 (0x0008) [0x0000000000000000]
    struct FName AnimName_RD;          // 0x0210 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1113];

        return pClassPointer;
    };

    void CheckAnimsUpToDate();
};

UClass* UAnimNodeSequenceBlendByAim::pClassPointer = NULL;

// Class Engine.AnimNodeFrame
// 0x0038 (0x00C4 - 0x008C)
class UAnimNodeFrame : public UAnimObject {
   public:
    int SizeX;            // 0x008C (0x0004) [0x0000000000000000]
    int SizeY;            // 0x0090 (0x0004) [0x0000000000000000]
    int BorderWidth;      // 0x0094 (0x0004) [0x0000000000000000]
    DWORD bDrawBox : 1;   // 0x0098 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bFilled : 1;    // 0x0098 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bTileFill : 1;  // 0x0098 (0x0004) [0x0000000000000000] [0x00000004]
    struct FColor BorderColor;      // 0x009C (0x0004) [0x0000000000000000]
    struct FColor FillColor;        // 0x00A0 (0x0004) [0x0000000000000000]
    class UTexture2D* FillTexture;  // 0x00A4 (0x0008) [0x0000000000000000]
    class UMaterial* FillMaterial;  // 0x00AC (0x0008) [0x0000000000000000]
    struct FString ObjComment;      // 0x00B4 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1115];

        return pClassPointer;
    };
};

UClass* UAnimNodeFrame::pClassPointer = NULL;

// Class Engine.MorphNodeBase
// 0x000C (0x0098 - 0x008C)
class UMorphNodeBase : public UAnimObject {
   public:
    struct FName NodeName;  // 0x008C (0x0008) [0x0000000000000000]
    DWORD bDrawSlider : 1;  // 0x0094 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1117];

        return pClassPointer;
    };
};

UClass* UMorphNodeBase::pClassPointer = NULL;

// Class Engine.MorphNodeMultiPose
// 0x0030 (0x00C8 - 0x0098)
class UMorphNodeMultiPose : public UMorphNodeBase {
   public:
    TArray<class UMorphTarget*>
        Targets;                      // 0x0098 (0x0010) [0x0000000000000000]
    TArray<struct FName> MorphNames;  // 0x00A8 (0x0010) [0x0000000000000000]
    TArray<float> Weights;            // 0x00B8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1119];

        return pClassPointer;
    };

    void UpdateMorphTarget();
    void RemoveMorphTarget();
    void AddMorphTarget();
};

UClass* UMorphNodeMultiPose::pClassPointer = NULL;

// Class Engine.MorphNodePose
// 0x0014 (0x00AC - 0x0098)
class UMorphNodePose : public UMorphNodeBase {
   public:
    class UMorphTarget* Target;  // 0x0098 (0x0008) [0x0000000000000000]
    struct FName MorphName;      // 0x00A0 (0x0008) [0x0000000000000000]
    float Weight;                // 0x00A8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1121];

        return pClassPointer;
    };

    void SetMorphTarget();
};

UClass* UMorphNodePose::pClassPointer = NULL;

// Class Engine.MorphNodeWeightBase
// 0x0010 (0x00A8 - 0x0098)
class UMorphNodeWeightBase : public UMorphNodeBase {
   public:
    TArray<struct FMorphNodeConn>
        NodeConns;  // 0x0098 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1123];

        return pClassPointer;
    };
};

UClass* UMorphNodeWeightBase::pClassPointer = NULL;

// Class Engine.MorphNodeWeight
// 0x0004 (0x00AC - 0x00A8)
class UMorphNodeWeight : public UMorphNodeWeightBase {
   public:
    float NodeWeight;  // 0x00A8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1125];

        return pClassPointer;
    };

    void SetNodeWeight();
};

UClass* UMorphNodeWeight::pClassPointer = NULL;

// Class Engine.MorphNodeWeightByBoneAngle
// 0x0044 (0x00EC - 0x00A8)
class UMorphNodeWeightByBoneAngle : public UMorphNodeWeightBase {
   public:
    float Angle;                     // 0x00A8 (0x0004) [0x0000000000000000]
    float NodeWeight;                // 0x00AC (0x0004) [0x0000000000000000]
    struct FName BaseBoneName;       // 0x00B0 (0x0008) [0x0000000000000000]
    unsigned char BaseBoneAxis;      // 0x00B8 (0x0001) [0x0000000000000000]
    unsigned char AngleBoneAxis;     // 0x00B9 (0x0001) [0x0000000000000000]
    DWORD bInvertBaseBoneAxis : 1;   // 0x00BC (0x0004) [0x0000000000000000]
                                     // [0x00000001]
    DWORD bInvertAngleBoneAxis : 1;  // 0x00BC (0x0004) [0x0000000000000000]
                                     // [0x00000002]
    DWORD bControlMaterialParameter : 1;  // 0x00BC (0x0004)
                                          // [0x0000000000000000] [0x00000004]
    struct FName AngleBoneName;        // 0x00C0 (0x0008) [0x0000000000000000]
    int MaterialSlotId;                // 0x00C8 (0x0004) [0x0000000000000000]
    struct FName ScalarParameterName;  // 0x00CC (0x0008) [0x0000000000000000]
    class UMaterialInstanceConstant*
        MaterialInstanceConstant;  // 0x00D4 (0x0008) [0x0000000000000000]
    TArray<struct FBoneAngleMorph>
        WeightArray;  // 0x00DC (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1127];

        return pClassPointer;
    };
};

UClass* UMorphNodeWeightByBoneAngle::pClassPointer = NULL;

// Class Engine.MorphNodeWeightByBoneRotation
// 0x003C (0x00E4 - 0x00A8)
class UMorphNodeWeightByBoneRotation : public UMorphNodeWeightBase {
   public:
    float Angle;                // 0x00A8 (0x0004) [0x0000000000000000]
    float NodeWeight;           // 0x00AC (0x0004) [0x0000000000000000]
    struct FName BoneName;      // 0x00B0 (0x0008) [0x0000000000000000]
    unsigned char BoneAxis;     // 0x00B8 (0x0001) [0x0000000000000000]
    DWORD bInvertBoneAxis : 1;  // 0x00BC (0x0004) [0x0000000000000000]
                                // [0x00000001]
    DWORD bControlMaterialParameter : 1;  // 0x00BC (0x0004)
                                          // [0x0000000000000000] [0x00000002]
    TArray<struct FBoneAngleMorph>
        WeightArray;                   // 0x00C0 (0x0010) [0x0000000000000000]
    int MaterialSlotId;                // 0x00D0 (0x0004) [0x0000000000000000]
    struct FName ScalarParameterName;  // 0x00D4 (0x0008) [0x0000000000000000]
    class UMaterialInstanceConstant*
        MaterialInstanceConstant;  // 0x00DC (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1129];

        return pClassPointer;
    };
};

UClass* UMorphNodeWeightByBoneRotation::pClassPointer = NULL;

// Class Engine.SkelControlBase
// 0x0068 (0x00F4 - 0x008C)
class USkelControlBase : public UAnimObject {
   public:
    struct FName ControlName;            // 0x008C (0x0008) [0x0000000000000000]
    float ControlStrength;               // 0x0094 (0x0004) [0x0000000000000000]
    float BlendInTime;                   // 0x0098 (0x0004) [0x0000000000000000]
    float BlendOutTime;                  // 0x009C (0x0004) [0x0000000000000000]
    unsigned char BlendType;             // 0x00A0 (0x0001) [0x0000000000000000]
    DWORD bPostPhysicsController : 1;    // 0x00A4 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bSetStrengthFromAnimNode : 1;  // 0x00A4 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bInitializedCachedNodeList : 1;  // 0x00A4 (0x0004)
                                           // [0x0000000000000000] [0x00000004]
    DWORD bControlledByAnimMetada : 1;  // 0x00A4 (0x0004) [0x0000000000000000]
                                        // [0x00000008]
    DWORD bInvertMetadataWeight : 1;    // 0x00A4 (0x0004) [0x0000000000000000]
                                        // [0x00000010]
    DWORD bPropagateSetActive : 1;      // 0x00A4 (0x0004) [0x0000000000000000]
                                        // [0x00000020]
    DWORD bIgnoreWhenNotRendered : 1;   // 0x00A4 (0x0004) [0x0000000000000000]
                                        // [0x00000040]
    DWORD bShouldTickInScript : 1;      // 0x00A4 (0x0004) [0x0000000000000000]
                                        // [0x00000080]
    DWORD bShouldTickOwner : 1;         // 0x00A4 (0x0004) [0x0000000000000000]
                                        // [0x00000100]
    DWORD bEnableEaseInOut : 1;         // 0x00A4 (0x0004) [0x0000000000000000]
                                        // [0x00000200]
    float StrengthTarget;               // 0x00A8 (0x0004) [0x0000000000000000]
    float BlendTimeToGo;                // 0x00AC (0x0004) [0x0000000000000000]
    TArray<struct FName>
        StrengthAnimNodeNameList;  // 0x00B0 (0x0010) [0x0000000000000000]
    TArray<class UAnimNode*>
        CachedNodeList;         // 0x00C0 (0x0010) [0x0000000000000000]
    float AnimMetadataWeight;   // 0x00D0 (0x0004) [0x0000000000000000]
    int AnimMetaDataUpdateTag;  // 0x00D4 (0x0004) [0x0000000000000000]
    float BoneScale;            // 0x00D8 (0x0004) [0x0000000000000000]
    int ControlTickTag;         // 0x00DC (0x0004) [0x0000000000000000]
    int IgnoreAtOrAboveLOD;     // 0x00E0 (0x0004) [0x0000000000000000]
    class USkelControlBase*
        NextControl;  // 0x00E4 (0x0008) [0x0000000000000000]
    int ControlPosX;  // 0x00EC (0x0004) [0x0000000000000000]
    int ControlPosY;  // 0x00F0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1131];

        return pClassPointer;
    };

    void GetControlMetadataWeight();
    void eventTickSkelControl();
    void SetSkelControlStrength();
    void SetSkelControlActive();
};

UClass* USkelControlBase::pClassPointer = NULL;

// Class Engine.SkelControl_CCD_IK
// 0x004C (0x0140 - 0x00F4)
class USkelControl_CCD_IK : public USkelControlBase {
   public:
    struct FVector EffectorLocation;  // 0x00F4 (0x000C) [0x0000000000000000]
    unsigned char
        EffectorLocationSpace;           // 0x0100 (0x0001) [0x0000000000000000]
    struct FName EffectorSpaceBoneName;  // 0x0104 (0x0008) [0x0000000000000000]
    struct FVector
        EffectorTranslationFromBone;  // 0x010C (0x000C) [0x0000000000000000]
    int NumBones;                     // 0x0118 (0x0004) [0x0000000000000000]
    int MaxPerBoneIterations;         // 0x011C (0x0004) [0x0000000000000000]
    int IterationsCount;              // 0x0120 (0x0004) [0x0000000000000000]
    float Precision;                  // 0x0124 (0x0004) [0x0000000000000000]
    DWORD bStartFromTail : 1;         // 0x0128 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bNoTurnOptimization : 1;    // 0x0128 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    TArray<float> AngleConstraint;    // 0x012C (0x0010) [0x0000000000000000]
    float MaxAngleSteps;              // 0x013C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1133];

        return pClassPointer;
    };
};

UClass* USkelControl_CCD_IK::pClassPointer = NULL;

// Class Engine.SkelControl_Multiply
// 0x0004 (0x00F8 - 0x00F4)
class USkelControl_Multiply : public USkelControlBase {
   public:
    float Multiplier;  // 0x00F4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1135];

        return pClassPointer;
    };
};

UClass* USkelControl_Multiply::pClassPointer = NULL;

// Class Engine.SkelControl_TwistBone
// 0x000C (0x0100 - 0x00F4)
class USkelControl_TwistBone : public USkelControlBase {
   public:
    struct FName SourceBoneName;  // 0x00F4 (0x0008) [0x0000000000000000]
    float TwistAngleScale;        // 0x00FC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1137];

        return pClassPointer;
    };
};

UClass* USkelControl_TwistBone::pClassPointer = NULL;

// Class Engine.SkelControlLimb
// 0x0058 (0x014C - 0x00F4)
class USkelControlLimb : public USkelControlBase {
   public:
    struct FVector EffectorLocation;  // 0x00F4 (0x000C) [0x0000000000000000]
    unsigned char
        EffectorLocationSpace;  // 0x0100 (0x0001) [0x0000000000000000]
    unsigned char
        JointTargetLocationSpace;        // 0x0101 (0x0001) [0x0000000000000000]
    unsigned char JointOffsetSpace;      // 0x0102 (0x0001) [0x0000000000000000]
    unsigned char BoneAxis;              // 0x0103 (0x0001) [0x0000000000000000]
    unsigned char JointAxis;             // 0x0104 (0x0001) [0x0000000000000000]
    struct FName EffectorSpaceBoneName;  // 0x0108 (0x0008) [0x0000000000000000]
    struct FVector JointTargetLocation;  // 0x0110 (0x000C) [0x0000000000000000]
    struct FName
        JointTargetSpaceBoneName;      // 0x011C (0x0008) [0x0000000000000000]
    struct FVector JointOffset;        // 0x0124 (0x000C) [0x0000000000000000]
    struct FName JointOffsetBoneName;  // 0x0130 (0x0008) [0x0000000000000000]
    DWORD bInvertBoneAxis : 1;         // 0x0138 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bInvertJointAxis : 1;        // 0x0138 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD
        bRotateJoint : 1;  // 0x0138 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bMaintainEffectorRelRot : 1;  // 0x0138 (0x0004) [0x0000000000000000]
                                        // [0x00000008]
    DWORD bTakeRotationFromEffectorSpace : 1;  // 0x0138 (0x0004)
                                               // [0x0000000000000000]
                                               // [0x00000010]
    DWORD bAllowStretching : 1;        // 0x0138 (0x0004) [0x0000000000000000]
                                       // [0x00000020]
    struct FVector2D StretchLimits;    // 0x013C (0x0008) [0x0000000000000000]
    struct FName StretchRollBoneName;  // 0x0144 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1139];

        return pClassPointer;
    };
};

UClass* USkelControlLimb::pClassPointer = NULL;

// Class Engine.SkelControlFootPlacement
// 0x0024 (0x0170 - 0x014C)
class USkelControlFootPlacement : public USkelControlLimb {
   public:
    float FootOffset;               // 0x014C (0x0004) [0x0000000000000000]
    unsigned char FootUpAxis;       // 0x0150 (0x0001) [0x0000000000000000]
    struct FRotator FootRotOffset;  // 0x0154 (0x000C) [0x0000000000000000]
    DWORD bInvertFootUpAxis : 1;    // 0x0160 (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    DWORD bOrientFootToGround : 1;  // 0x0160 (0x0004) [0x0000000000000000]
                                    // [0x00000002]
    DWORD bOnlyEnableForUpAdjustment : 1;  // 0x0160 (0x0004)
                                           // [0x0000000000000000] [0x00000004]
    float MaxUpAdjustment;      // 0x0164 (0x0004) [0x0000000000000000]
    float MaxDownAdjustment;    // 0x0168 (0x0004) [0x0000000000000000]
    float MaxFootOrientAdjust;  // 0x016C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1141];

        return pClassPointer;
    };
};

UClass* USkelControlFootPlacement::pClassPointer = NULL;

// Class Engine.SkelControlLookAt
// 0x009C (0x0190 - 0x00F4)
class USkelControlLookAt : public USkelControlBase {
   public:
    struct FVector TargetLocation;      // 0x00F4 (0x000C) [0x0000000000000000]
    unsigned char TargetLocationSpace;  // 0x0100 (0x0001) [0x0000000000000000]
    unsigned char LookAtAxis;           // 0x0101 (0x0001) [0x0000000000000000]
    unsigned char UpAxis;               // 0x0102 (0x0001) [0x0000000000000000]
    unsigned char AllowRotationSpace;   // 0x0103 (0x0001) [0x0000000000000000]
    struct FName TargetSpaceBoneName;   // 0x0104 (0x0008) [0x0000000000000000]
    DWORD bInvertLookAtAxis : 1;        // 0x010C (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD
        bDefineUpAxis : 1;  // 0x010C (0x0004) [0x0000000000000000] [0x00000002]
    DWORD
        bInvertUpAxis : 1;  // 0x010C (0x0004) [0x0000000000000000] [0x00000004]
    DWORD
        bEnableLimit : 1;  // 0x010C (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bLimitBasedOnRefPose : 1;  // 0x010C (0x0004) [0x0000000000000000]
                                     // [0x00000010]
    DWORD bDisableBeyondLimit : 1;   // 0x010C (0x0004) [0x0000000000000000]
                                     // [0x00000020]
    DWORD bNotifyBeyondLimit : 1;    // 0x010C (0x0004) [0x0000000000000000]
                                     // [0x00000040]
    DWORD bShowLimit : 1;  // 0x010C (0x0004) [0x0000000000000000] [0x00000080]
    DWORD bAllowRotationX : 1;        // 0x010C (0x0004) [0x0000000000000000]
                                      // [0x00000100]
    DWORD bAllowRotationY : 1;        // 0x010C (0x0004) [0x0000000000000000]
                                      // [0x00000200]
    DWORD bAllowRotationZ : 1;        // 0x010C (0x0004) [0x0000000000000000]
                                      // [0x00000400]
    float TargetLocationInterpSpeed;  // 0x0110 (0x0004) [0x0000000000000000]
    struct FVector
        DesiredTargetLocation;  // 0x0114 (0x000C) [0x0000000000000000]
    struct FVector
        ActorSpaceLookAtTarget;  // 0x0120 (0x000C) [0x0000000000000000]
    float MaxAngle;              // 0x012C (0x0004) [0x0000000000000000]
    float OuterMaxAngle;         // 0x0130 (0x0004) [0x0000000000000000]
    float DeadZoneAngle;         // 0x0134 (0x0004) [0x0000000000000000]
    struct FVector2D
        RotationAngleRangeX;  // 0x0138 (0x0008) [0x0000000000000000]
    struct FVector2D
        RotationAngleRangeY;  // 0x0140 (0x0008) [0x0000000000000000]
    struct FVector2D
        RotationAngleRangeZ;  // 0x0148 (0x0008) [0x0000000000000000]
    struct FName
        AllowRotationOtherBoneName;  // 0x0150 (0x0008) [0x0000000000000000]
    float LookAtAlpha;               // 0x0158 (0x0004) [0x0000000000000000]
    float LookAtAlphaTarget;         // 0x015C (0x0004) [0x0000000000000000]
    float LookAtAlphaBlendTimeToGo;  // 0x0160 (0x0004) [0x0000000000000000]
    struct FVector LimitLookDir;     // 0x0164 (0x000C) [0x0000000000000000]
    struct FVector BaseLookDir;      // 0x0170 (0x000C) [0x0000000000000000]
    struct FVector BaseBonePos;      // 0x017C (0x000C) [0x0000000000000000]
    float LastCalcTime;              // 0x0188 (0x0004) [0x0000000000000000]
    int ControlBoneIndex;            // 0x018C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1143];

        return pClassPointer;
    };

    void CanLookAtPoint();
    void SetLookAtAlpha();
    void InterpolateTargetLocation();
    void SetTargetLocation();
};

UClass* USkelControlLookAt::pClassPointer = NULL;

// Class Engine.SkelControlSingleBone
// 0x0030 (0x0124 - 0x00F4)
class USkelControlSingleBone : public USkelControlBase {
   public:
    DWORD bApplyTranslation : 1;  // 0x00F4 (0x0004) [0x0000000000000000]
                                  // [0x00000001]
    DWORD bApplyRotation : 1;     // 0x00F4 (0x0004) [0x0000000000000000]
                                  // [0x00000002]
    DWORD bAddTranslation : 1;    // 0x00F4 (0x0004) [0x0000000000000000]
                                  // [0x00000004]
    DWORD
        bAddRotation : 1;  // 0x00F4 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bRemoveMeshRotation : 1;       // 0x00F4 (0x0004) [0x0000000000000000]
                                         // [0x00000010]
    struct FVector BoneTranslation;      // 0x00F8 (0x000C) [0x0000000000000000]
    unsigned char BoneTranslationSpace;  // 0x0104 (0x0001) [0x0000000000000000]
    unsigned char BoneRotationSpace;     // 0x0105 (0x0001) [0x0000000000000000]
    struct FName
        TranslationSpaceBoneName;        // 0x0108 (0x0008) [0x0000000000000000]
    struct FRotator BoneRotation;        // 0x0110 (0x000C) [0x0000000000000000]
    struct FName RotationSpaceBoneName;  // 0x011C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1145];

        return pClassPointer;
    };
};

UClass* USkelControlSingleBone::pClassPointer = NULL;

// Class Engine.SkelControlHandlebars
// 0x0014 (0x0138 - 0x0124)
class USkelControlHandlebars : public USkelControlSingleBone {
   public:
    unsigned char WheelRollAxis;        // 0x0124 (0x0001) [0x0000000000000000]
    unsigned char HandlebarRotateAxis;  // 0x0125 (0x0001) [0x0000000000000000]
    struct FName WheelBoneName;         // 0x0128 (0x0008) [0x0000000000000000]
    DWORD bInvertRotation : 1;          // 0x0130 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    int SteerWheelBoneIndex;            // 0x0134 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1147];

        return pClassPointer;
    };
};

UClass* USkelControlHandlebars::pClassPointer = NULL;

// Class Engine.SkelControlWheel
// 0x0018 (0x013C - 0x0124)
class USkelControlWheel : public USkelControlSingleBone {
   public:
    float WheelDisplacement;           // 0x0124 (0x0004) [0x0000000000000000]
    float WheelMaxRenderDisplacement;  // 0x0128 (0x0004) [0x0000000000000000]
    float WheelRoll;                   // 0x012C (0x0004) [0x0000000000000000]
    unsigned char WheelRollAxis;       // 0x0130 (0x0001) [0x0000000000000000]
    unsigned char WheelSteeringAxis;   // 0x0131 (0x0001) [0x0000000000000000]
    float WheelSteering;               // 0x0134 (0x0004) [0x0000000000000000]
    DWORD bInvertWheelRoll : 1;        // 0x0138 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bInvertWheelSteering : 1;    // 0x0138 (0x0004) [0x0000000000000000]
                                       // [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1149];

        return pClassPointer;
    };
};

UClass* USkelControlWheel::pClassPointer = NULL;

// Class Engine.SkelControlSpline
// 0x0014 (0x0108 - 0x00F4)
class USkelControlSpline : public USkelControlBase {
   public:
    int SplineLength;                 // 0x00F4 (0x0004) [0x0000000000000000]
    unsigned char SplineBoneAxis;     // 0x00F8 (0x0001) [0x0000000000000000]
    unsigned char BoneRotMode;        // 0x00F9 (0x0001) [0x0000000000000000]
    DWORD bInvertSplineBoneAxis : 1;  // 0x00FC (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    float EndSplineTension;           // 0x0100 (0x0004) [0x0000000000000000]
    float StartSplineTension;         // 0x0104 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1151];

        return pClassPointer;
    };
};

UClass* USkelControlSpline::pClassPointer = NULL;

// Class Engine.SkelControlTrail
// 0x007C (0x0170 - 0x00F4)
class USkelControlTrail : public USkelControlBase {
   public:
    int ChainLength;                 // 0x00F4 (0x0004) [0x0000000000000000]
    unsigned char ChainBoneAxis;     // 0x00F8 (0x0001) [0x0000000000000000]
    DWORD bInvertChainBoneAxis : 1;  // 0x00FC (0x0004) [0x0000000000000000]
                                     // [0x00000001]
    DWORD
        bLimitStretch : 1;  // 0x00FC (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bActorSpaceFakeVel : 1;  // 0x00FC (0x0004) [0x0000000000000000]
                                   // [0x00000004]
    DWORD bHadValidStrength : 1;   // 0x00FC (0x0004) [0x0000000000000000]
                                   // [0x00000008]
    float TrailRelaxation;         // 0x0100 (0x0004) [0x0000000000000000]
    float StretchLimit;            // 0x0104 (0x0004) [0x0000000000000000]
    struct FVector FakeVelocity;   // 0x0108 (0x000C) [0x0000000000000000]
    float ThisTimstep;             // 0x0114 (0x0004) [0x0000000000000000]
    TArray<struct FVector>
        TrailBoneLocations;            // 0x0118 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x8];  // 0x0128 (0x0008) MISSED OFFSET
    struct FMatrix OldLocalToWorld;    // 0x0130 (0x0040) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1153];

        return pClassPointer;
    };
};

UClass* USkelControlTrail::pClassPointer = NULL;

// Class Engine.AnimSequence
// 0x0138 (0x0198 - 0x0060)
class UAnimSequence : public UObject {
   public:
    struct FName SequenceName;  // 0x0060 (0x0008) [0x0000000000000000]
    TArray<struct FAnimNotifyEvent>
        Notifies;  // 0x0068 (0x0010) [0x0000000000000000]
    TArray<class UAnimMetaData*>
        MetaData;  // 0x0078 (0x0010) [0x0000000000000000]
    TArray<struct FSkelControlModifier>
        BoneControlModifiers;           // 0x0088 (0x0010) [0x0000000000000000]
    float SequenceLength;               // 0x0098 (0x0004) [0x0000000000000000]
    int NumFrames;                      // 0x009C (0x0004) [0x0000000000000000]
    float RateScale;                    // 0x00A0 (0x0004) [0x0000000000000000]
    DWORD bNoLoopingInterpolation : 1;  // 0x00A4 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bIsAdditive : 1;  // 0x00A4 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bAdditiveBuiltLooping : 1;  // 0x00A4 (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    DWORD bDoNotOverrideCompression : 1;  // 0x00A4 (0x0004)
                                          // [0x0000000000000000] [0x00000008]
    DWORD
        bHasBeenUsed : 1;  // 0x00A4 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bWasCompressedWithoutTranslations : 1;  // 0x00A4 (0x0004)
                                                  // [0x0000000000000000]
                                                  // [0x00000020]
    TArray<struct FRawAnimSequenceTrack>
        RawAnimData;  // 0x00A8 (0x0010) [0x0000000000000000]
    TArray<struct FRawAnimSequenceTrack>
        RawAnimationData;  // 0x00B8 (0x0010) [0x0000000000000000]
    TArray<struct FTranslationTrack>
        TranslationData;  // 0x00C8 (0x0010) [0x0000000000000000]
    TArray<struct FRotationTrack>
        RotationData;  // 0x00D8 (0x0010) [0x0000000000000000]
    TArray<struct FCurveTrack>
        CurveData;  // 0x00E8 (0x0010) [0x0000000000000000]
    class UAnimationCompressionAlgorithm*
        CompressionScheme;  // 0x00F8 (0x0008) [0x0000000000000000]
    unsigned char
        TranslationCompressionFormat;  // 0x0100 (0x0001) [0x0000000000000000]
    unsigned char
        RotationCompressionFormat;       // 0x0101 (0x0001) [0x0000000000000000]
    unsigned char KeyEncodingFormat;     // 0x0102 (0x0001) [0x0000000000000000]
    TArray<int> CompressedTrackOffsets;  // 0x0104 (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        CompressedByteStream;          // 0x0114 (0x0010) [0x0000000000000000]
    struct FPointer TranslationCodec;  // 0x0124 (0x0008) [0x0000000000000000]
    struct FPointer RotationCodec;     // 0x012C (0x0008) [0x0000000000000000]
    TArray<struct FBoneAtom>
        AdditiveRefPose;  // 0x0134 (0x0010) [0x0000000000000000]
    TArray<struct FRawAnimSequenceTrack>
        AdditiveBasePose;          // 0x0144 (0x0010) [0x0000000000000000]
    struct FName AdditiveRefName;  // 0x0154 (0x0008) [0x0000000000000000]
    TArray<class UAnimSequence*>
        AdditiveBasePoseAnimSeq;  // 0x015C (0x0010) [0x0000000000000000]
    TArray<class UAnimSequence*>
        AdditiveTargetPoseAnimSeq;  // 0x016C (0x0010) [0x0000000000000000]
    TArray<class UAnimSequence*>
        RelatedAdditiveAnimSeqs;    // 0x017C (0x0010) [0x0000000000000000]
    int EncodingPkgVersion;         // 0x018C (0x0004) [0x0000000000000000]
    int CompressCommandletVersion;  // 0x0190 (0x0004) [0x0000000000000000]
    float UseScore;                 // 0x0194 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1155];

        return pClassPointer;
    };

    void GetNotifyTimeByClass();
};

UClass* UAnimSequence::pClassPointer = NULL;

// Class Engine.AnimSet
// 0x0114 (0x0174 - 0x0060)
class UAnimSet : public UObject {
   public:
    DWORD bAnimRotationOnly : 1;  // 0x0060 (0x0004) [0x0000000000000000]
                                  // [0x00000001]
    TArray<struct FName>
        TrackBoneNames;  // 0x0064 (0x0010) [0x0000000000000000]
    TArray<class UAnimSequence*>
        Sequences;  // 0x0074 (0x0010) [0x0000000000000000]
    unsigned char
        UnknownData00[0x48];  // 0x0084 (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.AnimSet.SequenceCache
    TArray<struct FAnimSetMeshLinkup>
        LinkupCache;  // 0x00CC (0x0010) [0x0000000000000000]
    unsigned char
        UnknownData01[0x48];  // 0x00DC (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.AnimSet.SkelMesh2LinkupCache
    TArray<unsigned char>
        BoneUseAnimTranslation;  // 0x0124 (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        ForceUseMeshTranslation;  // 0x0134 (0x0010) [0x0000000000000000]
    TArray<struct FName>
        UseTranslationBoneNames;  // 0x0144 (0x0010) [0x0000000000000000]
    TArray<struct FName>
        ForceMeshTranslationBoneNames;   // 0x0154 (0x0010) [0x0000000000000000]
    struct FName PreviewSkelMeshName;    // 0x0164 (0x0008) [0x0000000000000000]
    struct FName BestRatioSkelMeshName;  // 0x016C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1157];

        return pClassPointer;
    };
};

UClass* UAnimSet::pClassPointer = NULL;

// Class Engine.MorphTarget
// 0x001C (0x007C - 0x0060)
class UMorphTarget : public UObject {
   public:
    TArray<int> MorphLODModels;        // 0x0060 (0x0010) [0x0000000000000000]
    int MaterialSlotId;                // 0x0070 (0x0004) [0x0000000000000000]
    struct FName ScalarParameterName;  // 0x0074 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1159];

        return pClassPointer;
    };
};

UClass* UMorphTarget::pClassPointer = NULL;

// Class Engine.MorphTargetSet
// 0x0028 (0x0088 - 0x0060)
class UMorphTargetSet : public UObject {
   public:
    TArray<class UMorphTarget*>
        Targets;                        // 0x0060 (0x0010) [0x0000000000000000]
    class USkeletalMesh* BaseSkelMesh;  // 0x0070 (0x0008) [0x0000000000000000]
    struct FArray_Mirror
        RawWedgePointIndices;  // 0x0078 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1161];

        return pClassPointer;
    };

    void FindMorphTarget();
};

UClass* UMorphTargetSet::pClassPointer = NULL;

// Class Engine.MorphWeightSequence
// 0x0000 (0x0060 - 0x0060)
class UMorphWeightSequence : public UObject {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1163];

        return pClassPointer;
    };
};

UClass* UMorphWeightSequence::pClassPointer = NULL;

// Class Engine.DecalActorBase
// 0x0010 (0x0254 - 0x0244)
class ADecalActorBase : public AActor {
   public:
    struct FPointer
        VfTable_IEditorLinkSelectionInterface;  // 0x0244 (0x0008)
                                                // [0x0000000000000000]
    class UDecalComponent* Decal;  // 0x024C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1165];

        return pClassPointer;
    };
};

UClass* ADecalActorBase::pClassPointer = NULL;

// Class Engine.DecalActor
// 0x0000 (0x0254 - 0x0254)
class ADecalActor : public ADecalActorBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1167];

        return pClassPointer;
    };
};

UClass* ADecalActor::pClassPointer = NULL;

// Class Engine.DecalActorMovable
// 0x0000 (0x0254 - 0x0254)
class ADecalActorMovable : public ADecalActorBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1169];

        return pClassPointer;
    };
};

UClass* ADecalActorMovable::pClassPointer = NULL;

// Class Engine.DecalManager
// 0x0040 (0x0284 - 0x0244)
class ADecalManager : public AActor {
   public:
    class UDecalComponent*
        DecalTemplate;  // 0x0244 (0x0008) [0x0000000000000000]
    TArray<class UDecalComponent*>
        PoolDecals;                    // 0x024C (0x0010) [0x0000000000000000]
    int MaxActiveDecals;               // 0x025C (0x0004) [0x0000000000000000]
    float DecalLifeSpan;               // 0x0260 (0x0004) [0x0000000000000000]
    float DecalDepthBias;              // 0x0264 (0x0004) [0x0000000000000000]
    float OrbisDecalDepthBias;         // 0x0268 (0x0004) [0x0000000000000000]
    struct FVector2D DecalBlendRange;  // 0x026C (0x0008) [0x0000000000000000]
    TArray<struct FActiveDecalInfo>
        ActiveDecals;  // 0x0274 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1171];

        return pClassPointer;
    };

    void Reset();
    void SpawnDecal();
    void GetPooledComponent();
    void SetDecalParameters();
    void CanSpawnDecals();
    void eventDecalFinished();
    void AreDynamicDecalsEnabled();
};

UClass* ADecalManager::pClassPointer = NULL;

// Class Engine.DecalComponent
// 0x0188 (0x03C0 - 0x0238)
class UDecalComponent : public UPrimitiveComponent {
   public:
    class UMaterialInterface*
        DecalMaterial;            // 0x0238 (0x0008) [0x0000000000000000]
    float Width;                  // 0x0240 (0x0004) [0x0000000000000000]
    float Height;                 // 0x0244 (0x0004) [0x0000000000000000]
    float TileX;                  // 0x0248 (0x0004) [0x0000000000000000]
    float TileY;                  // 0x024C (0x0004) [0x0000000000000000]
    float OffsetX;                // 0x0250 (0x0004) [0x0000000000000000]
    float OffsetY;                // 0x0254 (0x0004) [0x0000000000000000]
    float DecalRotation;          // 0x0258 (0x0004) [0x0000000000000000]
    float FieldOfView;            // 0x025C (0x0004) [0x0000000000000000]
    float NearPlane;              // 0x0260 (0x0004) [0x0000000000000000]
    float FarPlane;               // 0x0264 (0x0004) [0x0000000000000000]
    struct FVector Location;      // 0x0268 (0x000C) [0x0000000000000000]
    struct FRotator Orientation;  // 0x0274 (0x000C) [0x0000000000000000]
    struct FVector HitLocation;   // 0x0280 (0x000C) [0x0000000000000000]
    struct FVector HitNormal;     // 0x028C (0x000C) [0x0000000000000000]
    struct FVector HitTangent;    // 0x0298 (0x000C) [0x0000000000000000]
    struct FVector HitBinormal;   // 0x02A4 (0x000C) [0x0000000000000000]
    DWORD bNoClip : 1;  // 0x02B0 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD
        bStaticDecal : 1;  // 0x02B0 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bProjectOnBackfaces : 1;  // 0x02B0 (0x0004) [0x0000000000000000]
                                    // [0x00000004]
    DWORD bProjectOnHidden : 1;     // 0x02B0 (0x0004) [0x0000000000000000]
                                    // [0x00000008]
    DWORD
        bProjectOnBSP : 1;  // 0x02B0 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bProjectOnStaticMeshes : 1;    // 0x02B0 (0x0004) [0x0000000000000000]
                                         // [0x00000020]
    DWORD bProjectOnSkeletalMeshes : 1;  // 0x02B0 (0x0004) [0x0000000000000000]
                                         // [0x00000040]
    DWORD bProjectOnTerrain : 1;         // 0x02B0 (0x0004) [0x0000000000000000]
                                         // [0x00000080]
    DWORD bFlipBackfaceDirection : 1;    // 0x02B0 (0x0004) [0x0000000000000000]
                                         // [0x00000100]
    DWORD
        bMovableDecal : 1;  // 0x02B0 (0x0004) [0x0000000000000000] [0x00000200]
    DWORD
        bTickParentRelativeTransform : 1;  // 0x02B0 (0x0004)
                                           // [0x0000000000000000] [0x00000400]
    DWORD bHasBeenAttached : 1;  // 0x02B0 (0x0004) [0x0000000000000000]
                                 // [0x00000800]
    DWORD bDecalMaterialSetAtRunTime : 1;  // 0x02B0 (0x0004)
                                           // [0x0000000000000000] [0x00001000]
    class UPrimitiveComponent*
        HitComponent;      // 0x02B4 (0x0008) [0x0000000000000000]
    struct FName HitBone;  // 0x02BC (0x0008) [0x0000000000000000]
    int HitNodeIndex;      // 0x02C4 (0x0004) [0x0000000000000000]
    int HitLevelIndex;     // 0x02C8 (0x0004) [0x0000000000000000]
    int FracturedStaticMeshComponentIndex;  // 0x02CC (0x0004)
                                            // [0x0000000000000000]
    TArray<int> HitNodeIndices;  // 0x02D0 (0x0010) [0x0000000000000000]
    TArray<struct FDecalReceiver>
        DecalReceivers;  // 0x02E0 (0x0010) [0x0000000000000000]
    TArray<struct FPointer>
        StaticReceivers;  // 0x02F0 (0x0010) [0x0000000000000000]
    struct FPointer
        ReleaseResourcesFence;          // 0x0300 (0x0008) [0x0000000000000000]
    TArray<struct FPlane> Planes;       // 0x0308 (0x0010) [0x0000000000000000]
    float DepthBias;                    // 0x0318 (0x0004) [0x0000000000000000]
    float SlopeScaleDepthBias;          // 0x031C (0x0004) [0x0000000000000000]
    float OrbisDepthBias;               // 0x0320 (0x0004) [0x0000000000000000]
    float OrbisSlopeScaleDepthBias;     // 0x0324 (0x0004) [0x0000000000000000]
    int SortOrder;                      // 0x0328 (0x0004) [0x0000000000000000]
    float BackfaceAngle;                // 0x032C (0x0004) [0x0000000000000000]
    struct FVector2D BlendRange;        // 0x0330 (0x0008) [0x0000000000000000]
    float StreamingDistanceMultiplier;  // 0x0338 (0x0004) [0x0000000000000000]
    unsigned char DecalTransform;       // 0x033C (0x0001) [0x0000000000000000]
    unsigned char FilterMode;           // 0x033D (0x0001) [0x0000000000000000]
    TArray<class AActor*> Filter;       // 0x0340 (0x0010) [0x0000000000000000]
    TArray<class UPrimitiveComponent*>
        ReceiverImages;  // 0x0350 (0x0010) [0x0000000000000000]
    struct FVector
        ParentRelativeLocation;  // 0x0360 (0x000C) [0x0000000000000000]
    struct FRotator
        ParentRelativeOrientation;     // 0x036C (0x000C) [0x0000000000000000]
    unsigned char UnknownData00[0x8];  // 0x0378 (0x0008) MISSED OFFSET
    struct FMatrix
        ParentRelLocRotMatrix;  // 0x0380 (0x0040) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1173];

        return pClassPointer;
    };

    void IsWaitingForResetToDefaultsToComplete();
    void GetDecalMaterial();
    void SetDecalMaterial();
    void ResetToDefaults();
};

UClass* UDecalComponent::pClassPointer = NULL;

// Class Engine.ActorFactoryDecal
// 0x0008 (0x00A4 - 0x009C)
class UActorFactoryDecal : public UActorFactory {
   public:
    class UMaterialInterface*
        DecalMaterial;  // 0x009C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1175];

        return pClassPointer;
    };
};

UClass* UActorFactoryDecal::pClassPointer = NULL;

// Class Engine.ActorFactoryDecalMovable
// 0x0000 (0x00A4 - 0x00A4)
class UActorFactoryDecalMovable : public UActorFactoryDecal {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1177];

        return pClassPointer;
    };
};

UClass* UActorFactoryDecalMovable::pClassPointer = NULL;

// Class Engine.Material
// 0x0624 (0x0888 - 0x0264)
class UMaterial : public UMaterialInterface {
   public:
    class UPhysicalMaterial*
        PhysMaterial;                    // 0x0264 (0x0008) [0x0000000000000000]
    class UClass* PhysicalMaterial;      // 0x026C (0x0008) [0x0000000000000000]
    class UTexture2D* PhysMaterialMask;  // 0x0274 (0x0008) [0x0000000000000000]
    int PhysMaterialMaskUVChannel;       // 0x027C (0x0004) [0x0000000000000000]
    class UPhysicalMaterial*
        BlackPhysicalMaterial;  // 0x0280 (0x0008) [0x0000000000000000]
    class UPhysicalMaterial*
        WhitePhysicalMaterial;  // 0x0288 (0x0008) [0x0000000000000000]
    struct FColorMaterialInput
        DiffuseColor;  // 0x0290 (0x003C) [0x0000000000000000]
    struct FScalarMaterialInput
        DiffusePower;  // 0x02CC (0x003C) [0x0000000000000000]
    struct FColorMaterialInput
        SpecularColor;  // 0x0308 (0x003C) [0x0000000000000000]
    struct FScalarMaterialInput
        SpecularPower;                   // 0x0344 (0x003C) [0x0000000000000000]
    struct FVectorMaterialInput Normal;  // 0x0380 (0x0044) [0x0000000000000000]
    struct FColorMaterialInput
        EmissiveColor;  // 0x03C4 (0x003C) [0x0000000000000000]
    struct FScalarMaterialInput
        Opacity;  // 0x0400 (0x003C) [0x0000000000000000]
    struct FScalarMaterialInput
        OpacityMask;             // 0x043C (0x003C) [0x0000000000000000]
    float OpacityMaskClipValue;  // 0x0478 (0x0004) [0x0000000000000000]
    float ShadowDepthBias;       // 0x047C (0x0004) [0x0000000000000000]
    struct FVector2MaterialInput
        Distortion;               // 0x0480 (0x0040) [0x0000000000000000]
    unsigned char BlendMode;      // 0x04C0 (0x0001) [0x0000000000000000]
    unsigned char LightingModel;  // 0x04C1 (0x0001) [0x0000000000000000]
    unsigned char
        D3D11TessellationMode;  // 0x04C2 (0x0001) [0x0000000000000000]
    struct FColorMaterialInput
        CustomLighting;  // 0x04C4 (0x003C) [0x0000000000000000]
    struct FColorMaterialInput
        CustomSkylightDiffuse;  // 0x0500 (0x003C) [0x0000000000000000]
    struct FVectorMaterialInput
        AnisotropicDirection;  // 0x053C (0x0044) [0x0000000000000000]
    struct FScalarMaterialInput
        TwoSidedLightingMask;  // 0x0580 (0x003C) [0x0000000000000000]
    struct FColorMaterialInput
        TwoSidedLightingColor;  // 0x05BC (0x003C) [0x0000000000000000]
    struct FVectorMaterialInput
        WorldPositionOffset;  // 0x05F8 (0x0044) [0x0000000000000000]
    struct FVectorMaterialInput
        WorldDisplacement;  // 0x063C (0x0044) [0x0000000000000000]
    struct FScalarMaterialInput
        TessellationMultiplier;  // 0x0680 (0x003C) [0x0000000000000000]
    struct FColorMaterialInput
        SubsurfaceInscatteringColor;  // 0x06BC (0x003C) [0x0000000000000000]
    struct FColorMaterialInput
        SubsurfaceAbsorptionColor;  // 0x06F8 (0x003C) [0x0000000000000000]
    struct FScalarMaterialInput
        SubsurfaceScatteringRadius;  // 0x0734 (0x003C) [0x0000000000000000]
    struct FScalarMaterialInput
        SubsurfaceScatteringMask;  // 0x0770 (0x003C) [0x0000000000000000]
    DWORD EnableSubsurfaceScattering : 1;  // 0x07AC (0x0004)
                                           // [0x0000000000000000] [0x00000001]
    DWORD
        EnableAOMask : 1;  // 0x07AC (0x0004) [0x0000000000000000] [0x00000002]
    DWORD EnableSeparateTranslucency : 1;  // 0x07AC (0x0004)
                                           // [0x0000000000000000] [0x00000004]
    DWORD bEnableMaskedAntialiasing : 1;   // 0x07AC (0x0004)
                                           // [0x0000000000000000] [0x00000008]
    DWORD TwoSided : 1;  // 0x07AC (0x0004) [0x0000000000000000] [0x00000010]
    DWORD TwoSidedSeparatePass : 1;  // 0x07AC (0x0004) [0x0000000000000000]
                                     // [0x00000020]
    DWORD bDisableDepthTest : 1;     // 0x07AC (0x0004) [0x0000000000000000]
                                     // [0x00000040]
    DWORD bSceneTextureRenderBehindTranslucency : 1;  // 0x07AC (0x0004)
                                                      // [0x0000000000000000]
                                                      // [0x00000080]
    DWORD bAllowFog : 1;  // 0x07AC (0x0004) [0x0000000000000000] [0x00000100]
    DWORD bTranslucencyReceiveDominantShadowsFromStatic : 1;  // 0x07AC (0x0004)
                                                              // [0x0000000000000000]
                                                              // [0x00000200]
    DWORD bTranslucencyInheritDominantShadowsFromOpaque : 1;  // 0x07AC (0x0004)
                                                              // [0x0000000000000000]
                                                              // [0x00000400]
    DWORD bAllowTranslucencyDoF : 1;   // 0x07AC (0x0004) [0x0000000000000000]
                                       // [0x00000800]
    DWORD bUseOneLayerDistortion : 1;  // 0x07AC (0x0004) [0x0000000000000000]
                                       // [0x00001000]
    DWORD
        bUseLitTranslucencyDepthPass : 1;  // 0x07AC (0x0004)
                                           // [0x0000000000000000] [0x00002000]
    DWORD bUseLitTranslucencyPostRenderDepthPass : 1;  // 0x07AC (0x0004)
                                                       // [0x0000000000000000]
                                                       // [0x00004000]
    DWORD bCastLitTranslucencyShadowAsMasked : 1;      // 0x07AC (0x0004)
                                                       // [0x0000000000000000]
                                                       // [0x00008000]
    DWORD bUsedAsLightFunction : 1;  // 0x07AC (0x0004) [0x0000000000000000]
                                     // [0x00010000]
    DWORD bUsedWithFogVolumes : 1;   // 0x07AC (0x0004) [0x0000000000000000]
                                     // [0x00020000]
    DWORD
        bUsedAsSpecialEngineMaterial : 1;  // 0x07AC (0x0004)
                                           // [0x0000000000000000] [0x00040000]
    DWORD bUsedWithSkeletalMesh : 1;     // 0x07AC (0x0004) [0x0000000000000000]
                                         // [0x00080000]
    DWORD bUsedWithTerrain : 1;          // 0x07AC (0x0004) [0x0000000000000000]
                                         // [0x00100000]
    DWORD bUsedWithLandscape : 1;        // 0x07AC (0x0004) [0x0000000000000000]
                                         // [0x00200000]
    DWORD bUsedWithMobileLandscape : 1;  // 0x07AC (0x0004) [0x0000000000000000]
                                         // [0x00400000]
    DWORD bUsedWithFracturedMeshes : 1;  // 0x07AC (0x0004) [0x0000000000000000]
                                         // [0x00800000]
    DWORD bUsedWithParticleSystem : 1;   // 0x07AC (0x0004) [0x0000000000000000]
                                         // [0x01000000]
    DWORD bUsedWithParticleSprites : 1;  // 0x07AC (0x0004) [0x0000000000000000]
                                         // [0x02000000]
    DWORD bUsedWithBeamTrails : 1;       // 0x07AC (0x0004) [0x0000000000000000]
                                         // [0x04000000]
    DWORD bUsedWithParticleSubUV : 1;    // 0x07AC (0x0004) [0x0000000000000000]
                                         // [0x08000000]
    DWORD bUsedWithSpeedTree : 1;        // 0x07AC (0x0004) [0x0000000000000000]
                                         // [0x10000000]
    DWORD bUsedWithStaticLighting : 1;   // 0x07AC (0x0004) [0x0000000000000000]
                                         // [0x20000000]
    DWORD bUsedWithLensFlare : 1;        // 0x07AC (0x0004) [0x0000000000000000]
                                         // [0x40000000]
    DWORD bUsedWithGammaCorrection : 1;  // 0x07AC (0x0004) [0x0000000000000000]
                                         // [0x80000000]
    DWORD bUsedWithInstancedMeshParticles : 1;  // 0x07B0 (0x0004)
                                                // [0x0000000000000000]
                                                // [0x00000001]
    DWORD bUsedWithFluidSurfaces : 1;    // 0x07B0 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bUsedWithDecals : 1;           // 0x07B0 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD bUsedWithMaterialEffect : 1;   // 0x07B0 (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    DWORD bUsedWithMorphTargets : 1;     // 0x07B0 (0x0004) [0x0000000000000000]
                                         // [0x00000010]
    DWORD bUsedWithRadialBlur : 1;       // 0x07B0 (0x0004) [0x0000000000000000]
                                         // [0x00000020]
    DWORD bUsedWithInstancedMeshes : 1;  // 0x07B0 (0x0004) [0x0000000000000000]
                                         // [0x00000040]
    DWORD bUsedWithSplineMeshes : 1;     // 0x07B0 (0x0004) [0x0000000000000000]
                                         // [0x00000080]
    DWORD bUsedWithAPEXMeshes : 1;       // 0x07B0 (0x0004) [0x0000000000000000]
                                         // [0x00000100]
    DWORD bUsedWithSPHFluid : 1;         // 0x07B0 (0x0004) [0x0000000000000000]
                                         // [0x00000200]
    DWORD bUsedWithSPHFluidThickness : 1;  // 0x07B0 (0x0004)
                                           // [0x0000000000000000] [0x00000400]
    DWORD bUsedWithScreenDoorFade : 1;  // 0x07B0 (0x0004) [0x0000000000000000]
                                        // [0x00000800]
    DWORD
        bEnableCrackFreeDisplacement : 1;  // 0x07B0 (0x0004)
                                           // [0x0000000000000000] [0x00001000]
    DWORD bUseImageBasedReflections : 1;   // 0x07B0 (0x0004)
                                           // [0x0000000000000000] [0x00002000]
    DWORD bUseScreenSpaceReflections : 1;  // 0x07B0 (0x0004)
                                           // [0x0000000000000000] [0x00004000]
    DWORD Wireframe : 1;  // 0x07B0 (0x0004) [0x0000000000000000] [0x00008000]
    DWORD bPerPixelCameraVector : 1;   // 0x07B0 (0x0004) [0x0000000000000000]
                                       // [0x00010000]
    DWORD bAllowLightmapSpecular : 1;  // 0x07B0 (0x0004) [0x0000000000000000]
                                       // [0x00020000]
    DWORD bIsFallbackMaterial : 1;     // 0x07B0 (0x0004) [0x0000000000000000]
                                       // [0x00040000]
    DWORD bUsesDistortion : 1;         // 0x07B0 (0x0004) [0x0000000000000000]
                                       // [0x00080000]
    DWORD bIsMasked : 1;  // 0x07B0 (0x0004) [0x0000000000000000] [0x00100000]
    DWORD bIsPreviewMaterial : 1;  // 0x07B0 (0x0004) [0x0000000000000000]
                                   // [0x00200000]
    float
        ImageReflectionNormalDampening;  // 0x07B4 (0x0004) [0x0000000000000000]
    struct FPointer
        MaterialResources[0x2];  // 0x07B8 (0x0010) [0x0000000000000000]
    struct FPointer
        DefaultMaterialInstances[0x3];  // 0x07C8 (0x0018) [0x0000000000000000]
    int EditorX;                        // 0x07E0 (0x0004) [0x0000000000000000]
    int EditorY;                        // 0x07E4 (0x0004) [0x0000000000000000]
    int EditorPitch;                    // 0x07E8 (0x0004) [0x0000000000000000]
    int EditorYaw;                      // 0x07EC (0x0004) [0x0000000000000000]
    TArray<class UMaterialExpression*>
        Expressions;  // 0x07F0 (0x0010) [0x0000000000000000]
    TArray<class UMaterialExpressionComment*>
        EditorComments;  // 0x0800 (0x0010) [0x0000000000000000]
    TArray<struct FMaterialFunctionInfo>
        MaterialFunctionInfos;  // 0x0810 (0x0010) [0x0000000000000000]
    unsigned char
        UnknownData00[0x48];  // 0x0820 (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.Material.EditorParameters
    TArray<class UTexture*>
        ReferencedTextures;  // 0x0868 (0x0010) [0x0000000000000000]
    TArray<struct FGuid>
        ReferencedTextureGuids;  // 0x0878 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1179];

        return pClassPointer;
    };
};

UClass* UMaterial::pClassPointer = NULL;

// Class Engine.DecalMaterial
// 0x0000 (0x0888 - 0x0888)
class UDecalMaterial : public UMaterial {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1181];

        return pClassPointer;
    };
};

UClass* UDecalMaterial::pClassPointer = NULL;

// Class Engine.FogVolumeDensityInfo
// 0x0014 (0x0258 - 0x0244)
class AFogVolumeDensityInfo : public AInfo {
   public:
    class UFogVolumeDensityComponent*
        DensityComponent;  // 0x0244 (0x0008) [0x0000000000000000]
    class UStaticMeshComponent*
        AutomaticMeshComponent;  // 0x024C (0x0008) [0x0000000000000000]
    DWORD bEnabled : 1;  // 0x0254 (0x0004) [0x0000000000150000] [0x00000001] (
                         // CPF_Travel | CPF_GlobalConfig )

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1183];

        return pClassPointer;
    };

    void ApplyCheckpointRecord();
    void CreateCheckpointRecord();
    void ShouldSaveForCheckpoint();
    void OnToggle();
    void eventReplicatedEvent();
    void eventPostBeginPlay();
};

UClass* AFogVolumeDensityInfo::pClassPointer = NULL;

// Class Engine.FogVolumeConeDensityInfo
// 0x0000 (0x0258 - 0x0258)
class AFogVolumeConeDensityInfo : public AFogVolumeDensityInfo {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1185];

        return pClassPointer;
    };
};

UClass* AFogVolumeConeDensityInfo::pClassPointer = NULL;

// Class Engine.FogVolumeConstantDensityInfo
// 0x0000 (0x0258 - 0x0258)
class AFogVolumeConstantDensityInfo : public AFogVolumeDensityInfo {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1187];

        return pClassPointer;
    };
};

UClass* AFogVolumeConstantDensityInfo::pClassPointer = NULL;

// Class Engine.FogVolumeLinearHalfspaceDensityInfo
// 0x0000 (0x0258 - 0x0258)
class AFogVolumeLinearHalfspaceDensityInfo : public AFogVolumeDensityInfo {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1189];

        return pClassPointer;
    };
};

UClass* AFogVolumeLinearHalfspaceDensityInfo::pClassPointer = NULL;

// Class Engine.FogVolumeSphericalDensityInfo
// 0x0000 (0x0258 - 0x0258)
class AFogVolumeSphericalDensityInfo : public AFogVolumeDensityInfo {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1191];

        return pClassPointer;
    };
};

UClass* AFogVolumeSphericalDensityInfo::pClassPointer = NULL;

// Class Engine.ExponentialHeightFogComponent
// 0x002F (0x00B4 - 0x0085)
class UExponentialHeightFogComponent : public UActorComponent {
   public:
    DWORD bEnabled : 1;  // 0x0088 (0x0004) [0x0000000000000000] [0x00000001]
    float FogHeight;     // 0x008C (0x0004) [0x0000000000000000]
    float FogDensity;    // 0x0090 (0x0004) [0x0000000000000000]
    float FogHeightFalloff;             // 0x0094 (0x0004) [0x0000000000000000]
    float FogMaxOpacity;                // 0x0098 (0x0004) [0x0000000000000000]
    float StartDistance;                // 0x009C (0x0004) [0x0000000000000000]
    float LightTerminatorAngle;         // 0x00A0 (0x0004) [0x0000000000000000]
    float OppositeLightBrightness;      // 0x00A4 (0x0004) [0x0000000000000000]
    struct FColor OppositeLightColor;   // 0x00A8 (0x0004) [0x0000000000000000]
    float LightInscatteringBrightness;  // 0x00AC (0x0004) [0x0000000000000000]
    struct FColor
        LightInscatteringColor;  // 0x00B0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1193];

        return pClassPointer;
    };

    void SetEnabled();
};

UClass* UExponentialHeightFogComponent::pClassPointer = NULL;

// Class Engine.FogVolumeDensityComponent
// 0x004F (0x00D4 - 0x0085)
class UFogVolumeDensityComponent : public UActorComponent {
   public:
    class UMaterialInterface*
        FogMaterial;  // 0x0088 (0x0008) [0x0000000000000000]
    class UMaterialInterface*
        DefaultFogVolumeMaterial;  // 0x0090 (0x0008) [0x0000000000000000]
    DWORD bEnabled : 1;  // 0x0098 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bAffectsTranslucency : 1;      // 0x0098 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bOnlyAffectsTranslucency : 1;  // 0x0098 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    struct FLinearColor
        SimpleLightColor;  // 0x009C (0x0010) [0x0000000000000000]
    struct FLinearColor
        ApproxFogLightColor;  // 0x00AC (0x0010) [0x0000000000000000]
    float StartDistance;      // 0x00BC (0x0004) [0x0000000000000000]
    float MaxDistance;        // 0x00C0 (0x0004) [0x0000000000000000]
    TArray<class AActor*>
        FogVolumeActors;  // 0x00C4 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1195];

        return pClassPointer;
    };

    void SetEnabled();
};

UClass* UFogVolumeDensityComponent::pClassPointer = NULL;

// Class Engine.FogVolumeConeDensityComponent
// 0x002C (0x0100 - 0x00D4)
class UFogVolumeConeDensityComponent : public UFogVolumeDensityComponent {
   public:
    float MaxDensity;           // 0x00D4 (0x0004) [0x0000000000000000]
    struct FVector ConeVertex;  // 0x00D8 (0x000C) [0x0000000000000000]
    float ConeRadius;           // 0x00E4 (0x0004) [0x0000000000000000]
    struct FVector ConeAxis;    // 0x00E8 (0x000C) [0x0000000000000000]
    float ConeMaxAngle;         // 0x00F4 (0x0004) [0x0000000000000000]
    class UDrawLightConeComponent*
        PreviewCone;  // 0x00F8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1197];

        return pClassPointer;
    };
};

UClass* UFogVolumeConeDensityComponent::pClassPointer = NULL;

// Class Engine.FogVolumeConstantDensityComponent
// 0x0004 (0x00D8 - 0x00D4)
class UFogVolumeConstantDensityComponent : public UFogVolumeDensityComponent {
   public:
    float Density;  // 0x00D4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1199];

        return pClassPointer;
    };
};

UClass* UFogVolumeConstantDensityComponent::pClassPointer = NULL;

// Class Engine.FogVolumeLinearHalfspaceDensityComponent
// 0x001C (0x00F0 - 0x00D4)
class UFogVolumeLinearHalfspaceDensityComponent
    : public UFogVolumeDensityComponent {
   public:
    float PlaneDistanceFactor;         // 0x00D4 (0x0004) [0x0000000000000000]
    unsigned char UnknownData00[0x8];  // 0x00D8 (0x0008) MISSED OFFSET
    struct FPlane HalfspacePlane;      // 0x00E0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1201];

        return pClassPointer;
    };
};

UClass* UFogVolumeLinearHalfspaceDensityComponent::pClassPointer = NULL;

// Class Engine.FogVolumeSphericalDensityComponent
// 0x001C (0x00F0 - 0x00D4)
class UFogVolumeSphericalDensityComponent : public UFogVolumeDensityComponent {
   public:
    float MaxDensity;             // 0x00D4 (0x0004) [0x0000000000000000]
    struct FVector SphereCenter;  // 0x00D8 (0x000C) [0x0000000000000000]
    float SphereRadius;           // 0x00E4 (0x0004) [0x0000000000000000]
    class UDrawLightRadiusComponent*
        PreviewSphereRadius;  // 0x00E8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1203];

        return pClassPointer;
    };
};

UClass* UFogVolumeSphericalDensityComponent::pClassPointer = NULL;

// Class Engine.ActorFactoryFogVolumeConstantDensityInfo
// 0x000C (0x00A8 - 0x009C)
class UActorFactoryFogVolumeConstantDensityInfo : public UActorFactory {
   public:
    class UMaterialInterface*
        SelectedMaterial;        // 0x009C (0x0008) [0x0000000000000000]
    DWORD bNothingSelected : 1;  // 0x00A4 (0x0004) [0x0000000000000000]
                                 // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1205];

        return pClassPointer;
    };
};

UClass* UActorFactoryFogVolumeConstantDensityInfo::pClassPointer = NULL;

// Class Engine.ActorFactoryFogVolumeLinearHalfspaceDensityInfo
// 0x0000 (0x00A8 - 0x00A8)
class UActorFactoryFogVolumeLinearHalfspaceDensityInfo
    : public UActorFactoryFogVolumeConstantDensityInfo {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1207];

        return pClassPointer;
    };
};

UClass* UActorFactoryFogVolumeLinearHalfspaceDensityInfo::pClassPointer = NULL;

// Class Engine.ActorFactoryFogVolumeSphericalDensityInfo
// 0x0000 (0x00A8 - 0x00A8)
class UActorFactoryFogVolumeSphericalDensityInfo
    : public UActorFactoryFogVolumeConstantDensityInfo {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1209];

        return pClassPointer;
    };
};

UClass* UActorFactoryFogVolumeSphericalDensityInfo::pClassPointer = NULL;

// Class Engine.ApexDestructibleActor
// 0x0058 (0x029C - 0x0244)
class AApexDestructibleActor : public AActor {
   public:
    class UDynamicLightEnvironmentComponent*
        LightEnvironment;  // 0x0244 (0x0008) [0x0000000000000000]
    DWORD bFractureMaterialOverride : 1;  // 0x024C (0x0004)
                                          // [0x0000000000000000] [0x00000001]
    DWORD bPlaySingleFractureMaterialEffect : 1;  // 0x024C (0x0004)
                                                  // [0x0000000000000000]
                                                  // [0x00000002]
    TArray<class UFractureMaterial*>
        FractureMaterials;  // 0x0250 (0x0010) [0x0000000000000000]
    class UApexStaticDestructibleComponent*
        StaticDestructibleComponent;  // 0x0260 (0x0008) [0x0000000000000000]
    int LOD;                          // 0x0268 (0x0004) [0x0000000000000000]
    TArray<unsigned char>
        VisibilityFactors;  // 0x026C (0x0010) [0x0000000000000000]
    TArray<class USoundCue*>
        FractureSounds;  // 0x027C (0x0010) [0x0000000000000000]
    TArray<class UParticleSystem*>
        FractureParticleEffects;  // 0x028C (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1211];

        return pClassPointer;
    };

    void OnSetMaterial();
    void TakeRadiusDamage();
    void TakeDamage();
    void eventPostBeginPlay();
    void CacheFractureEffects();
    void eventSpawnFractureEmitter();
};

UClass* AApexDestructibleActor::pClassPointer = NULL;

// Class Engine.FracturedStaticMeshActor
// 0x0094 (0x02D8 - 0x0244)
class AFracturedStaticMeshActor : public AActor {
   public:
    int MaxPartsToSpawnAtOnce;  // 0x0244 (0x0004) [0x0000000000000000]
    class UFracturedStaticMeshComponent*
        FracturedStaticMeshComponent;  // 0x0248 (0x0008) [0x0000000000000000]
    class UFracturedSkinnedMeshComponent*
        SkinnedComponent;     // 0x0250 (0x0008) [0x0000000000000000]
    TArray<int> ChunkHealth;  // 0x0258 (0x0010) [0x0000000000000000]
    DWORD
        bHasShownMissingSoundWarning : 1;  // 0x0268 (0x0004)
                                           // [0x0000000000000000] [0x00000001]
    DWORD bBreakChunksOnActorTouch : 1;  // 0x0268 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bShouldSaveForCheckpoint : 1;  // 0x0268 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD bDestroyFragmentsOnImpact : 1;  // 0x0268 (0x0004)
                                          // [0x0000000000000000] [0x00000008]
    DWORD bHasBeenDirtied : 1;  // 0x0268 (0x0004) [0x0000000000000000]
                                // [0x00000010]
    TArray<class UClass*>
        FracturedByDamageType;  // 0x026C (0x0010) [0x0000000000000000]
    float ChunkHealthScale;     // 0x027C (0x0004) [0x0000000000000000]
    TArray<class UParticleSystem*>
        OverrideFragmentDestroyEffects;  // 0x0280 (0x0010) [0x0000000000000000]
    float FractureCullMinDistance;       // 0x0290 (0x0004) [0x0000000000000000]
    float FractureCullMaxDistance;       // 0x0294 (0x0004) [0x0000000000000000]
    TArray<struct FDeferredPartToSpawn>
        DeferredPartsToSpawn;  // 0x0298 (0x0010) [0x0000000000000000]
    struct FPhysEffectInfo
        PartImpactEffect;  // 0x02A8 (0x0018) [0x0000000000000000]
    class UAkBaseSoundObject*
        ExplosionFractureSound;  // 0x02C0 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        SingleChunkFractureSound;  // 0x02C8 (0x0008) [0x0000000000000000]
    class UMaterialInterface*
        MI_LoseChunkPreviousMaterial;  // 0x02D0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1213];

        return pClassPointer;
    };

    void Reset();
    void NotifyHitByExplosion();
    void eventSetLoseChunkReplacementMaterial();
    void eventHideFragmentsToMaximizeMemoryUsage();
    void eventHideOneFragment();
    void eventResetVisibility();
    void eventBreakOffPartsInRadius();
    void eventExplode();
    void eventTakeDamage();
    void RemoveDecals();
    void FractureEffectIsRelevant();
    void IsFracturedByDamageType();
    void eventSpawnDeferredParts();
    void eventBreakOffIsolatedIslands();
    void ApplyCheckpointRecord();
    void CreateCheckpointRecord();
    void ShouldSaveForCheckpoint();
    void ResetHealth();
    void eventPostBeginPlay();
    void SpawnPartMulti();
    void SpawnPart();
};

UClass* AFracturedStaticMeshActor::pClassPointer = NULL;

// Class Engine.FracturedStaticMeshPart
// 0x0034 (0x030C - 0x02D8)
class AFracturedStaticMeshPart : public AFracturedStaticMeshActor {
   public:
    float DestroyPartRadiusFactor;  // 0x02D8 (0x0004) [0x0000000000000000]
    class AFracturedStaticMeshActor*
        BaseFracturedMeshActor;  // 0x02DC (0x0008) [0x0000000000000000]
    DWORD bHasBeenRecycled : 1;  // 0x02E4 (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    DWORD bChangeRBChannelWhenAsleep : 1;  // 0x02E4 (0x0004)
                                           // [0x0000000000000000] [0x00000002]
    DWORD bCompositeThatExplodesOnImpact : 1;  // 0x02E4 (0x0004)
                                               // [0x0000000000000000]
                                               // [0x00000004]
    float LastSpawnTime;            // 0x02E8 (0x0004) [0x0000000000000000]
    int PartPoolIndex;              // 0x02EC (0x0004) [0x0000000000000000]
    float FracPartGravScale;        // 0x02F0 (0x0004) [0x0000000000000000]
    unsigned char AsleepRBChannel;  // 0x02F4 (0x0001) [0x0000000000000000]
    struct FVector OldVelocity;     // 0x02F8 (0x000C) [0x0000000000000000]
    float CurrentVibrationLevel;    // 0x0304 (0x0004) [0x0000000000000000]
    float LastImpactSoundTime;      // 0x0308 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1215];

        return pClassPointer;
    };

    void eventReset();
    void eventBreakOffPartsInRadius();
    void eventExplode();
    void eventFellOutOfWorld();
    void TryToCleanUp();
    void eventTakeDamage();
    void RecyclePart();
    void Initialize();
};

UClass* AFracturedStaticMeshPart::pClassPointer = NULL;

// Class Engine.FractureManager
// 0x0044 (0x0288 - 0x0244)
class AFractureManager : public AActor {
   public:
    int FSMPartPoolSize;             // 0x0244 (0x0004) [0x0000000000000000]
    DWORD bEnableAntiVibration : 1;  // 0x0248 (0x0004) [0x0000000000000000]
                                     // [0x00000001]
    DWORD bEnableSpawnChunkEffectForRadialDamage : 1;  // 0x0248 (0x0004)
                                                       // [0x0000000000000000]
                                                       // [0x00000002]
    float DestroyVibrationLevel;  // 0x024C (0x0004) [0x0000000000000000]
    float DestroyMinAngVel;       // 0x0250 (0x0004) [0x0000000000000000]
    float ExplosionVelScale;      // 0x0254 (0x0004) [0x0000000000000000]
    TArray<class AFracturedStaticMeshPart*>
        PartPool;           // 0x0258 (0x0010) [0x0000000000000000]
    TArray<int> FreeParts;  // 0x0268 (0x0010) [0x0000000000000000]
    TArray<class AFracturedStaticMeshActor*>
        ActorsWithDeferredPartsToSpawn;  // 0x0278 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1217];

        return pClassPointer;
    };

    void Tick();
    void eventReturnPartActor();
    void eventSpawnPartActor();
    void GetFSMPart();
    void ResetPoolVisibility();
    void CreateFSMParts();
    void CleanUpFSMParts();
    void eventDestroyed();
    void eventPreBeginPlay();
    void GetFSMFractureCullDistanceScale();
    void GetFSMRadialSpawnChanceScale();
    void GetFSMDirectSpawnChanceScale();
    void GetNumFSMPartsScale();
    void eventSpawnChunkDestroyEffect();
};

UClass* AFractureManager::pClassPointer = NULL;

// Class Engine.ImageReflection
// 0x0014 (0x0258 - 0x0244)
class AImageReflection : public AActor {
   public:
    DWORD bEnabled : 1;  // 0x0244 (0x0004) [0x0000000000150000] [0x00000001] (
                         // CPF_Travel | CPF_GlobalConfig )
    class UImageReflectionComponent*
        ReflectionComponent;  // 0x0248 (0x0008) [0x0000000000000000]
    class UImageBasedReflectionComponent*
        ImageReflectionComponent;  // 0x0250 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1219];

        return pClassPointer;
    };

    void OnToggle();
    void eventReplicatedEvent();
    void eventPostBeginPlay();
};

UClass* AImageReflection::pClassPointer = NULL;

// Class Engine.ImageReflectionSceneCapture
// 0x0008 (0x0260 - 0x0258)
class AImageReflectionSceneCapture : public AImageReflection {
   public:
    float DepthRange;  // 0x0258 (0x0004) [0x0000000000000000]
    float ColorRange;  // 0x025C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1221];

        return pClassPointer;
    };
};

UClass* AImageReflectionSceneCapture::pClassPointer = NULL;

// Class Engine.ImageReflectionShadowPlane
// 0x000C (0x0250 - 0x0244)
class AImageReflectionShadowPlane : public AActor {
   public:
    DWORD bEnabled : 1;  // 0x0244 (0x0004) [0x0000000000150000] [0x00000001] (
                         // CPF_Travel | CPF_GlobalConfig )
    class UImageReflectionShadowPlaneComponent*
        ReflectionShadowComponent;  // 0x0248 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1223];

        return pClassPointer;
    };

    void OnToggle();
    void eventReplicatedEvent();
    void eventPostBeginPlay();
};

UClass* AImageReflectionShadowPlane::pClassPointer = NULL;

// Class Engine.ImageReflectionComponent
// 0x000B (0x0090 - 0x0085)
class UImageReflectionComponent : public UActorComponent {
   public:
    class UTexture2D*
        ReflectionTexture;  // 0x0088 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1225];

        return pClassPointer;
    };
};

UClass* UImageReflectionComponent::pClassPointer = NULL;

// Class Engine.ImageReflectionShadowPlaneComponent
// 0x0018 (0x0250 - 0x0238)
class UImageReflectionShadowPlaneComponent : public UPrimitiveComponent {
   public:
    DWORD bEnabled : 1;  // 0x0238 (0x0004) [0x0000000000000000] [0x00000001]
    unsigned char UnknownData00[0x4];  // 0x023C (0x0004) MISSED OFFSET
    struct FPlane ReflectionPlane;     // 0x0240 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1227];

        return pClassPointer;
    };

    void SetEnabled();
};

UClass* UImageReflectionShadowPlaneComponent::pClassPointer = NULL;

// Class Engine.ApexComponentBase
// 0x001C (0x0264 - 0x0248)
class UApexComponentBase : public UMeshComponent {
   public:
    struct FPointer
        ComponentBaseResources;  // 0x0248 (0x0008) [0x0000000000000000]
    struct FRenderCommandFence_Mirror
        ReleaseResourcesFence;     // 0x0250 (0x0004) [0x0000000000000000]
    class UApexAsset* Asset;       // 0x0254 (0x0008) [0x0000000000000000]
    struct FColor WireframeColor;  // 0x025C (0x0004) [0x0000000000000000]
    DWORD
        bAssetChanged : 1;  // 0x0260 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1229];

        return pClassPointer;
    };
};

UClass* UApexComponentBase::pClassPointer = NULL;

// Class Engine.ApexDynamicComponent
// 0x0008 (0x026C - 0x0264)
class UApexDynamicComponent : public UApexComponentBase {
   public:
    struct FPointer
        ComponentDynamicResources;  // 0x0264 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1231];

        return pClassPointer;
    };
};

UClass* UApexDynamicComponent::pClassPointer = NULL;

// Class Engine.ApexStaticComponent
// 0x0000 (0x0264 - 0x0264)
class UApexStaticComponent : public UApexComponentBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1233];

        return pClassPointer;
    };
};

UClass* UApexStaticComponent::pClassPointer = NULL;

// Class Engine.ApexStaticDestructibleComponent
// 0x001C (0x0280 - 0x0264)
class UApexStaticDestructibleComponent : public UApexStaticComponent {
   public:
    float SleepEnergyThreshold;  // 0x0264 (0x0004) [0x0000000000000000]
    float SleepDamping;          // 0x0268 (0x0004) [0x0000000000000000]
    struct FPointer
        ApexDestructibleActor;  // 0x026C (0x0008) [0x0000000000000000]
    struct FPointer
        ApexDestructiblePreview;      // 0x0274 (0x0008) [0x0000000000000000]
    DWORD bIsThumbnailComponent : 1;  // 0x027C (0x0004) [0x0000000000000000]
                                      // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1235];

        return pClassPointer;
    };
};

UClass* UApexStaticDestructibleComponent::pClassPointer = NULL;

// Class Engine.FlexComponent
// 0x0060 (0x033C - 0x02DC)
class UFlexComponent : public UStaticMeshComponent {
   public:
    class UFlexContainer*
        FlexComponentContainerTemplate;  // 0x02DC (0x0008) [0x0000000000000000]
    int FlexComponentPhaseId;            // 0x02E4 (0x0004) [0x0000000000000000]
    DWORD
        bFlexComponentAutoAssignPhase : 1;  // 0x02E8 (0x0004)
                                            // [0x0000000000000000] [0x00000001]
    DWORD
        bFlexComponentAttachToRigids : 1;  // 0x02E8 (0x0004)
                                           // [0x0000000000000000] [0x00000002]
    struct FPointer
        FlexComponentAssetInstance;  // 0x02EC (0x0008) [0x0000000000000000]
    struct FPointer
        FlexComponentContainerInstance;  // 0x02F4 (0x0008) [0x0000000000000000]
    TArray<struct FVector>
        FlexComponentPreSimPositions;  // 0x02FC (0x0010) [0x0000000000000000]
    TArray<struct FVector4>
        SimPositions;                   // 0x030C (0x0010) [0x0000000000000000]
    TArray<struct FVector> SimNormals;  // 0x031C (0x0010) [0x0000000000000000]
    TArray<struct FFlexParticleAttachment>
        Attachments;  // 0x032C (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1237];

        return pClassPointer;
    };
};

UClass* UFlexComponent::pClassPointer = NULL;

// Class Engine.FracturedBaseComponent
// 0x0028 (0x0304 - 0x02DC)
class UFracturedBaseComponent : public UStaticMeshComponent {
   public:
    struct FPointer
        ComponentBaseResources;  // 0x02DC (0x0008) [0x0000000000000000]
    struct FRenderCommandFence_Mirror
        ReleaseResourcesFence;  // 0x02E4 (0x0004) [0x0000000000000000]
    TArray<unsigned char>
        VisibleFragments;               // 0x02E8 (0x0010) [0x0000000000000000]
    DWORD bVisibilityHasChanged : 1;    // 0x02F8 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bVisibilityReset : 1;         // 0x02F8 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bInitialVisibilityValue : 1;  // 0x02F8 (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    DWORD bUseDynamicIndexBuffer : 1;   // 0x02F8 (0x0004) [0x0000000000000000]
                                        // [0x00000008]
    DWORD bUseDynamicIBWithHiddenFragments : 1;  // 0x02F8 (0x0004)
                                                 // [0x0000000000000000]
                                                 // [0x00000010]
    int NumResourceIndices;  // 0x02FC (0x0004) [0x0000000000000000]
    int bResetStaticMesh;    // 0x0300 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1239];

        return pClassPointer;
    };

    void GetNumVisibleFragments();
    void GetNumFragments();
    void IsFragmentVisible();
    void GetVisibleFragments();
    void SetStaticMesh();
};

UClass* UFracturedBaseComponent::pClassPointer = NULL;

// Class Engine.FracturedSkinnedMeshComponent
// 0x002C (0x0330 - 0x0304)
class UFracturedSkinnedMeshComponent : public UFracturedBaseComponent {
   public:
    struct FPointer
        ComponentSkinResources;  // 0x0304 (0x0008) [0x0000000000000000]
    TArray<struct FMatrix>
        FragmentTransforms;  // 0x030C (0x0010) [0x0000000000000000]
    TArray<class UFracturedStaticMeshComponent*>
        DependentComponents;   // 0x031C (0x0010) [0x0000000000000000]
    DWORD bBecameVisible : 1;  // 0x032C (0x0004) [0x0000000000000000]
                               // [0x00000001]
    DWORD bFragmentTransformsChanged : 1;  // 0x032C (0x0004)
                                           // [0x0000000000000000] [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1241];

        return pClassPointer;
    };
};

UClass* UFracturedSkinnedMeshComponent::pClassPointer = NULL;

// Class Engine.FracturedStaticMeshComponent
// 0x004C (0x0350 - 0x0304)
class UFracturedStaticMeshComponent : public UFracturedBaseComponent {
   public:
    TArray<unsigned char>
        FragmentNeighborsVisible;    // 0x0304 (0x0010) [0x0000000000000000]
    struct FBox VisibleBox;          // 0x0314 (0x001C) [0x0000000000000000]
    DWORD bUseSkinnedRendering : 1;  // 0x0330 (0x0004) [0x0000000000000000]
                                     // [0x00000001]
    DWORD bUseVisibleVertsForBounds : 1;  // 0x0330 (0x0004)
                                          // [0x0000000000000000] [0x00000002]
    DWORD bTopFragmentsRootNonDestroyable : 1;     // 0x0330 (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00000004]
    DWORD bBottomFragmentsRootNonDestroyable : 1;  // 0x0330 (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00000008]
    float
        TopBottomFragmentDistThreshold;  // 0x0334 (0x0004) [0x0000000000000000]
    class UMaterialInterface*
        LoseChunkOutsideMaterialOverride;  // 0x0338 (0x0008)
                                           // [0x0000000000000000]
    float FragmentBoundsMaxZ;  // 0x0340 (0x0004) [0x0000000000000000]
    float FragmentBoundsMinZ;  // 0x0344 (0x0004) [0x0000000000000000]
    class UFracturedSkinnedMeshComponent*
        SkinnedComponent;  // 0x0348 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1243];

        return pClassPointer;
    };

    void GetFracturedMeshPhysMaterial();
    void RecreatePhysState();
    void GetBoundaryHiddenFragments();
    void GetFragmentGroups();
    void GetCoreFragmentIndex();
    void GetFragmentAverageExteriorNormal();
    void GetFragmentBox();
    void IsNoPhysFragment();
    void IsRootFragment();
    void IsFragmentDestroyable();
    void SetVisibleFragments();
};

UClass* UFracturedStaticMeshComponent::pClassPointer = NULL;

// Class Engine.ImageBasedReflectionComponent
// 0x001C (0x02F8 - 0x02DC)
class UImageBasedReflectionComponent : public UStaticMeshComponent {
   public:
    DWORD bEnabled : 1;   // 0x02DC (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bTwoSided : 1;  // 0x02DC (0x0004) [0x0000000000000000] [0x00000002]
    class UTexture2D*
        ReflectionTexture;  // 0x02E0 (0x0008) [0x0000000000000000]
    struct FLinearColor
        ReflectionColor;  // 0x02E8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1245];

        return pClassPointer;
    };

    void OnUpdatePropertyReflectionColor();
    void UpdateImageReflectionParameters();
    void SetEnabled();
};

UClass* UImageBasedReflectionComponent::pClassPointer = NULL;

// Class Engine.InstancedStaticMeshComponent
// 0x0068 (0x0344 - 0x02DC)
class UInstancedStaticMeshComponent : public UStaticMeshComponent {
   public:
    TArray<struct FInstancedStaticMeshInstanceData>
        PerInstanceData;  // 0x02DC (0x0010) [0x0000000000000000]
    TArray<struct FInstancedStaticMeshInstanceData>
        PerInstanceSMData;    // 0x02EC (0x0010) [0x0000000000000000]
    int NumPendingLightmaps;  // 0x02FC (0x0004) [0x0000000000000000]
    int ComponentJoinKey;     // 0x0300 (0x0004) [0x0000000000000000]
    TArray<struct FInstancedStaticMeshMappingInfo>
        CachedMappings;             // 0x0304 (0x0010) [0x0000000000000000]
    int InstancingRandomSeed;       // 0x0314 (0x0004) [0x0000000000000000]
    int InstanceStartCullDistance;  // 0x0318 (0x0004) [0x0000000000000000]
    int InstanceEndCullDistance;    // 0x031C (0x0004) [0x0000000000000000]
    struct FBitArray_Mirror
        SelectedInstances;  // 0x0320 (0x0020) [0x0000000000000000]
    DWORD bDontResolveInstancedLightmaps : 1;  // 0x0340 (0x0004)
                                               // [0x0000000000000000]
                                               // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1247];

        return pClassPointer;
    };
};

UClass* UInstancedStaticMeshComponent::pClassPointer = NULL;

// Class Engine.SplineMeshComponent
// 0x0068 (0x0344 - 0x02DC)
class USplineMeshComponent : public UStaticMeshComponent {
   public:
    struct FSplineMeshParams
        SplineParams;                  // 0x02DC (0x0058) [0x0000000000000000]
    struct FVector SplineXDir;         // 0x0334 (0x000C) [0x0000000000000000]
    DWORD bSmoothInterpRollScale : 1;  // 0x0340 (0x0004) [0x0000000000000000]
                                       // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1249];

        return pClassPointer;
    };
};

UClass* USplineMeshComponent::pClassPointer = NULL;

// Class Engine.ApexAsset
// 0x0050 (0x00B0 - 0x0060)
class UApexAsset : public UObject {
   public:
    struct FString OriginalApexName;  // 0x0060 (0x0010) [0x0000000000000000]
    TArray<class UApexComponentBase*>
        ApexComponents;  // 0x0070 (0x0010) [0x0000000000000000]
    TArray<class UApexAsset*>
        NamedReferences;                 // 0x0080 (0x0010) [0x0000000000000000]
    struct FString SourceFilePath;       // 0x0090 (0x0010) [0x0000000000000000]
    struct FString SourceFileTimestamp;  // 0x00A0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1251];

        return pClassPointer;
    };
};

UClass* UApexAsset::pClassPointer = NULL;

// Class Engine.ApexClothingAsset
// 0x0078 (0x0128 - 0x00B0)
class UApexClothingAsset : public UApexAsset {
   public:
    TArray<struct FClothingLodInfo>
        LodMaterialInfo;         // 0x00B0 (0x0010) [0x0000000000000000]
    struct FPointer MApexAsset;  // 0x00C0 (0x0008) [0x0000000000000000]
    TArray<class UMaterialInterface*>
        Materials;  // 0x00C8 (0x0010) [0x0000000000000000]
    class UApexGenericAsset*
        ApexClothingLibrary;      // 0x00D8 (0x0008) [0x0000000000000000]
    DWORD bUseHardwareCloth : 1;  // 0x00E0 (0x0004) [0x0000000000000000]
                                  // [0x00000001]
    DWORD bFallbackSkinning : 1;  // 0x00E0 (0x0004) [0x0000000000000000]
                                  // [0x00000002]
    DWORD bSlowStart : 1;  // 0x00E0 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bRecomputeNormals : 1;  // 0x00E0 (0x0004) [0x0000000000000000]
                                  // [0x00000008]
    DWORD
        bAllowAdaptiveTargetFrequency : 1;  // 0x00E0 (0x0004)
                                            // [0x0000000000000000] [0x00000010]
    DWORD bResetAfterTeleport : 1;       // 0x00E0 (0x0004) [0x0000000000000000]
                                         // [0x00000020]
    DWORD bUseLocalSpaceSimulation : 1;  // 0x00E0 (0x0004) [0x0000000000000000]
                                         // [0x00000040]
    DWORD
        bHasUniqueAssetMaterialNames : 1;  // 0x00E0 (0x0004)
                                           // [0x0000000000000000] [0x00000080]
    DWORD IgnoreInitialTrigger : 1;     // 0x00E0 (0x0004) [0x0000000000000000]
                                        // [0x00000100]
    int UVChannelForTangentUpdate;      // 0x00E4 (0x0004) [0x0000000000000000]
    float MaxDistanceBlendTime;         // 0x00E8 (0x0004) [0x0000000000000000]
    float ContinuousRotationThreshold;  // 0x00EC (0x0004) [0x0000000000000000]
    float ContinuousDistanceThreshold;  // 0x00F0 (0x0004) [0x0000000000000000]
    float LodWeightsMaxDistance;        // 0x00F4 (0x0004) [0x0000000000000000]
    float LodWeightsDistanceWeight;     // 0x00F8 (0x0004) [0x0000000000000000]
    float LodWeightsBias;               // 0x00FC (0x0004) [0x0000000000000000]
    float LodWeightsBenefitsBias;       // 0x0100 (0x0004) [0x0000000000000000]
    float LODDecayTime;                 // 0x0104 (0x0004) [0x0000000000000000]
    class USoundCue* SoundOnMove;       // 0x0108 (0x0008) [0x0000000000000000]
    class USoundCue* SoundOnRest;       // 0x0110 (0x0008) [0x0000000000000000]
    class USoundCue* SoundWhileMoving;  // 0x0118 (0x0008) [0x0000000000000000]
    float SpeedThresholdOnMove;         // 0x0120 (0x0004) [0x0000000000000000]
    float SpeedThresholdOnRest;         // 0x0124 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1253];

        return pClassPointer;
    };
};

UClass* UApexClothingAsset::pClassPointer = NULL;

// Class Engine.ApexDestructibleAsset
// 0x014C (0x01FC - 0x00B0)
class UApexDestructibleAsset : public UApexAsset {
   public:
    struct FPointer MApexAsset;  // 0x00B0 (0x0008) [0x0000000000000000]
    TArray<class UMaterialInterface*>
        Materials;  // 0x00B8 (0x0010) [0x0000000000000000]
    TArray<class UFractureMaterial*>
        FractureMaterials;  // 0x00C8 (0x0010) [0x0000000000000000]
    DWORD bPlaySingleFractureMaterialEffect : 1;  // 0x00D8 (0x0004)
                                                  // [0x0000000000000000]
                                                  // [0x00000001]
    DWORD
        bHasUniqueAssetMaterialNames : 1;  // 0x00D8 (0x0004)
                                           // [0x0000000000000000] [0x00000002]
    DWORD bDynamic : 1;  // 0x00D8 (0x0004) [0x0000000000000000] [0x00000004]
    class UPhysicalMaterial*
        DefaultPhysMaterial;  // 0x00DC (0x0008) [0x0000000000000000]
    struct FPointer MDestructibleThumbnailComponent;  // 0x00E4 (0x0008)
                                                      // [0x0000000000000000]
    struct FString CrumbleEmitterName;  // 0x00EC (0x0010) [0x0000000000000000]
    struct FString DustEmitterName;     // 0x00FC (0x0010) [0x0000000000000000]
    struct FNxDestructibleParameters
        DestructibleParameters;  // 0x010C (0x00F0) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1255];

        return pClassPointer;
    };
};

UClass* UApexDestructibleAsset::pClassPointer = NULL;

// Class Engine.ApexGenericAsset
// 0x0018 (0x00C8 - 0x00B0)
class UApexGenericAsset : public UApexAsset {
   public:
    struct FPointer MApexAsset;  // 0x00B0 (0x0008) [0x0000000000000000]
    TArray<class UMaterialInterface*>
        Materials;  // 0x00B8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1257];

        return pClassPointer;
    };
};

UClass* UApexGenericAsset::pClassPointer = NULL;

// Class Engine.InterpFilter
// 0x0010 (0x0070 - 0x0060)
class UInterpFilter : public UObject {
   public:
    struct FString Caption;  // 0x0060 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1259];

        return pClassPointer;
    };
};

UClass* UInterpFilter::pClassPointer = NULL;

// Class Engine.InterpFilter_Classes
// 0x0018 (0x0088 - 0x0070)
class UInterpFilter_Classes : public UInterpFilter {
   public:
    class UClass* ClassToFilterBy;       // 0x0070 (0x0008) [0x0000000000000000]
    TArray<class UClass*> TrackClasses;  // 0x0078 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1261];

        return pClassPointer;
    };
};

UClass* UInterpFilter_Classes::pClassPointer = NULL;

// Class Engine.InterpFilter_Custom
// 0x0010 (0x0080 - 0x0070)
class UInterpFilter_Custom : public UInterpFilter {
   public:
    TArray<class UInterpGroup*>
        GroupsToInclude;  // 0x0070 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1263];

        return pClassPointer;
    };
};

UClass* UInterpFilter_Custom::pClassPointer = NULL;

// Class Engine.InterpGroup
// 0x0038 (0x0098 - 0x0060)
class UInterpGroup : public UObject {
   public:
    struct FPointer VfTable_FInterpEdInputInterface;  // 0x0060 (0x0008)
                                                      // [0x0000000000000000]
    TArray<class UInterpTrack*>
        InterpTracks;          // 0x0068 (0x0010) [0x0000000000000000]
    struct FName GroupName;    // 0x0078 (0x0008) [0x0000000000000000]
    struct FColor GroupColor;  // 0x0080 (0x0004) [0x0000000000000000]
    TArray<class UAnimSet*>
        GroupAnimSets;      // 0x0084 (0x0010) [0x0000000000000000]
    DWORD bCollapsed : 1;   // 0x0094 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bVisible : 1;     // 0x0094 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bIsFolder : 1;    // 0x0094 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bIsParented : 1;  // 0x0094 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bIsSelected : 1;  // 0x0094 (0x0004) [0x0000000000000000] [0x00000010]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1265];

        return pClassPointer;
    };
};

UClass* UInterpGroup::pClassPointer = NULL;

// Class Engine.InterpGroupAI
// 0x0014 (0x00AC - 0x0098)
class UInterpGroupAI : public UInterpGroup {
   public:
    class UClass* PreviewPawnClass;  // 0x0098 (0x0008) [0x0000000000000000]
    struct FName StageMarkGroup;     // 0x00A0 (0x0008) [0x0000000000000000]
    DWORD SnapToRootBoneLocationWhenFinished : 1;  // 0x00A8 (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00000001]
    DWORD bNoEncroachmentCheck : 1;    // 0x00A8 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD bDisableWorldCollision : 1;  // 0x00A8 (0x0004) [0x0000000000000000]
                                       // [0x00000004]
    DWORD bIgnoreLegacyHeightAdjust : 1;  // 0x00A8 (0x0004)
                                          // [0x0000000000000000] [0x00000008]
    DWORD bRecreatePreviewPawn : 1;    // 0x00A8 (0x0004) [0x0000000000000000]
                                       // [0x00000010]
    DWORD bRefreshStageMarkGroup : 1;  // 0x00A8 (0x0004) [0x0000000000000000]
                                       // [0x00000020]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1267];

        return pClassPointer;
    };
};

UClass* UInterpGroupAI::pClassPointer = NULL;

// Class Engine.InterpGroupCamera
// 0x004C (0x00E4 - 0x0098)
class UInterpGroupCamera : public UInterpGroup {
   public:
    class UCameraAnim* CameraAnimInst;  // 0x0098 (0x0008) [0x0000000000000000]
    struct FCameraPreviewInfo Target;   // 0x00A0 (0x0040) [0x0000000000000000]
    float CompressTolerance;            // 0x00E0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1269];

        return pClassPointer;
    };
};

UClass* UInterpGroupCamera::pClassPointer = NULL;

// Class Engine.InterpGroupDirector
// 0x0000 (0x0098 - 0x0098)
class UInterpGroupDirector : public UInterpGroup {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1271];

        return pClassPointer;
    };
};

UClass* UInterpGroupDirector::pClassPointer = NULL;

// Class Engine.InterpGroupInst
// 0x0028 (0x0088 - 0x0060)
class UInterpGroupInst : public UObject {
   public:
    class UInterpGroup* Group;  // 0x0060 (0x0008) [0x0000000000000000]
    class AActor* GroupActor;   // 0x0068 (0x0008) [0x0000000000000000]
    TArray<class UInterpTrackInst*>
        TrackInst;  // 0x0070 (0x0010) [0x0000000000000000]
    struct FPointer
        CachedCamOverridePostProcess;  // 0x0080 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1273];

        return pClassPointer;
    };
};

UClass* UInterpGroupInst::pClassPointer = NULL;

// Class Engine.InterpGroupInstAI
// 0x0020 (0x00A8 - 0x0088)
class UInterpGroupInstAI : public UInterpGroupInst {
   public:
    class UInterpGroupAI* AIGroup;    // 0x0088 (0x0008) [0x0000000000000000]
    unsigned char SavedPhysics;       // 0x0090 (0x0001) [0x0000000000000000]
    DWORD bSavedNoEncroachCheck : 1;  // 0x0094 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bSavedCollideActors : 1;    // 0x0094 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bSavedBlockActors : 1;      // 0x0094 (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    class APawn* PreviewPawn;         // 0x0098 (0x0008) [0x0000000000000000]
    class AActor* StageMarkActor;     // 0x00A0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1275];

        return pClassPointer;
    };
};

UClass* UInterpGroupInstAI::pClassPointer = NULL;

// Class Engine.InterpGroupInstCamera
// 0x0000 (0x0088 - 0x0088)
class UInterpGroupInstCamera : public UInterpGroupInst {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1277];

        return pClassPointer;
    };
};

UClass* UInterpGroupInstCamera::pClassPointer = NULL;

// Class Engine.InterpGroupInstDirector
// 0x0000 (0x0088 - 0x0088)
class UInterpGroupInstDirector : public UInterpGroupInst {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1279];

        return pClassPointer;
    };
};

UClass* UInterpGroupInstDirector::pClassPointer = NULL;

// Class Engine.InterpTrackBoolProp
// 0x0018 (0x00D8 - 0x00C0)
class UInterpTrackBoolProp : public UInterpTrack {
   public:
    TArray<struct FBoolTrackKey>
        BoolTrack;              // 0x00C0 (0x0010) [0x0000000000000000]
    struct FName PropertyName;  // 0x00D0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1281];

        return pClassPointer;
    };
};

UClass* UInterpTrackBoolProp::pClassPointer = NULL;

// Class Engine.InterpTrackDirector
// 0x0014 (0x00D4 - 0x00C0)
class UInterpTrackDirector : public UInterpTrack {
   public:
    TArray<struct FDirectorTrackCut>
        CutTrack;  // 0x00C0 (0x0010) [0x0000000000000000]
    DWORD
        bSimulateCameraCutsOnClients : 1;  // 0x00D0 (0x0004)
                                           // [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1283];

        return pClassPointer;
    };
};

UClass* UInterpTrackDirector::pClassPointer = NULL;

// Class Engine.InterpTrackEvent
// 0x0014 (0x00D4 - 0x00C0)
class UInterpTrackEvent : public UInterpTrack {
   public:
    TArray<struct FEventTrackKey>
        EventTrack;                      // 0x00C0 (0x0010) [0x0000000000000000]
    DWORD bFireEventsWhenForwards : 1;   // 0x00D0 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bFireEventsWhenBackwards : 1;  // 0x00D0 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bFireEventsWhenJumpingForwards : 1;  // 0x00D0 (0x0004)
                                               // [0x0000000000000000]
                                               // [0x00000004]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1285];

        return pClassPointer;
    };
};

UClass* UInterpTrackEvent::pClassPointer = NULL;

// Class Engine.InterpTrackFaceFX
// 0x0038 (0x00F8 - 0x00C0)
class UInterpTrackFaceFX : public UInterpTrack {
   public:
    TArray<class UFaceFXAnimSet*>
        FaceFXAnimSets;  // 0x00C0 (0x0010) [0x0000000000000000]
    TArray<struct FFaceFXTrackKey>
        FaceFXSeqs;  // 0x00D0 (0x0010) [0x0000000000000000]
    class UFaceFXAsset*
        CachedActorFXAsset;  // 0x00E0 (0x0008) [0x0000000000000000]
    TArray<struct FFaceFXSoundCueKey>
        FaceFXSoundCueKeys;  // 0x00E8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1287];

        return pClassPointer;
    };
};

UClass* UInterpTrackFaceFX::pClassPointer = NULL;

// Class Engine.InterpTrackFloatBase
// 0x0018 (0x00D8 - 0x00C0)
class UInterpTrackFloatBase : public UInterpTrack {
   public:
    struct FInterpCurveFloat
        FloatTrack;      // 0x00C0 (0x0014) [0x0000000000000000]
    float CurveTension;  // 0x00D4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1289];

        return pClassPointer;
    };
};

UClass* UInterpTrackFloatBase::pClassPointer = NULL;

// Class Engine.InterpTrackAnimControl
// 0x002C (0x0104 - 0x00D8)
class UInterpTrackAnimControl : public UInterpTrackFloatBase {
   public:
    TArray<class UAnimSet*> AnimSets;  // 0x00D8 (0x0010) [0x0000000000000000]
    struct FName SlotName;             // 0x00E8 (0x0008) [0x0000000000000000]
    TArray<struct FAnimControlTrackKey>
        AnimSeqs;                  // 0x00F0 (0x0010) [0x0000000000000000]
    DWORD bEnableRootMotion : 1;   // 0x0100 (0x0004) [0x0000000000000000]
                                   // [0x00000001]
    DWORD bSkipAnimNotifiers : 1;  // 0x0100 (0x0004) [0x0000000000000000]
                                   // [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1291];

        return pClassPointer;
    };
};

UClass* UInterpTrackAnimControl::pClassPointer = NULL;

// Class Engine.InterpTrackFade
// 0x0004 (0x00DC - 0x00D8)
class UInterpTrackFade : public UInterpTrackFloatBase {
   public:
    DWORD
        bPersistFade : 1;  // 0x00D8 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1293];

        return pClassPointer;
    };
};

UClass* UInterpTrackFade::pClassPointer = NULL;

// Class Engine.InterpTrackFloatMaterialParam
// 0x0024 (0x00FC - 0x00D8)
class UInterpTrackFloatMaterialParam : public UInterpTrackFloatBase {
   public:
    TArray<struct FMaterialReferenceList>
        Materials;                       // 0x00D8 (0x0010) [0x0000000000000000]
    class UMaterialInterface* Material;  // 0x00E8 (0x0008) [0x0000000000000000]
    struct FName ParamName;              // 0x00F0 (0x0008) [0x0000000000000000]
    DWORD bNeedsMaterialRefsUpdate : 1;  // 0x00F8 (0x0004) [0x0000000000000000]
                                         // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1295];

        return pClassPointer;
    };
};

UClass* UInterpTrackFloatMaterialParam::pClassPointer = NULL;

// Class Engine.InterpTrackFloatParticleParam
// 0x0008 (0x00E0 - 0x00D8)
class UInterpTrackFloatParticleParam : public UInterpTrackFloatBase {
   public:
    struct FName ParamName;  // 0x00D8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1297];

        return pClassPointer;
    };
};

UClass* UInterpTrackFloatParticleParam::pClassPointer = NULL;

// Class Engine.InterpTrackFloatProp
// 0x0008 (0x00E0 - 0x00D8)
class UInterpTrackFloatProp : public UInterpTrackFloatBase {
   public:
    struct FName PropertyName;  // 0x00D8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1299];

        return pClassPointer;
    };
};

UClass* UInterpTrackFloatProp::pClassPointer = NULL;

// Class Engine.InterpTrackMorphWeight
// 0x0008 (0x00E0 - 0x00D8)
class UInterpTrackMorphWeight : public UInterpTrackFloatBase {
   public:
    struct FName MorphNodeName;  // 0x00D8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1301];

        return pClassPointer;
    };
};

UClass* UInterpTrackMorphWeight::pClassPointer = NULL;

// Class Engine.InterpTrackMoveAxis
// 0x0014 (0x00EC - 0x00D8)
class UInterpTrackMoveAxis : public UInterpTrackFloatBase {
   public:
    unsigned char MoveAxis;  // 0x00D8 (0x0001) [0x0000000000000000]
    struct FInterpLookupTrack
        LookupTrack;  // 0x00DC (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1303];

        return pClassPointer;
    };
};

UClass* UInterpTrackMoveAxis::pClassPointer = NULL;

// Class Engine.InterpTrackSkelControlScale
// 0x0008 (0x00E0 - 0x00D8)
class UInterpTrackSkelControlScale : public UInterpTrackFloatBase {
   public:
    struct FName SkelControlName;  // 0x00D8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1305];

        return pClassPointer;
    };
};

UClass* UInterpTrackSkelControlScale::pClassPointer = NULL;

// Class Engine.InterpTrackSkelControlStrength
// 0x0008 (0x00E0 - 0x00D8)
class UInterpTrackSkelControlStrength : public UInterpTrackFloatBase {
   public:
    struct FName SkelControlName;  // 0x00D8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1307];

        return pClassPointer;
    };
};

UClass* UInterpTrackSkelControlStrength::pClassPointer = NULL;

// Class Engine.InterpTrackSlomo
// 0x0000 (0x00D8 - 0x00D8)
class UInterpTrackSlomo : public UInterpTrackFloatBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1309];

        return pClassPointer;
    };
};

UClass* UInterpTrackSlomo::pClassPointer = NULL;

// Class Engine.InterpTrackHeadTracking
// 0x0054 (0x0114 - 0x00C0)
class UInterpTrackHeadTracking : public UInterpTrack {
   public:
    TArray<struct FHeadTrackingKey>
        HeadTrackingTrack;  // 0x00C0 (0x0010) [0x0000000000000000]
    TArray<struct FName>
        TrackControllerName;        // 0x00D0 (0x0010) [0x0000000000000000]
    float LookAtActorRadius;        // 0x00E0 (0x0004) [0x0000000000000000]
    DWORD bDisableBeyondLimit : 1;  // 0x00E4 (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    DWORD
        bLookAtPawns : 1;   // 0x00E4 (0x0004) [0x0000000000000000] [0x00000002]
    float MaxLookAtTime;    // 0x00E8 (0x0004) [0x0000000000000000]
    float MinLookAtTime;    // 0x00EC (0x0004) [0x0000000000000000]
    float MaxInterestTime;  // 0x00F0 (0x0004) [0x0000000000000000]
    TArray<class UClass*>
        ActorClassesToLookAt;  // 0x00F4 (0x0010) [0x0000000000000000]
    TArray<struct FName>
        TargetBoneNames;  // 0x0104 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1311];

        return pClassPointer;
    };
};

UClass* UInterpTrackHeadTracking::pClassPointer = NULL;

// Class Engine.InterpTrackLinearColorBase
// 0x0018 (0x00D8 - 0x00C0)
class UInterpTrackLinearColorBase : public UInterpTrack {
   public:
    struct FInterpCurveLinearColor
        LinearColorTrack;  // 0x00C0 (0x0014) [0x0000000000000000]
    float CurveTension;    // 0x00D4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1313];

        return pClassPointer;
    };
};

UClass* UInterpTrackLinearColorBase::pClassPointer = NULL;

// Class Engine.InterpTrackLinearColorProp
// 0x0008 (0x00E0 - 0x00D8)
class UInterpTrackLinearColorProp : public UInterpTrackLinearColorBase {
   public:
    struct FName PropertyName;  // 0x00D8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1315];

        return pClassPointer;
    };
};

UClass* UInterpTrackLinearColorProp::pClassPointer = NULL;

// Class Engine.InterpTrackMove
// 0x004E (0x010E - 0x00C0)
class UInterpTrackMove : public UInterpTrack {
   public:
    struct FInterpCurveVector PosTrack;  // 0x00C0 (0x0014) [0x0000000000000000]
    struct FInterpCurveVector
        EulerTrack;  // 0x00D4 (0x0014) [0x0000000000000000]
    struct FInterpLookupTrack
        LookupTrack;                  // 0x00E8 (0x0010) [0x0000000000000000]
    struct FName LookAtGroupName;     // 0x00F8 (0x0008) [0x0000000000000000]
    float LinCurveTension;            // 0x0100 (0x0004) [0x0000000000000000]
    float AngCurveTension;            // 0x0104 (0x0004) [0x0000000000000000]
    DWORD bUseQuatInterpolation : 1;  // 0x0108 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bShowArrowAtKeys : 1;       // 0x0108 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bDisableMovement : 1;       // 0x0108 (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    DWORD bShowTranslationOnCurveEd : 1;  // 0x0108 (0x0004)
                                          // [0x0000000000000000] [0x00000008]
    DWORD bShowRotationOnCurveEd : 1;  // 0x0108 (0x0004) [0x0000000000000000]
                                       // [0x00000010]
    DWORD
        bHide3DTrack : 1;  // 0x0108 (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bUseRawActorTMforRelativeToInitial : 1;  // 0x0108 (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00000040]
    unsigned char MoveFrame;  // 0x010C (0x0001) [0x0000000000000000]
    unsigned char RotMode;    // 0x010D (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1317];

        return pClassPointer;
    };
};

UClass* UInterpTrackMove::pClassPointer = NULL;

// Class Engine.InterpTrackNotify
// 0x0030 (0x00F0 - 0x00C0)
class UInterpTrackNotify : public UInterpTrack {
   public:
    class UAnimNodeSequence* Node;       // 0x00C0 (0x0008) [0x0000000000000000]
    struct FName ParentNodeName;         // 0x00C8 (0x0008) [0x0000000000000000]
    class UAnimSequence* OuterSequence;  // 0x00D0 (0x0008) [0x0000000000000000]
    class UAnimSet* OuterSet;            // 0x00D8 (0x0008) [0x0000000000000000]
    TArray<struct FNotifyTrackKey>
        NotifyTrack;  // 0x00E0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1319];

        return pClassPointer;
    };
};

UClass* UInterpTrackNotify::pClassPointer = NULL;

// Class Engine.InterpTrackParticleReplay
// 0x0018 (0x00D8 - 0x00C0)
class UInterpTrackParticleReplay : public UInterpTrack {
   public:
    TArray<struct FParticleReplayTrackKey>
        TrackKeys;                 // 0x00C0 (0x0010) [0x0000000000000000]
    DWORD bIsCapturingReplay : 1;  // 0x00D0 (0x0004) [0x0000000000000000]
                                   // [0x00000001]
    float FixedTimeStep;           // 0x00D4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1321];

        return pClassPointer;
    };
};

UClass* UInterpTrackParticleReplay::pClassPointer = NULL;

// Class Engine.InterpTrackToggle
// 0x0014 (0x00D4 - 0x00C0)
class UInterpTrackToggle : public UInterpTrack {
   public:
    TArray<struct FToggleTrackKey>
        ToggleTrack;  // 0x00C0 (0x0010) [0x0000000000000000]
    DWORD bActivateSystemEachUpdate : 1;  // 0x00D0 (0x0004)
                                          // [0x0000000000000000] [0x00000001]
    DWORD
        bActivateWithJustAttachedFlag : 1;  // 0x00D0 (0x0004)
                                            // [0x0000000000000000] [0x00000002]
    DWORD bFireEventsWhenForwards : 1;   // 0x00D0 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD bFireEventsWhenBackwards : 1;  // 0x00D0 (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    DWORD bFireEventsWhenJumpingForwards : 1;  // 0x00D0 (0x0004)
                                               // [0x0000000000000000]
                                               // [0x00000010]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1323];

        return pClassPointer;
    };
};

UClass* UInterpTrackToggle::pClassPointer = NULL;

// Class Engine.InterpTrackVectorBase
// 0x0018 (0x00D8 - 0x00C0)
class UInterpTrackVectorBase : public UInterpTrack {
   public:
    struct FInterpCurveVector
        VectorTrack;     // 0x00C0 (0x0014) [0x0000000000000000]
    float CurveTension;  // 0x00D4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1325];

        return pClassPointer;
    };
};

UClass* UInterpTrackVectorBase::pClassPointer = NULL;

// Class Engine.InterpTrackAudioMaster
// 0x0000 (0x00D8 - 0x00D8)
class UInterpTrackAudioMaster : public UInterpTrackVectorBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1327];

        return pClassPointer;
    };
};

UClass* UInterpTrackAudioMaster::pClassPointer = NULL;

// Class Engine.InterpTrackColorProp
// 0x0008 (0x00E0 - 0x00D8)
class UInterpTrackColorProp : public UInterpTrackVectorBase {
   public:
    struct FName PropertyName;  // 0x00D8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1329];

        return pClassPointer;
    };
};

UClass* UInterpTrackColorProp::pClassPointer = NULL;

// Class Engine.InterpTrackColorScale
// 0x0000 (0x00D8 - 0x00D8)
class UInterpTrackColorScale : public UInterpTrackVectorBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1331];

        return pClassPointer;
    };
};

UClass* UInterpTrackColorScale::pClassPointer = NULL;

// Class Engine.InterpTrackSound
// 0x0014 (0x00EC - 0x00D8)
class UInterpTrackSound : public UInterpTrackVectorBase {
   public:
    TArray<struct FSoundTrackKey>
        Sounds;                // 0x00D8 (0x0010) [0x0000000000000000]
    DWORD bPlayOnReverse : 1;  // 0x00E8 (0x0004) [0x0000000000000000]
                               // [0x00000001]
    DWORD bContinueSoundOnMatineeEnd : 1;  // 0x00E8 (0x0004)
                                           // [0x0000000000000000] [0x00000002]
    DWORD bSuppressSubtitles : 1;  // 0x00E8 (0x0004) [0x0000000000000000]
                                   // [0x00000004]
    DWORD bTreatAsDialogue : 1;    // 0x00E8 (0x0004) [0x0000000000000000]
                                   // [0x00000008]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1333];

        return pClassPointer;
    };
};

UClass* UInterpTrackSound::pClassPointer = NULL;

// Class Engine.InterpTrackVectorMaterialParam
// 0x0024 (0x00FC - 0x00D8)
class UInterpTrackVectorMaterialParam : public UInterpTrackVectorBase {
   public:
    TArray<struct FMaterialReferenceList>
        Materials;                       // 0x00D8 (0x0010) [0x0000000000000000]
    class UMaterialInterface* Material;  // 0x00E8 (0x0008) [0x0000000000000000]
    struct FName ParamName;              // 0x00F0 (0x0008) [0x0000000000000000]
    DWORD bNeedsMaterialRefsUpdate : 1;  // 0x00F8 (0x0004) [0x0000000000000000]
                                         // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1335];

        return pClassPointer;
    };
};

UClass* UInterpTrackVectorMaterialParam::pClassPointer = NULL;

// Class Engine.InterpTrackVectorProp
// 0x0008 (0x00E0 - 0x00D8)
class UInterpTrackVectorProp : public UInterpTrackVectorBase {
   public:
    struct FName PropertyName;  // 0x00D8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1337];

        return pClassPointer;
    };
};

UClass* UInterpTrackVectorProp::pClassPointer = NULL;

// Class Engine.InterpTrackVisibility
// 0x0014 (0x00D4 - 0x00C0)
class UInterpTrackVisibility : public UInterpTrack {
   public:
    TArray<struct FVisibilityTrackKey>
        VisibilityTrack;                 // 0x00C0 (0x0010) [0x0000000000000000]
    DWORD bFireEventsWhenForwards : 1;   // 0x00D0 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bFireEventsWhenBackwards : 1;  // 0x00D0 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bFireEventsWhenJumpingForwards : 1;  // 0x00D0 (0x0004)
                                               // [0x0000000000000000]
                                               // [0x00000004]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1339];

        return pClassPointer;
    };
};

UClass* UInterpTrackVisibility::pClassPointer = NULL;

// Class Engine.InterpTrackInst
// 0x0000 (0x0060 - 0x0060)
class UInterpTrackInst : public UObject {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1341];

        return pClassPointer;
    };
};

UClass* UInterpTrackInst::pClassPointer = NULL;

// Class Engine.InterpTrackInstAnimControl
// 0x001C (0x007C - 0x0060)
class UInterpTrackInstAnimControl : public UInterpTrackInst {
   public:
    float LastUpdatePosition;      // 0x0060 (0x0004) [0x0000000000000000]
    struct FVector InitPosition;   // 0x0064 (0x000C) [0x0000000000000000]
    struct FRotator InitRotation;  // 0x0070 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1343];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstAnimControl::pClassPointer = NULL;

// Class Engine.InterpTrackInstAudioMaster
// 0x0000 (0x0060 - 0x0060)
class UInterpTrackInstAudioMaster : public UInterpTrackInst {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1345];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstAudioMaster::pClassPointer = NULL;

// Class Engine.InterpTrackInstColorScale
// 0x0000 (0x0060 - 0x0060)
class UInterpTrackInstColorScale : public UInterpTrackInst {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1347];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstColorScale::pClassPointer = NULL;

// Class Engine.InterpTrackInstDirector
// 0x000C (0x006C - 0x0060)
class UInterpTrackInstDirector : public UInterpTrackInst {
   public:
    class AActor* OldViewTarget;  // 0x0060 (0x0008) [0x0000000000000000]
    struct FRenderingPerformanceOverrides
        OldRenderingOverrides;  // 0x0068 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1349];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstDirector::pClassPointer = NULL;

// Class Engine.InterpTrackInstEvent
// 0x0004 (0x0064 - 0x0060)
class UInterpTrackInstEvent : public UInterpTrackInst {
   public:
    float LastUpdatePosition;  // 0x0060 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1351];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstEvent::pClassPointer = NULL;

// Class Engine.InterpTrackInstFaceFX
// 0x0008 (0x0068 - 0x0060)
class UInterpTrackInstFaceFX : public UInterpTrackInst {
   public:
    DWORD
        bFirstUpdate : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000001]
    float LastUpdatePosition;  // 0x0064 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1353];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstFaceFX::pClassPointer = NULL;

// Class Engine.InterpTrackInstFade
// 0x0000 (0x0060 - 0x0060)
class UInterpTrackInstFade : public UInterpTrackInst {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1355];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstFade::pClassPointer = NULL;

// Class Engine.InterpTrackInstFloatMaterialParam
// 0x0018 (0x0078 - 0x0060)
class UInterpTrackInstFloatMaterialParam : public UInterpTrackInst {
   public:
    TArray<struct FFloatMaterialParamMICData>
        MICInfos;  // 0x0060 (0x0010) [0x0000000000000000]
    class UInterpTrackFloatMaterialParam*
        InstancedTrack;  // 0x0070 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1357];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstFloatMaterialParam::pClassPointer = NULL;

// Class Engine.InterpTrackInstFloatParticleParam
// 0x0004 (0x0064 - 0x0060)
class UInterpTrackInstFloatParticleParam : public UInterpTrackInst {
   public:
    float ResetFloat;  // 0x0060 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1359];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstFloatParticleParam::pClassPointer = NULL;

// Class Engine.InterpTrackInstHeadTracking
// 0x0068 (0x00C8 - 0x0060)
class UInterpTrackInstHeadTracking : public UInterpTrackInst {
   public:
    unsigned char Action;  // 0x0060 (0x0001) [0x0000000000000000]
    unsigned char UnknownData00
        [0x48];  // 0x0064 (0x0048) UNKNOWN PROPERTY: MapProperty
                 // Engine.InterpTrackInstHeadTracking.CurrentActorMap
    class USkeletalMeshComponent* Mesh;  // 0x00AC (0x0008) [0x0000000000000000]
    TArray<class USkelControlLookAt*>
        TrackControls;         // 0x00B4 (0x0010) [0x0000000000000000]
    float LastUpdatePosition;  // 0x00C4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1361];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstHeadTracking::pClassPointer = NULL;

// Class Engine.InterpTrackInstMorphWeight
// 0x0000 (0x0060 - 0x0060)
class UInterpTrackInstMorphWeight : public UInterpTrackInst {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1363];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstMorphWeight::pClassPointer = NULL;

// Class Engine.InterpTrackInstMove
// 0x0070 (0x00D0 - 0x0060)
class UInterpTrackInstMove : public UInterpTrackInst {
   public:
    struct FVector ResetLocation;      // 0x0060 (0x000C) [0x0000000000000000]
    struct FRotator ResetRotation;     // 0x006C (0x000C) [0x0000000000000000]
    unsigned char UnknownData00[0x8];  // 0x0078 (0x0008) MISSED OFFSET
    struct FMatrix InitialTM;          // 0x0080 (0x0040) [0x0000000000000000]
    struct FQuat InitialQuat;          // 0x00C0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1365];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstMove::pClassPointer = NULL;

// Class Engine.InterpTrackInstNotify
// 0x0004 (0x0064 - 0x0060)
class UInterpTrackInstNotify : public UInterpTrackInst {
   public:
    float LastUpdatePosition;  // 0x0060 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1367];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstNotify::pClassPointer = NULL;

// Class Engine.InterpTrackInstParticleReplay
// 0x0004 (0x0064 - 0x0060)
class UInterpTrackInstParticleReplay : public UInterpTrackInst {
   public:
    float LastUpdatePosition;  // 0x0060 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1369];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstParticleReplay::pClassPointer = NULL;

// Class Engine.InterpTrackInstProperty
// 0x0010 (0x0070 - 0x0060)
class UInterpTrackInstProperty : public UInterpTrackInst {
   public:
    class UFunction*
        PropertyUpdateCallback;  // 0x0060 (0x0008) [0x0000000000000000]
    class UObject*
        PropertyOuterObjectInst;  // 0x0068 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1371];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstProperty::pClassPointer = NULL;

// Class Engine.InterpTrackInstBoolProp
// 0x0010 (0x0080 - 0x0070)
class UInterpTrackInstBoolProp : public UInterpTrackInstProperty {
   public:
    struct FPointer BoolProp;  // 0x0070 (0x0008) [0x0000000000000000]
    int BitMask;               // 0x0078 (0x0004) [0x0000000000000000]
    DWORD ResetBool : 1;  // 0x007C (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1373];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstBoolProp::pClassPointer = NULL;

// Class Engine.InterpTrackInstColorProp
// 0x000C (0x007C - 0x0070)
class UInterpTrackInstColorProp : public UInterpTrackInstProperty {
   public:
    struct FPointer ColorProp;  // 0x0070 (0x0008) [0x0000000000000000]
    struct FColor ResetColor;   // 0x0078 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1375];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstColorProp::pClassPointer = NULL;

// Class Engine.InterpTrackInstFloatProp
// 0x0014 (0x0084 - 0x0070)
class UInterpTrackInstFloatProp : public UInterpTrackInstProperty {
   public:
    struct FPointer FloatProp;         // 0x0070 (0x0008) [0x0000000000000000]
    float ResetFloat;                  // 0x0078 (0x0004) [0x0000000000000000]
    struct FPointer DistributionProp;  // 0x007C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1377];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstFloatProp::pClassPointer = NULL;

// Class Engine.InterpTrackInstLinearColorProp
// 0x0018 (0x0088 - 0x0070)
class UInterpTrackInstLinearColorProp : public UInterpTrackInstProperty {
   public:
    struct FPointer ColorProp;       // 0x0070 (0x0008) [0x0000000000000000]
    struct FLinearColor ResetColor;  // 0x0078 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1379];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstLinearColorProp::pClassPointer = NULL;

// Class Engine.InterpTrackInstVectorProp
// 0x0014 (0x0084 - 0x0070)
class UInterpTrackInstVectorProp : public UInterpTrackInstProperty {
   public:
    struct FPointer VectorProp;  // 0x0070 (0x0008) [0x0000000000000000]
    struct FVector ResetVector;  // 0x0078 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1381];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstVectorProp::pClassPointer = NULL;

// Class Engine.InterpTrackInstSkelControlScale
// 0x0000 (0x0060 - 0x0060)
class UInterpTrackInstSkelControlScale : public UInterpTrackInst {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1383];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstSkelControlScale::pClassPointer = NULL;

// Class Engine.InterpTrackInstSkelControlStrength
// 0x0004 (0x0064 - 0x0060)
class UInterpTrackInstSkelControlStrength : public UInterpTrackInst {
   public:
    DWORD bSavedControlledByAnimMetaData : 1;  // 0x0060 (0x0004)
                                               // [0x0000000000000000]
                                               // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1385];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstSkelControlStrength::pClassPointer = NULL;

// Class Engine.InterpTrackInstSlomo
// 0x0004 (0x0064 - 0x0060)
class UInterpTrackInstSlomo : public UInterpTrackInst {
   public:
    float OldTimeDilation;  // 0x0060 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1387];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstSlomo::pClassPointer = NULL;

// Class Engine.InterpTrackInstSound
// 0x000C (0x006C - 0x0060)
class UInterpTrackInstSound : public UInterpTrackInst {
   public:
    float LastUpdatePosition;  // 0x0060 (0x0004) [0x0000000000000000]
    class UAudioComponent*
        PlayAudioComp;  // 0x0064 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1389];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstSound::pClassPointer = NULL;

// Class Engine.InterpTrackInstToggle
// 0x000C (0x006C - 0x0060)
class UInterpTrackInstToggle : public UInterpTrackInst {
   public:
    unsigned char Action;         // 0x0060 (0x0001) [0x0000000000000000]
    float LastUpdatePosition;     // 0x0064 (0x0004) [0x0000000000000000]
    DWORD bSavedActiveState : 1;  // 0x0068 (0x0004) [0x0000000000000000]
                                  // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1391];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstToggle::pClassPointer = NULL;

// Class Engine.InterpTrackInstVectorMaterialParam
// 0x0018 (0x0078 - 0x0060)
class UInterpTrackInstVectorMaterialParam : public UInterpTrackInst {
   public:
    TArray<struct FVectorMaterialParamMICData>
        MICInfos;  // 0x0060 (0x0010) [0x0000000000000000]
    class UInterpTrackVectorMaterialParam*
        InstancedTrack;  // 0x0070 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1393];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstVectorMaterialParam::pClassPointer = NULL;

// Class Engine.InterpTrackInstVisibility
// 0x0008 (0x0068 - 0x0060)
class UInterpTrackInstVisibility : public UInterpTrackInst {
   public:
    unsigned char Action;      // 0x0060 (0x0001) [0x0000000000000000]
    float LastUpdatePosition;  // 0x0064 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1395];

        return pClassPointer;
    };
};

UClass* UInterpTrackInstVisibility::pClassPointer = NULL;

// Class Engine.MaterialExpression
// 0x0058 (0x00B8 - 0x0060)
class UMaterialExpression : public UObject {
   public:
    int EditorX;                       // 0x0060 (0x0004) [0x0000000000000000]
    int EditorY;                       // 0x0064 (0x0004) [0x0000000000000000]
    int MaterialExpressionEditorX;     // 0x0068 (0x0004) [0x0000000000000000]
    int MaterialExpressionEditorY;     // 0x006C (0x0004) [0x0000000000000000]
    DWORD bRealtimePreview : 1;        // 0x0070 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bNeedToUpdatePreview : 1;    // 0x0070 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD bIsParameterExpression : 1;  // 0x0070 (0x0004) [0x0000000000000000]
                                       // [0x00000004]
    DWORD bShowOutputNameOnPin : 1;    // 0x0070 (0x0004) [0x0000000000000000]
                                       // [0x00000008]
    DWORD bHidePreviewWindow : 1;      // 0x0070 (0x0004) [0x0000000000000000]
                                       // [0x00000010]
    DWORD bShowInputs : 1;  // 0x0070 (0x0004) [0x0000000000000000] [0x00000020]
    DWORD
        bShowOutputs : 1;  // 0x0070 (0x0004) [0x0000000000000000] [0x00000040]
    DWORD bUsedByStaticParameterSet : 1;  // 0x0070 (0x0004)
                                          // [0x0000000000000000] [0x00000080]
    class UMaterial* Material;          // 0x0074 (0x0008) [0x0000000000000000]
    class UMaterialFunction* Function;  // 0x007C (0x0008) [0x0000000000000000]
    struct FString Desc;                // 0x0084 (0x0010) [0x0000000000000000]
    struct FColor BorderColor;          // 0x0094 (0x0004) [0x0000000000000000]
    TArray<struct FName>
        MenuCategories;  // 0x0098 (0x0010) [0x0000000000000000]
    TArray<struct FExpressionOutput>
        Outputs;  // 0x00A8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1397];

        return pClassPointer;
    };
};

UClass* UMaterialExpression::pClassPointer = NULL;

// Class Engine.MaterialExpressionAbs
// 0x0034 (0x00EC - 0x00B8)
class UMaterialExpressionAbs : public UMaterialExpression {
   public:
    struct FExpressionInput Input;  // 0x00B8 (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1399];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionAbs::pClassPointer = NULL;

// Class Engine.MaterialExpressionActorWorldPosition
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionActorWorldPosition : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1401];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionActorWorldPosition::pClassPointer = NULL;

// Class Engine.MaterialExpressionAdd
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionAdd : public UMaterialExpression {
   public:
    struct FExpressionInput A;  // 0x00B8 (0x0034) [0x0000000000000000]
    struct FExpressionInput B;  // 0x00EC (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1403];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionAdd::pClassPointer = NULL;

// Class Engine.MaterialExpressionAppendVector
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionAppendVector : public UMaterialExpression {
   public:
    struct FExpressionInput A;  // 0x00B8 (0x0034) [0x0000000000000000]
    struct FExpressionInput B;  // 0x00EC (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1405];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionAppendVector::pClassPointer = NULL;

// Class Engine.MaterialExpressionBumpOffset
// 0x00A4 (0x015C - 0x00B8)
class UMaterialExpressionBumpOffset : public UMaterialExpression {
   public:
    struct FExpressionInput Coordinate;  // 0x00B8 (0x0034) [0x0000000000000000]
    struct FExpressionInput Height;      // 0x00EC (0x0034) [0x0000000000000000]
    struct FExpressionInput
        HeightRatioInput;  // 0x0120 (0x0034) [0x0000000000000000]
    float HeightRatio;     // 0x0154 (0x0004) [0x0000000000000000]
    float ReferencePlane;  // 0x0158 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1407];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionBumpOffset::pClassPointer = NULL;

// Class Engine.MaterialExpressionCameraVector
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionCameraVector : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1409];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionCameraVector::pClassPointer = NULL;

// Class Engine.MaterialExpressionCameraWorldPosition
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionCameraWorldPosition : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1411];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionCameraWorldPosition::pClassPointer = NULL;

// Class Engine.MaterialExpressionCeil
// 0x0034 (0x00EC - 0x00B8)
class UMaterialExpressionCeil : public UMaterialExpression {
   public:
    struct FExpressionInput Input;  // 0x00B8 (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1413];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionCeil::pClassPointer = NULL;

// Class Engine.MaterialExpressionClamp
// 0x009C (0x0154 - 0x00B8)
class UMaterialExpressionClamp : public UMaterialExpression {
   public:
    struct FExpressionInput Input;  // 0x00B8 (0x0034) [0x0000000000000000]
    struct FExpressionInput Min;    // 0x00EC (0x0034) [0x0000000000000000]
    struct FExpressionInput Max;    // 0x0120 (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1415];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionClamp::pClassPointer = NULL;

// Class Engine.MaterialExpressionComment
// 0x0020 (0x00D8 - 0x00B8)
class UMaterialExpressionComment : public UMaterialExpression {
   public:
    int PosX;             // 0x00B8 (0x0004) [0x0000000000000000]
    int PosY;             // 0x00BC (0x0004) [0x0000000000000000]
    int SizeX;            // 0x00C0 (0x0004) [0x0000000000000000]
    int SizeY;            // 0x00C4 (0x0004) [0x0000000000000000]
    struct FString Text;  // 0x00C8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1417];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionComment::pClassPointer = NULL;

// Class Engine.MaterialExpressionComponentMask
// 0x0038 (0x00F0 - 0x00B8)
class UMaterialExpressionComponentMask : public UMaterialExpression {
   public:
    struct FExpressionInput Input;  // 0x00B8 (0x0034) [0x0000000000000000]
    DWORD R : 1;  // 0x00EC (0x0004) [0x0000000000000000] [0x00000001]
    DWORD G : 1;  // 0x00EC (0x0004) [0x0000000000000000] [0x00000002]
    DWORD B : 1;  // 0x00EC (0x0004) [0x0000000000000000] [0x00000004]
    DWORD A : 1;  // 0x00EC (0x0004) [0x0000000000000000] [0x00000008]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1419];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionComponentMask::pClassPointer = NULL;

// Class Engine.MaterialExpressionConstant
// 0x0004 (0x00BC - 0x00B8)
class UMaterialExpressionConstant : public UMaterialExpression {
   public:
    float R;  // 0x00B8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1421];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionConstant::pClassPointer = NULL;

// Class Engine.MaterialExpressionConstant2Vector
// 0x0008 (0x00C0 - 0x00B8)
class UMaterialExpressionConstant2Vector : public UMaterialExpression {
   public:
    float R;  // 0x00B8 (0x0004) [0x0000000000000000]
    float G;  // 0x00BC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1423];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionConstant2Vector::pClassPointer = NULL;

// Class Engine.MaterialExpressionConstant3Vector
// 0x000C (0x00C4 - 0x00B8)
class UMaterialExpressionConstant3Vector : public UMaterialExpression {
   public:
    float R;  // 0x00B8 (0x0004) [0x0000000000000000]
    float G;  // 0x00BC (0x0004) [0x0000000000000000]
    float B;  // 0x00C0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1425];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionConstant3Vector::pClassPointer = NULL;

// Class Engine.MaterialExpressionConstant4Vector
// 0x0010 (0x00C8 - 0x00B8)
class UMaterialExpressionConstant4Vector : public UMaterialExpression {
   public:
    float R;  // 0x00B8 (0x0004) [0x0000000000000000]
    float G;  // 0x00BC (0x0004) [0x0000000000000000]
    float B;  // 0x00C0 (0x0004) [0x0000000000000000]
    float A;  // 0x00C4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1427];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionConstant4Vector::pClassPointer = NULL;

// Class Engine.MaterialExpressionConstantBiasScale
// 0x003C (0x00F4 - 0x00B8)
class UMaterialExpressionConstantBiasScale : public UMaterialExpression {
   public:
    struct FExpressionInput Input;  // 0x00B8 (0x0034) [0x0000000000000000]
    float Bias;                     // 0x00EC (0x0004) [0x0000000000000000]
    float Scale;                    // 0x00F0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1429];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionConstantBiasScale::pClassPointer = NULL;

// Class Engine.MaterialExpressionConstantClamp
// 0x003C (0x00F4 - 0x00B8)
class UMaterialExpressionConstantClamp : public UMaterialExpression {
   public:
    struct FExpressionInput Input;  // 0x00B8 (0x0034) [0x0000000000000000]
    float Min;                      // 0x00EC (0x0004) [0x0000000000000000]
    float Max;                      // 0x00F0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1431];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionConstantClamp::pClassPointer = NULL;

// Class Engine.MaterialExpressionCosine
// 0x0038 (0x00F0 - 0x00B8)
class UMaterialExpressionCosine : public UMaterialExpression {
   public:
    struct FExpressionInput Input;  // 0x00B8 (0x0034) [0x0000000000000000]
    float Period;                   // 0x00EC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1433];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionCosine::pClassPointer = NULL;

// Class Engine.MaterialExpressionCrossProduct
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionCrossProduct : public UMaterialExpression {
   public:
    struct FExpressionInput A;  // 0x00B8 (0x0034) [0x0000000000000000]
    struct FExpressionInput B;  // 0x00EC (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1435];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionCrossProduct::pClassPointer = NULL;

// Class Engine.MaterialExpressionCustom
// 0x0034 (0x00EC - 0x00B8)
class UMaterialExpressionCustom : public UMaterialExpression {
   public:
    struct FString Code;                 // 0x00B8 (0x0010) [0x0000000000000000]
    unsigned char OutputType;            // 0x00C8 (0x0001) [0x0000000000000000]
    struct FString Description;          // 0x00CC (0x0010) [0x0000000000000000]
    TArray<struct FCustomInput> Inputs;  // 0x00DC (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1437];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionCustom::pClassPointer = NULL;

// Class Engine.MaterialExpressionCustomTexture
// 0x0008 (0x00C0 - 0x00B8)
class UMaterialExpressionCustomTexture : public UMaterialExpression {
   public:
    class UTexture* Texture;  // 0x00B8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1439];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionCustomTexture::pClassPointer = NULL;

// Class Engine.MaterialExpressionDepthBiasedAlpha
// 0x0070 (0x0128 - 0x00B8)
class UMaterialExpressionDepthBiasedAlpha : public UMaterialExpression {
   public:
    DWORD bNormalize : 1;  // 0x00B8 (0x0004) [0x0000000000000000] [0x00000001]
    float BiasScale;       // 0x00BC (0x0004) [0x0000000000000000]
    struct FExpressionInput Alpha;  // 0x00C0 (0x0034) [0x0000000000000000]
    struct FExpressionInput Bias;   // 0x00F4 (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1441];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionDepthBiasedAlpha::pClassPointer = NULL;

// Class Engine.MaterialExpressionDepthBiasedBlend
// 0x00A4 (0x015C - 0x00B8)
class UMaterialExpressionDepthBiasedBlend : public UMaterialExpression {
   public:
    DWORD bNormalize : 1;  // 0x00B8 (0x0004) [0x0000000000000000] [0x00000001]
    float BiasScale;       // 0x00BC (0x0004) [0x0000000000000000]
    struct FExpressionInput RGB;    // 0x00C0 (0x0034) [0x0000000000000000]
    struct FExpressionInput Alpha;  // 0x00F4 (0x0034) [0x0000000000000000]
    struct FExpressionInput Bias;   // 0x0128 (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1443];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionDepthBiasedBlend::pClassPointer = NULL;

// Class Engine.MaterialExpressionDepthOfFieldFunction
// 0x0038 (0x00F0 - 0x00B8)
class UMaterialExpressionDepthOfFieldFunction : public UMaterialExpression {
   public:
    unsigned char FunctionValue;    // 0x00B8 (0x0001) [0x0000000000000000]
    struct FExpressionInput Depth;  // 0x00BC (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1445];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionDepthOfFieldFunction::pClassPointer = NULL;

// Class Engine.MaterialExpressionDeriveNormalZ
// 0x0034 (0x00EC - 0x00B8)
class UMaterialExpressionDeriveNormalZ : public UMaterialExpression {
   public:
    struct FExpressionInput InXY;  // 0x00B8 (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1447];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionDeriveNormalZ::pClassPointer = NULL;

// Class Engine.MaterialExpressionDesaturation
// 0x0078 (0x0130 - 0x00B8)
class UMaterialExpressionDesaturation : public UMaterialExpression {
   public:
    struct FExpressionInput Input;    // 0x00B8 (0x0034) [0x0000000000000000]
    struct FExpressionInput Percent;  // 0x00EC (0x0034) [0x0000000000000000]
    struct FLinearColor
        LuminanceFactors;  // 0x0120 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1449];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionDesaturation::pClassPointer = NULL;

// Class Engine.MaterialExpressionDestColor
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionDestColor : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1451];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionDestColor::pClassPointer = NULL;

// Class Engine.MaterialExpressionDestDepth
// 0x0004 (0x00BC - 0x00B8)
class UMaterialExpressionDestDepth : public UMaterialExpression {
   public:
    DWORD bNormalize : 1;  // 0x00B8 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1453];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionDestDepth::pClassPointer = NULL;

// Class Engine.MaterialExpressionDistance
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionDistance : public UMaterialExpression {
   public:
    struct FExpressionInput A;  // 0x00B8 (0x0034) [0x0000000000000000]
    struct FExpressionInput B;  // 0x00EC (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1455];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionDistance::pClassPointer = NULL;

// Class Engine.MaterialExpressionDivide
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionDivide : public UMaterialExpression {
   public:
    struct FExpressionInput A;  // 0x00B8 (0x0034) [0x0000000000000000]
    struct FExpressionInput B;  // 0x00EC (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1457];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionDivide::pClassPointer = NULL;

// Class Engine.MaterialExpressionDotProduct
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionDotProduct : public UMaterialExpression {
   public:
    struct FExpressionInput A;  // 0x00B8 (0x0034) [0x0000000000000000]
    struct FExpressionInput B;  // 0x00EC (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1459];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionDotProduct::pClassPointer = NULL;

// Class Engine.MaterialExpressionDynamicParameter
// 0x0010 (0x00C8 - 0x00B8)
class UMaterialExpressionDynamicParameter : public UMaterialExpression {
   public:
    TArray<struct FString> ParamNames;  // 0x00B8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1461];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionDynamicParameter::pClassPointer = NULL;

// Class Engine.MaterialExpressionMeshEmitterDynamicParameter
// 0x0000 (0x00C8 - 0x00C8)
class UMaterialExpressionMeshEmitterDynamicParameter
    : public UMaterialExpressionDynamicParameter {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1463];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionMeshEmitterDynamicParameter::pClassPointer = NULL;

// Class Engine.MaterialExpressionFloor
// 0x0034 (0x00EC - 0x00B8)
class UMaterialExpressionFloor : public UMaterialExpression {
   public:
    struct FExpressionInput Input;  // 0x00B8 (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1465];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionFloor::pClassPointer = NULL;

// Class Engine.MaterialExpressionFluidNormal
// 0x0034 (0x00EC - 0x00B8)
class UMaterialExpressionFluidNormal : public UMaterialExpression {
   public:
    struct FExpressionInput
        Coordinates;  // 0x00B8 (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1467];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionFluidNormal::pClassPointer = NULL;

// Class Engine.MaterialExpressionFmod
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionFmod : public UMaterialExpression {
   public:
    struct FExpressionInput A;  // 0x00B8 (0x0034) [0x0000000000000000]
    struct FExpressionInput B;  // 0x00EC (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1469];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionFmod::pClassPointer = NULL;

// Class Engine.MaterialExpressionFoliageImpulseDirection
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionFoliageImpulseDirection : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1471];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionFoliageImpulseDirection::pClassPointer = NULL;

// Class Engine.MaterialExpressionFoliageNormalizedRotationAxisAndAngle
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionFoliageNormalizedRotationAxisAndAngle
    : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1473];

        return pClassPointer;
    };
};

UClass*
    UMaterialExpressionFoliageNormalizedRotationAxisAndAngle::pClassPointer =
        NULL;

// Class Engine.MaterialExpressionFontSample
// 0x000C (0x00C4 - 0x00B8)
class UMaterialExpressionFontSample : public UMaterialExpression {
   public:
    class UFont* Font;    // 0x00B8 (0x0008) [0x0000000000000000]
    int FontTexturePage;  // 0x00C0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1475];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionFontSample::pClassPointer = NULL;

// Class Engine.MaterialExpressionFontSampleParameter
// 0x0020 (0x00E4 - 0x00C4)
class UMaterialExpressionFontSampleParameter
    : public UMaterialExpressionFontSample {
   public:
    struct FName ParameterName;   // 0x00C4 (0x0008) [0x0000000000000000]
    struct FGuid ExpressionGUID;  // 0x00CC (0x0010) [0x0000000000000000]
    struct FName Group;           // 0x00DC (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1477];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionFontSampleParameter::pClassPointer = NULL;

// Class Engine.MaterialExpressionFrac
// 0x0034 (0x00EC - 0x00B8)
class UMaterialExpressionFrac : public UMaterialExpression {
   public:
    struct FExpressionInput Input;  // 0x00B8 (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1479];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionFrac::pClassPointer = NULL;

// Class Engine.MaterialExpressionFresnel
// 0x0038 (0x00F0 - 0x00B8)
class UMaterialExpressionFresnel : public UMaterialExpression {
   public:
    float Exponent;                  // 0x00B8 (0x0004) [0x0000000000000000]
    struct FExpressionInput Normal;  // 0x00BC (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1481];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionFresnel::pClassPointer = NULL;

// Class Engine.MaterialExpressionFunctionInput
// 0x0080 (0x0138 - 0x00B8)
class UMaterialExpressionFunctionInput : public UMaterialExpression {
   public:
    struct FExpressionInput Preview;  // 0x00B8 (0x0034) [0x0000000000000000]
    struct FString InputName;         // 0x00EC (0x0010) [0x0000000000000000]
    struct FString Description;       // 0x00FC (0x0010) [0x0000000000000000]
    struct FGuid Id;                  // 0x010C (0x0010) [0x0000000000000000]
    unsigned char InputType;          // 0x011C (0x0001) [0x0000000000000000]
    struct FVector4 PreviewValue;     // 0x0120 (0x0010) [0x0000000000000000]
    DWORD bUsePreviewValueAsDefault : 1;  // 0x0130 (0x0004)
                                          // [0x0000000000000000] [0x00000001]
    DWORD bCompilingFunctionPreview : 1;  // 0x0130 (0x0004)
                                          // [0x0000000000000000] [0x00000002]
    int SortPriority;  // 0x0134 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1483];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionFunctionInput::pClassPointer = NULL;

// Class Engine.MaterialExpressionFunctionOutput
// 0x006C (0x0124 - 0x00B8)
class UMaterialExpressionFunctionOutput : public UMaterialExpression {
   public:
    struct FString OutputName;   // 0x00B8 (0x0010) [0x0000000000000000]
    struct FString Description;  // 0x00C8 (0x0010) [0x0000000000000000]
    int SortPriority;            // 0x00D8 (0x0004) [0x0000000000000000]
    struct FExpressionInput A;   // 0x00DC (0x0034) [0x0000000000000000]
    DWORD bLastPreviewed : 1;    // 0x0110 (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    struct FGuid Id;             // 0x0114 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1485];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionFunctionOutput::pClassPointer = NULL;

// Class Engine.MaterialExpressionIf
// 0x0104 (0x01BC - 0x00B8)
class UMaterialExpressionIf : public UMaterialExpression {
   public:
    struct FExpressionInput A;  // 0x00B8 (0x0034) [0x0000000000000000]
    struct FExpressionInput B;  // 0x00EC (0x0034) [0x0000000000000000]
    struct FExpressionInput
        AGreaterThanB;                   // 0x0120 (0x0034) [0x0000000000000000]
    struct FExpressionInput AEqualsB;    // 0x0154 (0x0034) [0x0000000000000000]
    struct FExpressionInput ALessThanB;  // 0x0188 (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1487];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionIf::pClassPointer = NULL;

// Class Engine.MaterialExpressionLandscapeLayerBlend
// 0x0020 (0x00D8 - 0x00B8)
class UMaterialExpressionLandscapeLayerBlend : public UMaterialExpression {
   public:
    TArray<struct FLayerBlendInput>
        Layers;                   // 0x00B8 (0x0010) [0x0000000000000000]
    struct FGuid ExpressionGUID;  // 0x00C8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1489];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionLandscapeLayerBlend::pClassPointer = NULL;

// Class Engine.MaterialExpressionLensFlareIntensity
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionLensFlareIntensity : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1491];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionLensFlareIntensity::pClassPointer = NULL;

// Class Engine.MaterialExpressionLensFlareOcclusion
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionLensFlareOcclusion : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1493];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionLensFlareOcclusion::pClassPointer = NULL;

// Class Engine.MaterialExpressionLensFlareRadialDistance
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionLensFlareRadialDistance : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1495];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionLensFlareRadialDistance::pClassPointer = NULL;

// Class Engine.MaterialExpressionLensFlareRayDistance
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionLensFlareRayDistance : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1497];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionLensFlareRayDistance::pClassPointer = NULL;

// Class Engine.MaterialExpressionLensFlareSourceDistance
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionLensFlareSourceDistance : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1499];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionLensFlareSourceDistance::pClassPointer = NULL;

// Class Engine.MaterialExpressionLightmapUVs
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionLightmapUVs : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1501];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionLightmapUVs::pClassPointer = NULL;

// Class Engine.MaterialExpressionLightmassReplace
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionLightmassReplace : public UMaterialExpression {
   public:
    struct FExpressionInput Realtime;   // 0x00B8 (0x0034) [0x0000000000000000]
    struct FExpressionInput Lightmass;  // 0x00EC (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1503];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionLightmassReplace::pClassPointer = NULL;

// Class Engine.MaterialExpressionLightVector
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionLightVector : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1505];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionLightVector::pClassPointer = NULL;

// Class Engine.MaterialExpressionLinearInterpolate
// 0x009C (0x0154 - 0x00B8)
class UMaterialExpressionLinearInterpolate : public UMaterialExpression {
   public:
    struct FExpressionInput A;      // 0x00B8 (0x0034) [0x0000000000000000]
    struct FExpressionInput B;      // 0x00EC (0x0034) [0x0000000000000000]
    struct FExpressionInput Alpha;  // 0x0120 (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1507];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionLinearInterpolate::pClassPointer = NULL;

// Class Engine.MaterialExpressionMaterialFunctionCall
// 0x0028 (0x00E0 - 0x00B8)
class UMaterialExpressionMaterialFunctionCall : public UMaterialExpression {
   public:
    class UMaterialFunction*
        MaterialFunction;  // 0x00B8 (0x0008) [0x0000000000000000]
    TArray<struct FFunctionExpressionInput>
        FunctionInputs;  // 0x00C0 (0x0010) [0x0000000000000000]
    TArray<struct FFunctionExpressionOutput>
        FunctionOutputs;  // 0x00D0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1509];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionMaterialFunctionCall::pClassPointer = NULL;

// Class Engine.MaterialExpressionMeshEmitterVertexColor
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionMeshEmitterVertexColor : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1511];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionMeshEmitterVertexColor::pClassPointer = NULL;

// Class Engine.MaterialExpressionMultiply
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionMultiply : public UMaterialExpression {
   public:
    struct FExpressionInput A;  // 0x00B8 (0x0034) [0x0000000000000000]
    struct FExpressionInput B;  // 0x00EC (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1513];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionMultiply::pClassPointer = NULL;

// Class Engine.MaterialExpressionNormalize
// 0x0034 (0x00EC - 0x00B8)
class UMaterialExpressionNormalize : public UMaterialExpression {
   public:
    struct FExpressionInput
        VectorInput;  // 0x00B8 (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1515];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionNormalize::pClassPointer = NULL;

// Class Engine.MaterialExpressionObjectOrientation
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionObjectOrientation : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1517];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionObjectOrientation::pClassPointer = NULL;

// Class Engine.MaterialExpressionObjectRadius
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionObjectRadius : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1519];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionObjectRadius::pClassPointer = NULL;

// Class Engine.MaterialExpressionObjectWorldPosition
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionObjectWorldPosition : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1521];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionObjectWorldPosition::pClassPointer = NULL;

// Class Engine.MaterialExpressionOcclusionPercentage
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionOcclusionPercentage : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1523];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionOcclusionPercentage::pClassPointer = NULL;

// Class Engine.MaterialExpressionOneMinus
// 0x0034 (0x00EC - 0x00B8)
class UMaterialExpressionOneMinus : public UMaterialExpression {
   public:
    struct FExpressionInput Input;  // 0x00B8 (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1525];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionOneMinus::pClassPointer = NULL;

// Class Engine.MaterialExpressionPanner
// 0x0070 (0x0128 - 0x00B8)
class UMaterialExpressionPanner : public UMaterialExpression {
   public:
    struct FExpressionInput Coordinate;  // 0x00B8 (0x0034) [0x0000000000000000]
    struct FExpressionInput Time;        // 0x00EC (0x0034) [0x0000000000000000]
    float SpeedX;                        // 0x0120 (0x0004) [0x0000000000000000]
    float SpeedY;                        // 0x0124 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1527];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionPanner::pClassPointer = NULL;

// Class Engine.MaterialExpressionParameter
// 0x0020 (0x00D8 - 0x00B8)
class UMaterialExpressionParameter : public UMaterialExpression {
   public:
    struct FName ParameterName;   // 0x00B8 (0x0008) [0x0000000000000000]
    struct FGuid ExpressionGUID;  // 0x00C0 (0x0010) [0x0000000000000000]
    struct FName Group;           // 0x00D0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1529];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionParameter::pClassPointer = NULL;

// Class Engine.MaterialExpressionScalarParameter
// 0x0004 (0x00DC - 0x00D8)
class UMaterialExpressionScalarParameter : public UMaterialExpressionParameter {
   public:
    float DefaultValue;  // 0x00D8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1531];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionScalarParameter::pClassPointer = NULL;

// Class Engine.MaterialExpressionStaticBoolParameter
// 0x000C (0x00E4 - 0x00D8)
class UMaterialExpressionStaticBoolParameter
    : public UMaterialExpressionParameter {
   public:
    DWORD
        DefaultValue : 1;  // 0x00D8 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD ExtendedCaptionDisplay : 1;  // 0x00D8 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    struct FPointer InstanceOverride;  // 0x00DC (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1533];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionStaticBoolParameter::pClassPointer = NULL;

// Class Engine.MaterialExpressionStaticSwitchParameter
// 0x0068 (0x014C - 0x00E4)
class UMaterialExpressionStaticSwitchParameter
    : public UMaterialExpressionStaticBoolParameter {
   public:
    struct FExpressionInput A;  // 0x00E4 (0x0034) [0x0000000000000000]
    struct FExpressionInput B;  // 0x0118 (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1535];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionStaticSwitchParameter::pClassPointer = NULL;

// Class Engine.MaterialExpressionStaticComponentMaskParameter
// 0x0040 (0x0118 - 0x00D8)
class UMaterialExpressionStaticComponentMaskParameter
    : public UMaterialExpressionParameter {
   public:
    struct FExpressionInput Input;  // 0x00D8 (0x0034) [0x0000000000000000]
    DWORD DefaultR : 1;  // 0x010C (0x0004) [0x0000000000000000] [0x00000001]
    DWORD DefaultG : 1;  // 0x010C (0x0004) [0x0000000000000000] [0x00000002]
    DWORD DefaultB : 1;  // 0x010C (0x0004) [0x0000000000000000] [0x00000004]
    DWORD DefaultA : 1;  // 0x010C (0x0004) [0x0000000000000000] [0x00000008]
    struct FPointer InstanceOverride;  // 0x0110 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1537];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionStaticComponentMaskParameter::pClassPointer = NULL;

// Class Engine.MaterialExpressionVectorParameter
// 0x0010 (0x00E8 - 0x00D8)
class UMaterialExpressionVectorParameter : public UMaterialExpressionParameter {
   public:
    struct FLinearColor DefaultValue;  // 0x00D8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1539];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionVectorParameter::pClassPointer = NULL;

// Class Engine.MaterialExpressionParticleMacroUV
// 0x0004 (0x00BC - 0x00B8)
class UMaterialExpressionParticleMacroUV : public UMaterialExpression {
   public:
    DWORD
        bUseViewSpace : 1;  // 0x00B8 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1541];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionParticleMacroUV::pClassPointer = NULL;

// Class Engine.MaterialExpressionPerInstanceRandom
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionPerInstanceRandom : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1543];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionPerInstanceRandom::pClassPointer = NULL;

// Class Engine.MaterialExpressionPixelDepth
// 0x0004 (0x00BC - 0x00B8)
class UMaterialExpressionPixelDepth : public UMaterialExpression {
   public:
    DWORD bNormalize : 1;  // 0x00B8 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1545];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionPixelDepth::pClassPointer = NULL;

// Class Engine.MaterialExpressionPower
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionPower : public UMaterialExpression {
   public:
    struct FExpressionInput Base;      // 0x00B8 (0x0034) [0x0000000000000000]
    struct FExpressionInput Exponent;  // 0x00EC (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1547];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionPower::pClassPointer = NULL;

// Class Engine.MaterialExpressionQualitySwitch
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionQualitySwitch : public UMaterialExpression {
   public:
    struct FExpressionInput High;  // 0x00B8 (0x0034) [0x0000000000000000]
    struct FExpressionInput Low;   // 0x00EC (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1549];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionQualitySwitch::pClassPointer = NULL;

// Class Engine.MaterialExpressionReflectionVector
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionReflectionVector : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1551];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionReflectionVector::pClassPointer = NULL;

// Class Engine.MaterialExpressionRotateAboutAxis
// 0x009C (0x0154 - 0x00B8)
class UMaterialExpressionRotateAboutAxis : public UMaterialExpression {
   public:
    struct FExpressionInput
        NormalizedRotationAxisAndAngle;  // 0x00B8 (0x0034) [0x0000000000000000]
    struct FExpressionInput
        PositionOnAxis;                // 0x00EC (0x0034) [0x0000000000000000]
    struct FExpressionInput Position;  // 0x0120 (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1553];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionRotateAboutAxis::pClassPointer = NULL;

// Class Engine.MaterialExpressionRotator
// 0x0074 (0x012C - 0x00B8)
class UMaterialExpressionRotator : public UMaterialExpression {
   public:
    struct FExpressionInput Coordinate;  // 0x00B8 (0x0034) [0x0000000000000000]
    struct FExpressionInput Time;        // 0x00EC (0x0034) [0x0000000000000000]
    float CenterX;                       // 0x0120 (0x0004) [0x0000000000000000]
    float CenterY;                       // 0x0124 (0x0004) [0x0000000000000000]
    float Speed;                         // 0x0128 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1555];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionRotator::pClassPointer = NULL;

// Class Engine.MaterialExpressionSceneDepth
// 0x0038 (0x00F0 - 0x00B8)
class UMaterialExpressionSceneDepth : public UMaterialExpression {
   public:
    struct FExpressionInput
        Coordinates;       // 0x00B8 (0x0034) [0x0000000000000000]
    DWORD bNormalize : 1;  // 0x00EC (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1557];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionSceneDepth::pClassPointer = NULL;

// Class Engine.MaterialExpressionSceneTexture
// 0x003C (0x00F4 - 0x00B8)
class UMaterialExpressionSceneTexture : public UMaterialExpression {
   public:
    struct FExpressionInput
        Coordinates;                 // 0x00B8 (0x0034) [0x0000000000000000]
    unsigned char SceneTextureType;  // 0x00EC (0x0001) [0x0000000000000000]
    DWORD ScreenAlign : 1;  // 0x00F0 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1559];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionSceneTexture::pClassPointer = NULL;

// Class Engine.MaterialExpressionScreenPosition
// 0x0004 (0x00BC - 0x00B8)
class UMaterialExpressionScreenPosition : public UMaterialExpression {
   public:
    DWORD ScreenAlign : 1;  // 0x00B8 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1561];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionScreenPosition::pClassPointer = NULL;

// Class Engine.MaterialExpressionScreenSize
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionScreenSize : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1563];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionScreenSize::pClassPointer = NULL;

// Class Engine.MaterialExpressionSine
// 0x0038 (0x00F0 - 0x00B8)
class UMaterialExpressionSine : public UMaterialExpression {
   public:
    struct FExpressionInput Input;  // 0x00B8 (0x0034) [0x0000000000000000]
    float Period;                   // 0x00EC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1565];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionSine::pClassPointer = NULL;

// Class Engine.MaterialExpressionSphereMask
// 0x00D8 (0x0190 - 0x00B8)
class UMaterialExpressionSphereMask : public UMaterialExpression {
   public:
    struct FExpressionInput A;         // 0x00B8 (0x0034) [0x0000000000000000]
    struct FExpressionInput B;         // 0x00EC (0x0034) [0x0000000000000000]
    struct FExpressionInput Radius;    // 0x0120 (0x0034) [0x0000000000000000]
    struct FExpressionInput Hardness;  // 0x0154 (0x0034) [0x0000000000000000]
    float AttenuationRadius;           // 0x0188 (0x0004) [0x0000000000000000]
    float HardnessPercent;             // 0x018C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1567];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionSphereMask::pClassPointer = NULL;

// Class Engine.MaterialExpressionSPHFluidNormal
// 0x003C (0x00F4 - 0x00B8)
class UMaterialExpressionSPHFluidNormal : public UMaterialExpression {
   public:
    class UTexture* DefaultTexture;  // 0x00B8 (0x0008) [0x0000000000000000]
    struct FExpressionInput
        DepthMipmapThreshold;  // 0x00C0 (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1569];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionSPHFluidNormal::pClassPointer = NULL;

// Class Engine.MaterialExpressionSPHFluidThickness
// 0x0008 (0x00C0 - 0x00B8)
class UMaterialExpressionSPHFluidThickness : public UMaterialExpression {
   public:
    class UTexture* DefaultTexture;  // 0x00B8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1571];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionSPHFluidThickness::pClassPointer = NULL;

// Class Engine.MaterialExpressionSPHFluidVertexColor
// 0x0008 (0x00C0 - 0x00B8)
class UMaterialExpressionSPHFluidVertexColor : public UMaterialExpression {
   public:
    class UTexture* DefaultTexture;  // 0x00B8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1573];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionSPHFluidVertexColor::pClassPointer = NULL;

// Class Engine.MaterialExpressionSquareRoot
// 0x0034 (0x00EC - 0x00B8)
class UMaterialExpressionSquareRoot : public UMaterialExpression {
   public:
    struct FExpressionInput Input;  // 0x00B8 (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1575];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionSquareRoot::pClassPointer = NULL;

// Class Engine.MaterialExpressionStaticBool
// 0x0004 (0x00BC - 0x00B8)
class UMaterialExpressionStaticBool : public UMaterialExpression {
   public:
    DWORD Value : 1;  // 0x00B8 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1577];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionStaticBool::pClassPointer = NULL;

// Class Engine.MaterialExpressionStaticSwitch
// 0x00A0 (0x0158 - 0x00B8)
class UMaterialExpressionStaticSwitch : public UMaterialExpression {
   public:
    DWORD
        DefaultValue : 1;  // 0x00B8 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD ExtendedCaptionDisplay : 1;  // 0x00B8 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    struct FExpressionInput A;         // 0x00BC (0x0034) [0x0000000000000000]
    struct FExpressionInput B;         // 0x00F0 (0x0034) [0x0000000000000000]
    struct FExpressionInput Value;     // 0x0124 (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1579];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionStaticSwitch::pClassPointer = NULL;

// Class Engine.MaterialExpressionSubtract
// 0x0068 (0x0120 - 0x00B8)
class UMaterialExpressionSubtract : public UMaterialExpression {
   public:
    struct FExpressionInput A;  // 0x00B8 (0x0034) [0x0000000000000000]
    struct FExpressionInput B;  // 0x00EC (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1581];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionSubtract::pClassPointer = NULL;

// Class Engine.MaterialExpressionTerrainLayerCoords
// 0x0014 (0x00CC - 0x00B8)
class UMaterialExpressionTerrainLayerCoords : public UMaterialExpression {
   public:
    unsigned char MappingType;  // 0x00B8 (0x0001) [0x0000000000000000]
    float MappingScale;         // 0x00BC (0x0004) [0x0000000000000000]
    float MappingRotation;      // 0x00C0 (0x0004) [0x0000000000000000]
    float MappingPanU;          // 0x00C4 (0x0004) [0x0000000000000000]
    float MappingPanV;          // 0x00C8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1583];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionTerrainLayerCoords::pClassPointer = NULL;

// Class Engine.MaterialExpressionTerrainLayerSwitch
// 0x008C (0x0144 - 0x00B8)
class UMaterialExpressionTerrainLayerSwitch : public UMaterialExpression {
   public:
    struct FPointer InstanceOverride;   // 0x00B8 (0x0008) [0x0000000000000000]
    struct FExpressionInput LayerUsed;  // 0x00C0 (0x0034) [0x0000000000000000]
    struct FExpressionInput
        LayerNotUsed;            // 0x00F4 (0x0034) [0x0000000000000000]
    struct FName ParameterName;  // 0x0128 (0x0008) [0x0000000000000000]
    DWORD PreviewUsed : 1;  // 0x0130 (0x0004) [0x0000000000000000] [0x00000001]
    struct FGuid ExpressionGUID;  // 0x0134 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1585];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionTerrainLayerSwitch::pClassPointer = NULL;

// Class Engine.MaterialExpressionTerrainLayerWeight
// 0x008C (0x0144 - 0x00B8)
class UMaterialExpressionTerrainLayerWeight : public UMaterialExpression {
   public:
    struct FPointer InstanceOverride;  // 0x00B8 (0x0008) [0x0000000000000000]
    struct FExpressionInput Base;      // 0x00C0 (0x0034) [0x0000000000000000]
    struct FExpressionInput Layer;     // 0x00F4 (0x0034) [0x0000000000000000]
    struct FName ParameterName;        // 0x0128 (0x0008) [0x0000000000000000]
    float PreviewWeight;               // 0x0130 (0x0004) [0x0000000000000000]
    struct FGuid ExpressionGUID;       // 0x0134 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1587];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionTerrainLayerWeight::pClassPointer = NULL;

// Class Engine.MaterialExpressionTexelSize
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionTexelSize : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1589];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionTexelSize::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureCoordinate
// 0x0010 (0x00C8 - 0x00B8)
class UMaterialExpressionTextureCoordinate : public UMaterialExpression {
   public:
    int CoordinateIndex;  // 0x00B8 (0x0004) [0x0000000000000000]
    float UTiling;        // 0x00BC (0x0004) [0x0000000000000000]
    float VTiling;        // 0x00C0 (0x0004) [0x0000000000000000]
    DWORD UnMirrorU : 1;  // 0x00C4 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD UnMirrorV : 1;  // 0x00C4 (0x0004) [0x0000000000000000] [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1591];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionTextureCoordinate::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureObject
// 0x0008 (0x00C0 - 0x00B8)
class UMaterialExpressionTextureObject : public UMaterialExpression {
   public:
    class UTexture* Texture;  // 0x00B8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1593];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionTextureObject::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureSample
// 0x0070 (0x0128 - 0x00B8)
class UMaterialExpressionTextureSample : public UMaterialExpression {
   public:
    class UTexture* Texture;  // 0x00B8 (0x0008) [0x0000000000000000]
    struct FExpressionInput
        Coordinates;  // 0x00C0 (0x0034) [0x0000000000000000]
    struct FExpressionInput
        TextureObject;  // 0x00F4 (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1595];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionTextureSample::pClassPointer = NULL;

// Class Engine.MaterialExpressionDepthBiasBlend
// 0x003C (0x0164 - 0x0128)
class UMaterialExpressionDepthBiasBlend
    : public UMaterialExpressionTextureSample {
   public:
    DWORD bNormalize : 1;  // 0x0128 (0x0004) [0x0000000000000000] [0x00000001]
    float BiasScale;       // 0x012C (0x0004) [0x0000000000000000]
    struct FExpressionInput Bias;  // 0x0130 (0x0034) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1597];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionDepthBiasBlend::pClassPointer = NULL;

// Class Engine.MaterialExpressionFlipBookSample
// 0x0000 (0x0128 - 0x0128)
class UMaterialExpressionFlipBookSample
    : public UMaterialExpressionTextureSample {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1599];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionFlipBookSample::pClassPointer = NULL;

// Class Engine.MaterialExpressionMeshSubUV
// 0x0000 (0x0128 - 0x0128)
class UMaterialExpressionMeshSubUV : public UMaterialExpressionTextureSample {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1601];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionMeshSubUV::pClassPointer = NULL;

// Class Engine.MaterialExpressionMeshSubUVBlend
// 0x0000 (0x0128 - 0x0128)
class UMaterialExpressionMeshSubUVBlend : public UMaterialExpressionMeshSubUV {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1603];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionMeshSubUVBlend::pClassPointer = NULL;

// Class Engine.MaterialExpressionParticleSubUV
// 0x0000 (0x0128 - 0x0128)
class UMaterialExpressionParticleSubUV
    : public UMaterialExpressionTextureSample {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1605];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionParticleSubUV::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureSampleParameter
// 0x0020 (0x0148 - 0x0128)
class UMaterialExpressionTextureSampleParameter
    : public UMaterialExpressionTextureSample {
   public:
    struct FName ParameterName;   // 0x0128 (0x0008) [0x0000000000000000]
    struct FGuid ExpressionGUID;  // 0x0130 (0x0010) [0x0000000000000000]
    struct FName Group;           // 0x0140 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1607];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionTextureSampleParameter::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureObjectParameter
// 0x0000 (0x0148 - 0x0148)
class UMaterialExpressionTextureObjectParameter
    : public UMaterialExpressionTextureSampleParameter {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1609];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionTextureObjectParameter::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureSampleParameter2D
// 0x0000 (0x0148 - 0x0148)
class UMaterialExpressionTextureSampleParameter2D
    : public UMaterialExpressionTextureSampleParameter {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1611];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionTextureSampleParameter2D::pClassPointer = NULL;

// Class Engine.MaterialExpressionAntialiasedTextureMask
// 0x0005 (0x014D - 0x0148)
class UMaterialExpressionAntialiasedTextureMask
    : public UMaterialExpressionTextureSampleParameter2D {
   public:
    float Threshold;        // 0x0148 (0x0004) [0x0000000000000000]
    unsigned char Channel;  // 0x014C (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1613];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionAntialiasedTextureMask::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureSampleParameterFlipbook
// 0x0000 (0x0148 - 0x0148)
class UMaterialExpressionTextureSampleParameterFlipbook
    : public UMaterialExpressionTextureSampleParameter2D {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1615];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionTextureSampleParameterFlipbook::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureSampleParameterMeshSubUV
// 0x0000 (0x0148 - 0x0148)
class UMaterialExpressionTextureSampleParameterMeshSubUV
    : public UMaterialExpressionTextureSampleParameter2D {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1617];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionTextureSampleParameterMeshSubUV::pClassPointer =
    NULL;

// Class Engine.MaterialExpressionTextureSampleParameterMeshSubUVBlend
// 0x0000 (0x0148 - 0x0148)
class UMaterialExpressionTextureSampleParameterMeshSubUVBlend
    : public UMaterialExpressionTextureSampleParameterMeshSubUV {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1619];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionTextureSampleParameterMeshSubUVBlend::pClassPointer =
    NULL;

// Class Engine.MaterialExpressionTextureSampleParameterSubUV
// 0x0000 (0x0148 - 0x0148)
class UMaterialExpressionTextureSampleParameterSubUV
    : public UMaterialExpressionTextureSampleParameter2D {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1621];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionTextureSampleParameterSubUV::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureSampleParameterCube
// 0x0000 (0x0148 - 0x0148)
class UMaterialExpressionTextureSampleParameterCube
    : public UMaterialExpressionTextureSampleParameter {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1623];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionTextureSampleParameterCube::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureSampleParameterMovie
// 0x0000 (0x0148 - 0x0148)
class UMaterialExpressionTextureSampleParameterMovie
    : public UMaterialExpressionTextureSampleParameter {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1625];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionTextureSampleParameterMovie::pClassPointer = NULL;

// Class Engine.MaterialExpressionTextureSampleParameterNormal
// 0x0008 (0x0150 - 0x0148)
class UMaterialExpressionTextureSampleParameterNormal
    : public UMaterialExpressionTextureSampleParameter {
   public:
    struct FPointer InstanceOverride;  // 0x0148 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1627];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionTextureSampleParameterNormal::pClassPointer = NULL;

// Class Engine.MaterialExpressionTime
// 0x0004 (0x00BC - 0x00B8)
class UMaterialExpressionTime : public UMaterialExpression {
   public:
    DWORD
        bIgnorePause : 1;  // 0x00B8 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1629];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionTime::pClassPointer = NULL;

// Class Engine.MaterialExpressionTransform
// 0x0036 (0x00EE - 0x00B8)
class UMaterialExpressionTransform : public UMaterialExpression {
   public:
    struct FExpressionInput Input;      // 0x00B8 (0x0034) [0x0000000000000000]
    unsigned char TransformSourceType;  // 0x00EC (0x0001) [0x0000000000000000]
    unsigned char TransformType;        // 0x00ED (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1631];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionTransform::pClassPointer = NULL;

// Class Engine.MaterialExpressionTransformPosition
// 0x0036 (0x00EE - 0x00B8)
class UMaterialExpressionTransformPosition : public UMaterialExpression {
   public:
    struct FExpressionInput Input;      // 0x00B8 (0x0034) [0x0000000000000000]
    unsigned char TransformSourceType;  // 0x00EC (0x0001) [0x0000000000000000]
    unsigned char TransformType;        // 0x00ED (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1633];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionTransformPosition::pClassPointer = NULL;

// Class Engine.MaterialExpressionTwoSidedSign
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionTwoSidedSign : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1635];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionTwoSidedSign::pClassPointer = NULL;

// Class Engine.MaterialExpressionVertexColor
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionVertexColor : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1637];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionVertexColor::pClassPointer = NULL;

// Class Engine.MaterialExpressionWindDirectionAndSpeed
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionWindDirectionAndSpeed : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1639];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionWindDirectionAndSpeed::pClassPointer = NULL;

// Class Engine.MaterialExpressionWorldNormal
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionWorldNormal : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1641];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionWorldNormal::pClassPointer = NULL;

// Class Engine.MaterialExpressionWorldPosition
// 0x0000 (0x00B8 - 0x00B8)
class UMaterialExpressionWorldPosition : public UMaterialExpression {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1643];

        return pClassPointer;
    };
};

UClass* UMaterialExpressionWorldPosition::pClassPointer = NULL;

// Class Engine.MaterialFunction
// 0x005C (0x00BC - 0x0060)
class UMaterialFunction : public UObject {
   public:
    struct FGuid StateId;  // 0x0060 (0x0010) [0x0000000000000000]
    class UMaterialFunction*
        ParentFunction;          // 0x0070 (0x0008) [0x0000000000000000]
    struct FString Description;  // 0x0078 (0x0010) [0x0000000000000000]
    DWORD bExposeToLibrary : 1;  // 0x0088 (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    DWORD bReentrantFlag : 1;    // 0x0088 (0x0004) [0x0000000000000000]
                                 // [0x00000002]
    TArray<struct FString>
        LibraryCategories;  // 0x008C (0x0010) [0x0000000000000000]
    TArray<class UMaterialExpression*>
        FunctionExpressions;  // 0x009C (0x0010) [0x0000000000000000]
    TArray<class UMaterialExpressionComment*>
        FunctionEditorComments;  // 0x00AC (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1645];

        return pClassPointer;
    };
};

UClass* UMaterialFunction::pClassPointer = NULL;

// Class Engine.MaterialInstance
// 0x0098 (0x02FC - 0x0264)
class UMaterialInstance : public UMaterialInterface {
   public:
    class UPhysicalMaterial*
        PhysMaterial;                    // 0x0264 (0x0008) [0x0000000000000000]
    class UMaterialInterface* Parent;    // 0x026C (0x0008) [0x0000000000000000]
    class UTexture2D* PhysMaterialMask;  // 0x0274 (0x0008) [0x0000000000000000]
    int PhysMaterialMaskUVChannel;       // 0x027C (0x0004) [0x0000000000000000]
    class UPhysicalMaterial*
        BlackPhysicalMaterial;  // 0x0280 (0x0008) [0x0000000000000000]
    class UPhysicalMaterial*
        WhitePhysicalMaterial;  // 0x0288 (0x0008) [0x0000000000000000]
    DWORD
        bHasStaticPermutationResource : 1;  // 0x0290 (0x0004)
                                            // [0x0000000000000000] [0x00000001]
    DWORD bStaticPermutationDirty : 1;  // 0x0290 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD
        ReentrantFlag : 1;  // 0x0290 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bNeedsMaterialFlattening : 1;  // 0x0290 (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    struct FPointer
        StaticParameters[0x2];  // 0x0294 (0x0010) [0x0000000000000000]
    struct FPointer StaticPermutationResources[0x2];  // 0x02A4 (0x0010)
                                                      // [0x0000000000000000]
    struct FPointer Resources[0x3];  // 0x02B4 (0x0018) [0x0000000000000000]
    TArray<class UTexture*>
        ReferencedTextures;  // 0x02CC (0x0010) [0x0000000000000000]
    TArray<struct FGuid>
        ReferencedTextureGuids;       // 0x02DC (0x0010) [0x0000000000000000]
    struct FGuid ParentLightingGuid;  // 0x02EC (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1647];

        return pClassPointer;
    };

    void IsInMapOrTransientPackage();
    void ClearParameterValues();
    void SetFontParameterValue();
    void GetTextureParameterValue();
    void SetTextureParameterValue();
    void SetScalarCurveParameterValue();
    void SetScalarParameterValue();
    void SetVectorParameterValue();
    void SetParent();
};

UClass* UMaterialInstance::pClassPointer = NULL;

// Class Engine.MaterialInstanceConstant
// 0x0040 (0x033C - 0x02FC)
class UMaterialInstanceConstant : public UMaterialInstance {
   public:
    TArray<struct FFontParameterValue>
        FontParameterValues;  // 0x02FC (0x0010) [0x0000000000000000]
    TArray<struct FScalarParameterValue>
        ScalarParameterValues;  // 0x030C (0x0010) [0x0000000000000000]
    TArray<struct FTextureParameterValue>
        TextureParameterValues;  // 0x031C (0x0010) [0x0000000000000000]
    TArray<struct FVectorParameterValue>
        VectorParameterValues;  // 0x032C (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1649];

        return pClassPointer;
    };

    void ClearParameterValues();
    void GetMobileVectorParameterValue();
    void GetMobileTextureParameterValue();
    void GetMobileScalarParameterValue();
    void SetFontParameterValue();
    void SetVectorParameterValue();
    void SetTextureParameterValue();
    void SetScalarParameterValue();
    void SetParent();
};

UClass* UMaterialInstanceConstant::pClassPointer = NULL;

// Class Engine.LandscapeMaterialInstanceConstant
// 0x000C (0x0348 - 0x033C)
class ULandscapeMaterialInstanceConstant : public UMaterialInstanceConstant {
   public:
    DWORD bIsLayerThumbnail : 1;  // 0x033C (0x0004) [0x0000000000000000]
                                  // [0x00000001]
    int DataWeightmapIndex;       // 0x0340 (0x0004) [0x0000000000000000]
    int DataWeightmapSize;        // 0x0344 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1651];

        return pClassPointer;
    };
};

UClass* ULandscapeMaterialInstanceConstant::pClassPointer = NULL;

// Class Engine.MaterialInstanceTimeVarying
// 0x0058 (0x0354 - 0x02FC)
class UMaterialInstanceTimeVarying : public UMaterialInstance {
   public:
    DWORD bAutoActivateAll : 1;  // 0x02FC (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    float Duration;              // 0x0300 (0x0004) [0x0000000000000000]
    TArray<struct FFontParameterValueOverTime>
        FontParameterValues;  // 0x0304 (0x0010) [0x0000000000000000]
    TArray<struct FScalarParameterValueOverTime>
        ScalarParameterValues;  // 0x0314 (0x0010) [0x0000000000000000]
    TArray<struct FTextureParameterValueOverTime>
        TextureParameterValues;  // 0x0324 (0x0010) [0x0000000000000000]
    TArray<struct FVectorParameterValueOverTime>
        VectorParameterValues;  // 0x0334 (0x0010) [0x0000000000000000]
    TArray<struct FLinearColorParameterValueOverTime>
        LinearColorParameterValues;  // 0x0344 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1653];

        return pClassPointer;
    };

    void CheckForVectorParameterConflicts();
    void GetMaxDurationFromAllParameters();
    void ClearParameterValues();
    void SetFontParameterValue();
    void SetVectorStartTime();
    void SetLinearColorCurveParameterValue();
    void SetLinearColorParameterValue();
    void SetVectorCurveParameterValue();
    void SetVectorParameterValue();
    void SetTextureParameterValue();
    void SetDuration();
    void SetScalarStartTime();
    void SetScalarCurveParameterValue();
    void SetScalarParameterValue();
    void SetParent();
};

UClass* UMaterialInstanceTimeVarying::pClassPointer = NULL;

// Class Engine.EmitterCameraLensEffectBase
// 0x0034 (0x028C - 0x0258)
class AEmitterCameraLensEffectBase : public AEmitter {
   public:
    class UParticleSystem*
        PS_CameraEffect;  // 0x0258 (0x0008) [0x0000000000000000]
    class UParticleSystem*
        PS_CameraEffectNonExtremeContent;  // 0x0260 (0x0008)
                                           // [0x0000000000000000]
    float BaseFOV;                      // 0x0268 (0x0004) [0x0000000000000000]
    float DistFromCamera;               // 0x026C (0x0004) [0x0000000000000000]
    DWORD bAllowMultipleInstances : 1;  // 0x0270 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    TArray<class UClass*>
        EmittersToTreatAsSame;  // 0x0274 (0x0010) [0x0000000000000000]
    class ACamera* BaseCamera;  // 0x0284 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1655];

        return pClassPointer;
    };

    void UpdateLocation();
    void ActivateLensEffect();
    void PostBeginPlay();
    void NotifyRetriggered();
    void RegisterCamera();
    void Destroyed();
};

UClass* AEmitterCameraLensEffectBase::pClassPointer = NULL;

// Class Engine.ParticleEventManager
// 0x0000 (0x0244 - 0x0244)
class AParticleEventManager : public AActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1657];

        return pClassPointer;
    };

    void eventHandleParticleModuleEventSendToGame();
};

UClass* AParticleEventManager::pClassPointer = NULL;

// Class Engine.ParticleSystemComponent
// 0x0180 (0x03B8 - 0x0238)
class UParticleSystemComponent : public UPrimitiveComponent {
   public:
    class UParticleSystem* Template;  // 0x0238 (0x0008) [0x0000000000000000]
    TArray<class UParticleSystem*>
        ExtensionTemplates;  // 0x0240 (0x0010) [0x0000000000000000]
    class UClass*
        LightEnvironmentClass;  // 0x0250 (0x0008) [0x0000000000000000]
    class AActor* LightEnvironmentSharedInstigator;  // 0x0258 (0x0008)
                                                     // [0x0000000000000000]
    int MaxLightEnvironmentPooledReuses;             // 0x0260 (0x0004)
                                                     // [0x0000000000000000]
    int NumActiveParticles;  // 0x0264 (0x0004) [0x0000000000000000]
    TArray<struct FPointer>
        EmitterInstances;  // 0x0268 (0x0010) [0x0000000000000000]
    TArray<class UStaticMeshComponent*>
        SMComponents;  // 0x0278 (0x0010) [0x0000000000000000]
    TArray<class UMaterialInterface*>
        SMMaterialInterfaces;  // 0x0288 (0x0010) [0x0000000000000000]
    TArray<class USkeletalMeshComponent*>
        SkelMeshComponents;  // 0x0298 (0x0010) [0x0000000000000000]
    TArray<struct FViewParticleEmitterInstanceMotionBlurInfo>
        ViewMBInfoArray;  // 0x02A8 (0x0010) [0x0000000000000000]
    DWORD
        bAutoActivate : 1;  // 0x02B8 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD
        bWasCompleted : 1;  // 0x02B8 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bSuppressSpawning : 1;         // 0x02B8 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD bWasDeactivated : 1;           // 0x02B8 (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    DWORD bResetOnDetach : 1;            // 0x02B8 (0x0004) [0x0000000000000000]
                                         // [0x00000010]
    DWORD bUpdateOnDedicatedServer : 1;  // 0x02B8 (0x0004) [0x0000000000000000]
                                         // [0x00000020]
    DWORD
        bJustAttached : 1;  // 0x02B8 (0x0004) [0x0000000000000000] [0x00000040]
    DWORD bIsActive : 1;    // 0x02B8 (0x0004) [0x0000000000000000] [0x00000080]
    DWORD bHasBeenActivated : 1;  // 0x02B8 (0x0004) [0x0000000000000000]
                                  // [0x00000100]
    DWORD bWarmingUp : 1;  // 0x02B8 (0x0004) [0x0000000000000000] [0x00000200]
    DWORD bIsCachedInPool : 1;     // 0x02B8 (0x0004) [0x0000000000000000]
                                   // [0x00000400]
    DWORD bOverrideLODMethod : 1;  // 0x02B8 (0x0004) [0x0000000000000000]
                                   // [0x00000800]
    DWORD bSkipUpdateDynamicDataDuringTick : 1;  // 0x02B8 (0x0004)
                                                 // [0x0000000000000000]
                                                 // [0x00001000]
    DWORD bSkipBoundsUpdate : 1;       // 0x02B8 (0x0004) [0x0000000000000000]
                                       // [0x00002000]
    DWORD bUpdateComponentInTick : 1;  // 0x02B8 (0x0004) [0x0000000000000000]
                                       // [0x00004000]
    DWORD bDeferredBeamUpdate : 1;     // 0x02B8 (0x0004) [0x0000000000000000]
                                       // [0x00008000]
    DWORD bForcedInActive : 1;         // 0x02B8 (0x0004) [0x0000000000000000]
                                       // [0x00010000]
    DWORD
        bIsWarmingUp : 1;  // 0x02B8 (0x0004) [0x0000000000000000] [0x00020000]
    DWORD bIsViewRelevanceDirty : 1;  // 0x02B8 (0x0004) [0x0000000000000000]
                                      // [0x00040000]
    DWORD bRecacheViewRelevance : 1;  // 0x02B8 (0x0004) [0x0000000000000000]
                                      // [0x00080000]
    DWORD bDepthTestEnabled : 1;      // 0x02B8 (0x0004) [0x0000000000000000]
                                      // [0x00100000]
    DWORD bLODUpdatePending : 1;      // 0x02B8 (0x0004) [0x0000000000000000]
                                      // [0x00200000]
    DWORD bSkipSpawnCountCheck : 1;   // 0x02B8 (0x0004) [0x0000000000000000]
                                      // [0x00400000]
    TArray<struct FParticleSysParam>
        InstanceParameters;          // 0x02BC (0x0010) [0x0000000000000000]
    struct FVector OldPosition;      // 0x02CC (0x000C) [0x0000000000000000]
    struct FVector PartSysVelocity;  // 0x02D8 (0x000C) [0x0000000000000000]
    float WarmupTime;                // 0x02E4 (0x0004) [0x0000000000000000]
    float WarmupTickRate;            // 0x02E8 (0x0004) [0x0000000000000000]
    int LODLevel;                    // 0x02EC (0x0004) [0x0000000000000000]
    float SecondsBeforeInactive;     // 0x02F0 (0x0004) [0x0000000000000000]
    float TimeSinceLastForceUpdateTransform;  // 0x02F4 (0x0004)
                                              // [0x0000000000000000]
    float MaxTimeBeforeForceUpdateTransform;  // 0x02F8 (0x0004)
                                              // [0x0000000000000000]
    int EditorLODLevel;         // 0x02FC (0x0004) [0x0000000000000000]
    int EditorDetailMode;       // 0x0300 (0x0004) [0x0000000000000000]
    float AccumTickTime;        // 0x0304 (0x0004) [0x0000000000000000]
    unsigned char LODMethod;    // 0x0308 (0x0001) [0x0000000000000000]
    unsigned char ReplayState;  // 0x0309 (0x0001) [0x0000000000000000]
    TArray<struct FMaterialViewRelevance>
        CachedViewRelevanceFlags;  // 0x030C (0x0010) [0x0000000000000000]
    TArray<class UParticleSystemReplay*>
        ReplayClips;                  // 0x031C (0x0010) [0x0000000000000000]
    int ReplayClipIDNumber;           // 0x032C (0x0004) [0x0000000000000000]
    int ReplayFrameIndex;             // 0x0330 (0x0004) [0x0000000000000000]
    float AccumLODDistanceCheckTime;  // 0x0334 (0x0004) [0x0000000000000000]
    TArray<struct FParticleEventSpawnData>
        SpawnEvents;  // 0x0338 (0x0010) [0x0000000000000000]
    TArray<struct FParticleEventDeathData>
        DeathEvents;  // 0x0348 (0x0010) [0x0000000000000000]
    TArray<struct FParticleEventCollideData>
        CollisionEvents;  // 0x0358 (0x0010) [0x0000000000000000]
    TArray<struct FParticleEventKismetData>
        KismetEvents;  // 0x0368 (0x0010) [0x0000000000000000]
    TArray<struct FParticleEventAttractorCollideData>
        AttractorCollisionEvents;  // 0x0378 (0x0010) [0x0000000000000000]
    struct FPointer
        ReleaseResourcesFence;  // 0x0388 (0x0008) [0x0000000000000000]
    float CustomTimeDilation;   // 0x0390 (0x0004) [0x0000000000000000]
    float EmitterDelay;         // 0x0394 (0x0004) [0x0000000000000000]
    TArray<struct FFlexEmitterPreSimPositions>
        FlexEmitterPreSimState;  // 0x0398 (0x0010) [0x0000000000000000]
    struct FScriptDelegate
        __OnSystemFinished__Delegate;  // 0x03A8 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x03AC (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1659];

        return pClassPointer;
    };

    void SetStopSpawning();
    void ResetToDefaults();
    void SetActive();
    void ClearParameter();
    void GetMaterialParameter();
    void GetActorParameter();
    void GetColorParameter();
    void GetVectorParameter();
    void GetFloatParameter();
    void SetMaterialParameter();
    void SetActorParameter();
    void SetColorParameter();
    void SetVectorRandParameter();
    void SetVectorParameter();
    void SetFloatRandParameter();
    void SetFloatParameter();
    void GetEditorLODLevel();
    void GetLODLevel();
    void SetEditorLODLevel();
    void SetLODLevel();
    void SystemHasCompleted();
    void GetMaxLifespan();
    void DetermineLODLevelForLocation();
    void SetBeamTargetStrength();
    void SetBeamTargetTangent();
    void SetBeamTargetPoint();
    void SetBeamSourceStrength();
    void SetBeamSourceTangent();
    void SetBeamSourcePoint();
    void SetBeamDistance();
    void SetBeamEndPoint();
    void SetBeamTessellationFactor();
    void SetBeamType();
    void RewindEmitterInstances();
    void RewindEmitterInstance();
    void SetKillOnCompleted();
    void SetKillOnDeactivate();
    void GetSkipBoundsUpdate();
    void SetSkipBoundsUpdate();
    void GetSkipUpdateDynamicDataDuringTick();
    void SetSkipUpdateDynamicDataDuringTick();
    void KillParticlesInEmitter();
    void KillParticlesForced();
    void DeactivateSystem();
    void ActivateSystem();
    void SetTemplate();
    void OnSystemFinished();
};

UClass* UParticleSystemComponent::pClassPointer = NULL;

// Class Engine.DistributionFloatParticleParameter
// 0x0003 (0x009C - 0x0099)
class UDistributionFloatParticleParameter
    : public UDistributionFloatParameterBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1661];

        return pClassPointer;
    };
};

UClass* UDistributionFloatParticleParameter::pClassPointer = NULL;

// Class Engine.DistributionVectorParticleParameter
// 0x0001 (0x00CC - 0x00CB)
class UDistributionVectorParticleParameter
    : public UDistributionVectorParameterBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1663];

        return pClassPointer;
    };
};

UClass* UDistributionVectorParticleParameter::pClassPointer = NULL;

// Class Engine.ParticleEmitter
// 0x0048 (0x00A8 - 0x0060)
class UParticleEmitter : public UObject {
   public:
    struct FName EmitterName;          // 0x0060 (0x0008) [0x0000000000000000]
    int SubUVDataOffset;               // 0x0068 (0x0004) [0x0000000000000000]
    unsigned char EmitterRenderMode;   // 0x006C (0x0001) [0x0000000000000000]
    struct FColor EmitterEditorColor;  // 0x0070 (0x0004) [0x0000000000000000]
    TArray<class UParticleLODLevel*>
        LODLevels;               // 0x0074 (0x0010) [0x0000000000000000]
    DWORD ConvertedModules : 1;  // 0x0084 (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    DWORD bCollapsed : 1;  // 0x0084 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bIsSoloing : 1;  // 0x0084 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bCookedOut : 1;  // 0x0084 (0x0004) [0x0000000000000000] [0x00000008]
    int PeakActiveParticles;           // 0x0088 (0x0004) [0x0000000000000000]
    int InitialAllocationCount;        // 0x008C (0x0004) [0x0000000000000000]
    float MediumDetailSpawnRateScale;  // 0x0090 (0x0004) [0x0000000000000000]
    class UFlexContainer*
        FlexContainerTemplate;     // 0x0094 (0x0008) [0x0000000000000000]
    float FlexSmoothScreenRadius;  // 0x009C (0x0004) [0x0000000000000000]
    float FlexSmoothDepthRadius;   // 0x00A0 (0x0004) [0x0000000000000000]
    float FlexCutoffThickness;     // 0x00A4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1665];

        return pClassPointer;
    };

    void GetMaxLifespan();
};

UClass* UParticleEmitter::pClassPointer = NULL;

// Class Engine.ParticleSpriteEmitter
// 0x0000 (0x00A8 - 0x00A8)
class UParticleSpriteEmitter : public UParticleEmitter {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1667];

        return pClassPointer;
    };
};

UClass* UParticleSpriteEmitter::pClassPointer = NULL;

// Class Engine.ParticleLODLevel
// 0x008C (0x00EC - 0x0060)
class UParticleLODLevel : public UObject {
   public:
    int Level;           // 0x0060 (0x0004) [0x0000000000000000]
    DWORD bEnabled : 1;  // 0x0064 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD ConvertedModules : 1;  // 0x0064 (0x0004) [0x0000000000000000]
                                 // [0x00000002]
    class UParticleModuleRequired*
        RequiredModule;  // 0x0068 (0x0008) [0x0000000000000000]
    TArray<class UParticleModule*>
        Modules;  // 0x0070 (0x0010) [0x0000000000000000]
    class UParticleModule*
        TypeDataModule;  // 0x0080 (0x0008) [0x0000000000000000]
    class UParticleModuleSpawn*
        SpawnModule;  // 0x0088 (0x0008) [0x0000000000000000]
    class UParticleModuleEventGenerator*
        EventGenerator;  // 0x0090 (0x0008) [0x0000000000000000]
    TArray<class UParticleModuleSpawnBase*>
        SpawningModules;  // 0x0098 (0x0010) [0x0000000000000000]
    TArray<class UParticleModule*>
        SpawnModules;  // 0x00A8 (0x0010) [0x0000000000000000]
    TArray<class UParticleModule*>
        UpdateModules;  // 0x00B8 (0x0010) [0x0000000000000000]
    TArray<class UParticleModuleOrbit*>
        OrbitModules;  // 0x00C8 (0x0010) [0x0000000000000000]
    TArray<class UParticleModuleEventReceiverBase*>
        EventReceiverModules;  // 0x00D8 (0x0010) [0x0000000000000000]
    int PeakActiveParticles;   // 0x00E8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1669];

        return pClassPointer;
    };
};

UClass* UParticleLODLevel::pClassPointer = NULL;

// Class Engine.ParticleModule
// 0x000C (0x006C - 0x0060)
class UParticleModule : public UObject {
   public:
    DWORD
        bSpawnModule : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD
        bUpdateModule : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bFinalUpdateModule : 1;  // 0x0060 (0x0004) [0x0000000000000000]
                                   // [0x00000004]
    DWORD bCurvesAsColor : 1;      // 0x0060 (0x0004) [0x0000000000000000]
                                   // [0x00000008]
    DWORD b3DDrawMode : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bSupported3DDrawMode : 1;  // 0x0060 (0x0004) [0x0000000000000000]
                                     // [0x00000020]
    DWORD bEnabled : 1;   // 0x0060 (0x0004) [0x0000000000000000] [0x00000040]
    DWORD bEditable : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000080]
    DWORD
        LODDuplicate : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000100]
    DWORD bSupportsRandomSeed : 1;  // 0x0060 (0x0004) [0x0000000000000000]
                                    // [0x00000200]
    DWORD
        bRequiresLoopingNotification : 1;  // 0x0060 (0x0004)
                                           // [0x0000000000000000] [0x00000400]
    unsigned char LODValidity;        // 0x0064 (0x0001) [0x0000000000000000]
    struct FColor ModuleEditorColor;  // 0x0068 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1671];

        return pClassPointer;
    };
};

UClass* UParticleModule::pClassPointer = NULL;

// Class Engine.ParticleModuleAccelerationBase
// 0x0004 (0x0070 - 0x006C)
class UParticleModuleAccelerationBase : public UParticleModule {
   public:
    DWORD bAlwaysInWorldSpace : 1;  // 0x006C (0x0004) [0x0000000000000000]
                                    // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1673];

        return pClassPointer;
    };
};

UClass* UParticleModuleAccelerationBase::pClassPointer = NULL;

// Class Engine.ParticleModuleAcceleration
// 0x0028 (0x0098 - 0x0070)
class UParticleModuleAcceleration : public UParticleModuleAccelerationBase {
   public:
    struct FRawDistributionVector
        Acceleration;            // 0x0070 (0x0024) [0x0000000000000000]
    DWORD bApplyOwnerScale : 1;  // 0x0094 (0x0004) [0x0000000000000000]
                                 // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1675];

        return pClassPointer;
    };
};

UClass* UParticleModuleAcceleration::pClassPointer = NULL;

// Class Engine.ParticleModuleAccelerationOverLifetime
// 0x0024 (0x0094 - 0x0070)
class UParticleModuleAccelerationOverLifetime
    : public UParticleModuleAccelerationBase {
   public:
    struct FRawDistributionVector
        AccelOverLife;  // 0x0070 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1677];

        return pClassPointer;
    };
};

UClass* UParticleModuleAccelerationOverLifetime::pClassPointer = NULL;

// Class Engine.ParticleModuleAttractorBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleAttractorBase : public UParticleModule {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1679];

        return pClassPointer;
    };
};

UClass* UParticleModuleAttractorBase::pClassPointer = NULL;

// Class Engine.ParticleModuleAttractorBoneSocket
// 0x010C (0x0178 - 0x006C)
class UParticleModuleAttractorBoneSocket : public UParticleModuleAttractorBase {
   public:
    unsigned char FalloffType;        // 0x006C (0x0001) [0x0000000000000000]
    unsigned char DestinationType;    // 0x006D (0x0001) [0x0000000000000000]
    unsigned char SelectionMethod;    // 0x006E (0x0001) [0x0000000000000000]
    DWORD bParticleLifeRelative : 1;  // 0x0070 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bAttractAlongLengthOfBone : 1;  // 0x0070 (0x0004)
                                          // [0x0000000000000000] [0x00000002]
    struct FRawDistributionFloat
        FalloffExponent;                 // 0x0074 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat Range;  // 0x0098 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        Strength;  // 0x00BC (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        CollisionRadius;  // 0x00E0 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        DragCoefficient;  // 0x0104 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        DragRadius;                  // 0x0128 (0x0024) [0x0000000000000000]
    struct FVector UniversalOffset;  // 0x014C (0x000C) [0x0000000000000000]
    TArray<struct FAttractLocationBoneSocketInfo>
        SourceLocations;  // 0x0158 (0x0010) [0x0000000000000000]
    struct FName
        SkelMeshActorParamName;  // 0x0168 (0x0008) [0x0000000000000000]
    class USkeletalMesh*
        EditorSkelMesh;  // 0x0170 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1681];

        return pClassPointer;
    };
};

UClass* UParticleModuleAttractorBoneSocket::pClassPointer = NULL;

// Class Engine.ParticleModuleAttractorLine
// 0x0060 (0x00CC - 0x006C)
class UParticleModuleAttractorLine : public UParticleModuleAttractorBase {
   public:
    struct FVector EndPoint0;            // 0x006C (0x000C) [0x0000000000000000]
    struct FVector EndPoint1;            // 0x0078 (0x000C) [0x0000000000000000]
    struct FRawDistributionFloat Range;  // 0x0084 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        Strength;  // 0x00A8 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1683];

        return pClassPointer;
    };
};

UClass* UParticleModuleAttractorLine::pClassPointer = NULL;

// Class Engine.ParticleModuleAttractorParticle
// 0x005C (0x00C8 - 0x006C)
class UParticleModuleAttractorParticle : public UParticleModuleAttractorBase {
   public:
    struct FName EmitterName;            // 0x006C (0x0008) [0x0000000000000000]
    struct FRawDistributionFloat Range;  // 0x0074 (0x0024) [0x0000000000000000]
    DWORD bStrengthByDistance : 1;       // 0x0098 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bAffectBaseVelocity : 1;       // 0x0098 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD
        bRenewSource : 1;  // 0x0098 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bInheritSourceVel : 1;  // 0x0098 (0x0004) [0x0000000000000000]
                                  // [0x00000008]
    struct FRawDistributionFloat
        Strength;                   // 0x009C (0x0024) [0x0000000000000000]
    unsigned char SelectionMethod;  // 0x00C0 (0x0001) [0x0000000000000000]
    int LastSelIndex;               // 0x00C4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1685];

        return pClassPointer;
    };
};

UClass* UParticleModuleAttractorParticle::pClassPointer = NULL;

// Class Engine.ParticleModuleAttractorPoint
// 0x0070 (0x00DC - 0x006C)
class UParticleModuleAttractorPoint : public UParticleModuleAttractorBase {
   public:
    struct FRawDistributionVector
        Position;                        // 0x006C (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat Range;  // 0x0090 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        Strength;                      // 0x00B4 (0x0024) [0x0000000000000000]
    DWORD StrengthByDistance : 1;      // 0x00D8 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bAffectBaseVelocity : 1;     // 0x00D8 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD bOverrideVelocity : 1;       // 0x00D8 (0x0004) [0x0000000000000000]
                                       // [0x00000004]
    DWORD bUseWorldSpacePosition : 1;  // 0x00D8 (0x0004) [0x0000000000000000]
                                       // [0x00000008]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1687];

        return pClassPointer;
    };
};

UClass* UParticleModuleAttractorPoint::pClassPointer = NULL;

// Class Engine.ParticleModuleAttractorSkelVertSurface
// 0x0130 (0x019C - 0x006C)
class UParticleModuleAttractorSkelVertSurface
    : public UParticleModuleAttractorBase {
   public:
    unsigned char FalloffType;        // 0x006C (0x0001) [0x0000000000000000]
    unsigned char DestinationType;    // 0x006D (0x0001) [0x0000000000000000]
    DWORD bParticleLifeRelative : 1;  // 0x0070 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bEnforceNormalCheck : 1;    // 0x0070 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    struct FRawDistributionFloat
        FalloffExponent;                 // 0x0074 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat Range;  // 0x0098 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        Strength;  // 0x00BC (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        CollisionRadius;  // 0x00E0 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        DragCoefficient;  // 0x0104 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        DragRadius;                  // 0x0128 (0x0024) [0x0000000000000000]
    struct FVector UniversalOffset;  // 0x014C (0x000C) [0x0000000000000000]
    struct FName
        SkelMeshActorParamName;  // 0x0158 (0x0008) [0x0000000000000000]
    class USkeletalMesh*
        EditorSkelMesh;  // 0x0160 (0x0008) [0x0000000000000000]
    TArray<struct FName>
        ValidAssociatedBones;           // 0x0168 (0x0010) [0x0000000000000000]
    struct FVector NormalToCompare;     // 0x0178 (0x000C) [0x0000000000000000]
    float NormalCheckToleranceDegrees;  // 0x0184 (0x0004) [0x0000000000000000]
    float NormalCheckTolerance;         // 0x0188 (0x0004) [0x0000000000000000]
    TArray<int> ValidMaterialIndices;   // 0x018C (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1689];

        return pClassPointer;
    };
};

UClass* UParticleModuleAttractorSkelVertSurface::pClassPointer = NULL;

// Class Engine.ParticleModuleBeamBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleBeamBase : public UParticleModule {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1691];

        return pClassPointer;
    };
};

UClass* UParticleModuleBeamBase::pClassPointer = NULL;

// Class Engine.ParticleModuleBeamModifier
// 0x0080 (0x00EC - 0x006C)
class UParticleModuleBeamModifier : public UParticleModuleBeamBase {
   public:
    unsigned char ModifierType;  // 0x006C (0x0001) [0x0000000000000000]
    struct FBeamModifierOptions
        PositionOptions;  // 0x0070 (0x0004) [0x0000000000000000]
    struct FRawDistributionVector
        Position;  // 0x0074 (0x0024) [0x0000000000000000]
    struct FBeamModifierOptions
        TangentOptions;  // 0x0098 (0x0004) [0x0000000000000000]
    struct FRawDistributionVector
        Tangent;                 // 0x009C (0x0024) [0x0000000000000000]
    DWORD bAbsoluteTangent : 1;  // 0x00C0 (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    struct FBeamModifierOptions
        StrengthOptions;  // 0x00C4 (0x0004) [0x0000000000000000]
    struct FRawDistributionFloat
        Strength;  // 0x00C8 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1693];

        return pClassPointer;
    };
};

UClass* UParticleModuleBeamModifier::pClassPointer = NULL;

// Class Engine.ParticleModuleBeamNoise
// 0x00D4 (0x0140 - 0x006C)
class UParticleModuleBeamNoise : public UParticleModuleBeamBase {
   public:
    DWORD bLowFreq_Enabled : 1;     // 0x006C (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    DWORD bNRScaleEmitterTime : 1;  // 0x006C (0x0004) [0x0000000000000000]
                                    // [0x00000002]
    DWORD bSmooth : 1;     // 0x006C (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bNoiseLock : 1;  // 0x006C (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bOscillate : 1;  // 0x006C (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bUseNoiseTangents : 1;  // 0x006C (0x0004) [0x0000000000000000]
                                  // [0x00000020]
    DWORD
        bTargetNoise : 1;  // 0x006C (0x0004) [0x0000000000000000] [0x00000040]
    DWORD bApplyNoiseScale : 1;  // 0x006C (0x0004) [0x0000000000000000]
                                 // [0x00000080]
    int Frequency;               // 0x0070 (0x0004) [0x0000000000000000]
    int Frequency_LowRange;      // 0x0074 (0x0004) [0x0000000000000000]
    struct FRawDistributionVector
        NoiseRange;  // 0x0078 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        NoiseRangeScale;  // 0x009C (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        NoiseSpeed;         // 0x00C0 (0x0024) [0x0000000000000000]
    float NoiseLockRadius;  // 0x00E4 (0x0004) [0x0000000000000000]
    float NoiseLockTime;    // 0x00E8 (0x0004) [0x0000000000000000]
    float NoiseTension;     // 0x00EC (0x0004) [0x0000000000000000]
    struct FRawDistributionFloat
        NoiseTangentStrength;  // 0x00F0 (0x0024) [0x0000000000000000]
    int NoiseTessellation;     // 0x0114 (0x0004) [0x0000000000000000]
    float FrequencyDistance;   // 0x0118 (0x0004) [0x0000000000000000]
    struct FRawDistributionFloat
        NoiseScale;  // 0x011C (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1695];

        return pClassPointer;
    };
};

UClass* UParticleModuleBeamNoise::pClassPointer = NULL;

// Class Engine.ParticleModuleBeamSource
// 0x0084 (0x00F0 - 0x006C)
class UParticleModuleBeamSource : public UParticleModuleBeamBase {
   public:
    unsigned char SourceMethod;         // 0x006C (0x0001) [0x0000000000000000]
    unsigned char SourceTangentMethod;  // 0x006D (0x0001) [0x0000000000000000]
    struct FName SourceName;            // 0x0070 (0x0008) [0x0000000000000000]
    struct FName SourceSocketName;      // 0x0078 (0x0008) [0x0000000000000000]
    DWORD bSourceAbsolute : 1;          // 0x0080 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bLockSource : 1;  // 0x0080 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bLockSourceTangent : 1;  // 0x0080 (0x0004) [0x0000000000000000]
                                   // [0x00000004]
    DWORD bLockSourceStength : 1;  // 0x0080 (0x0004) [0x0000000000000000]
                                   // [0x00000008]
    struct FRawDistributionVector
        Source;  // 0x0084 (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        SourceTangent;  // 0x00A8 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        SourceStrength;  // 0x00CC (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1697];

        return pClassPointer;
    };
};

UClass* UParticleModuleBeamSource::pClassPointer = NULL;

// Class Engine.ParticleModuleBeamTarget
// 0x0088 (0x00F4 - 0x006C)
class UParticleModuleBeamTarget : public UParticleModuleBeamBase {
   public:
    unsigned char TargetMethod;         // 0x006C (0x0001) [0x0000000000000000]
    unsigned char TargetTangentMethod;  // 0x006D (0x0001) [0x0000000000000000]
    struct FName TargetName;            // 0x0070 (0x0008) [0x0000000000000000]
    struct FName TargetSocketName;      // 0x0078 (0x0008) [0x0000000000000000]
    struct FRawDistributionVector
        Target;                 // 0x0080 (0x0024) [0x0000000000000000]
    DWORD bTargetAbsolute : 1;  // 0x00A4 (0x0004) [0x0000000000000000]
                                // [0x00000001]
    DWORD bLockTarget : 1;  // 0x00A4 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bLockTargetTangent : 1;  // 0x00A4 (0x0004) [0x0000000000000000]
                                   // [0x00000004]
    DWORD bLockTargetStength : 1;  // 0x00A4 (0x0004) [0x0000000000000000]
                                   // [0x00000008]
    struct FRawDistributionVector
        TargetTangent;  // 0x00A8 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        TargetStrength;  // 0x00CC (0x0024) [0x0000000000000000]
    float LockRadius;    // 0x00F0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1699];

        return pClassPointer;
    };
};

UClass* UParticleModuleBeamTarget::pClassPointer = NULL;

// Class Engine.ParticleModuleCameraBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleCameraBase : public UParticleModule {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1701];

        return pClassPointer;
    };
};

UClass* UParticleModuleCameraBase::pClassPointer = NULL;

// Class Engine.ParticleModuleCameraOffset
// 0x0029 (0x0095 - 0x006C)
class UParticleModuleCameraOffset : public UParticleModuleCameraBase {
   public:
    struct FRawDistributionFloat
        CameraOffset;            // 0x006C (0x0024) [0x0000000000000000]
    DWORD bSpawnTimeOnly : 1;    // 0x0090 (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    unsigned char UpdateMethod;  // 0x0094 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1703];

        return pClassPointer;
    };
};

UClass* UParticleModuleCameraOffset::pClassPointer = NULL;

// Class Engine.ParticleModuleCollisionBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleCollisionBase : public UParticleModule {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1705];

        return pClassPointer;
    };
};

UClass* UParticleModuleCollisionBase::pClassPointer = NULL;

// Class Engine.ParticleModuleCollision
// 0x00D8 (0x0144 - 0x006C)
class UParticleModuleCollision : public UParticleModuleCollisionBase {
   public:
    struct FRawDistributionVector
        DampingFactor;  // 0x006C (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        DampingFactorRotation;  // 0x0090 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        MaxCollisions;  // 0x00B4 (0x0024) [0x0000000000000000]
    unsigned char
        CollisionCompletionOption;  // 0x00D8 (0x0001) [0x0000000000000000]
    DWORD
        bApplyPhysics : 1;  // 0x00DC (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bPawnsDoNotDecrementCount : 1;  // 0x00DC (0x0004)
                                          // [0x0000000000000000] [0x00000002]
    DWORD bOnlyVerticalNormalsDecrementCount : 1;  // 0x00DC (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00000004]
    DWORD bDropDetail : 1;  // 0x00DC (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bCollideOnlyIfVisible : 1;  // 0x00DC (0x0004) [0x0000000000000000]
                                      // [0x00000010]
    DWORD bCollideWithWorld : 1;      // 0x00DC (0x0004) [0x0000000000000000]
                                      // [0x00000020]
    DWORD bCollideWithWorldAttractors : 1;  // 0x00DC (0x0004)
                                            // [0x0000000000000000] [0x00000040]
    struct FRawDistributionFloat
        ParticleMass;           // 0x00E0 (0x0024) [0x0000000000000000]
    float DirScalar;            // 0x0104 (0x0004) [0x0000000000000000]
    float VerticalFudgeFactor;  // 0x0108 (0x0004) [0x0000000000000000]
    struct FRawDistributionFloat
        DelayAmount;             // 0x010C (0x0024) [0x0000000000000000]
    float MaxCollisionDistance;  // 0x0130 (0x0004) [0x0000000000000000]
    TArray<struct FParticleAttractorCollisionAction>
        ParticleAttractorCollisionActions;  // 0x0134 (0x0010)
                                            // [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1707];

        return pClassPointer;
    };
};

UClass* UParticleModuleCollision::pClassPointer = NULL;

// Class Engine.ParticleModuleCollisionActor
// 0x0014 (0x0158 - 0x0144)
class UParticleModuleCollisionActor : public UParticleModuleCollision {
   public:
    TArray<struct FName>
        ActorsToCollideWith;         // 0x0144 (0x0010) [0x0000000000000000]
    DWORD bCheckPawnCollisions : 1;  // 0x0154 (0x0004) [0x0000000000000000]
                                     // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1709];

        return pClassPointer;
    };
};

UClass* UParticleModuleCollisionActor::pClassPointer = NULL;

// Class Engine.ParticleModuleColorBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleColorBase : public UParticleModule {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1711];

        return pClassPointer;
    };
};

UClass* UParticleModuleColorBase::pClassPointer = NULL;

// Class Engine.ParticleModuleColor
// 0x004C (0x00B8 - 0x006C)
class UParticleModuleColor : public UParticleModuleColorBase {
   public:
    struct FRawDistributionVector
        StartColor;  // 0x006C (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        StartAlpha;         // 0x0090 (0x0024) [0x0000000000000000]
    DWORD bClampAlpha : 1;  // 0x00B4 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1713];

        return pClassPointer;
    };
};

UClass* UParticleModuleColor::pClassPointer = NULL;

// Class Engine.ParticleModuleColor_Seeded
// 0x001C (0x00D4 - 0x00B8)
class UParticleModuleColor_Seeded : public UParticleModuleColor {
   public:
    struct FParticleRandomSeedInfo
        RandomSeedInfo;  // 0x00B8 (0x001C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1715];

        return pClassPointer;
    };
};

UClass* UParticleModuleColor_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleColorByParameter
// 0x000C (0x0078 - 0x006C)
class UParticleModuleColorByParameter : public UParticleModuleColorBase {
   public:
    struct FName ColorParam;     // 0x006C (0x0008) [0x0000000000000000]
    struct FColor DefaultColor;  // 0x0074 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1717];

        return pClassPointer;
    };
};

UClass* UParticleModuleColorByParameter::pClassPointer = NULL;

// Class Engine.ParticleModuleColorOverDensity
// 0x0048 (0x00B4 - 0x006C)
class UParticleModuleColorOverDensity : public UParticleModuleColorBase {
   public:
    struct FRawDistributionVector
        ColorOverDensity;  // 0x006C (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        AlphaOverDensity;  // 0x0090 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1719];

        return pClassPointer;
    };
};

UClass* UParticleModuleColorOverDensity::pClassPointer = NULL;

// Class Engine.ParticleModuleColorOverLife
// 0x004C (0x00B8 - 0x006C)
class UParticleModuleColorOverLife : public UParticleModuleColorBase {
   public:
    struct FRawDistributionVector
        ColorOverLife;  // 0x006C (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        AlphaOverLife;      // 0x0090 (0x0024) [0x0000000000000000]
    DWORD bClampAlpha : 1;  // 0x00B4 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1721];

        return pClassPointer;
    };
};

UClass* UParticleModuleColorOverLife::pClassPointer = NULL;

// Class Engine.ParticleModuleColorScaleOverDensity
// 0x0048 (0x00B4 - 0x006C)
class UParticleModuleColorScaleOverDensity : public UParticleModuleColorBase {
   public:
    struct FRawDistributionVector
        ColorScaleOverDensity;  // 0x006C (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        AlphaScaleOverDensity;  // 0x0090 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1723];

        return pClassPointer;
    };
};

UClass* UParticleModuleColorScaleOverDensity::pClassPointer = NULL;

// Class Engine.ParticleModuleColorScaleOverLife
// 0x004C (0x00B8 - 0x006C)
class UParticleModuleColorScaleOverLife : public UParticleModuleColorBase {
   public:
    struct FRawDistributionVector
        ColorScaleOverLife;  // 0x006C (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        AlphaScaleOverLife;  // 0x0090 (0x0024) [0x0000000000000000]
    DWORD
        bEmitterTime : 1;  // 0x00B4 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1725];

        return pClassPointer;
    };
};

UClass* UParticleModuleColorScaleOverLife::pClassPointer = NULL;

// Class Engine.ParticleModuleEventBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleEventBase : public UParticleModule {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1727];

        return pClassPointer;
    };
};

UClass* UParticleModuleEventBase::pClassPointer = NULL;

// Class Engine.ParticleModuleEventGenerator
// 0x0010 (0x007C - 0x006C)
class UParticleModuleEventGenerator : public UParticleModuleEventBase {
   public:
    TArray<struct FParticleEvent_GenerateInfo>
        Events;  // 0x006C (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1729];

        return pClassPointer;
    };
};

UClass* UParticleModuleEventGenerator::pClassPointer = NULL;

// Class Engine.ParticleModuleEventReceiverBase
// 0x000C (0x0078 - 0x006C)
class UParticleModuleEventReceiverBase : public UParticleModuleEventBase {
   public:
    unsigned char EventGeneratorType;  // 0x006C (0x0001) [0x0000000000000000]
    struct FName EventName;            // 0x0070 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1731];

        return pClassPointer;
    };
};

UClass* UParticleModuleEventReceiverBase::pClassPointer = NULL;

// Class Engine.ParticleModuleEventReceiverKillParticles
// 0x0004 (0x007C - 0x0078)
class UParticleModuleEventReceiverKillParticles
    : public UParticleModuleEventReceiverBase {
   public:
    DWORD
        bStopSpawning : 1;  // 0x0078 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1733];

        return pClassPointer;
    };
};

UClass* UParticleModuleEventReceiverKillParticles::pClassPointer = NULL;

// Class Engine.ParticleModuleEventReceiverSpawn
// 0x004C (0x00C4 - 0x0078)
class UParticleModuleEventReceiverSpawn
    : public UParticleModuleEventReceiverBase {
   public:
    struct FRawDistributionFloat
        SpawnCount;              // 0x0078 (0x0024) [0x0000000000000000]
    DWORD bUseParticleTime : 1;  // 0x009C (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    DWORD bUsePSysLocation : 1;  // 0x009C (0x0004) [0x0000000000000000]
                                 // [0x00000002]
    DWORD bInheritVelocity : 1;  // 0x009C (0x0004) [0x0000000000000000]
                                 // [0x00000004]
    struct FRawDistributionVector
        InheritVelocityScale;  // 0x00A0 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1735];

        return pClassPointer;
    };
};

UClass* UParticleModuleEventReceiverSpawn::pClassPointer = NULL;

// Class Engine.TWParticleModuleEventReceiverBlood
// 0x0000 (0x0078 - 0x0078)
class UTWParticleModuleEventReceiverBlood
    : public UParticleModuleEventReceiverBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1737];

        return pClassPointer;
    };
};

UClass* UTWParticleModuleEventReceiverBlood::pClassPointer = NULL;

// Class Engine.TWParticleModuleEventReceiverSFX
// 0x0008 (0x0080 - 0x0078)
class UTWParticleModuleEventReceiverSFX
    : public UParticleModuleEventReceiverBase {
   public:
    class UAkEvent* SFXEvent;  // 0x0078 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1739];

        return pClassPointer;
    };
};

UClass* UTWParticleModuleEventReceiverSFX::pClassPointer = NULL;

// Class Engine.ParticleModuleForceFieldBase
// 0x0008 (0x0074 - 0x006C)
class UParticleModuleForceFieldBase : public UParticleModule {
   public:
    class UNxForceFieldComponent*
        ForceField;  // 0x006C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1741];

        return pClassPointer;
    };

    void eventGetForceFieldInstance();
};

UClass* UParticleModuleForceFieldBase::pClassPointer = NULL;

// Class Engine.ParticleModuleFlexForceField
// 0x0008 (0x007C - 0x0074)
class UParticleModuleFlexForceField : public UParticleModuleForceFieldBase {
   public:
    class UFlexForceFieldComponent*
        FlexForceField;  // 0x0074 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1743];

        return pClassPointer;
    };

    void eventGetFlexForceFieldInstance();
};

UClass* UParticleModuleFlexForceField::pClassPointer = NULL;

// Class Engine.ParticleModuleKillBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleKillBase : public UParticleModule {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1745];

        return pClassPointer;
    };
};

UClass* UParticleModuleKillBase::pClassPointer = NULL;

// Class Engine.ParticleModuleKillBox
// 0x004C (0x00B8 - 0x006C)
class UParticleModuleKillBox : public UParticleModuleKillBase {
   public:
    struct FRawDistributionVector
        LowerLeftCorner;  // 0x006C (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        UpperRightCorner;   // 0x0090 (0x0024) [0x0000000000000000]
    DWORD bAbsolute : 1;    // 0x00B4 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bKillInside : 1;  // 0x00B4 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bAxisAlignedAndFixedSize : 1;  // 0x00B4 (0x0004) [0x0000000000000000]
                                         // [0x00000004]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1747];

        return pClassPointer;
    };
};

UClass* UParticleModuleKillBox::pClassPointer = NULL;

// Class Engine.ParticleModuleKillHeight
// 0x0028 (0x0094 - 0x006C)
class UParticleModuleKillHeight : public UParticleModuleKillBase {
   public:
    struct FRawDistributionFloat
        Height;           // 0x006C (0x0024) [0x0000000000000000]
    DWORD bAbsolute : 1;  // 0x0090 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bFloor : 1;     // 0x0090 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bApplyPSysScale : 1;  // 0x0090 (0x0004) [0x0000000000000000]
                                // [0x00000004]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1749];

        return pClassPointer;
    };
};

UClass* UParticleModuleKillHeight::pClassPointer = NULL;

// Class Engine.ParticleModuleLifetimeBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleLifetimeBase : public UParticleModule {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1751];

        return pClassPointer;
    };
};

UClass* UParticleModuleLifetimeBase::pClassPointer = NULL;

// Class Engine.ParticleModuleLifetime
// 0x0024 (0x0090 - 0x006C)
class UParticleModuleLifetime : public UParticleModuleLifetimeBase {
   public:
    struct FRawDistributionFloat
        Lifetime;  // 0x006C (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1753];

        return pClassPointer;
    };
};

UClass* UParticleModuleLifetime::pClassPointer = NULL;

// Class Engine.ParticleModuleLifetime_Seeded
// 0x001C (0x00AC - 0x0090)
class UParticleModuleLifetime_Seeded : public UParticleModuleLifetime {
   public:
    struct FParticleRandomSeedInfo
        RandomSeedInfo;  // 0x0090 (0x001C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1755];

        return pClassPointer;
    };
};

UClass* UParticleModuleLifetime_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleLocationBase : public UParticleModule {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1757];

        return pClassPointer;
    };
};

UClass* UParticleModuleLocationBase::pClassPointer = NULL;

// Class Engine.ParticleModuleLocation
// 0x002C (0x0098 - 0x006C)
class UParticleModuleLocation : public UParticleModuleLocationBase {
   public:
    struct FRawDistributionVector
        StartLocation;            // 0x006C (0x0024) [0x0000000000000000]
    float DistributeOverNPoints;  // 0x0090 (0x0004) [0x0000000000000000]
    float DistributeThreshold;    // 0x0094 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1759];

        return pClassPointer;
    };
};

UClass* UParticleModuleLocation::pClassPointer = NULL;

// Class Engine.ParticleModuleLocation_Seeded
// 0x001C (0x00B4 - 0x0098)
class UParticleModuleLocation_Seeded : public UParticleModuleLocation {
   public:
    struct FParticleRandomSeedInfo
        RandomSeedInfo;  // 0x0098 (0x001C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1761];

        return pClassPointer;
    };
};

UClass* UParticleModuleLocation_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationWorldOffset
// 0x0000 (0x0098 - 0x0098)
class UParticleModuleLocationWorldOffset : public UParticleModuleLocation {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1763];

        return pClassPointer;
    };
};

UClass* UParticleModuleLocationWorldOffset::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationWorldOffset_Seeded
// 0x001C (0x00B4 - 0x0098)
class UParticleModuleLocationWorldOffset_Seeded
    : public UParticleModuleLocationWorldOffset {
   public:
    struct FParticleRandomSeedInfo
        RandomSeedInfo;  // 0x0098 (0x001C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1765];

        return pClassPointer;
    };
};

UClass* UParticleModuleLocationWorldOffset_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationBoneSocket
// 0x0038 (0x00A4 - 0x006C)
class UParticleModuleLocationBoneSocket : public UParticleModuleLocationBase {
   public:
    unsigned char SourceType;        // 0x006C (0x0001) [0x0000000000000000]
    unsigned char SelectionMethod;   // 0x006D (0x0001) [0x0000000000000000]
    struct FVector UniversalOffset;  // 0x0070 (0x000C) [0x0000000000000000]
    TArray<struct FLocationBoneSocketInfo>
        SourceLocations;                 // 0x007C (0x0010) [0x0000000000000000]
    DWORD bUpdatePositionEachFrame : 1;  // 0x008C (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bOrientMeshEmitters : 1;       // 0x008C (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bInheritVelocityAtSpawn : 1;   // 0x008C (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    struct FName
        SkelMeshActorParamName;  // 0x0090 (0x0008) [0x0000000000000000]
    class USkeletalMesh*
        EditorSkelMesh;    // 0x0098 (0x0008) [0x0000000000000000]
    float LastUpdateTime;  // 0x00A0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1767];

        return pClassPointer;
    };
};

UClass* UParticleModuleLocationBoneSocket::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationDirect
// 0x0090 (0x00FC - 0x006C)
class UParticleModuleLocationDirect : public UParticleModuleLocationBase {
   public:
    struct FRawDistributionVector
        Location;  // 0x006C (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        LocationOffset;  // 0x0090 (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        ScaleFactor;  // 0x00B4 (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        Direction;  // 0x00D8 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1769];

        return pClassPointer;
    };
};

UClass* UParticleModuleLocationDirect::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationEmitter
// 0x0018 (0x0084 - 0x006C)
class UParticleModuleLocationEmitter : public UParticleModuleLocationBase {
   public:
    struct FName EmitterName;          // 0x006C (0x0008) [0x0000000000000000]
    unsigned char SelectionMethod;     // 0x0074 (0x0001) [0x0000000000000000]
    DWORD InheritSourceVelocity : 1;   // 0x0078 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bInheritSourceRotation : 1;  // 0x0078 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    float InheritSourceVelocityScale;  // 0x007C (0x0004) [0x0000000000000000]
    float InheritSourceRotationScale;  // 0x0080 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1771];

        return pClassPointer;
    };
};

UClass* UParticleModuleLocationEmitter::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationEmitterDirect
// 0x0008 (0x0074 - 0x006C)
class UParticleModuleLocationEmitterDirect
    : public UParticleModuleLocationBase {
   public:
    struct FName EmitterName;  // 0x006C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1773];

        return pClassPointer;
    };
};

UClass* UParticleModuleLocationEmitterDirect::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationPrimitiveBase
// 0x004C (0x00B8 - 0x006C)
class UParticleModuleLocationPrimitiveBase
    : public UParticleModuleLocationBase {
   public:
    DWORD Positive_X : 1;   // 0x006C (0x0004) [0x0000000000000000] [0x00000001]
    DWORD Positive_Y : 1;   // 0x006C (0x0004) [0x0000000000000000] [0x00000002]
    DWORD Positive_Z : 1;   // 0x006C (0x0004) [0x0000000000000000] [0x00000004]
    DWORD Negative_X : 1;   // 0x006C (0x0004) [0x0000000000000000] [0x00000008]
    DWORD Negative_Y : 1;   // 0x006C (0x0004) [0x0000000000000000] [0x00000010]
    DWORD Negative_Z : 1;   // 0x006C (0x0004) [0x0000000000000000] [0x00000020]
    DWORD SurfaceOnly : 1;  // 0x006C (0x0004) [0x0000000000000000] [0x00000040]
    DWORD Velocity : 1;     // 0x006C (0x0004) [0x0000000000000000] [0x00000080]
    struct FRawDistributionFloat
        VelocityScale;  // 0x0070 (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        StartLocation;  // 0x0094 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1775];

        return pClassPointer;
    };
};

UClass* UParticleModuleLocationPrimitiveBase::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationPrimitiveCylinder
// 0x004D (0x0105 - 0x00B8)
class UParticleModuleLocationPrimitiveCylinder
    : public UParticleModuleLocationPrimitiveBase {
   public:
    DWORD RadialVelocity : 1;        // 0x00B8 (0x0004) [0x0000000000000000]
                                     // [0x00000001]
    DWORD bAdjustForWorldSpace : 1;  // 0x00B8 (0x0004) [0x0000000000000000]
                                     // [0x00000002]
    struct FRawDistributionFloat
        StartRadius;  // 0x00BC (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        StartHeight;           // 0x00E0 (0x0024) [0x0000000000000000]
    unsigned char HeightAxis;  // 0x0104 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1777];

        return pClassPointer;
    };
};

UClass* UParticleModuleLocationPrimitiveCylinder::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationPrimitiveCylinder_Seeded
// 0x001F (0x0124 - 0x0105)
class UParticleModuleLocationPrimitiveCylinder_Seeded
    : public UParticleModuleLocationPrimitiveCylinder {
   public:
    struct FParticleRandomSeedInfo
        RandomSeedInfo;  // 0x0108 (0x001C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1779];

        return pClassPointer;
    };
};

UClass* UParticleModuleLocationPrimitiveCylinder_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationPrimitiveSphere
// 0x0024 (0x00DC - 0x00B8)
class UParticleModuleLocationPrimitiveSphere
    : public UParticleModuleLocationPrimitiveBase {
   public:
    struct FRawDistributionFloat
        StartRadius;  // 0x00B8 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1781];

        return pClassPointer;
    };
};

UClass* UParticleModuleLocationPrimitiveSphere::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationPrimitiveSphere_Seeded
// 0x001C (0x00F8 - 0x00DC)
class UParticleModuleLocationPrimitiveSphere_Seeded
    : public UParticleModuleLocationPrimitiveSphere {
   public:
    struct FParticleRandomSeedInfo
        RandomSeedInfo;  // 0x00DC (0x001C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1783];

        return pClassPointer;
    };
};

UClass* UParticleModuleLocationPrimitiveSphere_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationSkelVertSurface
// 0x0058 (0x00C4 - 0x006C)
class UParticleModuleLocationSkelVertSurface
    : public UParticleModuleLocationBase {
   public:
    unsigned char SourceType;            // 0x006C (0x0001) [0x0000000000000000]
    struct FVector UniversalOffset;      // 0x0070 (0x000C) [0x0000000000000000]
    DWORD bUpdatePositionEachFrame : 1;  // 0x007C (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bOrientMeshEmitters : 1;       // 0x007C (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bEnforceNormalCheck : 1;       // 0x007C (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    struct FName
        SkelMeshActorParamName;  // 0x0080 (0x0008) [0x0000000000000000]
    class USkeletalMesh*
        EditorSkelMesh;  // 0x0088 (0x0008) [0x0000000000000000]
    TArray<struct FName>
        ValidAssociatedBones;           // 0x0090 (0x0010) [0x0000000000000000]
    struct FVector NormalToCompare;     // 0x00A0 (0x000C) [0x0000000000000000]
    float NormalCheckToleranceDegrees;  // 0x00AC (0x0004) [0x0000000000000000]
    float NormalCheckTolerance;         // 0x00B0 (0x0004) [0x0000000000000000]
    TArray<int> ValidMaterialIndices;   // 0x00B4 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1785];

        return pClassPointer;
    };
};

UClass* UParticleModuleLocationSkelVertSurface::pClassPointer = NULL;

// Class Engine.ParticleModuleLocationStaticVertSurface
// 0x0048 (0x00B4 - 0x006C)
class UParticleModuleLocationStaticVertSurface
    : public UParticleModuleLocationBase {
   public:
    unsigned char SourceType;            // 0x006C (0x0001) [0x0000000000000000]
    struct FVector UniversalOffset;      // 0x0070 (0x000C) [0x0000000000000000]
    DWORD bUpdatePositionEachFrame : 1;  // 0x007C (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bOrientMeshEmitters : 1;       // 0x007C (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bEnforceNormalCheck : 1;       // 0x007C (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    struct FName
        StaticMeshActorParamName;  // 0x0080 (0x0008) [0x0000000000000000]
    class UStaticMesh*
        EditorStaticMesh;               // 0x0088 (0x0008) [0x0000000000000000]
    struct FVector NormalToCompare;     // 0x0090 (0x000C) [0x0000000000000000]
    float NormalCheckToleranceDegrees;  // 0x009C (0x0004) [0x0000000000000000]
    float NormalCheckTolerance;         // 0x00A0 (0x0004) [0x0000000000000000]
    TArray<int> ValidMaterialIndices;   // 0x00A4 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1787];

        return pClassPointer;
    };
};

UClass* UParticleModuleLocationStaticVertSurface::pClassPointer = NULL;

// Class Engine.ParticleModuleSourceMovement
// 0x0024 (0x0090 - 0x006C)
class UParticleModuleSourceMovement : public UParticleModuleLocationBase {
   public:
    struct FRawDistributionVector
        SourceMovementScale;  // 0x006C (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1789];

        return pClassPointer;
    };
};

UClass* UParticleModuleSourceMovement::pClassPointer = NULL;

// Class Engine.ParticleModuleMaterialBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleMaterialBase : public UParticleModule {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1791];

        return pClassPointer;
    };
};

UClass* UParticleModuleMaterialBase::pClassPointer = NULL;

// Class Engine.ParticleModuleMaterialByParameter
// 0x0020 (0x008C - 0x006C)
class UParticleModuleMaterialByParameter : public UParticleModuleMaterialBase {
   public:
    TArray<struct FName>
        MaterialParameters;  // 0x006C (0x0010) [0x0000000000000000]
    TArray<class UMaterialInterface*>
        DefaultMaterials;  // 0x007C (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1793];

        return pClassPointer;
    };
};

UClass* UParticleModuleMaterialByParameter::pClassPointer = NULL;

// Class Engine.ParticleModuleMeshMaterial
// 0x0010 (0x007C - 0x006C)
class UParticleModuleMeshMaterial : public UParticleModuleMaterialBase {
   public:
    TArray<class UMaterialInterface*>
        MeshMaterials;  // 0x006C (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1795];

        return pClassPointer;
    };
};

UClass* UParticleModuleMeshMaterial::pClassPointer = NULL;

// Class Engine.ParticleModuleOrbitBase
// 0x0004 (0x0070 - 0x006C)
class UParticleModuleOrbitBase : public UParticleModule {
   public:
    DWORD bUseEmitterTime : 1;  // 0x006C (0x0004) [0x0000000000000000]
                                // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1797];

        return pClassPointer;
    };
};

UClass* UParticleModuleOrbitBase::pClassPointer = NULL;

// Class Engine.ParticleModuleOrbit
// 0x007C (0x00EC - 0x0070)
class UParticleModuleOrbit : public UParticleModuleOrbitBase {
   public:
    unsigned char ChainMode;  // 0x0070 (0x0001) [0x0000000000000000]
    struct FRawDistributionVector
        OffsetAmount;                    // 0x0074 (0x0024) [0x0000000000000000]
    struct FOrbitOptions OffsetOptions;  // 0x0098 (0x0004) [0x0000000000000000]
    struct FRawDistributionVector
        RotationAmount;  // 0x009C (0x0024) [0x0000000000000000]
    struct FOrbitOptions
        RotationOptions;  // 0x00C0 (0x0004) [0x0000000000000000]
    struct FRawDistributionVector
        RotationRateAmount;  // 0x00C4 (0x0024) [0x0000000000000000]
    struct FOrbitOptions
        RotationRateOptions;  // 0x00E8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1799];

        return pClassPointer;
    };
};

UClass* UParticleModuleOrbit::pClassPointer = NULL;

// Class Engine.ParticleModuleOrientationBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleOrientationBase : public UParticleModule {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1801];

        return pClassPointer;
    };
};

UClass* UParticleModuleOrientationBase::pClassPointer = NULL;

// Class Engine.ParticleModuleOrientationAxisLock
// 0x0001 (0x006D - 0x006C)
class UParticleModuleOrientationAxisLock
    : public UParticleModuleOrientationBase {
   public:
    unsigned char LockAxisFlags;  // 0x006C (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1803];

        return pClassPointer;
    };
};

UClass* UParticleModuleOrientationAxisLock::pClassPointer = NULL;

// Class Engine.ParticleModuleParameterBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleParameterBase : public UParticleModule {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1805];

        return pClassPointer;
    };
};

UClass* UParticleModuleParameterBase::pClassPointer = NULL;

// Class Engine.ParticleModuleParameterDynamic
// 0x0018 (0x0084 - 0x006C)
class UParticleModuleParameterDynamic : public UParticleModuleParameterBase {
   public:
    TArray<struct FEmitterDynamicParameter>
        DynamicParams;  // 0x006C (0x0010) [0x0000000000000000]
    int UpdateFlags;    // 0x007C (0x0004) [0x0000000000000000]
    DWORD
        bUsesVelocity : 1;  // 0x0080 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1807];

        return pClassPointer;
    };
};

UClass* UParticleModuleParameterDynamic::pClassPointer = NULL;

// Class Engine.ParticleModuleParameterDynamic_Seeded
// 0x001C (0x00A0 - 0x0084)
class UParticleModuleParameterDynamic_Seeded
    : public UParticleModuleParameterDynamic {
   public:
    struct FParticleRandomSeedInfo
        RandomSeedInfo;  // 0x0084 (0x001C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1809];

        return pClassPointer;
    };
};

UClass* UParticleModuleParameterDynamic_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleRequired
// 0x00AC (0x0118 - 0x006C)
class UParticleModuleRequired : public UParticleModule {
   public:
    class UMaterialInterface* Material;  // 0x006C (0x0008) [0x0000000000000000]
    unsigned char ScreenAlignment;       // 0x0074 (0x0001) [0x0000000000000000]
    unsigned char SortMode;              // 0x0075 (0x0001) [0x0000000000000000]
    unsigned char ParticleBurstMethod;   // 0x0076 (0x0001) [0x0000000000000000]
    unsigned char InterpolationMethod;   // 0x0077 (0x0001) [0x0000000000000000]
    unsigned char EmitterNormalsMode;    // 0x0078 (0x0001) [0x0000000000000000]
    DWORD bAllowImageFlipping : 1;       // 0x007C (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bSquareImageFlipping : 1;      // 0x007C (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bUseLocalSpace : 1;            // 0x007C (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD bKillOnDeactivate : 1;         // 0x007C (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    DWORD bKillOnCompleted : 1;          // 0x007C (0x0004) [0x0000000000000000]
                                         // [0x00000010]
    DWORD bRequiresSorting : 1;          // 0x007C (0x0004) [0x0000000000000000]
                                         // [0x00000020]
    DWORD bUseLegacyEmitterTime : 1;     // 0x007C (0x0004) [0x0000000000000000]
                                         // [0x00000040]
    DWORD bEnableNearParticleCulling : 1;  // 0x007C (0x0004)
                                           // [0x0000000000000000] [0x00000080]
    DWORD bEnableFarParticleCulling : 1;   // 0x007C (0x0004)
                                           // [0x0000000000000000] [0x00000100]
    DWORD bEmitterDurationUseRange : 1;  // 0x007C (0x0004) [0x0000000000000000]
                                         // [0x00000200]
    DWORD bDurationRecalcEachLoop : 1;   // 0x007C (0x0004) [0x0000000000000000]
                                         // [0x00000400]
    DWORD bEmitterDelayUseRange : 1;     // 0x007C (0x0004) [0x0000000000000000]
                                         // [0x00000800]
    DWORD bDelayFirstLoopOnly : 1;       // 0x007C (0x0004) [0x0000000000000000]
                                         // [0x00001000]
    DWORD bScaleUV : 1;   // 0x007C (0x0004) [0x0000000000000000] [0x00002000]
    DWORD bDirectUV : 1;  // 0x007C (0x0004) [0x0000000000000000] [0x00004000]
    DWORD bOverrideSystemMacroUV : 1;  // 0x007C (0x0004) [0x0000000000000000]
                                       // [0x00008000]
    DWORD bUseMaxDrawCount : 1;        // 0x007C (0x0004) [0x0000000000000000]
                                       // [0x00010000]
    DWORD bOrbitModuleAffectsVelocityAlignment : 1;  // 0x007C (0x0004)
                                                     // [0x0000000000000000]
                                                     // [0x00020000]
    float NearCullDistance;    // 0x0080 (0x0004) [0x0000000000000000]
    float NearFadeDistance;    // 0x0084 (0x0004) [0x0000000000000000]
    float FarFadeDistance;     // 0x0088 (0x0004) [0x0000000000000000]
    float FarCullDistance;     // 0x008C (0x0004) [0x0000000000000000]
    float EmitterDuration;     // 0x0090 (0x0004) [0x0000000000000000]
    float EmitterDurationLow;  // 0x0094 (0x0004) [0x0000000000000000]
    int EmitterLoops;          // 0x0098 (0x0004) [0x0000000000000000]
    struct FRawDistributionFloat
        SpawnRate;  // 0x009C (0x0024) [0x0000000000000000]
    TArray<struct FParticleBurst>
        BurstList;                   // 0x00C0 (0x0010) [0x0000000000000000]
    float EmitterDelay;              // 0x00D0 (0x0004) [0x0000000000000000]
    float EmitterDelayLow;           // 0x00D4 (0x0004) [0x0000000000000000]
    int SubImages_Horizontal;        // 0x00D8 (0x0004) [0x0000000000000000]
    int SubImages_Vertical;          // 0x00DC (0x0004) [0x0000000000000000]
    float RandomImageTime;           // 0x00E0 (0x0004) [0x0000000000000000]
    int RandomImageChanges;          // 0x00E4 (0x0004) [0x0000000000000000]
    struct FVector MacroUVPosition;  // 0x00E8 (0x000C) [0x0000000000000000]
    float MacroUVRadius;             // 0x00F4 (0x0004) [0x0000000000000000]
    int MaxDrawCount;                // 0x00F8 (0x0004) [0x0000000000000000]
    float DownsampleThresholdScreenFraction;  // 0x00FC (0x0004)
                                              // [0x0000000000000000]
    struct FVector NormalsSphereCenter;  // 0x0100 (0x000C) [0x0000000000000000]
    struct FVector
        NormalsCylinderDirection;  // 0x010C (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1811];

        return pClassPointer;
    };
};

UClass* UParticleModuleRequired::pClassPointer = NULL;

// Class Engine.ParticleModuleRotationBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleRotationBase : public UParticleModule {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1813];

        return pClassPointer;
    };
};

UClass* UParticleModuleRotationBase::pClassPointer = NULL;

// Class Engine.ParticleModuleMeshRotation
// 0x0028 (0x0094 - 0x006C)
class UParticleModuleMeshRotation : public UParticleModuleRotationBase {
   public:
    struct FRawDistributionVector
        StartRotation;         // 0x006C (0x0024) [0x0000000000000000]
    DWORD bInheritParent : 1;  // 0x0090 (0x0004) [0x0000000000000000]
                               // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1815];

        return pClassPointer;
    };
};

UClass* UParticleModuleMeshRotation::pClassPointer = NULL;

// Class Engine.ParticleModuleMeshRotation_Seeded
// 0x001C (0x00B0 - 0x0094)
class UParticleModuleMeshRotation_Seeded : public UParticleModuleMeshRotation {
   public:
    struct FParticleRandomSeedInfo
        RandomSeedInfo;  // 0x0094 (0x001C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1817];

        return pClassPointer;
    };
};

UClass* UParticleModuleMeshRotation_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleRotation
// 0x0024 (0x0090 - 0x006C)
class UParticleModuleRotation : public UParticleModuleRotationBase {
   public:
    struct FRawDistributionFloat
        StartRotation;  // 0x006C (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1819];

        return pClassPointer;
    };
};

UClass* UParticleModuleRotation::pClassPointer = NULL;

// Class Engine.ParticleModuleRotation_Seeded
// 0x001C (0x00AC - 0x0090)
class UParticleModuleRotation_Seeded : public UParticleModuleRotation {
   public:
    struct FParticleRandomSeedInfo
        RandomSeedInfo;  // 0x0090 (0x001C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1821];

        return pClassPointer;
    };
};

UClass* UParticleModuleRotation_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleRotationOverLifetime
// 0x0028 (0x0094 - 0x006C)
class UParticleModuleRotationOverLifetime : public UParticleModuleRotationBase {
   public:
    struct FRawDistributionFloat
        RotationOverLife;  // 0x006C (0x0024) [0x0000000000000000]
    DWORD Scale : 1;       // 0x0090 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1823];

        return pClassPointer;
    };
};

UClass* UParticleModuleRotationOverLifetime::pClassPointer = NULL;

// Class Engine.ParticleModuleRotationRateBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleRotationRateBase : public UParticleModule {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1825];

        return pClassPointer;
    };
};

UClass* UParticleModuleRotationRateBase::pClassPointer = NULL;

// Class Engine.ParticleModuleMeshRotationRate
// 0x0024 (0x0090 - 0x006C)
class UParticleModuleMeshRotationRate : public UParticleModuleRotationRateBase {
   public:
    struct FRawDistributionVector
        StartRotationRate;  // 0x006C (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1827];

        return pClassPointer;
    };
};

UClass* UParticleModuleMeshRotationRate::pClassPointer = NULL;

// Class Engine.ParticleModuleMeshRotationRate_Seeded
// 0x001C (0x00AC - 0x0090)
class UParticleModuleMeshRotationRate_Seeded
    : public UParticleModuleMeshRotationRate {
   public:
    struct FParticleRandomSeedInfo
        RandomSeedInfo;  // 0x0090 (0x001C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1829];

        return pClassPointer;
    };
};

UClass* UParticleModuleMeshRotationRate_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleMeshRotationRateMultiplyLife
// 0x0024 (0x0090 - 0x006C)
class UParticleModuleMeshRotationRateMultiplyLife
    : public UParticleModuleRotationRateBase {
   public:
    struct FRawDistributionVector
        LifeMultiplier;  // 0x006C (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1831];

        return pClassPointer;
    };
};

UClass* UParticleModuleMeshRotationRateMultiplyLife::pClassPointer = NULL;

// Class Engine.ParticleModuleMeshRotationRateOverLife
// 0x0028 (0x0094 - 0x006C)
class UParticleModuleMeshRotationRateOverLife
    : public UParticleModuleRotationRateBase {
   public:
    struct FRawDistributionVector
        RotRate;  // 0x006C (0x0024) [0x0000000000000000]
    DWORD
        bScaleRotRate : 1;  // 0x0090 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1833];

        return pClassPointer;
    };
};

UClass* UParticleModuleMeshRotationRateOverLife::pClassPointer = NULL;

// Class Engine.ParticleModuleRotationRate
// 0x0024 (0x0090 - 0x006C)
class UParticleModuleRotationRate : public UParticleModuleRotationRateBase {
   public:
    struct FRawDistributionFloat
        StartRotationRate;  // 0x006C (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1835];

        return pClassPointer;
    };
};

UClass* UParticleModuleRotationRate::pClassPointer = NULL;

// Class Engine.ParticleModuleRotationRate_Seeded
// 0x001C (0x00AC - 0x0090)
class UParticleModuleRotationRate_Seeded : public UParticleModuleRotationRate {
   public:
    struct FParticleRandomSeedInfo
        RandomSeedInfo;  // 0x0090 (0x001C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1837];

        return pClassPointer;
    };
};

UClass* UParticleModuleRotationRate_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleRotationRateMultiplyLife
// 0x0024 (0x0090 - 0x006C)
class UParticleModuleRotationRateMultiplyLife
    : public UParticleModuleRotationRateBase {
   public:
    struct FRawDistributionFloat
        LifeMultiplier;  // 0x006C (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1839];

        return pClassPointer;
    };
};

UClass* UParticleModuleRotationRateMultiplyLife::pClassPointer = NULL;

// Class Engine.ParticleModuleSizeBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleSizeBase : public UParticleModule {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1841];

        return pClassPointer;
    };
};

UClass* UParticleModuleSizeBase::pClassPointer = NULL;

// Class Engine.ParticleModuleSize
// 0x0024 (0x0090 - 0x006C)
class UParticleModuleSize : public UParticleModuleSizeBase {
   public:
    struct FRawDistributionVector
        StartSize;  // 0x006C (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1843];

        return pClassPointer;
    };
};

UClass* UParticleModuleSize::pClassPointer = NULL;

// Class Engine.ParticleModuleSize_Seeded
// 0x001C (0x00AC - 0x0090)
class UParticleModuleSize_Seeded : public UParticleModuleSize {
   public:
    struct FParticleRandomSeedInfo
        RandomSeedInfo;  // 0x0090 (0x001C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1845];

        return pClassPointer;
    };
};

UClass* UParticleModuleSize_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleSizeMultiplyLife
// 0x0028 (0x0094 - 0x006C)
class UParticleModuleSizeMultiplyLife : public UParticleModuleSizeBase {
   public:
    struct FRawDistributionVector
        LifeMultiplier;   // 0x006C (0x0024) [0x0000000000000000]
    DWORD MultiplyX : 1;  // 0x0090 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD MultiplyY : 1;  // 0x0090 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD MultiplyZ : 1;  // 0x0090 (0x0004) [0x0000000000000000] [0x00000004]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1847];

        return pClassPointer;
    };
};

UClass* UParticleModuleSizeMultiplyLife::pClassPointer = NULL;

// Class Engine.ParticleModuleSizeMultiplyVelocity
// 0x0040 (0x00AC - 0x006C)
class UParticleModuleSizeMultiplyVelocity : public UParticleModuleSizeBase {
   public:
    struct FRawDistributionVector
        VelocityMultiplier;  // 0x006C (0x0024) [0x0000000000000000]
    DWORD MultiplyX : 1;  // 0x0090 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD MultiplyY : 1;  // 0x0090 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD MultiplyZ : 1;  // 0x0090 (0x0004) [0x0000000000000000] [0x00000004]
    struct FVector CapMaxSize;  // 0x0094 (0x000C) [0x0000000000000000]
    struct FVector CapMinSize;  // 0x00A0 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1849];

        return pClassPointer;
    };
};

UClass* UParticleModuleSizeMultiplyVelocity::pClassPointer = NULL;

// Class Engine.ParticleModuleSizeScale
// 0x0028 (0x0094 - 0x006C)
class UParticleModuleSizeScale : public UParticleModuleSizeBase {
   public:
    struct FRawDistributionVector
        SizeScale;      // 0x006C (0x0024) [0x0000000000000000]
    DWORD EnableX : 1;  // 0x0090 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD EnableY : 1;  // 0x0090 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD EnableZ : 1;  // 0x0090 (0x0004) [0x0000000000000000] [0x00000004]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1851];

        return pClassPointer;
    };
};

UClass* UParticleModuleSizeScale::pClassPointer = NULL;

// Class Engine.ParticleModuleSizeScaleByTime
// 0x0028 (0x0094 - 0x006C)
class UParticleModuleSizeScaleByTime : public UParticleModuleSizeBase {
   public:
    struct FRawDistributionVector
        SizeScaleByTime;  // 0x006C (0x0024) [0x0000000000000000]
    DWORD bEnableX : 1;   // 0x0090 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bEnableY : 1;   // 0x0090 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bEnableZ : 1;   // 0x0090 (0x0004) [0x0000000000000000] [0x00000004]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1853];

        return pClassPointer;
    };
};

UClass* UParticleModuleSizeScaleByTime::pClassPointer = NULL;

// Class Engine.ParticleModuleSizeScaleOverDensity
// 0x0024 (0x0090 - 0x006C)
class UParticleModuleSizeScaleOverDensity : public UParticleModuleSizeBase {
   public:
    struct FRawDistributionVector
        SizeScaleOverDensity;  // 0x006C (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1855];

        return pClassPointer;
    };
};

UClass* UParticleModuleSizeScaleOverDensity::pClassPointer = NULL;

// Class Engine.ParticleModuleSpawnBase
// 0x0004 (0x0070 - 0x006C)
class UParticleModuleSpawnBase : public UParticleModule {
   public:
    DWORD bProcessSpawnRate : 1;  // 0x006C (0x0004) [0x0000000000000000]
                                  // [0x00000001]
    DWORD bProcessBurstList : 1;  // 0x006C (0x0004) [0x0000000000000000]
                                  // [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1857];

        return pClassPointer;
    };
};

UClass* UParticleModuleSpawnBase::pClassPointer = NULL;

// Class Engine.ParticleModuleFlexSpawn
// 0x000C (0x007C - 0x0070)
class UParticleModuleFlexSpawn : public UParticleModuleSpawnBase {
   public:
    int DimX;        // 0x0070 (0x0004) [0x0000000000000000]
    int DimY;        // 0x0074 (0x0004) [0x0000000000000000]
    float Velocity;  // 0x0078 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1859];

        return pClassPointer;
    };
};

UClass* UParticleModuleFlexSpawn::pClassPointer = NULL;

// Class Engine.ParticleModuleSpawn
// 0x005C (0x00CC - 0x0070)
class UParticleModuleSpawn : public UParticleModuleSpawnBase {
   public:
    struct FRawDistributionFloat Rate;  // 0x0070 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        RateScale;                      // 0x0094 (0x0024) [0x0000000000000000]
    unsigned char ParticleBurstMethod;  // 0x00B8 (0x0001) [0x0000000000000000]
    TArray<struct FParticleBurst>
        BurstList;  // 0x00BC (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1861];

        return pClassPointer;
    };
};

UClass* UParticleModuleSpawn::pClassPointer = NULL;

// Class Engine.ParticleModuleSpawnPerUnit
// 0x0038 (0x00A8 - 0x0070)
class UParticleModuleSpawnPerUnit : public UParticleModuleSpawnBase {
   public:
    float UnitScalar;  // 0x0070 (0x0004) [0x0000000000000000]
    struct FRawDistributionFloat
        SpawnPerUnit;  // 0x0074 (0x0024) [0x0000000000000000]
    DWORD bIgnoreSpawnRateWhenMoving : 1;  // 0x0098 (0x0004)
                                           // [0x0000000000000000] [0x00000001]
    DWORD bIgnoreMovementAlongX : 1;  // 0x0098 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bIgnoreMovementAlongY : 1;  // 0x0098 (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    DWORD bIgnoreMovementAlongZ : 1;  // 0x0098 (0x0004) [0x0000000000000000]
                                      // [0x00000008]
    float MovementTolerance;          // 0x009C (0x0004) [0x0000000000000000]
    float MaxFrameDistance;           // 0x00A0 (0x0004) [0x0000000000000000]
    float MinFrameDistance;           // 0x00A4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1863];

        return pClassPointer;
    };
};

UClass* UParticleModuleSpawnPerUnit::pClassPointer = NULL;

// Class Engine.ParticleModuleStoreSpawnTimeBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleStoreSpawnTimeBase : public UParticleModule {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1865];

        return pClassPointer;
    };
};

UClass* UParticleModuleStoreSpawnTimeBase::pClassPointer = NULL;

// Class Engine.ParticleModuleStoreSpawnTime
// 0x0000 (0x006C - 0x006C)
class UParticleModuleStoreSpawnTime : public UParticleModuleStoreSpawnTimeBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1867];

        return pClassPointer;
    };
};

UClass* UParticleModuleStoreSpawnTime::pClassPointer = NULL;

// Class Engine.ParticleModuleSubUVBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleSubUVBase : public UParticleModule {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1869];

        return pClassPointer;
    };
};

UClass* UParticleModuleSubUVBase::pClassPointer = NULL;

// Class Engine.ParticleModuleSubUV
// 0x0028 (0x0094 - 0x006C)
class UParticleModuleSubUV : public UParticleModuleSubUVBase {
   public:
    struct FRawDistributionFloat
        SubImageIndex;  // 0x006C (0x0024) [0x0000000000000000]
    DWORD
        bUseRealTime : 1;  // 0x0090 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1871];

        return pClassPointer;
    };
};

UClass* UParticleModuleSubUV::pClassPointer = NULL;

// Class Engine.ParticleModuleSubUVMovie
// 0x002C (0x00C0 - 0x0094)
class UParticleModuleSubUVMovie : public UParticleModuleSubUV {
   public:
    DWORD bUseEmitterTime : 1;  // 0x0094 (0x0004) [0x0000000000000000]
                                // [0x00000001]
    struct FRawDistributionFloat
        FrameRate;      // 0x0098 (0x0024) [0x0000000000000000]
    int StartingFrame;  // 0x00BC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1873];

        return pClassPointer;
    };
};

UClass* UParticleModuleSubUVMovie::pClassPointer = NULL;

// Class Engine.ParticleModuleSubUVDirect
// 0x0048 (0x00B4 - 0x006C)
class UParticleModuleSubUVDirect : public UParticleModuleSubUVBase {
   public:
    struct FRawDistributionVector
        SubUVPosition;  // 0x006C (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        SubUVSize;  // 0x0090 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1875];

        return pClassPointer;
    };
};

UClass* UParticleModuleSubUVDirect::pClassPointer = NULL;

// Class Engine.ParticleModuleSubUVSelect
// 0x0024 (0x0090 - 0x006C)
class UParticleModuleSubUVSelect : public UParticleModuleSubUVBase {
   public:
    struct FRawDistributionVector
        SubImageSelect;  // 0x006C (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1877];

        return pClassPointer;
    };
};

UClass* UParticleModuleSubUVSelect::pClassPointer = NULL;

// Class Engine.ParticleModuleTrailBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleTrailBase : public UParticleModule {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1879];

        return pClassPointer;
    };
};

UClass* UParticleModuleTrailBase::pClassPointer = NULL;

// Class Engine.ParticleModuleTrailSource
// 0x0048 (0x00B4 - 0x006C)
class UParticleModuleTrailSource : public UParticleModuleTrailBase {
   public:
    unsigned char SourceMethod;     // 0x006C (0x0001) [0x0000000000000000]
    unsigned char SelectionMethod;  // 0x006D (0x0001) [0x0000000000000000]
    struct FName SourceName;        // 0x0070 (0x0008) [0x0000000000000000]
    struct FRawDistributionFloat
        SourceStrength;            // 0x0078 (0x0024) [0x0000000000000000]
    DWORD bLockSourceStength : 1;  // 0x009C (0x0004) [0x0000000000000000]
                                   // [0x00000001]
    DWORD bInheritRotation : 1;    // 0x009C (0x0004) [0x0000000000000000]
                                   // [0x00000002]
    int SourceOffsetCount;         // 0x00A0 (0x0004) [0x0000000000000000]
    TArray<struct FVector>
        SourceOffsetDefaults;  // 0x00A4 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1881];

        return pClassPointer;
    };
};

UClass* UParticleModuleTrailSource::pClassPointer = NULL;

// Class Engine.ParticleModuleTrailSpawn
// 0x000C (0x0078 - 0x006C)
class UParticleModuleTrailSpawn : public UParticleModuleTrailBase {
   public:
    class UDistributionFloatParticleParameter*
        SpawnDistanceMap;    // 0x006C (0x0008) [0x0000000000000000]
    float MinSpawnVelocity;  // 0x0074 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1883];

        return pClassPointer;
    };
};

UClass* UParticleModuleTrailSpawn::pClassPointer = NULL;

// Class Engine.ParticleModuleTrailTaper
// 0x0028 (0x0094 - 0x006C)
class UParticleModuleTrailTaper : public UParticleModuleTrailBase {
   public:
    unsigned char TaperMethod;  // 0x006C (0x0001) [0x0000000000000000]
    struct FRawDistributionFloat
        TaperFactor;  // 0x0070 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1885];

        return pClassPointer;
    };
};

UClass* UParticleModuleTrailTaper::pClassPointer = NULL;

// Class Engine.ParticleModuleTypeDataBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleTypeDataBase : public UParticleModule {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1887];

        return pClassPointer;
    };
};

UClass* UParticleModuleTypeDataBase::pClassPointer = NULL;

// Class Engine.ParticleModuleTypeDataAnimTrail
// 0x001C (0x0088 - 0x006C)
class UParticleModuleTypeDataAnimTrail : public UParticleModuleTypeDataBase {
   public:
    struct FName ControlEdgeName;       // 0x006C (0x0008) [0x0000000000000000]
    int SheetsPerTrail;                 // 0x0074 (0x0004) [0x0000000000000000]
    DWORD bDeadTrailsOnDeactivate : 1;  // 0x0078 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bClipSourceSegement : 1;      // 0x0078 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bEnablePreviousTangentRecalculation : 1;  // 0x0078 (0x0004)
                                                    // [0x0000000000000000]
                                                    // [0x00000004]
    DWORD bTangentRecalculationEveryFrame : 1;      // 0x0078 (0x0004)
                                                    // [0x0000000000000000]
                                                    // [0x00000008]
    DWORD bRenderGeometry : 1;           // 0x0078 (0x0004) [0x0000000000000000]
                                         // [0x00000010]
    DWORD bRenderSpawnPoints : 1;        // 0x0078 (0x0004) [0x0000000000000000]
                                         // [0x00000020]
    DWORD bRenderTangents : 1;           // 0x0078 (0x0004) [0x0000000000000000]
                                         // [0x00000040]
    DWORD bRenderTessellation : 1;       // 0x0078 (0x0004) [0x0000000000000000]
                                         // [0x00000080]
    float TilingDistance;                // 0x007C (0x0004) [0x0000000000000000]
    float DistanceTessellationStepSize;  // 0x0080 (0x0004) [0x0000000000000000]
    float TangentTessellationScalar;     // 0x0084 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1889];

        return pClassPointer;
    };
};

UClass* UParticleModuleTypeDataAnimTrail::pClassPointer = NULL;

// Class Engine.ParticleModuleTypeDataApex
// 0x0010 (0x007C - 0x006C)
class UParticleModuleTypeDataApex : public UParticleModuleTypeDataBase {
   public:
    class UApexGenericAsset* ApexIOFX;  // 0x006C (0x0008) [0x0000000000000000]
    class UApexGenericAsset*
        ApexEmitter;  // 0x0074 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1891];

        return pClassPointer;
    };
};

UClass* UParticleModuleTypeDataApex::pClassPointer = NULL;

// Class Engine.ParticleModuleTypeDataBeam
// 0x00C4 (0x0130 - 0x006C)
class UParticleModuleTypeDataBeam : public UParticleModuleTypeDataBase {
   public:
    unsigned char BeamMethod;      // 0x006C (0x0001) [0x0000000000000000]
    unsigned char EndPointMethod;  // 0x006D (0x0001) [0x0000000000000000]
    struct FRawDistributionFloat
        Distance;  // 0x0070 (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        EndPoint;            // 0x0094 (0x0024) [0x0000000000000000]
    int TessellationFactor;  // 0x00B8 (0x0004) [0x0000000000000000]
    struct FRawDistributionFloat
        EmitterStrength;  // 0x00BC (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        TargetStrength;  // 0x00E0 (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        EndPointDirection;       // 0x0104 (0x0024) [0x0000000000000000]
    int TextureTile;             // 0x0128 (0x0004) [0x0000000000000000]
    DWORD RenderGeometry : 1;    // 0x012C (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    DWORD RenderDirectLine : 1;  // 0x012C (0x0004) [0x0000000000000000]
                                 // [0x00000002]
    DWORD RenderLines : 1;  // 0x012C (0x0004) [0x0000000000000000] [0x00000004]
    DWORD RenderTessellation : 1;  // 0x012C (0x0004) [0x0000000000000000]
                                   // [0x00000008]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1893];

        return pClassPointer;
    };
};

UClass* UParticleModuleTypeDataBeam::pClassPointer = NULL;

// Class Engine.ParticleModuleTypeDataBeam2
// 0x0098 (0x0104 - 0x006C)
class UParticleModuleTypeDataBeam2 : public UParticleModuleTypeDataBase {
   public:
    unsigned char BeamMethod;   // 0x006C (0x0001) [0x0000000000000000]
    unsigned char TaperMethod;  // 0x006D (0x0001) [0x0000000000000000]
    int TextureTile;            // 0x0070 (0x0004) [0x0000000000000000]
    float TextureTileDistance;  // 0x0074 (0x0004) [0x0000000000000000]
    int Sheets;                 // 0x0078 (0x0004) [0x0000000000000000]
    int MaxBeamCount;           // 0x007C (0x0004) [0x0000000000000000]
    float Speed;                // 0x0080 (0x0004) [0x0000000000000000]
    int InterpolationPoints;    // 0x0084 (0x0004) [0x0000000000000000]
    DWORD bAlwaysOn : 1;  // 0x0088 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD RenderGeometry : 1;    // 0x0088 (0x0004) [0x0000000000000000]
                                 // [0x00000002]
    DWORD RenderDirectLine : 1;  // 0x0088 (0x0004) [0x0000000000000000]
                                 // [0x00000004]
    DWORD RenderLines : 1;  // 0x0088 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD RenderTessellation : 1;   // 0x0088 (0x0004) [0x0000000000000000]
                                    // [0x00000010]
    int UpVectorStepSize;           // 0x008C (0x0004) [0x0000000000000000]
    struct FName BranchParentName;  // 0x0090 (0x0008) [0x0000000000000000]
    struct FRawDistributionFloat
        Distance;  // 0x0098 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        TaperFactor;  // 0x00BC (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        TaperScale;  // 0x00E0 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1895];

        return pClassPointer;
    };
};

UClass* UParticleModuleTypeDataBeam2::pClassPointer = NULL;

// Class Engine.ParticleModuleTypeDataMesh
// 0x001C (0x0088 - 0x006C)
class UParticleModuleTypeDataMesh : public UParticleModuleTypeDataBase {
   public:
    class UStaticMesh* Mesh;  // 0x006C (0x0008) [0x0000000000000000]
    DWORD CastShadows : 1;  // 0x0074 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD
        DoCollisions : 1;  // 0x0074 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bAllowMotionBlur : 1;   // 0x0074 (0x0004) [0x0000000000000000]
                                  // [0x00000004]
    DWORD bOverrideMaterial : 1;  // 0x0074 (0x0004) [0x0000000000000000]
                                  // [0x00000008]
    DWORD
        bCameraFacing : 1;  // 0x0074 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD
        bApplyParticleRotationAsSpin : 1;  // 0x0074 (0x0004)
                                           // [0x0000000000000000] [0x00000020]
    unsigned char MeshAlignment;   // 0x0078 (0x0001) [0x0000000000000000]
    unsigned char AxisLockOption;  // 0x0079 (0x0001) [0x0000000000000000]
    unsigned char
        CameraFacingUpAxisOption;      // 0x007A (0x0001) [0x0000000000000000]
    unsigned char CameraFacingOption;  // 0x007B (0x0001) [0x0000000000000000]
    float Pitch;                       // 0x007C (0x0004) [0x0000000000000000]
    float Roll;                        // 0x0080 (0x0004) [0x0000000000000000]
    float Yaw;                         // 0x0084 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1897];

        return pClassPointer;
    };
};

UClass* UParticleModuleTypeDataMesh::pClassPointer = NULL;

// Class Engine.ParticleModuleTypeDataMeshPhysX
// 0x0024 (0x00AC - 0x0088)
class UParticleModuleTypeDataMeshPhysX : public UParticleModuleTypeDataMesh {
   public:
    class UPhysXParticleSystem*
        PhysXParSys;                    // 0x0088 (0x0008) [0x0000000000000000]
    unsigned char PhysXRotationMethod;  // 0x0090 (0x0001) [0x0000000000000000]
    float FluidRotationCoefficient;     // 0x0094 (0x0004) [0x0000000000000000]
    struct FPhysXEmitterVerticalLodProperties
        VerticalLod;  // 0x0098 (0x0010) [0x0000000000000000]
    float ZOffset;    // 0x00A8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1899];

        return pClassPointer;
    };
};

UClass* UParticleModuleTypeDataMeshPhysX::pClassPointer = NULL;

// Class Engine.ParticleModuleTypeDataPhysX
// 0x0024 (0x0090 - 0x006C)
class UParticleModuleTypeDataPhysX : public UParticleModuleTypeDataBase {
   public:
    class UPhysXParticleSystem*
        PhysXParSys;  // 0x006C (0x0008) [0x0000000000000000]
    struct FPhysXEmitterVerticalLodProperties
        VerticalLod;              // 0x0074 (0x0010) [0x0000000000000000]
    float SPHSmoothScreenRadius;  // 0x0084 (0x0004) [0x0000000000000000]
    float SPHSmoothDepthRadius;   // 0x0088 (0x0004) [0x0000000000000000]
    float SPHCutoffThickness;     // 0x008C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1901];

        return pClassPointer;
    };
};

UClass* UParticleModuleTypeDataPhysX::pClassPointer = NULL;

// Class Engine.ParticleModuleTypeDataRibbon
// 0x0028 (0x0094 - 0x006C)
class UParticleModuleTypeDataRibbon : public UParticleModuleTypeDataBase {
   public:
    int MaxTessellationBetweenParticles;  // 0x006C (0x0004)
                                          // [0x0000000000000000]
    int SheetsPerTrail;                 // 0x0070 (0x0004) [0x0000000000000000]
    int MaxTrailCount;                  // 0x0074 (0x0004) [0x0000000000000000]
    int MaxParticleInTrailCount;        // 0x0078 (0x0004) [0x0000000000000000]
    DWORD bDeadTrailsOnDeactivate : 1;  // 0x007C (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bDeadTrailsOnSourceLoss : 1;  // 0x007C (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bClipSourceSegement : 1;      // 0x007C (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    DWORD bEnablePreviousTangentRecalculation : 1;  // 0x007C (0x0004)
                                                    // [0x0000000000000000]
                                                    // [0x00000008]
    DWORD bTangentRecalculationEveryFrame : 1;      // 0x007C (0x0004)
                                                    // [0x0000000000000000]
                                                    // [0x00000010]
    DWORD bSpawnInitialParticle : 1;  // 0x007C (0x0004) [0x0000000000000000]
                                      // [0x00000020]
    DWORD bRenderGeometry : 1;        // 0x007C (0x0004) [0x0000000000000000]
                                      // [0x00000040]
    DWORD bRenderSpawnPoints : 1;     // 0x007C (0x0004) [0x0000000000000000]
                                      // [0x00000080]
    DWORD bRenderTangents : 1;        // 0x007C (0x0004) [0x0000000000000000]
                                      // [0x00000100]
    DWORD bRenderTessellation : 1;    // 0x007C (0x0004) [0x0000000000000000]
                                      // [0x00000200]
    DWORD
        bEnableTangentDiffInterpScale : 1;  // 0x007C (0x0004)
                                            // [0x0000000000000000] [0x00000400]
    unsigned char RenderAxis;            // 0x0080 (0x0001) [0x0000000000000000]
    float TangentSpawningScalar;         // 0x0084 (0x0004) [0x0000000000000000]
    float TilingDistance;                // 0x0088 (0x0004) [0x0000000000000000]
    float DistanceTessellationStepSize;  // 0x008C (0x0004) [0x0000000000000000]
    float TangentTessellationScalar;     // 0x0090 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1903];

        return pClassPointer;
    };
};

UClass* UParticleModuleTypeDataRibbon::pClassPointer = NULL;

// Class Engine.ParticleModuleTypeDataTrail
// 0x0038 (0x00A4 - 0x006C)
class UParticleModuleTypeDataTrail : public UParticleModuleTypeDataBase {
   public:
    DWORD RenderGeometry : 1;  // 0x006C (0x0004) [0x0000000000000000]
                               // [0x00000001]
    DWORD RenderLines : 1;  // 0x006C (0x0004) [0x0000000000000000] [0x00000002]
    DWORD RenderTessellation : 1;  // 0x006C (0x0004) [0x0000000000000000]
                                   // [0x00000004]
    DWORD Tapered : 1;  // 0x006C (0x0004) [0x0000000000000000] [0x00000008]
    DWORD SpawnByDistance : 1;  // 0x006C (0x0004) [0x0000000000000000]
                                // [0x00000010]
    int TessellationFactor;     // 0x0070 (0x0004) [0x0000000000000000]
    struct FRawDistributionFloat
        Tension;                   // 0x0074 (0x0024) [0x0000000000000000]
    struct FVector SpawnDistance;  // 0x0098 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1905];

        return pClassPointer;
    };
};

UClass* UParticleModuleTypeDataTrail::pClassPointer = NULL;

// Class Engine.ParticleModuleTypeDataTrail2
// 0x0020 (0x008C - 0x006C)
class UParticleModuleTypeDataTrail2 : public UParticleModuleTypeDataBase {
   public:
    int TessellationFactor;            // 0x006C (0x0004) [0x0000000000000000]
    float TessellationFactorDistance;  // 0x0070 (0x0004) [0x0000000000000000]
    float TessellationStrength;        // 0x0074 (0x0004) [0x0000000000000000]
    int TextureTile;                   // 0x0078 (0x0004) [0x0000000000000000]
    int Sheets;                        // 0x007C (0x0004) [0x0000000000000000]
    int MaxTrailCount;                 // 0x0080 (0x0004) [0x0000000000000000]
    int MaxParticleInTrailCount;       // 0x0084 (0x0004) [0x0000000000000000]
    DWORD bClipSourceSegement : 1;     // 0x0088 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bClearTangents : 1;          // 0x0088 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD RenderGeometry : 1;          // 0x0088 (0x0004) [0x0000000000000000]
                                       // [0x00000004]
    DWORD RenderDirectLine : 1;        // 0x0088 (0x0004) [0x0000000000000000]
                                       // [0x00000008]
    DWORD RenderLines : 1;  // 0x0088 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD RenderTessellation : 1;  // 0x0088 (0x0004) [0x0000000000000000]
                                   // [0x00000020]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1907];

        return pClassPointer;
    };
};

UClass* UParticleModuleTypeDataTrail2::pClassPointer = NULL;

// Class Engine.ParticleModuleUberBase
// 0x0010 (0x007C - 0x006C)
class UParticleModuleUberBase : public UParticleModule {
   public:
    TArray<struct FName>
        RequiredModules;  // 0x006C (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1909];

        return pClassPointer;
    };
};

UClass* UParticleModuleUberBase::pClassPointer = NULL;

// Class Engine.ParticleModuleUberLTISIVCL
// 0x00D8 (0x0154 - 0x007C)
class UParticleModuleUberLTISIVCL : public UParticleModuleUberBase {
   public:
    struct FRawDistributionFloat
        Lifetime;  // 0x007C (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        StartSize;  // 0x00A0 (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        StartVelocity;  // 0x00C4 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        StartVelocityRadial;  // 0x00E8 (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        ColorOverLife;  // 0x010C (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        AlphaOverLife;  // 0x0130 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1911];

        return pClassPointer;
    };
};

UClass* UParticleModuleUberLTISIVCL::pClassPointer = NULL;

// Class Engine.ParticleModuleUberLTISIVCLIL
// 0x00FC (0x0178 - 0x007C)
class UParticleModuleUberLTISIVCLIL : public UParticleModuleUberBase {
   public:
    struct FRawDistributionFloat
        Lifetime;  // 0x007C (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        StartSize;  // 0x00A0 (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        StartVelocity;  // 0x00C4 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        StartVelocityRadial;  // 0x00E8 (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        ColorOverLife;  // 0x010C (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        AlphaOverLife;  // 0x0130 (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        StartLocation;  // 0x0154 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1913];

        return pClassPointer;
    };
};

UClass* UParticleModuleUberLTISIVCLIL::pClassPointer = NULL;

// Class Engine.ParticleModuleUberLTISIVCLILIRSSBLIRR
// 0x016C (0x01E8 - 0x007C)
class UParticleModuleUberLTISIVCLILIRSSBLIRR : public UParticleModuleUberBase {
   public:
    struct FRawDistributionFloat
        Lifetime;  // 0x007C (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        StartSize;  // 0x00A0 (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        StartVelocity;  // 0x00C4 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        StartVelocityRadial;  // 0x00E8 (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        ColorOverLife;  // 0x010C (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        AlphaOverLife;  // 0x0130 (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        StartLocation;  // 0x0154 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        StartRotation;  // 0x0178 (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        SizeLifeMultiplier;  // 0x019C (0x0024) [0x0000000000000000]
    DWORD
        SizeMultiplyX : 1;  // 0x01C0 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD
        SizeMultiplyY : 1;  // 0x01C0 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD
        SizeMultiplyZ : 1;  // 0x01C0 (0x0004) [0x0000000000000000] [0x00000004]
    struct FRawDistributionFloat
        StartRotationRate;  // 0x01C4 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1915];

        return pClassPointer;
    };
};

UClass* UParticleModuleUberLTISIVCLILIRSSBLIRR::pClassPointer = NULL;

// Class Engine.ParticleModuleUberRainDrops
// 0x0088 (0x0104 - 0x007C)
class UParticleModuleUberRainDrops : public UParticleModuleUberBase {
   public:
    float LifetimeMin;                // 0x007C (0x0004) [0x0000000000000000]
    float LifetimeMax;                // 0x0080 (0x0004) [0x0000000000000000]
    struct FVector StartSizeMin;      // 0x0084 (0x000C) [0x0000000000000000]
    struct FVector StartSizeMax;      // 0x0090 (0x000C) [0x0000000000000000]
    struct FVector StartVelocityMin;  // 0x009C (0x000C) [0x0000000000000000]
    struct FVector StartVelocityMax;  // 0x00A8 (0x000C) [0x0000000000000000]
    float StartVelocityRadialMin;     // 0x00B4 (0x0004) [0x0000000000000000]
    float StartVelocityRadialMax;     // 0x00B8 (0x0004) [0x0000000000000000]
    struct FVector ColorOverLife;     // 0x00BC (0x000C) [0x0000000000000000]
    float AlphaOverLife;              // 0x00C8 (0x0004) [0x0000000000000000]
    DWORD bIsUsingCylinder : 1;       // 0x00CC (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bPositive_X : 1;  // 0x00CC (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bPositive_Y : 1;  // 0x00CC (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bPositive_Z : 1;  // 0x00CC (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bNegative_X : 1;  // 0x00CC (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bNegative_Y : 1;  // 0x00CC (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bNegative_Z : 1;  // 0x00CC (0x0004) [0x0000000000000000] [0x00000040]
    DWORD
        bSurfaceOnly : 1;  // 0x00CC (0x0004) [0x0000000000000000] [0x00000080]
    DWORD bVelocity : 1;   // 0x00CC (0x0004) [0x0000000000000000] [0x00000100]
    DWORD bRadialVelocity : 1;        // 0x00CC (0x0004) [0x0000000000000000]
                                      // [0x00000200]
    float PC_VelocityScale;           // 0x00D0 (0x0004) [0x0000000000000000]
    struct FVector PC_StartLocation;  // 0x00D4 (0x000C) [0x0000000000000000]
    float PC_StartRadius;             // 0x00E0 (0x0004) [0x0000000000000000]
    float PC_StartHeight;             // 0x00E4 (0x0004) [0x0000000000000000]
    unsigned char PC_HeightAxis;      // 0x00E8 (0x0001) [0x0000000000000000]
    struct FVector StartLocationMin;  // 0x00EC (0x000C) [0x0000000000000000]
    struct FVector StartLocationMax;  // 0x00F8 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1917];

        return pClassPointer;
    };
};

UClass* UParticleModuleUberRainDrops::pClassPointer = NULL;

// Class Engine.ParticleModuleUberRainImpacts
// 0x0170 (0x01EC - 0x007C)
class UParticleModuleUberRainImpacts : public UParticleModuleUberBase {
   public:
    struct FRawDistributionFloat
        Lifetime;  // 0x007C (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        StartSize;  // 0x00A0 (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        StartRotation;         // 0x00C4 (0x0024) [0x0000000000000000]
    DWORD bInheritParent : 1;  // 0x00E8 (0x0004) [0x0000000000000000]
                               // [0x00000001]
    DWORD MultiplyX : 1;  // 0x00E8 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD MultiplyY : 1;  // 0x00E8 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD MultiplyZ : 1;  // 0x00E8 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bIsUsingCylinder : 1;  // 0x00E8 (0x0004) [0x0000000000000000]
                                 // [0x00000010]
    DWORD bPositive_X : 1;  // 0x00E8 (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bPositive_Y : 1;  // 0x00E8 (0x0004) [0x0000000000000000] [0x00000040]
    DWORD bPositive_Z : 1;  // 0x00E8 (0x0004) [0x0000000000000000] [0x00000080]
    DWORD bNegative_X : 1;  // 0x00E8 (0x0004) [0x0000000000000000] [0x00000100]
    DWORD bNegative_Y : 1;  // 0x00E8 (0x0004) [0x0000000000000000] [0x00000200]
    DWORD bNegative_Z : 1;  // 0x00E8 (0x0004) [0x0000000000000000] [0x00000400]
    DWORD
        bSurfaceOnly : 1;  // 0x00E8 (0x0004) [0x0000000000000000] [0x00000800]
    DWORD bVelocity : 1;   // 0x00E8 (0x0004) [0x0000000000000000] [0x00001000]
    DWORD bRadialVelocity : 1;  // 0x00E8 (0x0004) [0x0000000000000000]
                                // [0x00002000]
    struct FRawDistributionVector
        LifeMultiplier;  // 0x00EC (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        PC_VelocityScale;  // 0x0110 (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        PC_StartLocation;  // 0x0134 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        PC_StartRadius;  // 0x0158 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        PC_StartHeight;           // 0x017C (0x0024) [0x0000000000000000]
    unsigned char PC_HeightAxis;  // 0x01A0 (0x0001) [0x0000000000000000]
    struct FRawDistributionVector
        ColorOverLife;  // 0x01A4 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        AlphaOverLife;  // 0x01C8 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1919];

        return pClassPointer;
    };
};

UClass* UParticleModuleUberRainImpacts::pClassPointer = NULL;

// Class Engine.ParticleModuleUberRainSplashA
// 0x00DC (0x0158 - 0x007C)
class UParticleModuleUberRainSplashA : public UParticleModuleUberBase {
   public:
    struct FRawDistributionFloat
        Lifetime;  // 0x007C (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        StartSize;  // 0x00A0 (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        StartRotation;         // 0x00C4 (0x0024) [0x0000000000000000]
    DWORD bInheritParent : 1;  // 0x00E8 (0x0004) [0x0000000000000000]
                               // [0x00000001]
    DWORD MultiplyX : 1;  // 0x00E8 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD MultiplyY : 1;  // 0x00E8 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD MultiplyZ : 1;  // 0x00E8 (0x0004) [0x0000000000000000] [0x00000008]
    struct FRawDistributionVector
        LifeMultiplier;  // 0x00EC (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        ColorOverLife;  // 0x0110 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        AlphaOverLife;  // 0x0134 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1921];

        return pClassPointer;
    };
};

UClass* UParticleModuleUberRainSplashA::pClassPointer = NULL;

// Class Engine.ParticleModuleUberRainSplashB
// 0x00DC (0x0158 - 0x007C)
class UParticleModuleUberRainSplashB : public UParticleModuleUberBase {
   public:
    struct FRawDistributionFloat
        Lifetime;  // 0x007C (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        StartSize;  // 0x00A0 (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        ColorOverLife;  // 0x00C4 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        AlphaOverLife;  // 0x00E8 (0x0024) [0x0000000000000000]
    struct FRawDistributionVector
        LifeMultiplier;   // 0x010C (0x0024) [0x0000000000000000]
    DWORD MultiplyX : 1;  // 0x0130 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD MultiplyY : 1;  // 0x0130 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD MultiplyZ : 1;  // 0x0130 (0x0004) [0x0000000000000000] [0x00000004]
    struct FRawDistributionFloat
        StartRotationRate;  // 0x0134 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1923];

        return pClassPointer;
    };
};

UClass* UParticleModuleUberRainSplashB::pClassPointer = NULL;

// Class Engine.ParticleModuleVelocityBase
// 0x0004 (0x0070 - 0x006C)
class UParticleModuleVelocityBase : public UParticleModule {
   public:
    DWORD
        bInWorldSpace : 1;  // 0x006C (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bApplyOwnerScale : 1;  // 0x006C (0x0004) [0x0000000000000000]
                                 // [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1925];

        return pClassPointer;
    };
};

UClass* UParticleModuleVelocityBase::pClassPointer = NULL;

// Class Engine.ParticleModuleVelocity
// 0x0048 (0x00B8 - 0x0070)
class UParticleModuleVelocity : public UParticleModuleVelocityBase {
   public:
    struct FRawDistributionVector
        StartVelocity;  // 0x0070 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        StartVelocityRadial;  // 0x0094 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1927];

        return pClassPointer;
    };
};

UClass* UParticleModuleVelocity::pClassPointer = NULL;

// Class Engine.ParticleModuleVelocity_Seeded
// 0x001C (0x00D4 - 0x00B8)
class UParticleModuleVelocity_Seeded : public UParticleModuleVelocity {
   public:
    struct FParticleRandomSeedInfo
        RandomSeedInfo;  // 0x00B8 (0x001C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1929];

        return pClassPointer;
    };
};

UClass* UParticleModuleVelocity_Seeded::pClassPointer = NULL;

// Class Engine.ParticleModuleVelocityCone
// 0x0054 (0x00C4 - 0x0070)
class UParticleModuleVelocityCone : public UParticleModuleVelocityBase {
   public:
    struct FRawDistributionFloat Angle;  // 0x0070 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        Velocity;              // 0x0094 (0x0024) [0x0000000000000000]
    struct FVector Direction;  // 0x00B8 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1931];

        return pClassPointer;
    };
};

UClass* UParticleModuleVelocityCone::pClassPointer = NULL;

// Class Engine.ParticleModuleVelocityInheritParent
// 0x0024 (0x0094 - 0x0070)
class UParticleModuleVelocityInheritParent
    : public UParticleModuleVelocityBase {
   public:
    struct FRawDistributionVector
        Scale;  // 0x0070 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1933];

        return pClassPointer;
    };
};

UClass* UParticleModuleVelocityInheritParent::pClassPointer = NULL;

// Class Engine.ParticleModuleVelocityOverLifetime
// 0x0028 (0x0098 - 0x0070)
class UParticleModuleVelocityOverLifetime : public UParticleModuleVelocityBase {
   public:
    struct FRawDistributionVector
        VelOverLife;     // 0x0070 (0x0024) [0x0000000000000000]
    DWORD Absolute : 1;  // 0x0094 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1935];

        return pClassPointer;
    };
};

UClass* UParticleModuleVelocityOverLifetime::pClassPointer = NULL;

// Class Engine.ParticleModuleWorldForcesBase
// 0x0000 (0x006C - 0x006C)
class UParticleModuleWorldForcesBase : public UParticleModule {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1937];

        return pClassPointer;
    };
};

UClass* UParticleModuleWorldForcesBase::pClassPointer = NULL;

// Class Engine.ParticleModulePhysicsVolumes
// 0x0025 (0x0091 - 0x006C)
class UParticleModulePhysicsVolumes : public UParticleModuleWorldForcesBase {
   public:
    struct FRawDistributionFloat
        GlobalInfluence;               // 0x006C (0x0024) [0x0000000000000000]
    unsigned char LevelInfluenceType;  // 0x0090 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1939];

        return pClassPointer;
    };
};

UClass* UParticleModulePhysicsVolumes::pClassPointer = NULL;

// Class Engine.ParticleModuleWorldAttractor
// 0x0028 (0x0094 - 0x006C)
class UParticleModuleWorldAttractor : public UParticleModuleWorldForcesBase {
   public:
    DWORD bParticleLifeRelative : 1;  // 0x006C (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    struct FRawDistributionFloat
        AttractorInfluence;  // 0x0070 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1941];

        return pClassPointer;
    };
};

UClass* UParticleModuleWorldAttractor::pClassPointer = NULL;

// Class Engine.ParticleModuleEventSendToGame
// 0x0000 (0x0060 - 0x0060)
class UParticleModuleEventSendToGame : public UObject {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1943];

        return pClassPointer;
    };

    void DoEvent();
};

UClass* UParticleModuleEventSendToGame::pClassPointer = NULL;

// Class Engine.ParticleSystemReplay
// 0x0014 (0x0074 - 0x0060)
class UParticleSystemReplay : public UObject {
   public:
    int ClipIDNumber;  // 0x0060 (0x0004) [0x0000000000000000]
    TArray<struct FParticleSystemReplayFrame>
        Frames;  // 0x0064 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1945];

        return pClassPointer;
    };
};

UClass* UParticleSystemReplay::pClassPointer = NULL;

// Class Engine.PhysXParticleSystem
// 0x008C (0x00EC - 0x0060)
class UPhysXParticleSystem : public UObject {
   public:
    int MaxParticles;                    // 0x0060 (0x0004) [0x0000000000000000]
    int ParticleSpawnReserve;            // 0x0064 (0x0004) [0x0000000000000000]
    unsigned char RBChannel;             // 0x0068 (0x0001) [0x0000000000000000]
    unsigned char SimulationMethod;      // 0x0069 (0x0001) [0x0000000000000000]
    unsigned char PacketSizeMultiplier;  // 0x006A (0x0001) [0x0000000000000000]
    struct FRBCollisionChannelContainer
        RBCollideWithChannels;           // 0x006C (0x0004) [0x0000000000000000]
    float CollisionDistance;             // 0x0070 (0x0004) [0x0000000000000000]
    float RestitutionWithStaticShapes;   // 0x0074 (0x0004) [0x0000000000000000]
    float RestitutionWithDynamicShapes;  // 0x0078 (0x0004) [0x0000000000000000]
    float FrictionWithStaticShapes;      // 0x007C (0x0004) [0x0000000000000000]
    float FrictionWithDynamicShapes;     // 0x0080 (0x0004) [0x0000000000000000]
    float
        StaticFrictionWithStaticShapes;  // 0x0084 (0x0004) [0x0000000000000000]
    float StaticFrictionWithDynamicShapes;  // 0x0088 (0x0004)
                                            // [0x0000000000000000]
    DWORD bDynamicCollision : 1;  // 0x008C (0x0004) [0x0000000000000000]
                                  // [0x00000001]
    DWORD bDisableGravity : 1;    // 0x008C (0x0004) [0x0000000000000000]
                                  // [0x00000002]
    DWORD bUseGPU : 1;  // 0x008C (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bStaticCollision : 1;  // 0x008C (0x0004) [0x0000000000000000]
                                 // [0x00000008]
    DWORD bTwoWayCollision : 1;  // 0x008C (0x0004) [0x0000000000000000]
                                 // [0x00000010]
    DWORD bDestroy : 1;     // 0x008C (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bSyncFailed : 1;  // 0x008C (0x0004) [0x0000000000000000] [0x00000040]
    DWORD bIsInGame : 1;    // 0x008C (0x0004) [0x0000000000000000] [0x00000080]
    DWORD bProcessImpactEffects : 1;  // 0x008C (0x0004) [0x0000000000000000]
                                      // [0x00000100]
    float MaxMotionDistance;          // 0x0090 (0x0004) [0x0000000000000000]
    float Damping;                    // 0x0094 (0x0004) [0x0000000000000000]
    struct FVector
        ExternalAcceleration;            // 0x0098 (0x000C) [0x0000000000000000]
    float RestParticleDistance;          // 0x00A4 (0x0004) [0x0000000000000000]
    float RestDensity;                   // 0x00A8 (0x0004) [0x0000000000000000]
    float KernelRadiusMultiplier;        // 0x00AC (0x0004) [0x0000000000000000]
    float Stiffness;                     // 0x00B0 (0x0004) [0x0000000000000000]
    float Viscosity;                     // 0x00B4 (0x0004) [0x0000000000000000]
    float CollisionResponseCoefficient;  // 0x00B8 (0x0004) [0x0000000000000000]
    struct FPointer CascadeScene;        // 0x00BC (0x0008) [0x0000000000000000]
    struct FPointer PSys;                // 0x00C4 (0x0008) [0x0000000000000000]
    float ImpactThreshold;               // 0x00CC (0x0004) [0x0000000000000000]
    class UAkBaseSoundObject*
        ImpactSound;  // 0x00D0 (0x0008) [0x0000000000000000]
    TArray<struct FPhysXParticleImpactInfo>
        MaterialImpactSounds;     // 0x00D8 (0x0010) [0x0000000000000000]
    float PhysMaterialFrequency;  // 0x00E8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1947];

        return pClassPointer;
    };
};

UClass* UPhysXParticleSystem::pClassPointer = NULL;

// Class Engine.KActor
// 0x00E4 (0x0378 - 0x0294)
class AKActor : public ADynamicSMActor {
   public:
    DWORD bDamageAppliesImpulse : 1;  // 0x0294 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bWakeOnLevelStart : 1;      // 0x0294 (0x0004) [0x00000000001C0020]
                                  // [0x00000002] ( CPF_Net | CPF_GlobalConfig |
                                  // CPF_Component )
    DWORD
        bCurrentSlide : 1;  // 0x0294 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD
        bSlideActive : 1;  // 0x0294 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bEnableStayUprightSpring : 1;  // 0x0294 (0x0004) [0x0000000000000000]
                                         // [0x00000010]
    DWORD bLimitMaxPhysicsVelocity : 1;  // 0x0294 (0x0004) [0x0000000000000000]
                                         // [0x00000020]
    DWORD bNeedsRBStateReplication : 1;  // 0x0294 (0x0004) [0x0000000000000000]
                                         // [0x00000040]
    DWORD bDisableClientSidePawnInteractions : 1;  // 0x0294 (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00000080]
    class UParticleSystemComponent*
        ImpactEffectComponent;  // 0x0298 (0x0008) [0x0000000000000000]
    class UAudioComponent*
        ImpactSoundComponent;  // 0x02A0 (0x0008) [0x0000000000000000]
    class UAudioComponent*
        ImpactSoundComponent2;  // 0x02A8 (0x0008) [0x0000000000000000]
    float LastImpactTime;       // 0x02B0 (0x0004) [0x0000000000000000]
    struct FPhysEffectInfo
        ImpactEffectInfo;  // 0x02B4 (0x0018) [0x0000000000000000]
    class UParticleSystemComponent*
        SlideEffectComponent;  // 0x02CC (0x0008) [0x0000000000000000]
    class UAudioComponent*
        SlideSoundComponent;  // 0x02D4 (0x0008) [0x0000000000000000]
    float LastSlideTime;      // 0x02DC (0x0004) [0x0000000000000000]
    struct FPhysEffectInfo
        SlideEffectInfo;               // 0x02E0 (0x0018) [0x0000000000000000]
    float StayUprightTorqueFactor;     // 0x02F8 (0x0004) [0x0000000000000000]
    float StayUprightMaxTorque;        // 0x02FC (0x0004) [0x0000000000000000]
    float MaxPhysicsVelocity;          // 0x0300 (0x0004) [0x0000000000000000]
    unsigned char UnknownData00[0xC];  // 0x0304 (0x000C) MISSED OFFSET
    struct FRigidBodyState
        RBState;  // 0x0310 (0x0040) [0x00000000001D0000]              (
                  // CPF_Travel | CPF_GlobalConfig | CPF_Component )
    float AngErrorAccumulator;  // 0x0350 (0x0004) [0x0000000000000000]
    struct FVector
        ReplicatedDrawScale3D;  // 0x0354 (0x000C) [0x00000000001E0020] (
                                // CPF_Net | CPF_EditConst | CPF_GlobalConfig |
                                // CPF_Component )
    struct FVector InitialLocation;   // 0x0360 (0x000C) [0x0000000000000000]
    struct FRotator InitialRotation;  // 0x036C (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1949];

        return pClassPointer;
    };

    void Reset();
    void OnTeleport();
    void OnToggle();
    void TakeRadiusDamage();
    void eventTakeDamage();
    void eventApplyImpulse();
    void eventReplicatedEvent();
    void eventSpawnedByKismet();
    void SetPhysicalCollisionProperties();
    void eventDestroyed();
    void eventFellOutOfWorld();
    void eventPostBeginPlay();
    void ResolveRBState();
    void GetKActorPhysMaterial();
};

UClass* AKActor::pClassPointer = NULL;

// Class Engine.KActorFromStatic
// 0x000C (0x0384 - 0x0378)
class AKActorFromStatic : public AKActor {
   public:
    class AActor* MyStaticMeshActor;  // 0x0378 (0x0008) [0x0000000000000000]
    float MaxImpulseSpeed;            // 0x0380 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1951];

        return pClassPointer;
    };

    void eventDestroyed();
    void Reset();
    void TakeRadiusDamage();
    void eventTouch();
    void eventBump();
    void ReceiveImpulse();
    void eventApplyImpulse();
    void MakeDynamic();
    void MakeStatic();
    void BecomeStatic();
    void eventOnWakeRBPhysics();
    void eventOnSleepRBPhysics();
    void DisablePrecomputedLighting();
};

UClass* AKActorFromStatic::pClassPointer = NULL;

// Class Engine.KActorSpawnable
// 0x0004 (0x037C - 0x0378)
class AKActorSpawnable : public AKActor {
   public:
    DWORD bRecycleScaleToZero : 1;  // 0x0378 (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    DWORD bScalingToZero : 1;       // 0x0378 (0x0004) [0x0000000000000000]
                                    // [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1953];

        return pClassPointer;
    };

    void ResetComponents();
    void eventRecycleInternal();
    void Recycle();
    void Initialize();
};

UClass* AKActorSpawnable::pClassPointer = NULL;

// Class Engine.FlexForceFieldActor
// 0x0008 (0x024C - 0x0244)
class AFlexForceFieldActor : public AActor {
   public:
    class UFlexForceFieldComponent*
        ForceFieldComponent;  // 0x0244 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1955];

        return pClassPointer;
    };

    void OnToggle();
};

UClass* AFlexForceFieldActor::pClassPointer = NULL;

// Class Engine.KAsset
// 0x001C (0x0260 - 0x0244)
class AKAsset : public AActor {
   public:
    class USkeletalMeshComponent*
        SkeletalMeshComponent;        // 0x0244 (0x0008) [0x0000000000000000]
    DWORD bDamageAppliesImpulse : 1;  // 0x024C (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bWakeOnLevelStart : 1;      // 0x024C (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bBlockPawns : 1;  // 0x024C (0x0004) [0x0000000000000000] [0x00000004]
    class USkeletalMesh*
        ReplicatedMesh;  // 0x0250 (0x0008) [0x0000000000150000]              (
                         // CPF_Travel | CPF_GlobalConfig )
    class UPhysicsAsset*
        ReplicatedPhysAsset;  // 0x0258 (0x0008) [0x0000000000160000] (
                              // CPF_EditConst | CPF_GlobalConfig )

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1957];

        return pClassPointer;
    };

    void DoKismetAttachment();
    void OnTeleport();
    void OnToggle();
    void TakeRadiusDamage();
    void eventTakeDamage();
    void eventReplicatedEvent();
    void SetMeshAndPhysAsset();
    void eventPostBeginPlay();
};

UClass* AKAsset::pClassPointer = NULL;

// Class Engine.Pawn
// 0x0314 (0x0558 - 0x0244)
class APawn : public AActor {
   public:
    struct FPointer
        VfTable_IInterface_Speaker;      // 0x0244 (0x0008) [0x0000000000000000]
    float MaxStepHeight;                 // 0x024C (0x0004) [0x0000000000000000]
    float MaxJumpHeight;                 // 0x0250 (0x0004) [0x0000000000000000]
    float WalkableFloorZ;                // 0x0254 (0x0004) [0x0000000000000000]
    float LedgeCheckThreshold;           // 0x0258 (0x0004) [0x0000000000000000]
    struct FVector PartialLedgeMoveDir;  // 0x025C (0x000C) [0x0000000000000000]
    class AController* Controller;  // 0x0268 (0x0008) [0x0000000000150032] (
                                    // CPF_Const | CPF_OptionalParm | CPF_Net |
                                    // CPF_Travel | CPF_GlobalConfig )
    class APawn* NextPawn;   // 0x0270 (0x0008) [0x0000000000000000]
    float NetRelevancyTime;  // 0x0278 (0x0004) [0x0000000000000000]
    class APlayerController*
        LastRealViewer;            // 0x027C (0x0008) [0x0000000000000000]
    class AActor* LastViewer;      // 0x0284 (0x0008) [0x0000000000000000]
    DWORD bScriptTickSpecial : 1;  // 0x028C (0x0004) [0x0000000000000000]
                                   // [0x00000001]
    DWORD bUpAndOut : 1;   // 0x028C (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bIsWalking : 1;  // 0x028C (0x0004) [0x0000000000160000] [0x00000004]
                           // ( CPF_EditConst | CPF_GlobalConfig )
    DWORD bWantsToCrouch : 1;  // 0x028C (0x0004) [0x0000000000000000]
                               // [0x00000008]
    DWORD bIsCrouched : 1;  // 0x028C (0x0004) [0x0000000000170073] [0x00000010]
                            // ( CPF_Edit | CPF_Const | CPF_OptionalParm |
                            // CPF_Net | CPF_EditConstArray | CPF_Travel |
                            // CPF_EditConst | CPF_GlobalConfig )
    DWORD bTryToUncrouch : 1;  // 0x028C (0x0004) [0x0000000000000000]
                               // [0x00000020]
    DWORD bCanCrouch : 1;  // 0x028C (0x0004) [0x0000000000000000] [0x00000040]
    DWORD bCrawler : 1;    // 0x028C (0x0004) [0x0000000000000000] [0x00000080]
    DWORD
        bReducedSpeed : 1;  // 0x028C (0x0004) [0x0000000000000000] [0x00000100]
    DWORD
        bJumpCapable : 1;  // 0x028C (0x0004) [0x0000000000000000] [0x00000200]
    DWORD bCanJump : 1;    // 0x028C (0x0004) [0x0000000000000000] [0x00000400]
    DWORD bCanWalk : 1;    // 0x028C (0x0004) [0x0000000000000000] [0x00000800]
    DWORD bCanSwim : 1;    // 0x028C (0x0004) [0x0000000000000000] [0x00001000]
    DWORD bCanFly : 1;     // 0x028C (0x0004) [0x0000000000000000] [0x00002000]
    DWORD bCanClimbLadders : 1;  // 0x028C (0x0004) [0x0000000000000000]
                                 // [0x00004000]
    DWORD bCanStrafe : 1;  // 0x028C (0x0004) [0x0000000000000000] [0x00008000]
    DWORD
        bAvoidLedges : 1;  // 0x028C (0x0004) [0x0000000000000000] [0x00010000]
    DWORD
        bStopAtLedges : 1;  // 0x028C (0x0004) [0x0000000000000000] [0x00020000]
    DWORD bAllowLedgeOverhang : 1;  // 0x028C (0x0004) [0x0000000000000000]
                                    // [0x00040000]
    DWORD bPartiallyOverLedge : 1;  // 0x028C (0x0004) [0x0000000000000000]
                                    // [0x00080000]
    DWORD bSimulateGravity : 1;     // 0x028C (0x0004) [0x0000000000180000]
                                    // [0x00100000] ( CPF_Component )
    DWORD
        bIgnoreForces : 1;  // 0x028C (0x0004) [0x0000000000000000] [0x00200000]
    DWORD bCanWalkOffLedges : 1;    // 0x028C (0x0004) [0x0000000000000000]
                                    // [0x00400000]
    DWORD bCanBeBaseForPawns : 1;   // 0x028C (0x0004) [0x0000000000000000]
                                    // [0x00800000]
    DWORD bSimGravityDisabled : 1;  // 0x028C (0x0004) [0x0000000000000000]
                                    // [0x01000000]
    DWORD bDirectHitWall : 1;       // 0x028C (0x0004) [0x0000000000000000]
                                    // [0x02000000]
    DWORD bPushesRigidBodies : 1;   // 0x028C (0x0004) [0x0000000000000000]
                                    // [0x04000000]
    DWORD bForceFloorCheck : 1;     // 0x028C (0x0004) [0x0000000000000000]
                                    // [0x08000000]
    DWORD bForceKeepAnchor : 1;     // 0x028C (0x0004) [0x0000000000000000]
                                    // [0x10000000]
    DWORD bCanMantle : 1;   // 0x028C (0x0004) [0x0000000000000000] [0x20000000]
    DWORD bCanClimbUp : 1;  // 0x028C (0x0004) [0x0000000000000000] [0x40000000]
    DWORD bCanClimbCeilings : 1;  // 0x028C (0x0004) [0x0000000000000000]
                                  // [0x80000000]
    DWORD
        bCanSwatTurn : 1;  // 0x0290 (0x0004) [0x000000000019004B] [0x00000001]
                           // ( CPF_Edit | CPF_Const | CPF_ExportObject |
                           // CPF_EditConstArray | CPF_Travel | CPF_Component )
    DWORD bCanLeap : 1;    // 0x0290 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD
        bCanCoverSlip : 1;  // 0x0290 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bDisplayPathErrors : 1;   // 0x0290 (0x0004) [0x0000000000000000]
                                    // [0x00000008]
    DWORD bCanPickupInventory : 1;  // 0x0290 (0x0004) [0x0000000000000000]
                                    // [0x00000010]
    DWORD bAmbientCreature : 1;     // 0x0290 (0x0004) [0x0000000000000000]
                                    // [0x00000020]
    DWORD bLOSHearing : 1;  // 0x0290 (0x0004) [0x0000000000000000] [0x00000040]
    DWORD bMuffledHearing : 1;  // 0x0290 (0x0004) [0x0000000000000000]
                                // [0x00000080]
    DWORD
        bDontPossess : 1;  // 0x0290 (0x0004) [0x0000000000000000] [0x00000100]
    DWORD bRollToDesired : 1;  // 0x0290 (0x0004) [0x0000000000000000]
                               // [0x00000200]
    DWORD bStationary : 1;  // 0x0290 (0x0004) [0x0000000000000000] [0x00000400]
    DWORD bCachedRelevant : 1;       // 0x0290 (0x0004) [0x0000000000000000]
                                     // [0x00000800]
    DWORD bNoWeaponFiring : 1;       // 0x0290 (0x0004) [0x0000000000000000]
                                     // [0x00001000]
    DWORD bModifyReachSpecCost : 1;  // 0x0290 (0x0004) [0x0000000000000000]
                                     // [0x00002000]
    DWORD bModifyNavPointDest : 1;   // 0x0290 (0x0004) [0x0000000000000000]
                                     // [0x00004000]
    DWORD bPathfindsAsVehicle : 1;   // 0x0290 (0x0004) [0x0000000000000000]
                                     // [0x00008000]
    DWORD bPrevBypassSimulatedClientPhysics : 1;  // 0x0290 (0x0004)
                                                  // [0x0000000000000000]
                                                  // [0x00010000]
    DWORD bRunPhysicsWithNoController : 1;        // 0x0290 (0x0004)
                                            // [0x0000000000000000] [0x00020000]
    DWORD bForceMaxAccel : 1;         // 0x0290 (0x0004) [0x0000000000000000]
                                      // [0x00040000]
    DWORD bLimitFallAccel : 1;        // 0x0290 (0x0004) [0x0000000000000000]
                                      // [0x00080000]
    DWORD bReplicateHealthToAll : 1;  // 0x0290 (0x0004) [0x0000000000000000]
                                      // [0x00100000]
    DWORD bForceRMVelocity : 1;       // 0x0290 (0x0004) [0x0000000000000000]
                                      // [0x00200000]
    DWORD bForceRegularVelocity : 1;  // 0x0290 (0x0004) [0x0000000000000000]
                                      // [0x00400000]
    DWORD
        bPlayedDeath : 1;  // 0x0290 (0x0004) [0x0000000000000000] [0x00800000]
    DWORD bDesiredRotationSet : 1;    // 0x0290 (0x0004) [0x0000000000000000]
                                      // [0x01000000]
    DWORD bLockDesiredRotation : 1;   // 0x0290 (0x0004) [0x0000000000000000]
                                      // [0x02000000]
    DWORD bUnlockWhenReached : 1;     // 0x0290 (0x0004) [0x0000000000000000]
                                      // [0x04000000]
    DWORD bNeedsBaseTickedFirst : 1;  // 0x0290 (0x0004) [0x0000000000000000]
                                      // [0x08000000]
    DWORD bUsedByMatinee : 1;         // 0x0290 (0x0004) [0x00000000001A0000]
                               // [0x10000000] ( CPF_EditConst | CPF_Component )
    DWORD bRootMotionFromInterpCurve : 1;  // 0x0290 (0x0004)
                                           // [0x00000000001B00D1] [0x20000000]
                                           // ( CPF_Edit | CPF_OptionalParm |
                                           // CPF_EditConstArray | CPF_Parm |
                                           // CPF_Travel | CPF_EditConst |
                                           // CPF_Component )
    DWORD bDebugShowCameraLocation : 1;  // 0x0290 (0x0004) [0x0000000000000000]
                                         // [0x40000000]
    DWORD bFastAttachedMove : 1;         // 0x0290 (0x0004) [0x00000000001C0000]
                                         // [0x80000000] ( CPF_GlobalConfig |
                                         // CPF_Component )
    DWORD bCanJumpOverWalls : 1;         // 0x0294 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bDebugCrawlerPhysics : 1;      // 0x0294 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    unsigned char WalkingPhysics;        // 0x0298 (0x0001) [0x0000000000000000]
    unsigned char PathSearchType;        // 0x0299 (0x0001) [0x0000000000000000]
    unsigned char RemoteViewPitch;  // 0x029A (0x0001) [0x00000000001D00B6] (
                                    // CPF_Const | CPF_Input | CPF_OptionalParm
                                    // | CPF_Net | CPF_Parm | CPF_Travel |
                                    // CPF_GlobalConfig | CPF_Component )
    unsigned char FlashCount;  // 0x029B (0x0001) [0x00000000001E0073] (
                               // CPF_Edit | CPF_Const | CPF_OptionalParm |
                               // CPF_Net | CPF_EditConstArray | CPF_EditConst |
                               // CPF_GlobalConfig | CPF_Component )
    unsigned char
        FiringMode;  // 0x029C (0x0001) [0x00000000001F0073]              (
                     // CPF_Edit | CPF_Const | CPF_OptionalParm | CPF_Net |
                     // CPF_EditConstArray | CPF_Travel | CPF_EditConst |
                     // CPF_GlobalConfig | CPF_Component )
    unsigned char
        LightingVolumeEnterCount;  // 0x029D (0x0001) [0x0000000000000000]
    float UncrouchTime;            // 0x02A0 (0x0004) [0x0000000000000000]
    float CrouchHeight;            // 0x02A4 (0x0004) [0x0000000000000000]
    float CrouchRadius;            // 0x02A8 (0x0004) [0x0000000000000000]
    int FullHeight;                // 0x02AC (0x0004) [0x0000000000000000]
    float NonPreferredVehiclePathMultiplier;  // 0x02B0 (0x0004)
                                              // [0x0000000000000000]
    class UPathConstraint*
        PathConstraintList;  // 0x02B4 (0x0008) [0x0000000000000000]
    class UPathGoalEvaluator*
        PathGoalList;                    // 0x02BC (0x0008) [0x0000000000000000]
    float DesiredSpeed;                  // 0x02C4 (0x0004) [0x0000000000000000]
    float MaxDesiredSpeed;               // 0x02C8 (0x0004) [0x0000000000000000]
    float HearingThreshold;              // 0x02CC (0x0004) [0x0000000000000000]
    float Alertness;                     // 0x02D0 (0x0004) [0x0000000000000000]
    float SightRadius;                   // 0x02D4 (0x0004) [0x0000000000000000]
    float PeripheralVision;              // 0x02D8 (0x0004) [0x0000000000000000]
    float AvgPhysicsTime;                // 0x02DC (0x0004) [0x0000000000000000]
    float Mass;                          // 0x02E0 (0x0004) [0x0000000000000000]
    float Buoyancy;                      // 0x02E4 (0x0004) [0x0000000000000000]
    float MeleeRange;                    // 0x02E8 (0x0004) [0x0000000000000000]
    class ANavigationPoint* Anchor;      // 0x02EC (0x0008) [0x0000000000000000]
    int AnchorItem;                      // 0x02F4 (0x0004) [0x0000000000000000]
    class ANavigationPoint* LastAnchor;  // 0x02F8 (0x0008) [0x0000000000000000]
    float FindAnchorFailedTime;          // 0x0300 (0x0004) [0x0000000000000000]
    float LastValidAnchorTime;           // 0x0304 (0x0004) [0x0000000000000000]
    float DestinationOffset;             // 0x0308 (0x0004) [0x0000000000000000]
    float NextPathRadius;                // 0x030C (0x0004) [0x0000000000000000]
    struct FVector SerpentineDir;        // 0x0310 (0x000C) [0x0000000000000000]
    float SerpentineDist;                // 0x031C (0x0004) [0x0000000000000000]
    float SerpentineTime;                // 0x0320 (0x0004) [0x0000000000000000]
    float SpawnTime;                     // 0x0324 (0x0004) [0x0000000000000000]
    int MaxPitchLimit;                   // 0x0328 (0x0004) [0x0000000000000000]
    float GroundSpeed;  // 0x032C (0x0004) [0x0000000000200032]              (
                        // CPF_Const | CPF_OptionalParm | CPF_Net )
    float WaterSpeed;   // 0x0330 (0x0004) [0x0000000000210032]              (
                        // CPF_Const | CPF_OptionalParm | CPF_Net | CPF_Travel )
    float AirSpeed;     // 0x0334 (0x0004) [0x0000000000220032]              (
                     // CPF_Const | CPF_OptionalParm | CPF_Net | CPF_EditConst )
    float LadderSpeed;  // 0x0338 (0x0004) [0x0000000000000000]
    float AccelRate;    // 0x033C (0x0004) [0x0000000000230032]              (
                        // CPF_Const | CPF_OptionalParm | CPF_Net | CPF_Travel |
                        // CPF_EditConst )
    float JumpZ;        // 0x0340 (0x0004) [0x0000000000240032]              (
                  // CPF_Const | CPF_OptionalParm | CPF_Net | CPF_GlobalConfig )
    float OutofWaterZ;              // 0x0344 (0x0004) [0x0000000000000000]
    float MaxOutOfWaterStepHeight;  // 0x0348 (0x0004) [0x0000000000000000]
    float AirControl;  // 0x034C (0x0004) [0x0000000000250032]              (
                       // CPF_Const | CPF_OptionalParm | CPF_Net | CPF_Travel |
                       // CPF_GlobalConfig )
    float WalkingPct;  // 0x0350 (0x0004) [0x0000000000000000]
    float MovementSpeedModifier;       // 0x0354 (0x0004) [0x0000000000000000]
    float CrouchedPct;                 // 0x0358 (0x0004) [0x0000000000000000]
    float MaxFallSpeed;                // 0x035C (0x0004) [0x0000000000000000]
    float AIMaxFallSpeedFactor;        // 0x0360 (0x0004) [0x0000000000000000]
    float BaseEyeHeight;               // 0x0364 (0x0004) [0x0000000000000000]
    float EyeHeight;                   // 0x0368 (0x0004) [0x0000000000000000]
    struct FVector Floor;              // 0x036C (0x000C) [0x0000000000000000]
    float SplashTime;                  // 0x0378 (0x0004) [0x0000000000000000]
    class APhysicsVolume* HeadVolume;  // 0x037C (0x0008) [0x0000000000000000]
    int Health;     // 0x0384 (0x0004) [0x000000000026000A]              (
                    // CPF_Const | CPF_ExportObject | CPF_EditConst |
                    // CPF_GlobalConfig )
    int HealthMax;  // 0x0388 (0x0004) [0x0000000000270116]              (
                    // CPF_Const | CPF_Input | CPF_OptionalParm | CPF_OutParm |
                    // CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
    float BreathTime;               // 0x038C (0x0004) [0x0000000000000000]
    float UnderWaterTime;           // 0x0390 (0x0004) [0x0000000000000000]
    float LastPainTime;             // 0x0394 (0x0004) [0x0000000000000000]
    float KismetDeathDelayTime;     // 0x0398 (0x0004) [0x0000000000000000]
    struct FVector RMVelocity;      // 0x039C (0x000C) [0x0000000000000000]
    struct FVector noise1spot;      // 0x03A8 (0x000C) [0x0000000000000000]
    float noise1time;               // 0x03B4 (0x0004) [0x0000000000000000]
    class APawn* noise1other;       // 0x03B8 (0x0008) [0x0000000000000000]
    float noise1loudness;           // 0x03C0 (0x0004) [0x0000000000000000]
    struct FVector noise2spot;      // 0x03C4 (0x000C) [0x0000000000000000]
    float noise2time;               // 0x03D0 (0x0004) [0x0000000000000000]
    class APawn* noise2other;       // 0x03D4 (0x0008) [0x0000000000000000]
    float noise2loudness;           // 0x03DC (0x0004) [0x0000000000000000]
    float SoundDampening;           // 0x03E0 (0x0004) [0x0000000000000000]
    float DamageScaling;            // 0x03E4 (0x0004) [0x0000000000000000]
    struct FString MenuName;        // 0x03E8 (0x0010) [0x0000000000000000]
    class UClass* ControllerClass;  // 0x03F8 (0x0008) [0x0000000000000000]
    class APlayerReplicationInfo*
        PlayerReplicationInfo;  // 0x0400 (0x0008) [0x0000000000280000] (
                                // CPF_Component )
    class ALadderVolume* OnLadder;      // 0x0408 (0x0008) [0x0000000000000000]
    struct FName LandMovementState;     // 0x0410 (0x0008) [0x0000000000000000]
    struct FName WaterMovementState;    // 0x0418 (0x0008) [0x0000000000000000]
    class APlayerStart* LastStartSpot;  // 0x0420 (0x0008) [0x0000000000000000]
    float LastStartTime;                // 0x0428 (0x0004) [0x0000000000000000]
    struct FVector TakeHitLocation;  // 0x042C (0x000C) [0x0000000000290000] (
                                     // CPF_Travel | CPF_Component )
    class UClass* HitDamageType;  // 0x0438 (0x0008) [0x00000000002A0000] (
                                  // CPF_EditConst | CPF_Component )
    struct FVector
        TearOffMomentum;  // 0x0440 (0x000C) [0x00000000002B009D]              (
                          // CPF_Edit | CPF_Input | CPF_ExportObject |
                          // CPF_OptionalParm | CPF_Parm | CPF_Travel |
                          // CPF_EditConst | CPF_Component )
    class USkeletalMeshComponent* Mesh;  // 0x044C (0x0008) [0x0000000000000000]
    class UCylinderComponent*
        CylinderComponent;          // 0x0454 (0x0008) [0x0000000000000000]
    float RBPushRadius;             // 0x045C (0x0004) [0x0000000000000000]
    float RBPushStrength;           // 0x0460 (0x0004) [0x0000000000000000]
    class AVehicle* DrivenVehicle;  // 0x0464 (0x0008) [0x00000000002C0000] (
                                    // CPF_GlobalConfig | CPF_Component )
    float
        AlwaysRelevantDistanceSquared;  // 0x046C (0x0004) [0x0000000000000000]
    float VehicleCheckRadius;           // 0x0470 (0x0004) [0x0000000000000000]
    class AController* LastHitBy;       // 0x0474 (0x0008) [0x0000000000000000]
    float ViewPitchMin;                 // 0x047C (0x0004) [0x0000000000000000]
    float ViewPitchMax;                 // 0x0480 (0x0004) [0x0000000000000000]
    int AllowedYawError;                // 0x0484 (0x0004) [0x0000000000000000]
    struct FRotator DesiredRotation;    // 0x0488 (0x000C) [0x0000000000000000]
    class UClass*
        InventoryManagerClass;  // 0x0494 (0x0008) [0x0000000000000000]
    class AInventoryManager*
        InvManager;  // 0x049C (0x0008) [0x00000000002D0032]              (
                     // CPF_Const | CPF_OptionalParm | CPF_Net | CPF_Travel |
                     // CPF_GlobalConfig | CPF_Component )
    class AWeapon* Weapon;  // 0x04A4 (0x0008) [0x0000000000000000]
    struct FVector
        FlashLocation;  // 0x04AC (0x000C) [0x00000000002E0000]              (
                        // CPF_EditConst | CPF_GlobalConfig | CPF_Component )
    struct FVector
        LastFiringFlashLocation;  // 0x04B8 (0x000C) [0x0000000000000000]
    int ShotCount;                // 0x04C4 (0x0004) [0x0000000000000000]
    class UPrimitiveComponent*
        PreRagdollCollisionComponent;  // 0x04C8 (0x0008) [0x0000000000000000]
    class URB_BodyInstance*
        PhysicsPushBody;     // 0x04D0 (0x0008) [0x0000000000000000]
    int FailedLandingCount;  // 0x04D8 (0x0004) [0x0000000000000000]
    TArray<class UAnimNodeSlot*>
        SlotNodes;  // 0x04DC (0x0010) [0x0000000000000000]
    TArray<class UInterpGroup*>
        InterpGroupList;  // 0x04EC (0x0010) [0x0000000000000000]
    class UAudioComponent*
        FacialAudioComp;  // 0x04FC (0x0008) [0x0000000000000000]
    class UMaterialInstanceConstant*
        MIC_PawnMat;  // 0x0504 (0x0008) [0x0000000000000000]
    class UMaterialInstanceConstant*
        MIC_PawnHair;  // 0x050C (0x0008) [0x0000000000000000]
    TArray<struct FScalarParameterInterpStruct>
        ScalarParameterInterpArray;  // 0x0514 (0x0010) [0x0000000000000000]
    struct FRootMotionCurve
        RootMotionInterpCurve;   // 0x0524 (0x0020) [0x0000000000000000]
    float RootMotionInterpRate;  // 0x0544 (0x0004) [0x00000000002F00EC] (
                                 // CPF_Input | CPF_ExportObject | CPF_Net |
                                 // CPF_EditConstArray | CPF_Parm | CPF_Travel |
                                 // CPF_EditConst | CPF_GlobalConfig |
                                 // CPF_Component )
    float
        RootMotionInterpCurrentTime;  // 0x0548 (0x0004) [0x00000000003000EC] (
                                      // CPF_Input | CPF_ExportObject | CPF_Net
                                      // | CPF_EditConstArray | CPF_Parm )
    struct FVector
        RootMotionInterpCurveLastValue;  // 0x054C (0x000C) [0x00000000003100EC]
                                         // ( CPF_Input | CPF_ExportObject |
                                         // CPF_Net | CPF_EditConstArray |
                                         // CPF_Parm | CPF_Travel )

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1959];

        return pClassPointer;
    };

    void SetMeshLightingChannels();
    void OnSetVelocity();
    void eventSpeak();
    void SetScalarParameterInterp();
    void SetRootMotionInterpCurrentTime();
    void SetCinematicMode();
    void ZeroMovementVariables();
    void ClearPathStep();
    void DrawPathStep();
    void IncrementPathChild();
    void IncrementPathStep();
    void CreatePathGoalEvaluator();
    void CreatePathConstraint();
    void AddGoalEvaluator();
    void AddPathConstraint();
    void ClearConstraints();
    void eventSoakPause();
    void eventBecomeViewTarget();
    void eventMessagePlayer();
    void HandleTeleport();
    void OnTeleport();
    void OnSetMaterial();
    void GetDamageScaling();
    void DoKismetAttachment();
    void eventSpawnedByKismet();
    void IsStationary();
    void GetCollisionExtent();
    void GetCollisionHeight();
    void GetCollisionRadius();
    void CheatFly();
    void CheatGhost();
    void CheatWalk();
    void PlayWeaponSwitch();
    void SetActiveWeapon();
    void TossInventory();
    void ThrowActiveWeapon();
    void DrawHUD();
    void FindInventoryType();
    void eventCreateInventory();
    void AddDefaultInventory();
    void eventStopDriving();
    void eventStartDriving();
    void CanThrowWeapon();
    void Suicide();
    void GetVehicleBase();
    void PlayLanded();
    void CannotJumpNow();
    void eventPlayFootStepSound();
    void eventTornOff();
    void PlayDying();
    void SetDyingPhysics();
    void TurnOff();
    void PlayHit();
    void PlayDyingSound();
    void DoJump();
    void CheckWaterJump();
    void TakeDrowningDamage();
    void eventBreathTimer();
    void TouchingWaterVolume();
    void eventHeadVolumeChange();
    void eventTickSpecial();
    void eventLanded();
    void eventFalling();
    void DelayTriggerDeath();
    void Died();
    void ThrowWeaponOnDeath();
    void eventIsSameTeam();
    void GetTeam();
    void GetTeamNum();
    void eventTakeDamage();
    void SetKillInstigator();
    void NotifyTakeHit();
    void eventTakeRadiusDamageOnBones();
    void PruneDamagedBoneList();
    void eventHealDamage();
    void AdjustDamage();
    void SetMovementPhysics();
    void Gasp();
    void OnGiveInventory();
    void OnAssignController();
    void eventReceivedNewEvent();
    void SpawnDefaultController();
    void eventPostBeginPlay();
    void eventPreBeginPlay();
    void eventDestroyed();
    void DetachFromController();
    void CrushedBy();
    void CanBeBaseForPawn();
    void eventBaseChange();
    void eventStuckOnPawn();
    void JumpOffPawn();
    void gibbedBy();
    void eventEncroachedBy();
    void eventEncroachingOn();
    void FaceRotation();
    void eventUpdatePawnRotation();
    void ClientSetRotation();
    void ClientRestart();
    void Restart();
    void TakeFallingDamage();
    void KilledBy();
    void AddVelocity();
    void HandleMomentum();
    void eventStartCrouch();
    void eventEndCrouch();
    void ShouldCrouch();
    void UnCrouch();
    void eventOutsideWorldBounds();
    void eventFellOutOfWorld();
    void eventClientMessage();
    void HandlePickup();
    void LineOfSightTo();
    void SetMoveTarget();
    void InGodMode();
    void SetViewRotation();
    void GetAdjustedAimFor();
    void eventInFreeCam();
    void eventGetBaseAimRotation();
    void eventGetWeaponStartTraceLocation();
    void eventGetPawnViewLocation();
    void eventGetViewRotation();
    void eventGetActorEyesViewPoint();
    void ProcessViewRotation();
    void IsFirstPerson();
    void IsPlayerPawn();
    void IsLocallyControlled();
    void IsHumanControlled();
    void DisplayDebug();
    void ClimbLadder();
    void EndClimbLadder();
    void CanSplash();
    void eventSetWalking();
    void RangedAttackTime();
    void RecommendLongRangedAttack();
    void CanGrabLadder();
    void DropToGround();
    void GetDefaultCameraMode();
    void UnPossessed();
    void UpdateControllerOnPossess();
    void PossessedBy();
    void NotifyTeamChanged();
    void PlayTeleportEffect();
    void GetHumanReadableName();
    void NeedToTurn();
    void IsFiring();
    void HasRangedAttack();
    void FireOnRelease();
    void TooCloseToAttack();
    void CanAttack();
    void BotFire();
    void WeaponStoppedFiring();
    void WeaponFired();
    void FlashLocationUpdated();
    void ClearFlashLocation();
    void SetFlashLocation();
    void ClearFlashCount();
    void FlashCountUpdated();
    void IncrementFlashCount();
    void FiringModeUpdated();
    void SetFiringMode();
    void GetWeaponFiringMode();
    void StopFire();
    void StartFire();
    void StopFiring();
    void Reset();
    void PlayerChangedTeam();
    void SetBaseEyeheight();
    void eventSpecialMoveThruEdge();
    void SpecialMoveTo();
    void TermRagdoll();
    void InitRagdoll();
    void GetBoundingCylinder();
    void ReachedDesiredRotation();
    void SetPushesRigidBodies();
    void ForceCrouch();
    void ReachedPoint();
    void ReachedDestination();
    void GetBestAnchor();
    void SetAnchor();
    void SetRemoteViewPitch();
    void IsInvisible();
    void CanAITargetThisPawn();
    void IsValidTeamTargetFor();
    void IsValidEnemyTargetFor();
    void GetFallDuration();
    void SuggestJumpVelocity();
    void ValidAnchor();
    void AdjustDestination();
    void IsAliveAndWell();
    void eventReplicatedEvent();
    void eventSetSkelControlScale();
    void eventSetMorphWeight();
    void eventGetActorFaceFXAsset();
    void FaceFXAudioFinished();
    void OnPlayFaceFXAnim();
    void CanActorPlayFaceFXAnim();
    void IsActorPlayingFaceFXAnim();
    void eventGetFaceFXAudioComponent();
    void eventStopActorFaceFXAnim();
    void eventPlayActorFaceFXAnim();
    void eventMAT_FinishAIGroup();
    void eventMAT_BeginAIGroup();
    void FinishAIGroup();
    void BeginAIGroup();
    void eventInterpolationFinished();
    void eventInterpolationStarted();
    void MAT_SetSkelControlStrength();
    void MAT_SetSkelControlScale();
    void MAT_SetMorphWeight();
    void MAT_SetAnimWeights();
    void MAT_SetAnimPosition();
    void eventSetAnimPosition();
    void MAT_FinishAnimControl();
    void eventFinishAnimControl();
    void MAT_BeginAnimControl();
    void eventBeginAnimControl();
    void eventRestoreAnimSetsToDefault();
    void eventAnimSetListUpdated();
    void AddAnimSets();
    void eventBuildScriptAnimSetList();
    void UpdateAnimSetList();
    void ClearAnimNodes();
    void eventCacheAnimNodes();
    void eventPostInitAnimTree();
    void ReachedMyDestination();
    void IsDesiredRotationLocked();
    void IsDesiredRotationInUse();
    void CheckDesiredRotation();
    void ResetDesiredRotation();
    void LockDesiredRotation();
    void SetDesiredRotation();
    void PickWallAdjust();
};

UClass* APawn::pClassPointer = NULL;

// Class Engine.Vehicle
// 0x0080 (0x05D8 - 0x0558)
class AVehicle : public APawn {
   public:
    class APawn* Driver;  // 0x0558 (0x0008) [0x0000000000320020]              (
                          // CPF_Net | CPF_EditConst )
    DWORD bDriving : 1;   // 0x0560 (0x0004) [0x0000000000330000] [0x00000001] (
                          // CPF_Travel | CPF_EditConst )
    DWORD bDriverIsVisible : 1;  // 0x0560 (0x0004) [0x0000000000000000]
                                 // [0x00000002]
    DWORD
        bAttachDriver : 1;  // 0x0560 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD
        bTurnInPlace : 1;  // 0x0560 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bSeparateTurretFocus : 1;  // 0x0560 (0x0004) [0x0000000000000000]
                                     // [0x00000010]
    DWORD bFollowLookDir : 1;        // 0x0560 (0x0004) [0x0000000000000000]
                                     // [0x00000020]
    DWORD
        bHasHandbrake : 1;  // 0x0560 (0x0004) [0x0000000000000000] [0x00000040]
    DWORD
        bScriptedRise : 1;  // 0x0560 (0x0004) [0x0000000000000000] [0x00000080]
    DWORD bDuckObstacles : 1;   // 0x0560 (0x0004) [0x0000000000000000]
                                // [0x00000100]
    DWORD bAvoidReversing : 1;  // 0x0560 (0x0004) [0x0000000000000000]
                                // [0x00000200]
    DWORD bRetryPathfindingWithDriver : 1;  // 0x0560 (0x0004)
                                            // [0x0000000000000000] [0x00000400]
    DWORD
        bIgnoreStallZ : 1;  // 0x0560 (0x0004) [0x0000000000000000] [0x00000800]
    DWORD bDoExtraNetRelevancyTraces : 1;  // 0x0560 (0x0004)
                                           // [0x0000000000000000] [0x00001000]
    TArray<struct FVector>
        ExitPositions;          // 0x0564 (0x0010) [0x0000000000000000]
    float ExitRadius;           // 0x0574 (0x0004) [0x0000000000000000]
    struct FVector ExitOffset;  // 0x0578 (0x000C) [0x0000000000000000]
    float Steering;             // 0x0584 (0x0004) [0x0000000000000000]
    float Throttle;             // 0x0588 (0x0004) [0x0000000000000000]
    float Rise;                 // 0x058C (0x0004) [0x0000000000000000]
    struct FVector
        TargetLocationAdjustment;     // 0x0590 (0x000C) [0x0000000000000000]
    float DriverDamageMult;           // 0x059C (0x0004) [0x0000000000000000]
    float MomentumMult;               // 0x05A0 (0x0004) [0x0000000000000000]
    class UClass* CrushedDamageType;  // 0x05A4 (0x0008) [0x0000000000000000]
    float MinCrushSpeed;              // 0x05AC (0x0004) [0x0000000000000000]
    float ForceCrushPenetration;      // 0x05B0 (0x0004) [0x0000000000000000]
    unsigned char StuckCount;         // 0x05B4 (0x0001) [0x0000000000000000]
    float ThrottleTime;               // 0x05B8 (0x0004) [0x0000000000000000]
    float StuckTime;                  // 0x05BC (0x0004) [0x0000000000000000]
    float OldSteering;                // 0x05C0 (0x0004) [0x0000000000000000]
    float OnlySteeringStartTime;      // 0x05C4 (0x0004) [0x0000000000000000]
    float OldThrottle;                // 0x05C8 (0x0004) [0x0000000000000000]
    float AIMoveCheckTime;            // 0x05CC (0x0004) [0x0000000000000000]
    float VehicleMovingTime;          // 0x05D0 (0x0004) [0x0000000000000000]
    float TurnTime;                   // 0x05D4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1961];

        return pClassPointer;
    };

    void ZeroMovementVariables();
    void NotifyDriverTakeHit();
    void eventReplicatedEvent();
    void DrivingStatusChanged();
    void SetDriving();
    void eventGetEntryLocation();
    void CrushedBy();
    void PancakeOther();
    void eventEncroachingOn();
    void GetCollisionDamageInstigator();
    void eventEncroachedBy();
    void FaceRotation();
    void GetDefaultCameraMode();
    void PlayDying();
    void DriverDied();
    void Died();
    void ThrowActiveWeapon();
    void AdjustDriverDamage();
    void eventTakeDamage();
    void SetKillInstigator();
    void UnPossessed();
    void TryExitPos();
    void FindAutoExit();
    void PlaceExitingDriver();
    void DriverLeft();
    void SetInputs();
    void eventDriverLeave();
    void GetExitRotation();
    void eventContinueOnFoot();
    void DetachDriver();
    void AttachDriver();
    void EntryAnnouncement();
    void PossessedBy();
    void DriverEnter();
    void TryToDrive();
    void AnySeatAvailable();
    void CanEnterVehicle();
    void Destroyed_HandleDriver();
    void eventDestroyed();
    void CheatFly();
    void CheatGhost();
    void CheatWalk();
    void eventPostBeginPlay();
    void SetBaseEyeheight();
    void PlayerChangedTeam();
    void DriverRadiusDamage();
    void TakeRadiusDamage();
    void GetTargetLocation();
    void GetMaxRiseForce();
    void Suicide();
    void DisplayDebug();
    void NotifyTeamChanged();
};

UClass* AVehicle::pClassPointer = NULL;

// Class Engine.SVehicle
// 0x0160 (0x0738 - 0x05D8)
class ASVehicle : public AVehicle {
   public:
    struct FPointer PVehicle;          // 0x05D8 (0x0008) [0x0000000000000000]
    struct FPointer MyVehicleManager;  // 0x05E0 (0x0008) [0x0000000000000000]
    float ChassisMass;                 // 0x05E8 (0x0004) [0x0000000000000000]
    DWORD bIsTank : 1;  // 0x05EC (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bEnableDebugRendering : 1;  // 0x05EC (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bInReverseMode : 1;         // 0x05EC (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    DWORD
        bStayUpright : 1;  // 0x05EC (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bUseSuspensionAxis : 1;  // 0x05EC (0x0004) [0x0000000000000000]
                                   // [0x00000010]
    DWORD bUpdateWheelShapes : 1;  // 0x05EC (0x0004) [0x0000000000000000]
                                   // [0x00000020]
    DWORD bVehicleOnGround : 1;    // 0x05EC (0x0004) [0x0000000000000000]
                                   // [0x00000040]
    DWORD bVehicleOnWater : 1;     // 0x05EC (0x0004) [0x0000000000000000]
                                   // [0x00000080]
    DWORD bIsInverted : 1;  // 0x05EC (0x0004) [0x0000000000000000] [0x00000100]
    DWORD bChassisTouchingGround : 1;  // 0x05EC (0x0004) [0x0000000000000000]
                                       // [0x00000200]
    DWORD bWasChassisTouchingGroundLastTick : 1;  // 0x05EC (0x0004)
                                                  // [0x0000000000000000]
                                                  // [0x00000400]
    DWORD bCanFlip : 1;    // 0x05EC (0x0004) [0x0000000000000000] [0x00000800]
    DWORD bFlipRight : 1;  // 0x05EC (0x0004) [0x0000000000000000] [0x00001000]
    DWORD
        bIsUprighting : 1;  // 0x05EC (0x0004) [0x0000000000000000] [0x00002000]
    DWORD bOutputHandbrake : 1;       // 0x05EC (0x0004) [0x0000000000000000]
                                      // [0x00004000]
    DWORD bHoldingDownHandbrake : 1;  // 0x05EC (0x0004) [0x0000000000000000]
                                      // [0x00008000]
    int DebugRenderActiveGraphChannelWheel;   // 0x05F0 (0x0004)
                                              // [0x0000000000000000]
    int DebugRenderActiveGraphChannelEngine;  // 0x05F4 (0x0004)
                                              // [0x0000000000000000]
    class USVehicleSimBase* SimObj;  // 0x05F8 (0x0008) [0x0000000000000000]
    TArray<class USVehicleWheel*>
        Wheels;                // 0x0600 (0x0010) [0x0000000000000000]
    struct FVector COMOffset;  // 0x0610 (0x000C) [0x0000000000000000]
    struct FVector
        InertiaTensorMultiplier;        // 0x061C (0x000C) [0x0000000000000000]
    float StayUprightRollResistAngle;   // 0x0628 (0x0004) [0x0000000000000000]
    float StayUprightPitchResistAngle;  // 0x062C (0x0004) [0x0000000000000000]
    float StayUprightStiffness;         // 0x0630 (0x0004) [0x0000000000000000]
    float StayUprightDamping;           // 0x0634 (0x0004) [0x0000000000000000]
    class URB_StayUprightSetup*
        StayUprightConstraintSetup;  // 0x0638 (0x0008) [0x0000000000000000]
    class URB_ConstraintInstance*
        StayUprightConstraintInstance;  // 0x0640 (0x0008) [0x0000000000000000]
    float HeavySuspensionShiftPercent;  // 0x0648 (0x0004) [0x0000000000000000]
    float MaxSpeed;  // 0x064C (0x0004) [0x0000000000340000]              (
                     // CPF_GlobalConfig )
    float MaxAngularVelocity;            // 0x0650 (0x0004) [0x0000000000000000]
    float TimeOffGround;                 // 0x0654 (0x0004) [0x0000000000000000]
    float UprightLiftStrength;           // 0x0658 (0x0004) [0x0000000000000000]
    float UprightTorqueStrength;         // 0x065C (0x0004) [0x0000000000000000]
    float UprightTime;                   // 0x0660 (0x0004) [0x0000000000000000]
    float UprightStartTime;              // 0x0664 (0x0004) [0x0000000000000000]
    class UAudioComponent* EngineSound;  // 0x0668 (0x0008) [0x0000000000000000]
    class UAudioComponent* SquealSound;  // 0x0670 (0x0008) [0x0000000000000000]
    class USoundCue* CollisionSound;     // 0x0678 (0x0008) [0x0000000000000000]
    class USoundCue* EnterVehicleSound;  // 0x0680 (0x0008) [0x0000000000000000]
    class USoundCue* ExitVehicleSound;   // 0x0688 (0x0008) [0x0000000000000000]
    float CollisionIntervalSecs;         // 0x0690 (0x0004) [0x0000000000000000]
    float SquealThreshold;               // 0x0694 (0x0004) [0x0000000000000000]
    float SquealLatThreshold;            // 0x0698 (0x0004) [0x0000000000000000]
    float LatAngleVolumeMult;            // 0x069C (0x0004) [0x0000000000000000]
    float EngineStartOffsetSecs;         // 0x06A0 (0x0004) [0x0000000000000000]
    float EngineStopOffsetSecs;          // 0x06A4 (0x0004) [0x0000000000000000]
    float LastCollisionSoundTime;        // 0x06A8 (0x0004) [0x0000000000000000]
    float OutputBrake;                   // 0x06AC (0x0004) [0x0000000000000000]
    float OutputGas;                     // 0x06B0 (0x0004) [0x0000000000000000]
    float OutputSteering;                // 0x06B4 (0x0004) [0x0000000000000000]
    float OutputRise;                    // 0x06B8 (0x0004) [0x0000000000000000]
    float ForwardVel;                    // 0x06BC (0x0004) [0x0000000000000000]
    int NumPoweredWheels;                // 0x06C0 (0x0004) [0x0000000000000000]
    struct FVector BaseOffset;           // 0x06C4 (0x000C) [0x0000000000000000]
    float CamDist;                       // 0x06D0 (0x0004) [0x0000000000000000]
    int DriverViewPitch;                 // 0x06D4 (0x0004) [0x0000000000000000]
    int DriverViewYaw;                   // 0x06D8 (0x0004) [0x0000000000000000]
    unsigned char UnknownData00[0x4];    // 0x06DC (0x0004) MISSED OFFSET
    struct FVehicleState VState;  // 0x06E0 (0x0050) [0x0000000000350000] (
                                  // CPF_Travel | CPF_GlobalConfig )
    float AngErrorAccumulator;   // 0x0730 (0x0004) [0x0000000000000000]
    float RadialImpulseScaling;  // 0x0734 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1963];

        return pClassPointer;
    };

    void GetSVehicleDebug();
    void HermiteEval();
    void DisplayWheelsDebug();
    void DisplayDebug();
    void PostTeleport();
    void eventSuspensionHeavyShift();
    void eventRigidBodyCollision();
    void DrivingStatusChanged();
    void VehiclePlayExitSound();
    void VehiclePlayEnterSound();
    void StopEngineSoundTimed();
    void StopEngineSound();
    void StartEngineSoundTimed();
    void StartEngineSound();
    void HasWheelsOnGround();
    void TryToDrive();
    void GetDefaultCameraMode();
    void CalcCamera();
    void Died();
    void AddVelocity();
    void InitVehicleRagdoll();
    void TakeRadiusDamage();
    void StopVehicleSounds();
    void TurnOff();
    void eventDestroyed();
    void eventPostInitAnimTree();
    void eventPostBeginPlay();
    void SetWheelCollision();
    void DrawGraphsAndPrintTireSurfaceTypes();
    void IsSleeping();
    void AddTorque();
    void AddImpulse();
    void AddForce();
};

UClass* ASVehicle::pClassPointer = NULL;

// Class Engine.RB_ConstraintActor
// 0x0034 (0x0278 - 0x0244)
class ARB_ConstraintActor : public ARigidBodyBase {
   public:
    class AActor* ConstraintActor1;  // 0x0244 (0x0008) [0x0000000000000000]
    class AActor* ConstraintActor2;  // 0x024C (0x0008) [0x0000000000000000]
    class URB_ConstraintSetup*
        ConstraintSetup;  // 0x0254 (0x0008) [0x0000000000000000]
    class URB_ConstraintInstance*
        ConstraintInstance;           // 0x025C (0x0008) [0x0000000000000000]
    DWORD bDisableCollision : 1;      // 0x0264 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bUpdateActor1RefFrame : 1;  // 0x0264 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bUpdateActor2RefFrame : 1;  // 0x0264 (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    class AActor* PulleyPivotActor1;  // 0x0268 (0x0008) [0x0000000000000000]
    class AActor* PulleyPivotActor2;  // 0x0270 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1965];

        return pClassPointer;
    };

    void OnToggleConstraintDrive();
    void OnToggle();
    void OnDestroy();
    void TermConstraint();
    void InitConstraint();
    void SetDisableCollision();
};

UClass* ARB_ConstraintActor::pClassPointer = NULL;

// Class Engine.RB_LineImpulseActor
// 0x0015 (0x0259 - 0x0244)
class ARB_LineImpulseActor : public ARigidBodyBase {
   public:
    float ImpulseStrength;  // 0x0244 (0x0004) [0x0000000000000000]
    float ImpulseRange;     // 0x0248 (0x0004) [0x0000000000000000]
    DWORD bVelChange : 1;   // 0x024C (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bStopAtFirstHit : 1;     // 0x024C (0x0004) [0x0000000000000000]
                                   // [0x00000002]
    DWORD bCauseFracture : 1;      // 0x024C (0x0004) [0x0000000000000000]
                                   // [0x00000004]
    class UArrowComponent* Arrow;  // 0x0250 (0x0008) [0x0000000000000000]
    unsigned char ImpulseCount;    // 0x0258 (0x0001) [0x0000000000150000] (
                                 // CPF_Travel | CPF_GlobalConfig )

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1967];

        return pClassPointer;
    };

    void eventReplicatedEvent();
    void OnToggle();
    void FireLineImpulse();
};

UClass* ARB_LineImpulseActor::pClassPointer = NULL;

// Class Engine.RB_RadialImpulseActor
// 0x0011 (0x0255 - 0x0244)
class ARB_RadialImpulseActor : public ARigidBodyBase {
   public:
    class UDrawSphereComponent*
        RenderComponent;  // 0x0244 (0x0008) [0x0000000000000000]
    class URB_RadialImpulseComponent*
        ImpulseComponent;        // 0x024C (0x0008) [0x0000000000000000]
    unsigned char ImpulseCount;  // 0x0254 (0x0001) [0x0000000000150000] (
                                 // CPF_Travel | CPF_GlobalConfig )

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1969];

        return pClassPointer;
    };

    void eventReplicatedEvent();
    void OnToggle();
};

UClass* ARB_RadialImpulseActor::pClassPointer = NULL;

// Class Engine.RB_Thruster
// 0x0008 (0x024C - 0x0244)
class ARB_Thruster : public ARigidBodyBase {
   public:
    DWORD bThrustEnabled : 1;  // 0x0244 (0x0004) [0x0000000000000000]
                               // [0x00000001]
    float ThrustStrength;      // 0x0248 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1971];

        return pClassPointer;
    };

    void OnToggle();
};

UClass* ARB_Thruster::pClassPointer = NULL;

// Class Engine.WorldAttractor
// 0x00F0 (0x0334 - 0x0244)
class AWorldAttractor : public AActor {
   public:
    DWORD bEnabled : 1;  // 0x0244 (0x0004) [0x0000000000000000] [0x00000001]
    float LoopDuration;  // 0x0248 (0x0004) [0x0000000000000000]
    float CurrentTime;   // 0x024C (0x0004) [0x0000000000000000]
    unsigned char FalloffType;  // 0x0250 (0x0001) [0x0000000000000000]
    struct FMatineeRawDistributionFloat
        FalloffExponent;  // 0x0254 (0x002C) [0x0000000000000000]
    struct FMatineeRawDistributionFloat
        Range;  // 0x0280 (0x002C) [0x0000000000000000]
    struct FMatineeRawDistributionFloat
        Strength;           // 0x02AC (0x002C) [0x0000000000000000]
    float CollisionRadius;  // 0x02D8 (0x0004) [0x0000000000000000]
    struct FMatineeRawDistributionFloat
        DragCoefficient;  // 0x02DC (0x002C) [0x0000000000000000]
    struct FMatineeRawDistributionFloat
        DragRadius;  // 0x0308 (0x002C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1973];

        return pClassPointer;
    };

    void OnSetWorldAttractorParam();
};

UClass* AWorldAttractor::pClassPointer = NULL;

// Class Engine.FlexForceFieldComponent
// 0x0034 (0x026C - 0x0238)
class UFlexForceFieldComponent : public UPrimitiveComponent {
   public:
    float RotationalFieldStrength;   // 0x0238 (0x0004) [0x0000000000000000]
    float RadialFieldStrength;       // 0x023C (0x0004) [0x0000000000000000]
    float LiftFieldStrength;         // 0x0240 (0x0004) [0x0000000000000000]
    float CapsuleFieldHeight;        // 0x0244 (0x0004) [0x0000000000000000]
    float CapsuleFieldBottomRadius;  // 0x0248 (0x0004) [0x0000000000000000]
    float CapsuleFieldTopRadius;     // 0x024C (0x0004) [0x0000000000000000]
    float BoundaryFadePercentage;    // 0x0250 (0x0004) [0x0000000000000000]
    DWORD bEnabled : 1;  // 0x0254 (0x0004) [0x0000000000000000] [0x00000001]
    struct FRBCollisionChannelContainer
        CollideWithChannels;         // 0x0258 (0x0004) [0x0000000000000000]
    unsigned char CollisionChannel;  // 0x025C (0x0001) [0x0000000000000000]
    float Duration;                  // 0x0260 (0x0004) [0x0000000000000000]
    float NoiseStrength;             // 0x0264 (0x0004) [0x0000000000000000]
    float ElapsedTime;               // 0x0268 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1975];

        return pClassPointer;
    };

    void SetEnabled();
    void DoInitRBPhys();
};

UClass* UFlexForceFieldComponent::pClassPointer = NULL;

// Class Engine.RB_ConstraintDrawComponent
// 0x0008 (0x0240 - 0x0238)
class URB_ConstraintDrawComponent : public UPrimitiveComponent {
   public:
    class UMaterialInterface*
        LimitMaterial;  // 0x0238 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1977];

        return pClassPointer;
    };
};

UClass* URB_ConstraintDrawComponent::pClassPointer = NULL;

// Class Engine.RB_RadialImpulseComponent
// 0x0018 (0x0250 - 0x0238)
class URB_RadialImpulseComponent : public UPrimitiveComponent {
   public:
    unsigned char ImpulseFalloff;  // 0x0238 (0x0001) [0x0000000000000000]
    float ImpulseStrength;         // 0x023C (0x0004) [0x0000000000000000]
    float ImpulseRadius;           // 0x0240 (0x0004) [0x0000000000000000]
    DWORD bVelChange : 1;  // 0x0244 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bCauseFracture : 1;  // 0x0244 (0x0004) [0x0000000000000000]
                               // [0x00000002]
    class UDrawSphereComponent*
        PreviewSphere;  // 0x0248 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1979];

        return pClassPointer;
    };

    void FireImpulse();
};

UClass* URB_RadialImpulseComponent::pClassPointer = NULL;

// Class Engine.RB_Handle
// 0x007B (0x0100 - 0x0085)
class URB_Handle : public UActorComponent {
   public:
    class UPrimitiveComponent*
        GrabbedComponent;          // 0x0088 (0x0008) [0x0000000000000000]
    struct FName GrabbedBoneName;  // 0x0090 (0x0008) [0x0000000000000000]
    int SceneIndex;                // 0x0098 (0x0004) [0x0000000000000000]
    DWORD bInHardware : 1;  // 0x009C (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bRotationConstrained : 1;  // 0x009C (0x0004) [0x0000000000000000]
                                     // [0x00000002]
    DWORD bInterpolating : 1;        // 0x009C (0x0004) [0x0000000000000000]
                                     // [0x00000004]
    struct FPointer HandleData;      // 0x00A0 (0x0008) [0x0000000000000000]
    struct FPointer KinActorData;    // 0x00A8 (0x0008) [0x0000000000000000]
    float LinearDamping;             // 0x00B0 (0x0004) [0x0000000000000000]
    float LinearStiffness;           // 0x00B4 (0x0004) [0x0000000000000000]
    struct FVector
        LinearStiffnessScale3D;  // 0x00B8 (0x000C) [0x0000000000000000]
    struct FVector
        LinearDampingScale3D;    // 0x00C4 (0x000C) [0x0000000000000000]
    float AngularDamping;        // 0x00D0 (0x0004) [0x0000000000000000]
    float AngularStiffness;      // 0x00D4 (0x0004) [0x0000000000000000]
    float AngularForceLimit;     // 0x00D8 (0x0004) [0x0000000000000000]
    struct FVector Destination;  // 0x00DC (0x000C) [0x0000000000000000]
    struct FVector StepSize;     // 0x00E8 (0x000C) [0x0000000000000000]
    struct FVector Location;     // 0x00F4 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1981];

        return pClassPointer;
    };

    void GetOrientation();
    void SetOrientation();
    void UpdateSmoothLocation();
    void SetSmoothLocation();
    void SetLocation();
    void ReleaseComponent();
    void GrabComponent();
};

UClass* URB_Handle::pClassPointer = NULL;

// Class Engine.RB_Spring
// 0x0063 (0x00E8 - 0x0085)
class URB_Spring : public UActorComponent {
   public:
    class UPrimitiveComponent*
        Component1;          // 0x0088 (0x0008) [0x0000000000000000]
    struct FName BoneName1;  // 0x0090 (0x0008) [0x0000000000000000]
    class UPrimitiveComponent*
        Component2;          // 0x0098 (0x0008) [0x0000000000000000]
    struct FName BoneName2;  // 0x00A0 (0x0008) [0x0000000000000000]
    int SceneIndex;          // 0x00A8 (0x0004) [0x0000000000000000]
    DWORD bInHardware : 1;  // 0x00AC (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bEnableForceMassRatio : 1;  // 0x00AC (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    struct FPointer SpringData;       // 0x00B0 (0x0008) [0x0000000000000000]
    float TimeSinceActivation;        // 0x00B8 (0x0004) [0x0000000000000000]
    float MinBodyMass;                // 0x00BC (0x0004) [0x0000000000000000]
    float SpringSaturateDist;         // 0x00C0 (0x0004) [0x0000000000000000]
    float SpringMaxForce;             // 0x00C4 (0x0004) [0x0000000000000000]
    float MaxForceMassRatio;          // 0x00C8 (0x0004) [0x0000000000000000]
    struct FInterpCurveFloat
        SpringMaxForceTimeScale;  // 0x00CC (0x0014) [0x0000000000000000]
    float DampSaturateVel;        // 0x00E0 (0x0004) [0x0000000000000000]
    float DampMaxForce;           // 0x00E4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1983];

        return pClassPointer;
    };

    void Clear();
    void SetComponents();
};

UClass* URB_Spring::pClassPointer = NULL;

// Class Engine.SVehicleSimBase
// 0x0043 (0x00C8 - 0x0085)
class USVehicleSimBase : public UActorComponent {
   public:
    float EnginePeakTorque;           // 0x0088 (0x0004) [0x0000000000000000]
    float EngineMaxRPM;               // 0x008C (0x0004) [0x0000000000000000]
    float WheelSuspensionStiffness;   // 0x0090 (0x0004) [0x0000000000000000]
    float WheelSuspensionDamping;     // 0x0094 (0x0004) [0x0000000000000000]
    float WheelSuspensionBias;        // 0x0098 (0x0004) [0x0000000000000000]
    float WheelLongExtremumSlip;      // 0x009C (0x0004) [0x0000000000000000]
    float WheelLongExtremumValue;     // 0x00A0 (0x0004) [0x0000000000000000]
    float WheelLongAsymptoteSlip;     // 0x00A4 (0x0004) [0x0000000000000000]
    float WheelLongAsymptoteValue;    // 0x00A8 (0x0004) [0x0000000000000000]
    float WheelLatExtremumSlip;       // 0x00AC (0x0004) [0x0000000000000000]
    float WheelLatExtremumValue;      // 0x00B0 (0x0004) [0x0000000000000000]
    float WheelLatAsymptoteSlip;      // 0x00B4 (0x0004) [0x0000000000000000]
    float WheelLatAsymptoteValue;     // 0x00B8 (0x0004) [0x0000000000000000]
    float WheelInertia;               // 0x00BC (0x0004) [0x0000000000000000]
    DWORD bWheelSpeedOverride : 1;    // 0x00C0 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bClampedFrictionModel : 1;  // 0x00C0 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bAutoDrive : 1;  // 0x00C0 (0x0004) [0x0000000000000000] [0x00000004]
    float AutoDriveSteer;  // 0x00C4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1985];

        return pClassPointer;
    };
};

UClass* USVehicleSimBase::pClassPointer = NULL;

// Class Engine.SVehicleSimCar
// 0x0038 (0x0100 - 0x00C8)
class USVehicleSimCar : public USVehicleSimBase {
   public:
    float ChassisTorqueScale;  // 0x00C8 (0x0004) [0x0000000000000000]
    struct FInterpCurveFloat
        MaxSteerAngleCurve;   // 0x00CC (0x0014) [0x0000000000000000]
    float SteerSpeed;         // 0x00E0 (0x0004) [0x0000000000000000]
    float ReverseThrottle;    // 0x00E4 (0x0004) [0x0000000000000000]
    float EngineBrakeFactor;  // 0x00E8 (0x0004) [0x0000000000000000]
    float MaxBrakeTorque;     // 0x00EC (0x0004) [0x0000000000000000]
    float StopThreshold;      // 0x00F0 (0x0004) [0x0000000000000000]
    DWORD bIsDriving : 1;  // 0x00F4 (0x0004) [0x0000000000000000] [0x00000001]
    float ActualSteering;  // 0x00F8 (0x0004) [0x0000000000000000]
    float TimeSinceThrottle;  // 0x00FC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1987];

        return pClassPointer;
    };
};

UClass* USVehicleSimCar::pClassPointer = NULL;

// Class Engine.SVehicleSimTank
// 0x0030 (0x0130 - 0x0100)
class USVehicleSimTank : public USVehicleSimCar {
   public:
    float LeftTrackVel;                // 0x0100 (0x0004) [0x0000000000000000]
    float RightTrackVel;               // 0x0104 (0x0004) [0x0000000000000000]
    float LeftTrackTorque;             // 0x0108 (0x0004) [0x0000000000000000]
    float RightTrackTorque;            // 0x010C (0x0004) [0x0000000000000000]
    float MaxEngineTorque;             // 0x0110 (0x0004) [0x0000000000000000]
    float EngineDamping;               // 0x0114 (0x0004) [0x0000000000000000]
    float InsideTrackTorqueFactor;     // 0x0118 (0x0004) [0x0000000000000000]
    float SteeringLatStiffnessFactor;  // 0x011C (0x0004) [0x0000000000000000]
    float TurnInPlaceThrottle;         // 0x0120 (0x0004) [0x0000000000000000]
    float TurnMaxGripReduction;        // 0x0124 (0x0004) [0x0000000000000000]
    float TurnGripScaleRate;           // 0x0128 (0x0004) [0x0000000000000000]
    DWORD bTurnInPlaceOnSteer : 1;     // 0x012C (0x0004) [0x0000000000000000]
                                       // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1989];

        return pClassPointer;
    };
};

UClass* USVehicleSimTank::pClassPointer = NULL;

// Class Engine.ActorFactoryFlexForceField
// 0x0020 (0x00BC - 0x009C)
class UActorFactoryFlexForceField : public UActorFactory {
   public:
    float RotationalFieldStrength;   // 0x009C (0x0004) [0x0000000000000000]
    float RadialFieldStrength;       // 0x00A0 (0x0004) [0x0000000000000000]
    float LiftFieldStrength;         // 0x00A4 (0x0004) [0x0000000000000000]
    float CapsuleFieldHeight;        // 0x00A8 (0x0004) [0x0000000000000000]
    float CapsuleFieldBottomRadius;  // 0x00AC (0x0004) [0x0000000000000000]
    float CapsuleFieldTopRadius;     // 0x00B0 (0x0004) [0x0000000000000000]
    float BoundaryFadePercentage;    // 0x00B4 (0x0004) [0x0000000000000000]
    float Noise;                     // 0x00B8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1991];

        return pClassPointer;
    };
};

UClass* UActorFactoryFlexForceField::pClassPointer = NULL;

// Class Engine.ActorFactoryApexClothing
// 0x003C (0x00F0 - 0x00B4)
class UActorFactoryApexClothing : public UActorFactorySkeletalMesh {
   public:
    TArray<class UApexClothingAsset*>
        ClothingAssets;               // 0x00B4 (0x0010) [0x0000000000000000]
    unsigned char ClothingRBChannel;  // 0x00C4 (0x0001) [0x0000000000000000]
    struct FRBCollisionChannelContainer
        ClothingRBCollideWithChannels;  // 0x00C8 (0x0004) [0x0000000000000000]
    DWORD bLocalSpaceWind : 1;          // 0x00CC (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bWindStrengthNoiseCentered : 1;  // 0x00CC (0x0004)
                                           // [0x0000000000000000] [0x00000002]
    DWORD bWindDirNoiseCentered : 1;  // 0x00CC (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    struct FVector WindVelocity;      // 0x00D0 (0x000C) [0x0000000000000000]
    float WindVelocityBlendTime;      // 0x00DC (0x0004) [0x0000000000000000]
    float WindStrengthNoiseBounds;    // 0x00E0 (0x0004) [0x0000000000000000]
    float WindStrengthNoiseStepSize;  // 0x00E4 (0x0004) [0x0000000000000000]
    float WindDirNoiseBounds;         // 0x00E8 (0x0004) [0x0000000000000000]
    float WindDirNoiseStepSize;       // 0x00EC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1993];

        return pClassPointer;
    };
};

UClass* UActorFactoryApexClothing::pClassPointer = NULL;

// Class Engine.ApexDestructibleDamageParameters
// 0x0010 (0x0070 - 0x0060)
class UApexDestructibleDamageParameters : public UObject {
   public:
    TArray<struct FDamagePair>
        DamageMap;  // 0x0060 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1995];

        return pClassPointer;
    };
};

UClass* UApexDestructibleDamageParameters::pClassPointer = NULL;

// Class Engine.FlexContainer
// 0x00B0 (0x0110 - 0x0060)
class UFlexContainer : public UObject {
   public:
    float Radius;  // 0x0060 (0x0004) [0x0000000000000000]
    TArray<struct FParticleInfo>
        MaxParticlesAtPhysXLevel;  // 0x0064 (0x0010) [0x0000000000000000]
    DWORD bDebugDrawPoints : 1;    // 0x0074 (0x0004) [0x0000000000000000]
                                   // [0x00000001]
    DWORD bFixedTimeStep : 1;      // 0x0074 (0x0004) [0x0000000000000000]
                                   // [0x00000002]
    DWORD bEnableCCD : 1;  // 0x0074 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bComplexCollision : 1;  // 0x0074 (0x0004) [0x0000000000000000]
                                  // [0x00000008]
    DWORD bFluid : 1;  // 0x0074 (0x0004) [0x0000000000000000] [0x00000010]
    float DebugDrawSpheres;   // 0x0078 (0x0004) [0x0000000000000000]
    int NumIterations;        // 0x007C (0x0004) [0x0000000000000000]
    int NumSubsteps;          // 0x0080 (0x0004) [0x0000000000000000]
    int MinFrameRate;         // 0x0084 (0x0004) [0x0000000000000000]
    struct FVector Gravity;   // 0x0088 (0x000C) [0x0000000000000000]
    float SleepThreshold;     // 0x0094 (0x0004) [0x0000000000000000]
    float MaxVelocity;        // 0x0098 (0x0004) [0x0000000000000000]
    float MaxContainerBound;  // 0x009C (0x0004) [0x0000000000000000]
    float RelaxationFactor;   // 0x00A0 (0x0004) [0x0000000000000000]
    unsigned char Mode;       // 0x00A4 (0x0001) [0x0000000000000000]
    unsigned char RBChannel;  // 0x00A5 (0x0001) [0x0000000000000000]
    struct FRBCollisionChannelContainer
        RBCollideWithChannels;    // 0x00A8 (0x0004) [0x0000000000000000]
    float CellSizeFactor;         // 0x00AC (0x0004) [0x0000000000000000]
    float CollisionMargin;        // 0x00B0 (0x0004) [0x0000000000000000]
    float CollisionMarginShapes;  // 0x00B4 (0x0004) [0x0000000000000000]
    float CollisionDistance;      // 0x00B8 (0x0004) [0x0000000000000000]
    float Friction;               // 0x00BC (0x0004) [0x0000000000000000]
    float ParticleFriction;       // 0x00C0 (0x0004) [0x0000000000000000]
    float StaticFriction;         // 0x00C4 (0x0004) [0x0000000000000000]
    float Restitution;            // 0x00C8 (0x0004) [0x0000000000000000]
    float ShockPropagation;       // 0x00CC (0x0004) [0x0000000000000000]
    float Dissipation;            // 0x00D0 (0x0004) [0x0000000000000000]
    struct FVector Wind;          // 0x00D4 (0x000C) [0x0000000000000000]
    float Drag;                   // 0x00E0 (0x0004) [0x0000000000000000]
    float Lift;                   // 0x00E4 (0x0004) [0x0000000000000000]
    float RestDistance;           // 0x00E8 (0x0004) [0x0000000000000000]
    float Adhesion;               // 0x00EC (0x0004) [0x0000000000000000]
    float Cohesion;               // 0x00F0 (0x0004) [0x0000000000000000]
    float SurfaceTension;         // 0x00F4 (0x0004) [0x0000000000000000]
    float Viscosity;              // 0x00F8 (0x0004) [0x0000000000000000]
    float VorticityConfinement;   // 0x00FC (0x0004) [0x0000000000000000]
    float SolidPressure;          // 0x0100 (0x0004) [0x0000000000000000]
    float FreeSurfaceDrag;        // 0x0104 (0x0004) [0x0000000000000000]
    float PlasticThreshold;       // 0x0108 (0x0004) [0x0000000000000000]
    float PlasticCreep;           // 0x010C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1997];

        return pClassPointer;
    };
};

UClass* UFlexContainer::pClassPointer = NULL;

// Class Engine.FractureMaterial
// 0x0010 (0x0070 - 0x0060)
class UFractureMaterial : public UObject {
   public:
    class UParticleSystem*
        FractureEffect;              // 0x0060 (0x0008) [0x0000000000000000]
    class USoundCue* FractureSound;  // 0x0068 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[1999];

        return pClassPointer;
    };
};

UClass* UFractureMaterial::pClassPointer = NULL;

// Class Engine.PhysicalMaterial
// 0x008C (0x00EC - 0x0060)
class UPhysicalMaterial : public UObject {
   public:
    struct FPointer PhysXMaterial;  // 0x0060 (0x0008) [0x0000000000000000]
    int MaterialIndex;              // 0x0068 (0x0004) [0x0000000000000000]
    float Friction;                 // 0x006C (0x0004) [0x0000000000000000]
    float Restitution;              // 0x0070 (0x0004) [0x0000000000000000]
    DWORD bForceConeFriction : 1;   // 0x0074 (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    DWORD bEnableAnisotropicFriction : 1;  // 0x0074 (0x0004)
                                           // [0x0000000000000000] [0x00000002]
    DWORD bCanSeeThrough : 1;         // 0x0074 (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    struct FVector AnisoFrictionDir;  // 0x0078 (0x000C) [0x0000000000000000]
    float FrictionV;                  // 0x0084 (0x0004) [0x0000000000000000]
    float Density;                    // 0x0088 (0x0004) [0x0000000000000000]
    float AngularDamping;             // 0x008C (0x0004) [0x0000000000000000]
    float LinearDamping;              // 0x0090 (0x0004) [0x0000000000000000]
    float MagneticResponse;           // 0x0094 (0x0004) [0x0000000000000000]
    float WindResponse;               // 0x0098 (0x0004) [0x0000000000000000]
    float ImpactThreshold;            // 0x009C (0x0004) [0x0000000000000000]
    float ImpactReFireDelay;          // 0x00A0 (0x0004) [0x0000000000000000]
    class UParticleSystem*
        ImpactEffect;  // 0x00A4 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        ImpactSound;                     // 0x00AC (0x0008) [0x0000000000000000]
    float SlideThreshold;                // 0x00B4 (0x0004) [0x0000000000000000]
    float SlideReFireDelay;              // 0x00B8 (0x0004) [0x0000000000000000]
    class UParticleSystem* SlideEffect;  // 0x00BC (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        SlideSound;  // 0x00C4 (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        FractureSoundExplosion;  // 0x00CC (0x0008) [0x0000000000000000]
    class UAkBaseSoundObject*
        FractureSoundSingle;          // 0x00D4 (0x0008) [0x0000000000000000]
    class UPhysicalMaterial* Parent;  // 0x00DC (0x0008) [0x0000000000000000]
    class UPhysicalMaterialPropertyBase*
        PhysicalMaterialProperty;  // 0x00E4 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2001];

        return pClassPointer;
    };

    void GetPhysicalMaterialProperty();
    void FindFractureSounds();
    void FindPhysEffectInfo();
};

UClass* UPhysicalMaterial::pClassPointer = NULL;

// Class Engine.PhysicalMaterialPropertyBase
// 0x0001 (0x0061 - 0x0060)
class UPhysicalMaterialPropertyBase : public UObject {
   public:
    unsigned char MaterialType;  // 0x0060 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2003];

        return pClassPointer;
    };
};

UClass* UPhysicalMaterialPropertyBase::pClassPointer = NULL;

// Class Engine.PhysicsAsset
// 0x0088 (0x00E8 - 0x0060)
class UPhysicsAsset : public UObject {
   public:
    class USkeletalMesh*
        DefaultSkelMesh;  // 0x0060 (0x0008) [0x0000000000000000]
    TArray<class URB_BodySetup*>
        BodySetup;  // 0x0068 (0x0010) [0x0000000000000000]
    struct FMap_Mirror
        BodySetupIndexMap;     // 0x0078 (0x0048) [0x0000000000000000]
    TArray<int> BoundsBodies;  // 0x00C0 (0x0010) [0x0000000000000000]
    TArray<class URB_ConstraintSetup*>
        ConstraintSetup;  // 0x00D0 (0x0010) [0x0000000000000000]
    class UPhysicsAssetInstance*
        DefaultInstance;  // 0x00E0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2005];

        return pClassPointer;
    };

    void FindBodyIndex();
};

UClass* UPhysicsAsset::pClassPointer = NULL;

// Class Engine.PhysicsAssetInstance
// 0x0090 (0x00F0 - 0x0060)
class UPhysicsAssetInstance : public UObject {
   public:
    class AActor* Owner;  // 0x0060 (0x0008) [0x0000000000000000]
    int RootBodyIndex;    // 0x0068 (0x0004) [0x0000000000000000]
    TArray<class URB_BodyInstance*>
        Bodies;  // 0x006C (0x0010) [0x0000000000000000]
    TArray<class URB_ConstraintInstance*>
        Constraints;  // 0x007C (0x0010) [0x0000000000000000]
    struct FMap_Mirror
        CollisionDisableTable;     // 0x008C (0x0048) [0x0000000000000000]
    float LinearSpringScale;       // 0x00D4 (0x0004) [0x0000000000000000]
    float LinearDampingScale;      // 0x00D8 (0x0004) [0x0000000000000000]
    float LinearForceLimitScale;   // 0x00DC (0x0004) [0x0000000000000000]
    float AngularSpringScale;      // 0x00E0 (0x0004) [0x0000000000000000]
    float AngularDampingScale;     // 0x00E4 (0x0004) [0x0000000000000000]
    float AngularForceLimitScale;  // 0x00E8 (0x0004) [0x0000000000000000]
    DWORD bInitBodies : 1;  // 0x00EC (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2007];

        return pClassPointer;
    };

    void FindConstraintInstance();
    void FindBodyInstance();
    void SetFullAnimWeightBonesFixed();
    void SetFullAnimWeightBlockRigidBody();
    void SetNamedBodiesBlockRigidBody();
    void SetNamedRBBoneSprings();
    void SetNamedMotorsAngularVelocityDrive();
    void SetNamedMotorsAngularPositionDrive();
    void SetAllMotorsAngularDriveParams();
    void SetAllMotorsAngularVelocityDrive();
    void SetAllMotorsAngularPositionDrive();
    void ForceAllBodiesBelowUnfixed();
    void SetNamedBodiesFixed();
    void SetAllBodiesFixed();
    void GetTotalMassBelowBone();
    void SetAngularDriveScale();
    void SetLinearDriveScale();
};

UClass* UPhysicsAssetInstance::pClassPointer = NULL;

// Class Engine.PhysicsLODVerticalEmitter
// 0x0004 (0x0064 - 0x0060)
class UPhysicsLODVerticalEmitter : public UObject {
   public:
    int ParticlePercentage;  // 0x0060 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2009];

        return pClassPointer;
    };
};

UClass* UPhysicsLODVerticalEmitter::pClassPointer = NULL;

// Class Engine.RB_BodyInstance
// 0x0074 (0x00D4 - 0x0060)
class URB_BodyInstance : public UObject {
   public:
    class UPrimitiveComponent*
        OwnerComponent;                  // 0x0060 (0x0008) [0x0000000000000000]
    int BodyIndex;                       // 0x0068 (0x0004) [0x0000000000000000]
    struct FVector Velocity;             // 0x006C (0x000C) [0x0000000000000000]
    struct FVector PreviousVelocity;     // 0x0078 (0x000C) [0x0000000000000000]
    int SceneIndex;                      // 0x0084 (0x0004) [0x0000000000000000]
    struct FPointer BodyData;            // 0x0088 (0x0008) [0x0000000000000000]
    struct FPointer BoneSpring;          // 0x0090 (0x0008) [0x0000000000000000]
    struct FPointer BoneSpringKinActor;  // 0x0098 (0x0008) [0x0000000000000000]
    DWORD bEnableBoneSpringLinear : 1;   // 0x00A0 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bEnableBoneSpringAngular : 1;  // 0x00A0 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bDisableOnOverextension : 1;   // 0x00A0 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD bNotifyOwnerOnOverextension : 1;  // 0x00A0 (0x0004)
                                            // [0x0000000000000000] [0x00000008]
    DWORD bTeleportOnOverextension : 1;  // 0x00A0 (0x0004) [0x0000000000000000]
                                         // [0x00000010]
    DWORD bUseKinActorForBoneSpring : 1;  // 0x00A0 (0x0004)
                                          // [0x0000000000000000] [0x00000020]
    DWORD bMakeSpringToBaseCollisionComponent : 1;  // 0x00A0 (0x0004)
                                                    // [0x0000000000000000]
                                                    // [0x00000040]
    DWORD bOnlyCollideWithPawns : 1;     // 0x00A0 (0x0004) [0x0000000000000000]
                                         // [0x00000080]
    DWORD bEnableCollisionResponse : 1;  // 0x00A0 (0x0004) [0x0000000000000000]
                                         // [0x00000100]
    DWORD bPushBody : 1;  // 0x00A0 (0x0004) [0x0000000000000000] [0x00000200]
    DWORD
        bForceUnfixed : 1;  // 0x00A0 (0x0004) [0x0000000000000000] [0x00000400]
    DWORD
        bInstanceAlwaysFullAnimWeight : 1;  // 0x00A0 (0x0004)
                                            // [0x0000000000000000] [0x00000800]
    float BoneLinearSpring;        // 0x00A4 (0x0004) [0x0000000000000000]
    float BoneLinearDamping;       // 0x00A8 (0x0004) [0x0000000000000000]
    float BoneAngularSpring;       // 0x00AC (0x0004) [0x0000000000000000]
    float BoneAngularDamping;      // 0x00B0 (0x0004) [0x0000000000000000]
    float OverextensionThreshold;  // 0x00B4 (0x0004) [0x0000000000000000]
    float CustomGravityFactor;     // 0x00B8 (0x0004) [0x0000000000000000]
    float LastEffectPlayedTime;    // 0x00BC (0x0004) [0x0000000000000000]
    class UPhysicalMaterial*
        PhysMaterialOverride;           // 0x00C0 (0x0008) [0x0000000000000000]
    float ContactReportForceThreshold;  // 0x00C8 (0x0004) [0x0000000000000000]
    float InstanceMassScale;            // 0x00CC (0x0004) [0x0000000000000000]
    float InstanceDampingScale;         // 0x00D0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2011];

        return pClassPointer;
    };

    void UpdateDampingProperties();
    void UpdateMassProperties();
    void SetContactReportForceThreshold();
    void EnableCollisionResponse();
    void SetPhysMaterialOverride();
    void SetBlockRigidBody();
    void SetBoneSpringTarget();
    void SetBoneSpringParams();
    void EnableBoneSpring();
    void GetUnrealWorldVelocityAtPoint();
    void GetUnrealWorldAngularVelocity();
    void GetUnrealWorldVelocity();
    void GetUnrealWorldTM();
    void GetPhysicsAssetInstance();
    void IsValidBodyInstance();
    void IsFixed();
    void SetFixed();
    void GetBodyMass();
};

UClass* URB_BodyInstance::pClassPointer = NULL;

// Class Engine.RB_ConstraintInstance
// 0x0080 (0x00E0 - 0x0060)
class URB_ConstraintInstance : public UObject {
   public:
    class AActor* Owner;  // 0x0060 (0x0008) [0x0000000000000000]
    class UPrimitiveComponent*
        OwnerComponent;     // 0x0068 (0x0008) [0x0000000000000000]
    int ConstraintIndex;    // 0x0070 (0x0004) [0x0000000000000000]
    int SceneIndex;         // 0x0074 (0x0004) [0x0000000000000000]
    DWORD bInHardware : 1;  // 0x0078 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bLinearXPositionDrive : 1;  // 0x0078 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bLinearXVelocityDrive : 1;  // 0x0078 (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    DWORD bLinearYPositionDrive : 1;  // 0x0078 (0x0004) [0x0000000000000000]
                                      // [0x00000008]
    DWORD bLinearYVelocityDrive : 1;  // 0x0078 (0x0004) [0x0000000000000000]
                                      // [0x00000010]
    DWORD bLinearZPositionDrive : 1;  // 0x0078 (0x0004) [0x0000000000000000]
                                      // [0x00000020]
    DWORD bLinearZVelocityDrive : 1;  // 0x0078 (0x0004) [0x0000000000000000]
                                      // [0x00000040]
    DWORD bSwingPositionDrive : 1;    // 0x0078 (0x0004) [0x0000000000000000]
                                      // [0x00000080]
    DWORD bSwingVelocityDrive : 1;    // 0x0078 (0x0004) [0x0000000000000000]
                                      // [0x00000100]
    DWORD bTwistPositionDrive : 1;    // 0x0078 (0x0004) [0x0000000000000000]
                                      // [0x00000200]
    DWORD bTwistVelocityDrive : 1;    // 0x0078 (0x0004) [0x0000000000000000]
                                      // [0x00000400]
    DWORD bAngularSlerpDrive : 1;     // 0x0078 (0x0004) [0x0000000000000000]
                                      // [0x00000800]
    DWORD bTerminated : 1;  // 0x0078 (0x0004) [0x0000000000000000] [0x00001000]
    struct FPointer ConstraintData;  // 0x007C (0x0008) [0x0000000000000000]
    struct FPointer PulleyJoint;     // 0x0084 (0x0008) [0x0000000000000000]
    struct FVector
        LinearPositionTarget;  // 0x008C (0x000C) [0x0000000000000000]
    struct FVector
        LinearVelocityTarget;            // 0x0098 (0x000C) [0x0000000000000000]
    float LinearDriveSpring;             // 0x00A4 (0x0004) [0x0000000000000000]
    float LinearDriveDamping;            // 0x00A8 (0x0004) [0x0000000000000000]
    float LinearDriveForceLimit;         // 0x00AC (0x0004) [0x0000000000000000]
    struct FQuat AngularPositionTarget;  // 0x00B0 (0x0010) [0x0000000000000000]
    struct FVector
        AngularVelocityTarget;      // 0x00C0 (0x000C) [0x0000000000000000]
    float AngularDriveSpring;       // 0x00CC (0x0004) [0x0000000000000000]
    float AngularDriveDamping;      // 0x00D0 (0x0004) [0x0000000000000000]
    float AngularDriveForceLimit;   // 0x00D4 (0x0004) [0x0000000000000000]
    struct FPointer DummyKinActor;  // 0x00D8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2013];

        return pClassPointer;
    };

    void MoveKinActorTransform();
    void SetLinearLimitSize();
    void SetAngularDOFLimitScale();
    void SetAngularDriveParams();
    void SetAngularVelocityTarget();
    void SetAngularPositionTarget();
    void SetLinearDriveParams();
    void SetLinearVelocityTarget();
    void SetLinearPositionTarget();
    void SetAngularVelocityDrive();
    void SetAngularPositionDrive();
    void SetLinearVelocityDrive();
    void SetLinearPositionDrive();
    void GetConstraintLocation();
    void GetPhysicsAssetInstance();
    void TermConstraint();
    void InitConstraint();
};

UClass* URB_ConstraintInstance::pClassPointer = NULL;

// Class Engine.RB_ConstraintSetup
// 0x00C4 (0x0124 - 0x0060)
class URB_ConstraintSetup : public UObject {
   public:
    struct FName JointName;        // 0x0060 (0x0008) [0x0000000000000000]
    struct FName ConstraintBone1;  // 0x0068 (0x0008) [0x0000000000000000]
    struct FName ConstraintBone2;  // 0x0070 (0x0008) [0x0000000000000000]
    struct FVector Pos1;           // 0x0078 (0x000C) [0x0000000000000000]
    struct FVector PriAxis1;       // 0x0084 (0x000C) [0x0000000000000000]
    struct FVector SecAxis1;       // 0x0090 (0x000C) [0x0000000000000000]
    struct FVector Pos2;           // 0x009C (0x000C) [0x0000000000000000]
    struct FVector PriAxis2;       // 0x00A8 (0x000C) [0x0000000000000000]
    struct FVector SecAxis2;       // 0x00B4 (0x000C) [0x0000000000000000]
    struct FVector PulleyPivot1;   // 0x00C0 (0x000C) [0x0000000000000000]
    struct FVector PulleyPivot2;   // 0x00CC (0x000C) [0x0000000000000000]
    DWORD bEnableProjection : 1;   // 0x00D8 (0x0004) [0x0000000000000000]
                                   // [0x00000001]
    DWORD bLinearLimitSoft : 1;    // 0x00D8 (0x0004) [0x0000000000000000]
                                   // [0x00000002]
    DWORD bLinearBreakable : 1;    // 0x00D8 (0x0004) [0x0000000000000000]
                                   // [0x00000004]
    DWORD
        bSwingLimited : 1;  // 0x00D8 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD
        bTwistLimited : 1;  // 0x00D8 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bSwingLimitSoft : 1;    // 0x00D8 (0x0004) [0x0000000000000000]
                                  // [0x00000020]
    DWORD bTwistLimitSoft : 1;    // 0x00D8 (0x0004) [0x0000000000000000]
                                  // [0x00000040]
    DWORD bAngularBreakable : 1;  // 0x00D8 (0x0004) [0x0000000000000000]
                                  // [0x00000080]
    DWORD bIsPulley : 1;  // 0x00D8 (0x0004) [0x0000000000000000] [0x00000100]
    DWORD bMaintainMinDistance : 1;  // 0x00D8 (0x0004) [0x0000000000000000]
                                     // [0x00000200]
    struct FLinearDOFSetup
        LinearXSetup;  // 0x00DC (0x0008) [0x0000000000000000]
    struct FLinearDOFSetup
        LinearYSetup;  // 0x00E4 (0x0008) [0x0000000000000000]
    struct FLinearDOFSetup
        LinearZSetup;             // 0x00EC (0x0008) [0x0000000000000000]
    float LinearLimitStiffness;   // 0x00F4 (0x0004) [0x0000000000000000]
    float LinearLimitDamping;     // 0x00F8 (0x0004) [0x0000000000000000]
    float LinearBreakThreshold;   // 0x00FC (0x0004) [0x0000000000000000]
    float Swing1LimitAngle;       // 0x0100 (0x0004) [0x0000000000000000]
    float Swing2LimitAngle;       // 0x0104 (0x0004) [0x0000000000000000]
    float TwistLimitAngle;        // 0x0108 (0x0004) [0x0000000000000000]
    float SwingLimitStiffness;    // 0x010C (0x0004) [0x0000000000000000]
    float SwingLimitDamping;      // 0x0110 (0x0004) [0x0000000000000000]
    float TwistLimitStiffness;    // 0x0114 (0x0004) [0x0000000000000000]
    float TwistLimitDamping;      // 0x0118 (0x0004) [0x0000000000000000]
    float AngularBreakThreshold;  // 0x011C (0x0004) [0x0000000000000000]
    float PulleyRatio;            // 0x0120 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2015];

        return pClassPointer;
    };
};

UClass* URB_ConstraintSetup::pClassPointer = NULL;

// Class Engine.RB_BSJointSetup
// 0x0000 (0x0124 - 0x0124)
class URB_BSJointSetup : public URB_ConstraintSetup {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2017];

        return pClassPointer;
    };
};

UClass* URB_BSJointSetup::pClassPointer = NULL;

// Class Engine.RB_DistanceJointSetup
// 0x0000 (0x0124 - 0x0124)
class URB_DistanceJointSetup : public URB_ConstraintSetup {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2019];

        return pClassPointer;
    };
};

UClass* URB_DistanceJointSetup::pClassPointer = NULL;

// Class Engine.RB_HingeSetup
// 0x0000 (0x0124 - 0x0124)
class URB_HingeSetup : public URB_ConstraintSetup {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2021];

        return pClassPointer;
    };
};

UClass* URB_HingeSetup::pClassPointer = NULL;

// Class Engine.RB_PrismaticSetup
// 0x0000 (0x0124 - 0x0124)
class URB_PrismaticSetup : public URB_ConstraintSetup {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2023];

        return pClassPointer;
    };
};

UClass* URB_PrismaticSetup::pClassPointer = NULL;

// Class Engine.RB_PulleyJointSetup
// 0x0000 (0x0124 - 0x0124)
class URB_PulleyJointSetup : public URB_ConstraintSetup {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2025];

        return pClassPointer;
    };
};

UClass* URB_PulleyJointSetup::pClassPointer = NULL;

// Class Engine.RB_SkelJointSetup
// 0x0000 (0x0124 - 0x0124)
class URB_SkelJointSetup : public URB_ConstraintSetup {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2027];

        return pClassPointer;
    };
};

UClass* URB_SkelJointSetup::pClassPointer = NULL;

// Class Engine.RB_StayUprightSetup
// 0x0000 (0x0124 - 0x0124)
class URB_StayUprightSetup : public URB_ConstraintSetup {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2029];

        return pClassPointer;
    };
};

UClass* URB_StayUprightSetup::pClassPointer = NULL;

// Class Engine.SVehicleWheel
// 0x00E8 (0x0158 - 0x0070)
class USVehicleWheel : public UComponent {
   public:
    float Steer;            // 0x0070 (0x0004) [0x0000000000000000]
    float MotorTorque;      // 0x0074 (0x0004) [0x0000000000000000]
    float BrakeTorque;      // 0x0078 (0x0004) [0x0000000000000000]
    float ChassisTorque;    // 0x007C (0x0004) [0x0000000000000000]
    float HandBrakeTorque;  // 0x0080 (0x0004) [0x0000000000000000]
    DWORD
        bPoweredWheel : 1;  // 0x0084 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bHoverWheel : 1;  // 0x0084 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bCollidesVehicles : 1;  // 0x0084 (0x0004) [0x0000000000000000]
                                  // [0x00000004]
    DWORD bCollidesPawns : 1;     // 0x0084 (0x0004) [0x0000000000000000]
                                  // [0x00000008]
    DWORD
        bIsSquealing : 1;  // 0x0084 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bWheelOnGround : 1;      // 0x0084 (0x0004) [0x0000000000000000]
                                   // [0x00000020]
    float SteerFactor;             // 0x0088 (0x0004) [0x0000000000000000]
    struct FName SkelControlName;  // 0x008C (0x0008) [0x0000000000000000]
    class USkelControlWheel*
        WheelControl;           // 0x0094 (0x0008) [0x0000000000000000]
    struct FName BoneName;      // 0x009C (0x0008) [0x0000000000000000]
    struct FVector BoneOffset;  // 0x00A4 (0x000C) [0x0000000000000000]
    float WheelRadius;          // 0x00B0 (0x0004) [0x0000000000000000]
    float WheelWidth;           // 0x00B4 (0x0004) [0x0000000000000000]
    float SuspensionTravel;     // 0x00B8 (0x0004) [0x0000000000000000]
    float SuspensionSpeed;      // 0x00BC (0x0004) [0x0000000000000000]
    class UParticleSystem*
        WheelParticleSystem;          // 0x00C0 (0x0008) [0x0000000000000000]
    unsigned char Side;               // 0x00C8 (0x0001) [0x0000000000000000]
    float LongSlipFactor;             // 0x00CC (0x0004) [0x0000000000000000]
    float LatSlipFactor;              // 0x00D0 (0x0004) [0x0000000000000000]
    float HandbrakeLongSlipFactor;    // 0x00D4 (0x0004) [0x0000000000000000]
    float HandbrakeLatSlipFactor;     // 0x00D8 (0x0004) [0x0000000000000000]
    float ParkedSlipFactor;           // 0x00DC (0x0004) [0x0000000000000000]
    struct FVector WheelPosition;     // 0x00E0 (0x000C) [0x0000000000000000]
    float SpinVel;                    // 0x00EC (0x0004) [0x0000000000000000]
    float LongSlipRatio;              // 0x00F0 (0x0004) [0x0000000000000000]
    float LatSlipAngle;               // 0x00F4 (0x0004) [0x0000000000000000]
    struct FVector ContactNormal;     // 0x00F8 (0x000C) [0x0000000000000000]
    struct FVector LongDirection;     // 0x0104 (0x000C) [0x0000000000000000]
    struct FVector LatDirection;      // 0x0110 (0x000C) [0x0000000000000000]
    float ContactForce;               // 0x011C (0x0004) [0x0000000000000000]
    float LongImpulse;                // 0x0120 (0x0004) [0x0000000000000000]
    float LatImpulse;                 // 0x0124 (0x0004) [0x0000000000000000]
    float DesiredSuspensionPosition;  // 0x0128 (0x0004) [0x0000000000000000]
    float SuspensionPosition;         // 0x012C (0x0004) [0x0000000000000000]
    float CurrentRotation;            // 0x0130 (0x0004) [0x0000000000000000]
    struct FPointer WheelShape;       // 0x0134 (0x0008) [0x0000000000000000]
    int WheelMaterialIndex;           // 0x013C (0x0004) [0x0000000000000000]
    class UClass* WheelPSCClass;      // 0x0140 (0x0008) [0x0000000000000000]
    class UParticleSystemComponent*
        WheelParticleComp;               // 0x0148 (0x0008) [0x0000000000000000]
    struct FName SlipParticleParamName;  // 0x0150 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2031];

        return pClassPointer;
    };
};

UClass* USVehicleWheel::pClassPointer = NULL;

// Class Engine.NxGenericForceFieldBrush
// 0x00E0 (0x0360 - 0x0280)
class ANxGenericForceFieldBrush : public AVolume {
   public:
    int ExcludeChannel;  // 0x0280 (0x0004) [0x0000000000000000]
    struct FRBCollisionChannelContainer
        CollideWithChannels;             // 0x0284 (0x0004) [0x0000000000000000]
    unsigned char RBChannel;             // 0x0288 (0x0001) [0x0000000000000000]
    unsigned char Coordinates;           // 0x0289 (0x0001) [0x0000000000000000]
    struct FVector Constant;             // 0x028C (0x000C) [0x0000000000000000]
    struct FVector PositionMultiplierX;  // 0x0298 (0x000C) [0x0000000000000000]
    struct FVector PositionMultiplierY;  // 0x02A4 (0x000C) [0x0000000000000000]
    struct FVector PositionMultiplierZ;  // 0x02B0 (0x000C) [0x0000000000000000]
    struct FVector PositionTarget;       // 0x02BC (0x000C) [0x0000000000000000]
    struct FVector VelocityMultiplierX;  // 0x02C8 (0x000C) [0x0000000000000000]
    struct FVector VelocityMultiplierY;  // 0x02D4 (0x000C) [0x0000000000000000]
    struct FVector VelocityMultiplierZ;  // 0x02E0 (0x000C) [0x0000000000000000]
    struct FVector VelocityTarget;       // 0x02EC (0x000C) [0x0000000000000000]
    struct FVector Noise;                // 0x02F8 (0x000C) [0x0000000000000000]
    struct FVector FalloffLinear;        // 0x0304 (0x000C) [0x0000000000000000]
    struct FVector FalloffQuadratic;     // 0x0310 (0x000C) [0x0000000000000000]
    float TorusRadius;                   // 0x031C (0x0004) [0x0000000000000000]
    struct FPointer ForceField;          // 0x0320 (0x0008) [0x0000000000000000]
    TArray<struct FPointer>
        ConvexMeshes;  // 0x0328 (0x0010) [0x0000000000000000]
    TArray<struct FPointer>
        ExclusionShapes;  // 0x0338 (0x0010) [0x0000000000000000]
    TArray<struct FPointer>
        ExclusionShapePoses;       // 0x0348 (0x0010) [0x0000000000000000]
    struct FPointer LinearKernel;  // 0x0358 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2033];

        return pClassPointer;
    };

    void StopsProjectile();
    void eventPostBeginPlay();
};

UClass* ANxGenericForceFieldBrush::pClassPointer = NULL;

// Class Engine.RB_ForceFieldExcludeVolume
// 0x0008 (0x0288 - 0x0280)
class ARB_ForceFieldExcludeVolume : public AVolume {
   public:
    int ForceFieldChannel;  // 0x0280 (0x0004) [0x0000000000000000]
    int SceneIndex;         // 0x0284 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2035];

        return pClassPointer;
    };
};

UClass* ARB_ForceFieldExcludeVolume::pClassPointer = NULL;

// Class Engine.NxForceField
// 0x0054 (0x0298 - 0x0244)
class ANxForceField : public AActor {
   public:
    int ExcludeChannel;      // 0x0244 (0x0004) [0x0000000000000000]
    DWORD bForceActive : 1;  // 0x0248 (0x0004) [0x0000000000150000]
                             // [0x00000001] ( CPF_Travel | CPF_GlobalConfig )
    struct FRBCollisionChannelContainer
        CollideWithChannels;     // 0x024C (0x0004) [0x0000000000000000]
    unsigned char RBChannel;     // 0x0250 (0x0001) [0x0000000000000000]
    struct FPointer ForceField;  // 0x0254 (0x0008) [0x0000000000000000]
    TArray<struct FPointer>
        ConvexMeshes;  // 0x025C (0x0010) [0x0000000000000000]
    TArray<struct FPointer>
        ExclusionShapes;  // 0x026C (0x0010) [0x0000000000000000]
    TArray<struct FPointer>
        ExclusionShapePoses;      // 0x027C (0x0010) [0x0000000000000000]
    struct FPointer U2NRotation;  // 0x028C (0x0008) [0x0000000000000000]
    int SceneIndex;               // 0x0294 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2037];

        return pClassPointer;
    };

    void OnToggle();
    void DoInitRBPhys();
};

UClass* ANxForceField::pClassPointer = NULL;

// Class Engine.NxCylindricalForceField
// 0x0030 (0x02C8 - 0x0298)
class ANxCylindricalForceField : public ANxForceField {
   public:
    float RadialStrength;             // 0x0298 (0x0004) [0x0000000000000000]
    float RotationalStrength;         // 0x029C (0x0004) [0x0000000000000000]
    float LiftStrength;               // 0x02A0 (0x0004) [0x0000000000000000]
    float ForceRadius;                // 0x02A4 (0x0004) [0x0000000000000000]
    float ForceTopRadius;             // 0x02A8 (0x0004) [0x0000000000000000]
    float LiftFalloffHeight;          // 0x02AC (0x0004) [0x0000000000000000]
    float EscapeVelocity;             // 0x02B0 (0x0004) [0x0000000000000000]
    float ForceHeight;                // 0x02B4 (0x0004) [0x0000000000000000]
    float HeightOffset;               // 0x02B8 (0x0004) [0x0000000000000000]
    DWORD UseSpecialRadialForce : 1;  // 0x02BC (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    struct FPointer Kernel;           // 0x02C0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2039];

        return pClassPointer;
    };
};

UClass* ANxCylindricalForceField::pClassPointer = NULL;

// Class Engine.NxCylindricalForceFieldCapsule
// 0x0008 (0x02D0 - 0x02C8)
class ANxCylindricalForceFieldCapsule : public ANxCylindricalForceField {
   public:
    class UDrawCapsuleComponent*
        RenderComponent;  // 0x02C8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2041];

        return pClassPointer;
    };

    void DoInitRBPhys();
};

UClass* ANxCylindricalForceFieldCapsule::pClassPointer = NULL;

// Class Engine.NxForceFieldGeneric
// 0x00BC (0x0354 - 0x0298)
class ANxForceFieldGeneric : public ANxForceField {
   public:
    class UForceFieldShape* Shape;  // 0x0298 (0x0008) [0x0000000000000000]
    class UActorComponent*
        DrawComponent;                   // 0x02A0 (0x0008) [0x0000000000000000]
    float RoughExtentX;                  // 0x02A8 (0x0004) [0x0000000000000000]
    float RoughExtentY;                  // 0x02AC (0x0004) [0x0000000000000000]
    float RoughExtentZ;                  // 0x02B0 (0x0004) [0x0000000000000000]
    unsigned char Coordinates;           // 0x02B4 (0x0001) [0x0000000000000000]
    struct FVector Constant;             // 0x02B8 (0x000C) [0x0000000000000000]
    struct FVector PositionMultiplierX;  // 0x02C4 (0x000C) [0x0000000000000000]
    struct FVector PositionMultiplierY;  // 0x02D0 (0x000C) [0x0000000000000000]
    struct FVector PositionMultiplierZ;  // 0x02DC (0x000C) [0x0000000000000000]
    struct FVector PositionTarget;       // 0x02E8 (0x000C) [0x0000000000000000]
    struct FVector VelocityMultiplierX;  // 0x02F4 (0x000C) [0x0000000000000000]
    struct FVector VelocityMultiplierY;  // 0x0300 (0x000C) [0x0000000000000000]
    struct FVector VelocityMultiplierZ;  // 0x030C (0x000C) [0x0000000000000000]
    struct FVector VelocityTarget;       // 0x0318 (0x000C) [0x0000000000000000]
    struct FVector Noise;                // 0x0324 (0x000C) [0x0000000000000000]
    struct FVector FalloffLinear;        // 0x0330 (0x000C) [0x0000000000000000]
    struct FVector FalloffQuadratic;     // 0x033C (0x000C) [0x0000000000000000]
    float TorusRadius;                   // 0x0348 (0x0004) [0x0000000000000000]
    struct FPointer LinearKernel;        // 0x034C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2043];

        return pClassPointer;
    };

    void DoInitRBPhys();
};

UClass* ANxForceFieldGeneric::pClassPointer = NULL;

// Class Engine.NxForceFieldRadial
// 0x0028 (0x02C0 - 0x0298)
class ANxForceFieldRadial : public ANxForceField {
   public:
    class UForceFieldShape* Shape;  // 0x0298 (0x0008) [0x0000000000000000]
    class UActorComponent*
        DrawComponent;           // 0x02A0 (0x0008) [0x0000000000000000]
    float ForceStrength;         // 0x02A8 (0x0004) [0x0000000000000000]
    float ForceRadius;           // 0x02AC (0x0004) [0x0000000000000000]
    float SelfRotationStrength;  // 0x02B0 (0x0004) [0x0000000000000000]
    unsigned char ForceFalloff;  // 0x02B4 (0x0001) [0x0000000000000000]
    struct FPointer Kernel;      // 0x02B8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2045];

        return pClassPointer;
    };

    void DoInitRBPhys();
};

UClass* ANxForceFieldRadial::pClassPointer = NULL;

// Class Engine.NxForceFieldTornado
// 0x0044 (0x02DC - 0x0298)
class ANxForceFieldTornado : public ANxForceField {
   public:
    class UForceFieldShape* Shape;  // 0x0298 (0x0008) [0x0000000000000000]
    class UActorComponent*
        DrawComponent;                  // 0x02A0 (0x0008) [0x0000000000000000]
    float RadialStrength;               // 0x02A8 (0x0004) [0x0000000000000000]
    float RotationalStrength;           // 0x02AC (0x0004) [0x0000000000000000]
    float LiftStrength;                 // 0x02B0 (0x0004) [0x0000000000000000]
    float ForceRadius;                  // 0x02B4 (0x0004) [0x0000000000000000]
    float ForceTopRadius;               // 0x02B8 (0x0004) [0x0000000000000000]
    float LiftFalloffHeight;            // 0x02BC (0x0004) [0x0000000000000000]
    float EscapeVelocity;               // 0x02C0 (0x0004) [0x0000000000000000]
    float ForceHeight;                  // 0x02C4 (0x0004) [0x0000000000000000]
    float HeightOffset;                 // 0x02C8 (0x0004) [0x0000000000000000]
    DWORD BSpecialRadialForceMode : 1;  // 0x02CC (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    float SelfRotationStrength;         // 0x02D0 (0x0004) [0x0000000000000000]
    struct FPointer Kernel;             // 0x02D4 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2047];

        return pClassPointer;
    };

    void DoInitRBPhys();
};

UClass* ANxForceFieldTornado::pClassPointer = NULL;

// Class Engine.NxGenericForceField
// 0x00A0 (0x0338 - 0x0298)
class ANxGenericForceField : public ANxForceField {
   public:
    unsigned char Coordinates;           // 0x0298 (0x0001) [0x0000000000000000]
    struct FVector Constant;             // 0x029C (0x000C) [0x0000000000000000]
    struct FVector PositionMultiplierX;  // 0x02A8 (0x000C) [0x0000000000000000]
    struct FVector PositionMultiplierY;  // 0x02B4 (0x000C) [0x0000000000000000]
    struct FVector PositionMultiplierZ;  // 0x02C0 (0x000C) [0x0000000000000000]
    struct FVector PositionTarget;       // 0x02CC (0x000C) [0x0000000000000000]
    struct FVector VelocityMultiplierX;  // 0x02D8 (0x000C) [0x0000000000000000]
    struct FVector VelocityMultiplierY;  // 0x02E4 (0x000C) [0x0000000000000000]
    struct FVector VelocityMultiplierZ;  // 0x02F0 (0x000C) [0x0000000000000000]
    struct FVector VelocityTarget;       // 0x02FC (0x000C) [0x0000000000000000]
    struct FVector Noise;                // 0x0308 (0x000C) [0x0000000000000000]
    struct FVector FalloffLinear;        // 0x0314 (0x000C) [0x0000000000000000]
    struct FVector FalloffQuadratic;     // 0x0320 (0x000C) [0x0000000000000000]
    float TorusRadius;                   // 0x032C (0x0004) [0x0000000000000000]
    struct FPointer LinearKernel;        // 0x0330 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2049];

        return pClassPointer;
    };
};

UClass* ANxGenericForceField::pClassPointer = NULL;

// Class Engine.NxGenericForceFieldBox
// 0x0014 (0x034C - 0x0338)
class ANxGenericForceFieldBox : public ANxGenericForceField {
   public:
    class UDrawBoxComponent*
        RenderComponent;       // 0x0338 (0x0008) [0x0000000000000000]
    struct FVector BoxExtent;  // 0x0340 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2051];

        return pClassPointer;
    };

    void DoInitRBPhys();
};

UClass* ANxGenericForceFieldBox::pClassPointer = NULL;

// Class Engine.NxGenericForceFieldCapsule
// 0x0010 (0x0348 - 0x0338)
class ANxGenericForceFieldCapsule : public ANxGenericForceField {
   public:
    class UDrawCapsuleComponent*
        RenderComponent;  // 0x0338 (0x0008) [0x0000000000000000]
    float CapsuleHeight;  // 0x0340 (0x0004) [0x0000000000000000]
    float CapsuleRadius;  // 0x0344 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2053];

        return pClassPointer;
    };
};

UClass* ANxGenericForceFieldCapsule::pClassPointer = NULL;

// Class Engine.NxRadialForceField
// 0x001C (0x02B4 - 0x0298)
class ANxRadialForceField : public ANxForceField {
   public:
    class UDrawSphereComponent*
        RenderComponent;           // 0x0298 (0x0008) [0x0000000000000000]
    float ForceStrength;           // 0x02A0 (0x0004) [0x0000000000000000]
    float ForceRadius;             // 0x02A4 (0x0004) [0x0000000000000000]
    unsigned char ForceFalloff;    // 0x02A8 (0x0001) [0x0000000000000000]
    struct FPointer LinearKernel;  // 0x02AC (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2055];

        return pClassPointer;
    };
};

UClass* ANxRadialForceField::pClassPointer = NULL;

// Class Engine.NxRadialCustomForceField
// 0x000C (0x02C0 - 0x02B4)
class ANxRadialCustomForceField : public ANxRadialForceField {
   public:
    float SelfRotationStrength;  // 0x02B4 (0x0004) [0x0000000000000000]
    struct FPointer Kernel;      // 0x02B8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2057];

        return pClassPointer;
    };
};

UClass* ANxRadialCustomForceField::pClassPointer = NULL;

// Class Engine.NxTornadoAngularForceField
// 0x0034 (0x02CC - 0x0298)
class ANxTornadoAngularForceField : public ANxForceField {
   public:
    float RadialStrength;               // 0x0298 (0x0004) [0x0000000000000000]
    float RotationalStrength;           // 0x029C (0x0004) [0x0000000000000000]
    float LiftStrength;                 // 0x02A0 (0x0004) [0x0000000000000000]
    float ForceRadius;                  // 0x02A4 (0x0004) [0x0000000000000000]
    float ForceTopRadius;               // 0x02A8 (0x0004) [0x0000000000000000]
    float LiftFalloffHeight;            // 0x02AC (0x0004) [0x0000000000000000]
    float EscapeVelocity;               // 0x02B0 (0x0004) [0x0000000000000000]
    float ForceHeight;                  // 0x02B4 (0x0004) [0x0000000000000000]
    float HeightOffset;                 // 0x02B8 (0x0004) [0x0000000000000000]
    DWORD BSpecialRadialForceMode : 1;  // 0x02BC (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    float SelfRotationStrength;         // 0x02C0 (0x0004) [0x0000000000000000]
    struct FPointer Kernel;             // 0x02C4 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2059];

        return pClassPointer;
    };
};

UClass* ANxTornadoAngularForceField::pClassPointer = NULL;

// Class Engine.NxTornadoAngularForceFieldCapsule
// 0x0008 (0x02D4 - 0x02CC)
class ANxTornadoAngularForceFieldCapsule : public ANxTornadoAngularForceField {
   public:
    class UDrawCapsuleComponent*
        RenderComponent;  // 0x02CC (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2061];

        return pClassPointer;
    };
};

UClass* ANxTornadoAngularForceFieldCapsule::pClassPointer = NULL;

// Class Engine.NxTornadoForceField
// 0x0030 (0x02C8 - 0x0298)
class ANxTornadoForceField : public ANxForceField {
   public:
    float RadialStrength;               // 0x0298 (0x0004) [0x0000000000000000]
    float RotationalStrength;           // 0x029C (0x0004) [0x0000000000000000]
    float LiftStrength;                 // 0x02A0 (0x0004) [0x0000000000000000]
    float ForceRadius;                  // 0x02A4 (0x0004) [0x0000000000000000]
    float ForceTopRadius;               // 0x02A8 (0x0004) [0x0000000000000000]
    float LiftFalloffHeight;            // 0x02AC (0x0004) [0x0000000000000000]
    float EscapeVelocity;               // 0x02B0 (0x0004) [0x0000000000000000]
    float ForceHeight;                  // 0x02B4 (0x0004) [0x0000000000000000]
    float HeightOffset;                 // 0x02B8 (0x0004) [0x0000000000000000]
    DWORD BSpecialRadialForceMode : 1;  // 0x02BC (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    struct FPointer Kernel;             // 0x02C0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2063];

        return pClassPointer;
    };
};

UClass* ANxTornadoForceField::pClassPointer = NULL;

// Class Engine.NxTornadoForceFieldCapsule
// 0x0008 (0x02D0 - 0x02C8)
class ANxTornadoForceFieldCapsule : public ANxTornadoForceField {
   public:
    class UDrawCapsuleComponent*
        RenderComponent;  // 0x02C8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2065];

        return pClassPointer;
    };
};

UClass* ANxTornadoForceFieldCapsule::pClassPointer = NULL;

// Class Engine.NxForceFieldSpawnable
// 0x0008 (0x024C - 0x0244)
class ANxForceFieldSpawnable : public AActor {
   public:
    class UNxForceFieldComponent*
        ForceFieldComponent;  // 0x0244 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2067];

        return pClassPointer;
    };

    void OnToggle();
};

UClass* ANxForceFieldSpawnable::pClassPointer = NULL;

// Class Engine.RB_CylindricalForceActor
// 0x0034 (0x0278 - 0x0244)
class ARB_CylindricalForceActor : public ARigidBodyBase {
   public:
    class UDrawCylinderComponent*
        RenderComponent;       // 0x0244 (0x0008) [0x0000000000000000]
    float RadialStrength;      // 0x024C (0x0004) [0x0000000000000000]
    float RotationalStrength;  // 0x0250 (0x0004) [0x0000000000000000]
    float LiftStrength;        // 0x0254 (0x0004) [0x0000000000000000]
    float LiftFalloffHeight;   // 0x0258 (0x0004) [0x0000000000000000]
    float EscapeVelocity;      // 0x025C (0x0004) [0x0000000000000000]
    float ForceRadius;         // 0x0260 (0x0004) [0x0000000000000000]
    float ForceTopRadius;      // 0x0264 (0x0004) [0x0000000000000000]
    float ForceHeight;         // 0x0268 (0x0004) [0x0000000000000000]
    float HeightOffset;        // 0x026C (0x0004) [0x0000000000000000]
    DWORD bForceActive : 1;    // 0x0270 (0x0004) [0x0000000000150000]
                               // [0x00000001] ( CPF_Travel | CPF_GlobalConfig )
    DWORD bForceApplyToCloth : 1;        // 0x0270 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bForceApplyToFluid : 1;        // 0x0270 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD bForceApplyToRigidBodies : 1;  // 0x0270 (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    DWORD bForceApplyToProjectiles : 1;  // 0x0270 (0x0004) [0x0000000000000000]
                                         // [0x00000010]
    struct FRBCollisionChannelContainer
        CollideWithChannels;  // 0x0274 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2069];

        return pClassPointer;
    };

    void OnToggle();
};

UClass* ARB_CylindricalForceActor::pClassPointer = NULL;

// Class Engine.RB_RadialForceActor
// 0x0024 (0x0268 - 0x0244)
class ARB_RadialForceActor : public ARigidBodyBase {
   public:
    class UDrawSphereComponent*
        RenderComponent;            // 0x0244 (0x0008) [0x0000000000000000]
    float ForceStrength;            // 0x024C (0x0004) [0x0000000000000000]
    float ForceRadius;              // 0x0250 (0x0004) [0x0000000000000000]
    float SwirlStrength;            // 0x0254 (0x0004) [0x0000000000000000]
    float SpinTorque;               // 0x0258 (0x0004) [0x0000000000000000]
    unsigned char ForceFalloff;     // 0x025C (0x0001) [0x0000000000000000]
    unsigned char RadialForceMode;  // 0x025D (0x0001) [0x0000000000000000]
    DWORD bForceActive : 1;         // 0x0260 (0x0004) [0x0000000000150000]
                             // [0x00000001] ( CPF_Travel | CPF_GlobalConfig )
    DWORD bForceApplyToCloth : 1;        // 0x0260 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bForceApplyToFluid : 1;        // 0x0260 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD bForceApplyToRigidBodies : 1;  // 0x0260 (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    DWORD bForceApplyToProjectiles : 1;  // 0x0260 (0x0004) [0x0000000000000000]
                                         // [0x00000010]
    struct FRBCollisionChannelContainer
        CollideWithChannels;  // 0x0264 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2071];

        return pClassPointer;
    };

    void OnToggle();
};

UClass* ARB_RadialForceActor::pClassPointer = NULL;

// Class Engine.NxForceFieldComponent
// 0x0070 (0x02A8 - 0x0238)
class UNxForceFieldComponent : public UPrimitiveComponent {
   public:
    class UForceFieldShape* Shape;  // 0x0238 (0x0008) [0x0000000000000000]
    class UActorComponent*
        DrawComponent;   // 0x0240 (0x0008) [0x0000000000000000]
    int ExcludeChannel;  // 0x0248 (0x0004) [0x0000000000000000]
    DWORD
        bForceActive : 1;  // 0x024C (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bDestroyWhenInactive : 1;  // 0x024C (0x0004) [0x0000000000000000]
                                     // [0x00000002]
    struct FRBCollisionChannelContainer
        CollideWithChannels;     // 0x0250 (0x0004) [0x0000000000000000]
    float Duration;              // 0x0254 (0x0004) [0x0000000000000000]
    struct FPointer ForceField;  // 0x0258 (0x0008) [0x0000000000000000]
    TArray<struct FPointer>
        ConvexMeshes;  // 0x0260 (0x0010) [0x0000000000000000]
    TArray<struct FPointer>
        ExclusionShapes;  // 0x0270 (0x0010) [0x0000000000000000]
    TArray<struct FPointer>
        ExclusionShapePoses;  // 0x0280 (0x0010) [0x0000000000000000]
    int SceneIndex;           // 0x0290 (0x0004) [0x0000000000000000]
    float ElapsedTime;        // 0x0294 (0x0004) [0x0000000000000000]
    class UPrimitiveComponent*
        RenderComponent;          // 0x0298 (0x0008) [0x0000000000000000]
    struct FPointer RBPhysScene;  // 0x02A0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2073];

        return pClassPointer;
    };

    void DoInitRBPhys();
};

UClass* UNxForceFieldComponent::pClassPointer = NULL;

// Class Engine.NxForceFieldCylindricalComponent
// 0x0030 (0x02D8 - 0x02A8)
class UNxForceFieldCylindricalComponent : public UNxForceFieldComponent {
   public:
    float RadialStrength;             // 0x02A8 (0x0004) [0x0000000000000000]
    float RotationalStrength;         // 0x02AC (0x0004) [0x0000000000000000]
    float LiftStrength;               // 0x02B0 (0x0004) [0x0000000000000000]
    float ForceRadius;                // 0x02B4 (0x0004) [0x0000000000000000]
    float ForceTopRadius;             // 0x02B8 (0x0004) [0x0000000000000000]
    float LiftFalloffHeight;          // 0x02BC (0x0004) [0x0000000000000000]
    float EscapeVelocity;             // 0x02C0 (0x0004) [0x0000000000000000]
    float ForceHeight;                // 0x02C4 (0x0004) [0x0000000000000000]
    float HeightOffset;               // 0x02C8 (0x0004) [0x0000000000000000]
    DWORD UseSpecialRadialForce : 1;  // 0x02CC (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    struct FPointer Kernel;           // 0x02D0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2075];

        return pClassPointer;
    };
};

UClass* UNxForceFieldCylindricalComponent::pClassPointer = NULL;

// Class Engine.NxForceFieldGenericComponent
// 0x00AC (0x0354 - 0x02A8)
class UNxForceFieldGenericComponent : public UNxForceFieldComponent {
   public:
    float RoughExtentX;                  // 0x02A8 (0x0004) [0x0000000000000000]
    float RoughExtentY;                  // 0x02AC (0x0004) [0x0000000000000000]
    float RoughExtentZ;                  // 0x02B0 (0x0004) [0x0000000000000000]
    unsigned char Coordinates;           // 0x02B4 (0x0001) [0x0000000000000000]
    struct FVector Constant;             // 0x02B8 (0x000C) [0x0000000000000000]
    struct FVector PositionMultiplierX;  // 0x02C4 (0x000C) [0x0000000000000000]
    struct FVector PositionMultiplierY;  // 0x02D0 (0x000C) [0x0000000000000000]
    struct FVector PositionMultiplierZ;  // 0x02DC (0x000C) [0x0000000000000000]
    struct FVector PositionTarget;       // 0x02E8 (0x000C) [0x0000000000000000]
    struct FVector VelocityMultiplierX;  // 0x02F4 (0x000C) [0x0000000000000000]
    struct FVector VelocityMultiplierY;  // 0x0300 (0x000C) [0x0000000000000000]
    struct FVector VelocityMultiplierZ;  // 0x030C (0x000C) [0x0000000000000000]
    struct FVector VelocityTarget;       // 0x0318 (0x000C) [0x0000000000000000]
    struct FVector Noise;                // 0x0324 (0x000C) [0x0000000000000000]
    struct FVector FalloffLinear;        // 0x0330 (0x000C) [0x0000000000000000]
    struct FVector FalloffQuadratic;     // 0x033C (0x000C) [0x0000000000000000]
    float TorusRadius;                   // 0x0348 (0x0004) [0x0000000000000000]
    struct FPointer Kernel;              // 0x034C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2077];

        return pClassPointer;
    };
};

UClass* UNxForceFieldGenericComponent::pClassPointer = NULL;

// Class Engine.NxForceFieldRadialComponent
// 0x0018 (0x02C0 - 0x02A8)
class UNxForceFieldRadialComponent : public UNxForceFieldComponent {
   public:
    float ForceStrength;         // 0x02A8 (0x0004) [0x0000000000000000]
    float ForceRadius;           // 0x02AC (0x0004) [0x0000000000000000]
    float SelfRotationStrength;  // 0x02B0 (0x0004) [0x0000000000000000]
    unsigned char ForceFalloff;  // 0x02B4 (0x0001) [0x0000000000000000]
    struct FPointer Kernel;      // 0x02B8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2079];

        return pClassPointer;
    };
};

UClass* UNxForceFieldRadialComponent::pClassPointer = NULL;

// Class Engine.NxForceFieldTornadoComponent
// 0x0034 (0x02DC - 0x02A8)
class UNxForceFieldTornadoComponent : public UNxForceFieldComponent {
   public:
    float RadialStrength;               // 0x02A8 (0x0004) [0x0000000000000000]
    float RotationalStrength;           // 0x02AC (0x0004) [0x0000000000000000]
    float LiftStrength;                 // 0x02B0 (0x0004) [0x0000000000000000]
    float ForceRadius;                  // 0x02B4 (0x0004) [0x0000000000000000]
    float ForceTopRadius;               // 0x02B8 (0x0004) [0x0000000000000000]
    float LiftFalloffHeight;            // 0x02BC (0x0004) [0x0000000000000000]
    float EscapeVelocity;               // 0x02C0 (0x0004) [0x0000000000000000]
    float ForceHeight;                  // 0x02C4 (0x0004) [0x0000000000000000]
    float HeightOffset;                 // 0x02C8 (0x0004) [0x0000000000000000]
    DWORD BSpecialRadialForceMode : 1;  // 0x02CC (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    float SelfRotationStrength;         // 0x02D0 (0x0004) [0x0000000000000000]
    struct FPointer Kernel;             // 0x02D4 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2081];

        return pClassPointer;
    };
};

UClass* UNxForceFieldTornadoComponent::pClassPointer = NULL;

// Class Engine.ForceFieldShape
// 0x0000 (0x0060 - 0x0060)
class UForceFieldShape : public UObject {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2083];

        return pClassPointer;
    };

    void eventGetDrawComponent();
    void eventFillByCylinder();
    void eventFillByCapsule();
    void eventFillByBox();
    void eventFillBySphere();
};

UClass* UForceFieldShape::pClassPointer = NULL;

// Class Engine.ForceFieldShapeBox
// 0x0008 (0x0068 - 0x0060)
class UForceFieldShapeBox : public UForceFieldShape {
   public:
    class UDrawBoxComponent* Shape;  // 0x0060 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2085];

        return pClassPointer;
    };

    void eventGetDrawComponent();
    void eventFillByCylinder();
    void eventFillByCapsule();
    void eventFillByBox();
    void eventFillBySphere();
    void eventGetRadii();
};

UClass* UForceFieldShapeBox::pClassPointer = NULL;

// Class Engine.ForceFieldShapeCapsule
// 0x0008 (0x0068 - 0x0060)
class UForceFieldShapeCapsule : public UForceFieldShape {
   public:
    class UDrawCapsuleComponent* Shape;  // 0x0060 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2087];

        return pClassPointer;
    };

    void eventGetDrawComponent();
    void eventFillByCylinder();
    void eventFillByCapsule();
    void eventFillByBox();
    void eventFillBySphere();
    void eventGetRadius();
    void eventGetHeight();
};

UClass* UForceFieldShapeCapsule::pClassPointer = NULL;

// Class Engine.ForceFieldShapeSphere
// 0x0008 (0x0068 - 0x0060)
class UForceFieldShapeSphere : public UForceFieldShape {
   public:
    class UDrawSphereComponent* Shape;  // 0x0060 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2089];

        return pClassPointer;
    };

    void eventGetDrawComponent();
    void eventFillByCylinder();
    void eventFillByCapsule();
    void eventFillByBox();
    void eventFillBySphere();
    void eventGetRadius();
};

UClass* UForceFieldShapeSphere::pClassPointer = NULL;

// Class Engine.PrefabInstance
// 0x00EC (0x0330 - 0x0244)
class APrefabInstance : public AActor {
   public:
    class UPrefab* TemplatePrefab;  // 0x0244 (0x0008) [0x0000000000000000]
    int TemplateVersion;            // 0x024C (0x0004) [0x0000000000000000]
    unsigned char
        UnknownData00[0x48];  // 0x0250 (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.PrefabInstance.ArchetypeToInstanceMap
    class UPrefabSequence*
        SequenceInstance;            // 0x0298 (0x0008) [0x0000000000000000]
    int PI_PackageVersion;           // 0x02A0 (0x0004) [0x0000000000000000]
    int PI_LicenseePackageVersion;   // 0x02A4 (0x0004) [0x0000000000000000]
    TArray<unsigned char> PI_Bytes;  // 0x02A8 (0x0010) [0x0000000000000000]
    TArray<class UObject*>
        PI_CompleteObjects;  // 0x02B8 (0x0010) [0x0000000000000000]
    TArray<class UObject*>
        PI_ReferencedObjects;  // 0x02C8 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        PI_SavedNames;  // 0x02D8 (0x0010) [0x0000000000000000]
    unsigned char
        UnknownData01[0x48];  // 0x02E8 (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.PrefabInstance.PI_ObjectMap

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2091];

        return pClassPointer;
    };
};

UClass* APrefabInstance::pClassPointer = NULL;

// Class Engine.Prefab
// 0x0034 (0x0094 - 0x0060)
class UPrefab : public UObject {
   public:
    int PrefabVersion;  // 0x0060 (0x0004) [0x0000000000000000]
    TArray<class UObject*>
        PrefabArchetypes;  // 0x0064 (0x0010) [0x0000000000000000]
    TArray<class UObject*>
        RemovedArchetypes;  // 0x0074 (0x0010) [0x0000000000000000]
    class UPrefabSequence*
        PrefabSequence;               // 0x0084 (0x0008) [0x0000000000000000]
    class UTexture2D* PrefabPreview;  // 0x008C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2093];

        return pClassPointer;
    };
};

UClass* UPrefab::pClassPointer = NULL;

// Class Engine.SequenceObject
// 0x006C (0x00CC - 0x0060)
class USequenceObject : public UObject {
   public:
    int ObjInstanceVersion;           // 0x0060 (0x0004) [0x0000000000000000]
    class USequence* ParentSequence;  // 0x0064 (0x0008) [0x0000000000000000]
    int ObjPosX;                      // 0x006C (0x0004) [0x0000000000000000]
    int ObjPosY;                      // 0x0070 (0x0004) [0x0000000000000000]
    struct FString ObjName;           // 0x0074 (0x0010) [0x0000000000000000]
    struct FString ObjCategory;       // 0x0084 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        ObjRemoveInProject;     // 0x0094 (0x0010) [0x0000000000000000]
    struct FColor ObjColor;     // 0x00A4 (0x0004) [0x0000000000000000]
    struct FString ObjComment;  // 0x00A8 (0x0010) [0x0000000000000000]
    DWORD bDeletable : 1;  // 0x00B8 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bDrawFirst : 1;  // 0x00B8 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bDrawLast : 1;   // 0x00B8 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bOutputObjCommentToScreen : 1;  // 0x00B8 (0x0004)
                                          // [0x0000000000000000] [0x00000008]
    DWORD bSuppressAutoComment : 1;  // 0x00B8 (0x0004) [0x0000000000000000]
                                     // [0x00000010]
    int DrawWidth;                   // 0x00BC (0x0004) [0x0000000000000000]
    int DrawHeight;                  // 0x00C0 (0x0004) [0x0000000000000000]
    class USequenceObject*
        PIESequenceObject;  // 0x00C4 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2095];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
    void eventShouldClearNameOnPasting();
    void eventIsPastingIntoLevelSequenceAllowed();
    void eventIsValidLevelSequenceObject();
    void GetWorldInfo();
    void ScriptLog();
};

UClass* USequenceObject::pClassPointer = NULL;

// Class Engine.SequenceFrame
// 0x0028 (0x00F4 - 0x00CC)
class USequenceFrame : public USequenceObject {
   public:
    int SizeX;            // 0x00CC (0x0004) [0x0000000000000000]
    int SizeY;            // 0x00D0 (0x0004) [0x0000000000000000]
    int BorderWidth;      // 0x00D4 (0x0004) [0x0000000000000000]
    DWORD bDrawBox : 1;   // 0x00D8 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bFilled : 1;    // 0x00D8 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bTileFill : 1;  // 0x00D8 (0x0004) [0x0000000000000000] [0x00000004]
    struct FColor BorderColor;      // 0x00DC (0x0004) [0x0000000000000000]
    struct FColor FillColor;        // 0x00E0 (0x0004) [0x0000000000000000]
    class UTexture2D* FillTexture;  // 0x00E4 (0x0008) [0x0000000000000000]
    class UMaterial* FillMaterial;  // 0x00EC (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2097];

        return pClassPointer;
    };
};

UClass* USequenceFrame::pClassPointer = NULL;

// Class Engine.SequenceFrameWrapped
// 0x0000 (0x00F4 - 0x00F4)
class USequenceFrameWrapped : public USequenceFrame {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2099];

        return pClassPointer;
    };
};

UClass* USequenceFrameWrapped::pClassPointer = NULL;

// Class Engine.SequenceOp
// 0x0068 (0x0134 - 0x00CC)
class USequenceOp : public USequenceObject {
   public:
    DWORD
        bIsActivated : 1;  // 0x00CC (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bIsCurrentDebuggerOp : 1;  // 0x00CC (0x0004) [0x0000000000000000]
                                     // [0x00000002]
    DWORD bActive : 1;  // 0x00CC (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bLatentExecution : 1;          // 0x00CC (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    DWORD bAutoActivateOutputLinks : 1;  // 0x00CC (0x0004) [0x0000000000000000]
                                         // [0x00000010]
    DWORD bHaveMovingVarConnector : 1;   // 0x00CC (0x0004) [0x0000000000000000]
                                         // [0x00000020]
    DWORD bHaveMovingInputConnector : 1;   // 0x00CC (0x0004)
                                           // [0x0000000000000000] [0x00000040]
    DWORD bHaveMovingOutputConnector : 1;  // 0x00CC (0x0004)
                                           // [0x0000000000000000] [0x00000080]
    DWORD bPendingVarConnectorRecalc : 1;  // 0x00CC (0x0004)
                                           // [0x0000000000000000] [0x00000100]
    DWORD
        bPendingInputConnectorRecalc : 1;  // 0x00CC (0x0004)
                                           // [0x0000000000000000] [0x00000200]
    DWORD
        bPendingOutputConnectorRecalc : 1;  // 0x00CC (0x0004)
                                            // [0x0000000000000000] [0x00000400]
    DWORD bIsBreakpointSet : 1;         // 0x00CC (0x0004) [0x0000000000000000]
                                        // [0x00000800]
    DWORD bIsHiddenBreakpointSet : 1;   // 0x00CC (0x0004) [0x0000000000000000]
                                        // [0x00001000]
    float PIEActivationTime;            // 0x00D0 (0x0004) [0x0000000000000000]
    class USequenceOp* ActivatorSeqOp;  // 0x00D4 (0x0008) [0x0000000000000000]
    int LastActivatedInputLink;         // 0x00DC (0x0004) [0x0000000000000000]
    int LastActivatedOutputLink;        // 0x00E0 (0x0004) [0x0000000000000000]
    TArray<struct FSeqOpInputLink>
        InputLinks;  // 0x00E4 (0x0010) [0x0000000000000000]
    TArray<struct FSeqOpOutputLink>
        OutputLinks;  // 0x00F4 (0x0010) [0x0000000000000000]
    TArray<struct FSeqVarLink>
        VariableLinks;  // 0x0104 (0x0010) [0x0000000000000000]
    TArray<struct FSeqEventLink>
        EventLinks;           // 0x0114 (0x0010) [0x0000000000000000]
    int PlayerIndex;          // 0x0124 (0x0004) [0x0000000000000000]
    unsigned char GamepadID;  // 0x0128 (0x0001) [0x0000000000000000]
    int ActivateCount;        // 0x012C (0x0004) [0x0000000000000000]
    int SearchTag;            // 0x0130 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2101];

        return pClassPointer;
    };

    void ForceActivateOutput();
    void ForceActivateInput();
    void GetController();
    void GetPawn();
    void Reset();
    void PublishLinkedVariableValues();
    void PopulateLinkedVariableValues();
    void eventVersionUpdated();
    void eventDeactivated();
    void eventActivated();
    void ActivateNamedOutputLink();
    void ActivateOutputLink();
    void LinkedVariables();
    void GetBoolVars();
    void GetInterpDataVars();
    void GetObjectVars();
    void GetLinkedObjects();
    void HasLinkedOps();
};

UClass* USequenceOp::pClassPointer = NULL;

// Class Engine.Sequence
// 0x0088 (0x01BC - 0x0134)
class USequence : public USequenceOp {
   public:
    struct FPointer LogFile;  // 0x0134 (0x0008) [0x0000000000000000]
    TArray<class USequenceObject*>
        SequenceObjects;  // 0x013C (0x0010) [0x0000000000000000]
    TArray<class USequenceOp*>
        ActiveSequenceOps;  // 0x014C (0x0010) [0x0000000000000000]
    TArray<class USequence*>
        NestedSequences;  // 0x015C (0x0010) [0x0000000000000000]
    TArray<class USequenceEvent*>
        UnregisteredEvents;  // 0x016C (0x0010) [0x0000000000000000]
    TArray<struct FActivateOp>
        DelayedActivatedOps;  // 0x017C (0x0010) [0x0000000000000000]
    TArray<class USequenceOp*>
        DelayedLatentOps;  // 0x018C (0x0010) [0x0000000000000000]
    DWORD bEnabled : 1;    // 0x019C (0x0004) [0x0000000000000000] [0x00000001]
    TArray<struct FQueuedActivationInfo>
        QueuedActivations;  // 0x01A0 (0x0010) [0x0000000000000000]
    int DefaultViewX;       // 0x01B0 (0x0004) [0x0000000000000000]
    int DefaultViewY;       // 0x01B4 (0x0004) [0x0000000000000000]
    float DefaultViewZoom;  // 0x01B8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2103];

        return pClassPointer;
    };

    void SetEnabled();
    void Reset();
    void FindSeqObjectsByName();
    void FindSeqObjectsByClass();
};

UClass* USequence::pClassPointer = NULL;

// Class Engine.PrefabSequence
// 0x0008 (0x01C4 - 0x01BC)
class UPrefabSequence : public USequence {
   public:
    class APrefabInstance* OwnerPrefab;  // 0x01BC (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2105];

        return pClassPointer;
    };

    void GetOwnerPrefab();
    void SetOwnerPrefab();
};

UClass* UPrefabSequence::pClassPointer = NULL;

// Class Engine.PrefabSequenceContainer
// 0x0000 (0x01BC - 0x01BC)
class UPrefabSequenceContainer : public USequence {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2107];

        return pClassPointer;
    };
};

UClass* UPrefabSequenceContainer::pClassPointer = NULL;

// Class Engine.SequenceAction
// 0x001C (0x0150 - 0x0134)
class USequenceAction : public USequenceOp {
   public:
    struct FName HandlerName;  // 0x0134 (0x0008) [0x0000000000000000]
    DWORD
        bCallHandler : 1;  // 0x013C (0x0004) [0x0000000000000000] [0x00000001]
    TArray<class UObject*> Targets;  // 0x0140 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2109];

        return pClassPointer;
    };
};

UClass* USequenceAction::pClassPointer = NULL;

// Class Engine.SeqAct_ActivateRemoteEvent
// 0x0014 (0x0164 - 0x0150)
class USeqAct_ActivateRemoteEvent : public USequenceAction {
   public:
    class AActor* Instigator;  // 0x0150 (0x0008) [0x0000000000000000]
    struct FName EventName;    // 0x0158 (0x0008) [0x0000000000000000]
    DWORD bStatusIsOk : 1;  // 0x0160 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2111];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_ActivateRemoteEvent::pClassPointer = NULL;

// Class Engine.SeqAct_AndGate
// 0x0024 (0x0174 - 0x0150)
class USeqAct_AndGate : public USequenceAction {
   public:
    DWORD bOpen : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000001]
    TArray<DWORD>
        LinkedOutputFiredStatus;  // 0x0154 (0x0010) [0x0000000000000000]
    TArray<struct FPointer>
        LinkedOutputs;  // 0x0164 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2113];

        return pClassPointer;
    };
};

UClass* USeqAct_AndGate::pClassPointer = NULL;

// Class Engine.SeqAct_ApplySoundNode
// 0x0010 (0x0160 - 0x0150)
class USeqAct_ApplySoundNode : public USequenceAction {
   public:
    class USoundCue* PlaySound;   // 0x0150 (0x0008) [0x0000000000000000]
    class USoundNode* ApplyNode;  // 0x0158 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2115];

        return pClassPointer;
    };
};

UClass* USeqAct_ApplySoundNode::pClassPointer = NULL;

// Class Engine.SeqAct_AttachToEvent
// 0x0004 (0x0154 - 0x0150)
class USeqAct_AttachToEvent : public USequenceAction {
   public:
    DWORD bPreferController : 1;  // 0x0150 (0x0004) [0x0000000000000000]
                                  // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2117];

        return pClassPointer;
    };
};

UClass* USeqAct_AttachToEvent::pClassPointer = NULL;

// Class Engine.SeqAct_CameraFade
// 0x002C (0x017C - 0x0150)
class USeqAct_CameraFade : public USequenceAction {
   public:
    struct FColor FadeColor;     // 0x0150 (0x0004) [0x0000000000000000]
    struct FVector2D FadeAlpha;  // 0x0154 (0x0008) [0x0000000000000000]
    float FadeOpacity;           // 0x015C (0x0004) [0x0000000000000000]
    float FadeTime;              // 0x0160 (0x0004) [0x0000000000000000]
    DWORD
        bPersistFade : 1;  // 0x0164 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bFadeAudio : 1;  // 0x0164 (0x0004) [0x0000000000000000] [0x00000002]
    float FadeTimeRemaining;  // 0x0168 (0x0004) [0x0000000000000000]
    TArray<class APlayerController*>
        CachedPCs;  // 0x016C (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2119];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_CameraFade::pClassPointer = NULL;

// Class Engine.SeqAct_CameraLookAt
// 0x0038 (0x0188 - 0x0150)
class USeqAct_CameraLookAt : public USequenceAction {
   public:
    DWORD
        bAffectCamera : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD
        bAlwaysFocus : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD
        bAdjustCamera : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD
        bTurnInPlace : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD
        bIgnoreTrace : 1;   // 0x0150 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bAffectHead : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bRotatePlayerWithCamera : 1;  // 0x0150 (0x0004) [0x0000000000000000]
                                        // [0x00000040]
    DWORD bToggleGodMode : 1;           // 0x0150 (0x0004) [0x0000000000000000]
                                        // [0x00000080]
    DWORD bLeaveCameraRotation : 1;     // 0x0150 (0x0004) [0x0000000000000000]
                                        // [0x00000100]
    DWORD
        bDisableInput : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000200]
    DWORD bUsedTimer : 1;   // 0x0150 (0x0004) [0x0000000000000000] [0x00000400]
    DWORD bCheckLineOfSight : 1;        // 0x0150 (0x0004) [0x0000000000000000]
                                        // [0x00000800]
    struct FVector2D InterpSpeedRange;  // 0x0154 (0x0008) [0x0000000000000000]
    struct FVector2D InFocusFOV;        // 0x015C (0x0008) [0x0000000000000000]
    struct FName FocusBoneName;         // 0x0164 (0x0008) [0x0000000000000000]
    struct FString TextDisplay;         // 0x016C (0x0010) [0x0000000000000000]
    float TotalTime;                    // 0x017C (0x0004) [0x0000000000000000]
    float CameraFOV;                    // 0x0180 (0x0004) [0x0000000000000000]
    float RemainingTime;                // 0x0184 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2121];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_CameraLookAt::pClassPointer = NULL;

// Class Engine.SeqAct_CameraShake
// 0x0028 (0x0178 - 0x0150)
class USeqAct_CameraShake : public USequenceAction {
   public:
    class UCameraShake* Shake;         // 0x0150 (0x0008) [0x0000000000000000]
    float ShakeScale;                  // 0x0158 (0x0004) [0x0000000000000000]
    DWORD bDoControllerVibration : 1;  // 0x015C (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD
        bRadialShake : 1;  // 0x015C (0x0004) [0x0000000000000000] [0x00000002]
    DWORD
        bOrientTowardRadialEpicenter : 1;  // 0x015C (0x0004)
                                           // [0x0000000000000000] [0x00000004]
    float RadialShake_InnerRadius;  // 0x0160 (0x0004) [0x0000000000000000]
    float RadialShake_OuterRadius;  // 0x0164 (0x0004) [0x0000000000000000]
    float RadialShake_Falloff;      // 0x0168 (0x0004) [0x0000000000000000]
    unsigned char PlaySpace;        // 0x016C (0x0001) [0x0000000000000000]
    class AActor* LocationActor;    // 0x0170 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2123];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_CameraShake::pClassPointer = NULL;

// Class Engine.SeqAct_ChangeCollision
// 0x0005 (0x0155 - 0x0150)
class USeqAct_ChangeCollision : public USequenceAction {
   public:
    DWORD bCollideActors : 1;  // 0x0150 (0x0004) [0x0000000000000000]
                               // [0x00000001]
    DWORD
        bBlockActors : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bIgnoreEncroachers : 1;  // 0x0150 (0x0004) [0x0000000000000000]
                                   // [0x00000004]
    unsigned char CollisionType;   // 0x0154 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2125];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_ChangeCollision::pClassPointer = NULL;

// Class Engine.SeqAct_CommitMapChange
// 0x0000 (0x0150 - 0x0150)
class USeqAct_CommitMapChange : public USequenceAction {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2127];

        return pClassPointer;
    };
};

UClass* USeqAct_CommitMapChange::pClassPointer = NULL;

// Class Engine.SeqAct_ConvertToString
// 0x0018 (0x0168 - 0x0150)
class USeqAct_ConvertToString : public USequenceAction {
   public:
    DWORD bIncludeVarComment : 1;  // 0x0150 (0x0004) [0x0000000000000000]
                                   // [0x00000001]
    struct FString VarSeparator;   // 0x0154 (0x0010) [0x0000000000000000]
    int NumberOfInputs;            // 0x0164 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2129];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_ConvertToString::pClassPointer = NULL;

// Class Engine.SeqAct_DrawText
// 0x0048 (0x0198 - 0x0150)
class USeqAct_DrawText : public USequenceAction {
   public:
    float DisplayTimeSeconds;    // 0x0150 (0x0004) [0x0000000000000000]
    DWORD bDisplayOnObject : 1;  // 0x0154 (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    struct FKismetDrawTextInfo
        DrawTextInfo;  // 0x0158 (0x0040) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2131];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_DrawText::pClassPointer = NULL;

// Class Engine.SeqAct_FinishSequence
// 0x0010 (0x0160 - 0x0150)
class USeqAct_FinishSequence : public USequenceAction {
   public:
    struct FString OutputLabel;  // 0x0150 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2133];

        return pClassPointer;
    };
};

UClass* USeqAct_FinishSequence::pClassPointer = NULL;

// Class Engine.SeqAct_Gate
// 0x000C (0x015C - 0x0150)
class USeqAct_Gate : public USequenceAction {
   public:
    DWORD bOpen : 1;        // 0x0150 (0x0004) [0x0000000000000000] [0x00000001]
    int AutoCloseCount;     // 0x0154 (0x0004) [0x0000000000000000]
    int CurrentCloseCount;  // 0x0158 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2135];

        return pClassPointer;
    };
};

UClass* USeqAct_Gate::pClassPointer = NULL;

// Class Engine.SeqAct_GetDistance
// 0x0004 (0x0154 - 0x0150)
class USeqAct_GetDistance : public USequenceAction {
   public:
    float Distance;  // 0x0150 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2137];

        return pClassPointer;
    };
};

UClass* USeqAct_GetDistance::pClassPointer = NULL;

// Class Engine.SeqAct_GetLocationAndRotation
// 0x002C (0x017C - 0x0150)
class USeqAct_GetLocationAndRotation : public USequenceAction {
   public:
    struct FVector Location;        // 0x0150 (0x000C) [0x0000000000000000]
    struct FVector RotationVector;  // 0x015C (0x000C) [0x0000000000000000]
    struct FVector Rotation;        // 0x0168 (0x000C) [0x0000000000000000]
    struct FName SocketOrBoneName;  // 0x0174 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2139];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_GetLocationAndRotation::pClassPointer = NULL;

// Class Engine.SeqAct_GetProperty
// 0x0008 (0x0158 - 0x0150)
class USeqAct_GetProperty : public USequenceAction {
   public:
    struct FName PropertyName;  // 0x0150 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2141];

        return pClassPointer;
    };
};

UClass* USeqAct_GetProperty::pClassPointer = NULL;

// Class Engine.SeqAct_GetVectorComponents
// 0x0018 (0x0168 - 0x0150)
class USeqAct_GetVectorComponents : public USequenceAction {
   public:
    struct FVector InVector;  // 0x0150 (0x000C) [0x0000000000000000]
    float X;                  // 0x015C (0x0004) [0x0000000000000000]
    float Y;                  // 0x0160 (0x0004) [0x0000000000000000]
    float Z;                  // 0x0164 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2143];

        return pClassPointer;
    };
};

UClass* USeqAct_GetVectorComponents::pClassPointer = NULL;

// Class Engine.SeqAct_GetVelocity
// 0x0010 (0x0160 - 0x0150)
class USeqAct_GetVelocity : public USequenceAction {
   public:
    float VelocityMag;            // 0x0150 (0x0004) [0x0000000000000000]
    struct FVector VelocityVect;  // 0x0154 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2145];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_GetVelocity::pClassPointer = NULL;

// Class Engine.SeqAct_HeadTrackingControl
// 0x009C (0x01EC - 0x0150)
class USeqAct_HeadTrackingControl : public USequenceAction {
   public:
    TArray<struct FName>
        TrackControllerName;        // 0x0150 (0x0010) [0x0000000000000000]
    float LookAtActorRadius;        // 0x0160 (0x0004) [0x0000000000000000]
    DWORD bDisableBeyondLimit : 1;  // 0x0164 (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    DWORD
        bLookAtPawns : 1;   // 0x0164 (0x0004) [0x0000000000000000] [0x00000002]
    float MaxLookAtTime;    // 0x0168 (0x0004) [0x0000000000000000]
    float MinLookAtTime;    // 0x016C (0x0004) [0x0000000000000000]
    float MaxInterestTime;  // 0x0170 (0x0004) [0x0000000000000000]
    TArray<class UClass*>
        ActorClassesToLookAt;  // 0x0174 (0x0010) [0x0000000000000000]
    TArray<struct FName>
        TargetBoneNames;  // 0x0184 (0x0010) [0x0000000000000000]
    TArray<class UObject*>
        LookAtTargets;  // 0x0194 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00
        [0x48];  // 0x01A4 (0x0048) UNKNOWN PROPERTY: MapProperty
                 // Engine.SeqAct_HeadTrackingControl.ActorToComponentMap

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2147];

        return pClassPointer;
    };

    void eventActivated();
    void eventGetObjClassVersion();
};

UClass* USeqAct_HeadTrackingControl::pClassPointer = NULL;

// Class Engine.SeqAct_IsInObjectList
// 0x0004 (0x0154 - 0x0150)
class USeqAct_IsInObjectList : public USequenceAction {
   public:
    DWORD bCheckForAllObjects : 1;  // 0x0150 (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    DWORD
        bObjectFound : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2149];

        return pClassPointer;
    };
};

UClass* USeqAct_IsInObjectList::pClassPointer = NULL;

// Class Engine.SeqAct_Latent
// 0x0018 (0x0168 - 0x0150)
class USeqAct_Latent : public USequenceAction {
   public:
    TArray<class AActor*> LatentActors;  // 0x0150 (0x0010) [0x0000000000000000]
    DWORD bAborted : 1;  // 0x0160 (0x0004) [0x0000000000000000] [0x00000001]
    float LatentActivationTime;  // 0x0164 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2151];

        return pClassPointer;
    };

    void eventUpdate();
    void AbortFor();
};

UClass* USeqAct_Latent::pClassPointer = NULL;

// Class Engine.SeqAct_ActorFactory
// 0x0058 (0x01C0 - 0x0168)
class USeqAct_ActorFactory : public USeqAct_Latent {
   public:
    DWORD bEnabled : 1;     // 0x0168 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bIsSpawning : 1;  // 0x0168 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bCheckSpawnCollision : 1;     // 0x0168 (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    class UActorFactory* Factory;       // 0x016C (0x0008) [0x0000000000000000]
    unsigned char PointSelection;       // 0x0174 (0x0001) [0x0000000000000000]
    TArray<class AActor*> SpawnPoints;  // 0x0178 (0x0010) [0x0000000000000000]
    TArray<struct FVector>
        SpawnLocations;  // 0x0188 (0x0010) [0x0000000000000000]
    TArray<struct FVector>
        SpawnOrientations;  // 0x0198 (0x0010) [0x0000000000000000]
    int SpawnCount;         // 0x01A8 (0x0004) [0x0000000000000000]
    float SpawnDelay;       // 0x01AC (0x0004) [0x0000000000000000]
    int LastSpawnIdx;       // 0x01B0 (0x0004) [0x0000000000000000]
    int CurrentSpawnIdx;    // 0x01B4 (0x0004) [0x0000000000000000]
    int SpawnedCount;       // 0x01B8 (0x0004) [0x0000000000000000]
    float RemainingDelay;   // 0x01BC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2153];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_ActorFactory::pClassPointer = NULL;

// Class Engine.SeqAct_ActorFactoryEx
// 0x0000 (0x01C0 - 0x01C0)
class USeqAct_ActorFactoryEx : public USeqAct_ActorFactory {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2155];

        return pClassPointer;
    };
};

UClass* USeqAct_ActorFactoryEx::pClassPointer = NULL;

// Class Engine.SeqAct_ProjectileFactory
// 0x0018 (0x01D8 - 0x01C0)
class USeqAct_ProjectileFactory : public USeqAct_ActorFactory {
   public:
    class UParticleSystem* PSTemplate;  // 0x01C0 (0x0008) [0x0000000000000000]
    struct FName SocketName;            // 0x01C8 (0x0008) [0x0000000000000000]
    struct FName BoneName;              // 0x01D0 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2157];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_ProjectileFactory::pClassPointer = NULL;

// Class Engine.SeqAct_AIMoveToActor
// 0x0024 (0x018C - 0x0168)
class USeqAct_AIMoveToActor : public USeqAct_Latent {
   public:
    DWORD bInterruptable : 1;  // 0x0168 (0x0004) [0x0000000000000000]
                               // [0x00000001]
    DWORD
        bPickClosest : 1;  // 0x0168 (0x0004) [0x0000000000000000] [0x00000002]
    TArray<class AActor*> Destination;  // 0x016C (0x0010) [0x0000000000000000]
    float MovementSpeedModifier;        // 0x017C (0x0004) [0x0000000000000000]
    class AActor* LookAt;               // 0x0180 (0x0008) [0x0000000000000000]
    int LastDestinationChoice;          // 0x0188 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2159];

        return pClassPointer;
    };

    void PickDestination();
    void eventGetObjClassVersion();
};

UClass* USeqAct_AIMoveToActor::pClassPointer = NULL;

// Class Engine.SeqAct_Delay
// 0x0014 (0x017C - 0x0168)
class USeqAct_Delay : public USeqAct_Latent {
   public:
    DWORD
        bDelayActive : 1;  // 0x0168 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bStartWillRestart : 1;  // 0x0168 (0x0004) [0x0000000000000000]
                                  // [0x00000002]
    float DefaultDuration;        // 0x016C (0x0004) [0x0000000000000000]
    float Duration;               // 0x0170 (0x0004) [0x0000000000000000]
    float LastUpdateTime;         // 0x0174 (0x0004) [0x0000000000000000]
    float RemainingTime;          // 0x0178 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2161];

        return pClassPointer;
    };

    void ResetDelayActive();
    void Reset();
};

UClass* USeqAct_Delay::pClassPointer = NULL;

// Class Engine.SeqAct_DelaySwitch
// 0x0010 (0x0178 - 0x0168)
class USeqAct_DelaySwitch : public USeqAct_Latent {
   public:
    int LinkCount;       // 0x0168 (0x0004) [0x0000000000000000]
    int CurrentIdx;      // 0x016C (0x0004) [0x0000000000000000]
    float SwitchDelay;   // 0x0170 (0x0004) [0x0000000000000000]
    float NextLinkTime;  // 0x0174 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2163];

        return pClassPointer;
    };
};

UClass* USeqAct_DelaySwitch::pClassPointer = NULL;

// Class Engine.SeqAct_ForceGarbageCollection
// 0x0000 (0x0168 - 0x0168)
class USeqAct_ForceGarbageCollection : public USeqAct_Latent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2165];

        return pClassPointer;
    };
};

UClass* USeqAct_ForceGarbageCollection::pClassPointer = NULL;

// Class Engine.SeqAct_Interp
// 0x00FC (0x0264 - 0x0168)
class USeqAct_Interp : public USeqAct_Latent {
   public:
    unsigned char
        UnknownData00[0x48];  // 0x0168 (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.SeqAct_Interp.SavedActorTransforms
    unsigned char
        UnknownData01[0x48];   // 0x01B0 (0x0048) UNKNOWN PROPERTY: MapProperty
                               // Engine.SeqAct_Interp.SavedActorVisibilities
    float PlayRate;            // 0x01F8 (0x0004) [0x0000000000000000]
    float Position;            // 0x01FC (0x0004) [0x0000000000000000]
    float ForceStartPosition;  // 0x0200 (0x0004) [0x0000000000000000]
    DWORD bIsPlaying : 1;  // 0x0204 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bPaused : 1;     // 0x0204 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bIsBeingEdited : 1;  // 0x0204 (0x0004) [0x0000000000000000]
                               // [0x00000004]
    DWORD bLooping : 1;  // 0x0204 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD
        bRewindOnPlay : 1;  // 0x0204 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bNoResetOnRewind : 1;         // 0x0204 (0x0004) [0x0000000000000000]
                                        // [0x00000020]
    DWORD bRewindIfAlreadyPlaying : 1;  // 0x0204 (0x0004) [0x0000000000000000]
                                        // [0x00000040]
    DWORD bReversePlayback : 1;         // 0x0204 (0x0004) [0x0000000000000000]
                                        // [0x00000080]
    DWORD bInterpForPathBuilding : 1;   // 0x0204 (0x0004) [0x0000000000000000]
                                        // [0x00000100]
    DWORD bForceStartPos : 1;           // 0x0204 (0x0004) [0x0000000000000000]
                                        // [0x00000200]
    DWORD bDisableRadioFilter : 1;      // 0x0204 (0x0004) [0x0000000000000000]
                                        // [0x00000400]
    DWORD bClientSideOnly : 1;          // 0x0204 (0x0004) [0x0000000000000000]
                                        // [0x00000800]
    DWORD bSkipUpdateIfNotVisible : 1;  // 0x0204 (0x0004) [0x0000000000000000]
                                        // [0x00001000]
    DWORD
        bIsSkippable : 1;  // 0x0204 (0x0004) [0x0000000000000000] [0x00002000]
    DWORD bShouldShowGore : 1;  // 0x0204 (0x0004) [0x0000000000000000]
                                // [0x00004000]
    TArray<class ACoverLink*>
        LinkedCover;                // 0x0208 (0x0010) [0x0000000000000000]
    class UInterpData* InterpData;  // 0x0218 (0x0008) [0x0000000000000000]
    TArray<class UInterpGroupInst*>
        GroupInst;                       // 0x0220 (0x0010) [0x0000000000000000]
    class UClass* ReplicatedActorClass;  // 0x0230 (0x0008) [0x0000000000000000]
    class AMatineeActor*
        ReplicatedActor;          // 0x0238 (0x0008) [0x0000000000000000]
    int PreferredSplitScreenNum;  // 0x0240 (0x0004) [0x0000000000000000]
    TArray<struct FCameraCutInfo>
        CameraCuts;         // 0x0244 (0x0010) [0x0000000000000000]
    float TerminationTime;  // 0x0254 (0x0004) [0x0000000000000000]
    struct FRenderingPerformanceOverrides
        RenderingOverrides;            // 0x0258 (0x0004) [0x0000000000000000]
    unsigned char ConstantCameraAnim;  // 0x025C (0x0001) [0x0000000000000000]
    float ConstantCameraAnimRate;      // 0x0260 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2167];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
    void Reset();
    void AddPlayerToDirectorTracks();
    void Stop();
    void SetPosition();
};

UClass* USeqAct_Interp::pClassPointer = NULL;

// Class Engine.SeqAct_LevelStreamingBase
// 0x0004 (0x016C - 0x0168)
class USeqAct_LevelStreamingBase : public USeqAct_Latent {
   public:
    DWORD bMakeVisibleAfterLoad : 1;  // 0x0168 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bShouldBlockOnLoad : 1;     // 0x0168 (0x0004) [0x0000000000000000]
                                      // [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2169];

        return pClassPointer;
    };
};

UClass* USeqAct_LevelStreamingBase::pClassPointer = NULL;

// Class Engine.SeqAct_LevelStreaming
// 0x0014 (0x0180 - 0x016C)
class USeqAct_LevelStreaming : public USeqAct_LevelStreamingBase {
   public:
    class ULevelStreaming* Level;  // 0x016C (0x0008) [0x0000000000000000]
    struct FName LevelName;        // 0x0174 (0x0008) [0x0000000000000000]
    DWORD bStatusIsOk : 1;  // 0x017C (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2171];

        return pClassPointer;
    };
};

UClass* USeqAct_LevelStreaming::pClassPointer = NULL;

// Class Engine.SeqAct_MultiLevelStreaming
// 0x0014 (0x0180 - 0x016C)
class USeqAct_MultiLevelStreaming : public USeqAct_LevelStreamingBase {
   public:
    TArray<struct FLevelStreamingNameCombo>
        Levels;                       // 0x016C (0x0010) [0x0000000000000000]
    DWORD bUnloadAllOtherLevels : 1;  // 0x017C (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bStatusIsOk : 1;  // 0x017C (0x0004) [0x0000000000000000] [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2173];

        return pClassPointer;
    };
};

UClass* USeqAct_MultiLevelStreaming::pClassPointer = NULL;

// Class Engine.SeqAct_LevelVisibility
// 0x0014 (0x017C - 0x0168)
class USeqAct_LevelVisibility : public USeqAct_Latent {
   public:
    class ULevelStreaming* Level;  // 0x0168 (0x0008) [0x0000000000000000]
    struct FName LevelName;        // 0x0170 (0x0008) [0x0000000000000000]
    DWORD bStatusIsOk : 1;  // 0x0178 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2175];

        return pClassPointer;
    };
};

UClass* USeqAct_LevelVisibility::pClassPointer = NULL;

// Class Engine.SeqAct_PlaySound
// 0x0028 (0x0190 - 0x0168)
class USeqAct_PlaySound : public USeqAct_Latent {
   public:
    class USoundCue* PlaySound;  // 0x0168 (0x0008) [0x0000000000000000]
    float ExtraDelay;            // 0x0170 (0x0004) [0x0000000000000000]
    DWORD
        bDelayReached : 1;  // 0x0174 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bSuppressSubtitles : 1;  // 0x0174 (0x0004) [0x0000000000000000]
                                   // [0x00000002]
    DWORD bStopped : 1;   // 0x0174 (0x0004) [0x0000000000000000] [0x00000004]
    float SoundDuration;  // 0x0178 (0x0004) [0x0000000000000000]
    float FadeInTime;     // 0x017C (0x0004) [0x0000000000000000]
    float FadeOutTime;    // 0x0180 (0x0004) [0x0000000000000000]
    float VolumeMultiplier;  // 0x0184 (0x0004) [0x0000000000000000]
    float PitchMultiplier;   // 0x0188 (0x0004) [0x0000000000000000]
    float BeforeEndTime;     // 0x018C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2177];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_PlaySound::pClassPointer = NULL;

// Class Engine.SeqAct_PrepareMapChange
// 0x001C (0x0184 - 0x0168)
class USeqAct_PrepareMapChange : public USeqAct_Latent {
   public:
    struct FName MainLevelName;  // 0x0168 (0x0008) [0x0000000000000000]
    TArray<struct FName>
        InitiallyLoadedSecondaryLevelNames;  // 0x0170 (0x0010)
                                             // [0x0000000000000000]
    DWORD bIsHighPriority : 1;  // 0x0180 (0x0004) [0x0000000000000000]
                                // [0x00000001]
    DWORD bStatusIsOk : 1;  // 0x0180 (0x0004) [0x0000000000000000] [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2179];

        return pClassPointer;
    };
};

UClass* USeqAct_PrepareMapChange::pClassPointer = NULL;

// Class Engine.SeqAct_SetDOFParams
// 0x0058 (0x01C0 - 0x0168)
class USeqAct_SetDOFParams : public USeqAct_Latent {
   public:
    float FalloffExponent;            // 0x0168 (0x0004) [0x0000000000000000]
    float BlurKernelSize;             // 0x016C (0x0004) [0x0000000000000000]
    float MaxNearBlurAmount;          // 0x0170 (0x0004) [0x0000000000000000]
    float MinBlurAmount;              // 0x0174 (0x0004) [0x0000000000000000]
    float MaxFarBlurAmount;           // 0x0178 (0x0004) [0x0000000000000000]
    float FocusInnerRadius;           // 0x017C (0x0004) [0x0000000000000000]
    float FocusDistance;              // 0x0180 (0x0004) [0x0000000000000000]
    struct FVector FocusPosition;     // 0x0184 (0x000C) [0x0000000000000000]
    float InterpolateSeconds;         // 0x0190 (0x0004) [0x0000000000000000]
    float InterpolateElapsed;         // 0x0194 (0x0004) [0x0000000000000000]
    float OldFalloffExponent;         // 0x0198 (0x0004) [0x0000000000000000]
    float OldBlurKernelSize;          // 0x019C (0x0004) [0x0000000000000000]
    float OldMaxNearBlurAmount;       // 0x01A0 (0x0004) [0x0000000000000000]
    float OldMinBlurAmount;           // 0x01A4 (0x0004) [0x0000000000000000]
    float OldMaxFarBlurAmount;        // 0x01A8 (0x0004) [0x0000000000000000]
    float OldFocusInnerRadius;        // 0x01AC (0x0004) [0x0000000000000000]
    float OldFocusDistance;           // 0x01B0 (0x0004) [0x0000000000000000]
    struct FVector OldFocusPosition;  // 0x01B4 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2181];

        return pClassPointer;
    };
};

UClass* USeqAct_SetDOFParams::pClassPointer = NULL;

// Class Engine.SeqAct_SetMotionBlurParams
// 0x0010 (0x0178 - 0x0168)
class USeqAct_SetMotionBlurParams : public USeqAct_Latent {
   public:
    float MotionBlurAmount;     // 0x0168 (0x0004) [0x0000000000000000]
    float InterpolateSeconds;   // 0x016C (0x0004) [0x0000000000000000]
    float InterpolateElapsed;   // 0x0170 (0x0004) [0x0000000000000000]
    float OldMotionBlurAmount;  // 0x0174 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2183];

        return pClassPointer;
    };
};

UClass* USeqAct_SetMotionBlurParams::pClassPointer = NULL;

// Class Engine.SeqAct_StreamInTextures
// 0x0040 (0x01A8 - 0x0168)
class USeqAct_StreamInTextures : public USeqAct_Latent {
   public:
    DWORD bLocationBased : 1;           // 0x0168 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bStreamingActive : 1;         // 0x0168 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bHasTriggeredAllLoaded : 1;   // 0x0168 (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    float Seconds;                      // 0x016C (0x0004) [0x0000000000000000]
    float StreamingDistanceMultiplier;  // 0x0170 (0x0004) [0x0000000000000000]
    int NumWantingResourcesID;          // 0x0174 (0x0004) [0x0000000000000000]
    float StopTimestamp;                // 0x0178 (0x0004) [0x0000000000000000]
    TArray<class UObject*>
        LocationActors;  // 0x017C (0x0010) [0x0000000000000000]
    TArray<class UMaterialInterface*>
        ForceMaterials;  // 0x018C (0x0010) [0x0000000000000000]
    struct FTextureGroupContainer
        CinematicTextureGroups;          // 0x019C (0x0008) [0x0000000000000000]
    int SelectedCinematicTextureGroups;  // 0x01A4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2185];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_StreamInTextures::pClassPointer = NULL;

// Class Engine.SeqAct_WaitForLevelsVisible
// 0x0014 (0x017C - 0x0168)
class USeqAct_WaitForLevelsVisible : public USeqAct_Latent {
   public:
    TArray<struct FName> LevelNames;  // 0x0168 (0x0010) [0x0000000000000000]
    DWORD bShouldBlockOnLoad : 1;     // 0x0178 (0x0004) [0x0000000000000000]
                                      // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2187];

        return pClassPointer;
    };

    void eventActivated();
    void CheckLevelsVisible();
};

UClass* USeqAct_WaitForLevelsVisible::pClassPointer = NULL;

// Class Engine.SeqAct_Log
// 0x0024 (0x0174 - 0x0150)
class USeqAct_Log : public USequenceAction {
   public:
    DWORD bOutputToScreen : 1;     // 0x0150 (0x0004) [0x0000000000000000]
                                   // [0x00000001]
    DWORD bIncludeObjComment : 1;  // 0x0150 (0x0004) [0x0000000000000000]
                                   // [0x00000002]
    float TargetDuration;          // 0x0154 (0x0004) [0x0000000000000000]
    struct FVector TargetOffset;   // 0x0158 (0x000C) [0x0000000000000000]
    struct FString LogMessage;     // 0x0164 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2189];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_Log::pClassPointer = NULL;

// Class Engine.SeqAct_FeatureTest
// 0x0028 (0x019C - 0x0174)
class USeqAct_FeatureTest : public USeqAct_Log {
   public:
    struct FString FreezeAtParameters;  // 0x0174 (0x0010) [0x0000000000000000]
    float ScreenShotDelay;              // 0x0184 (0x0004) [0x0000000000000000]
    struct FString ScreenShotName;      // 0x0188 (0x0010) [0x0000000000000000]
    float RemainingScreenShotDelay;     // 0x0198 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2191];

        return pClassPointer;
    };
};

UClass* USeqAct_FeatureTest::pClassPointer = NULL;

// Class Engine.SeqAct_ModifyCover
// 0x0018 (0x0168 - 0x0150)
class USeqAct_ModifyCover : public USequenceAction {
   public:
    TArray<int> Slots;                   // 0x0150 (0x0010) [0x0000000000000000]
    unsigned char ManualCoverType;       // 0x0160 (0x0001) [0x0000000000000000]
    DWORD bManualAdjustPlayersOnly : 1;  // 0x0164 (0x0004) [0x0000000000000000]
                                         // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2193];

        return pClassPointer;
    };
};

UClass* USeqAct_ModifyCover::pClassPointer = NULL;

// Class Engine.SeqAct_ModifyHealth
// 0x0020 (0x0170 - 0x0150)
class USeqAct_ModifyHealth : public USequenceAction {
   public:
    class UClass* DamageType;  // 0x0150 (0x0008) [0x0000000000000000]
    float Momentum;            // 0x0158 (0x0004) [0x0000000000000000]
    float Amount;              // 0x015C (0x0004) [0x0000000000000000]
    float Radius;              // 0x0160 (0x0004) [0x0000000000000000]
    DWORD bHeal : 1;     // 0x0164 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bRadial : 1;   // 0x0164 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bFalloff : 1;  // 0x0164 (0x0004) [0x0000000000000000] [0x00000004]
    class AActor* Instigator;  // 0x0168 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2195];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_ModifyHealth::pClassPointer = NULL;

// Class Engine.SeqAct_ParticleEventGenerator
// 0x0050 (0x01A0 - 0x0150)
class USeqAct_ParticleEventGenerator : public USequenceAction {
   public:
    DWORD bEnabled : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bUseEmitterLocation : 1;      // 0x0150 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    class AActor* Instigator;           // 0x0154 (0x0008) [0x0000000000000000]
    TArray<struct FString> EventNames;  // 0x015C (0x0010) [0x0000000000000000]
    float EventTime;                    // 0x016C (0x0004) [0x0000000000000000]
    struct FVector EventLocation;       // 0x0170 (0x000C) [0x0000000000000000]
    struct FVector EventDirection;      // 0x017C (0x000C) [0x0000000000000000]
    struct FVector EventVelocity;       // 0x0188 (0x000C) [0x0000000000000000]
    struct FVector EventNormal;         // 0x0194 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2197];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_ParticleEventGenerator::pClassPointer = NULL;

// Class Engine.SeqAct_PhysXSwitch
// 0x0000 (0x0150 - 0x0150)
class USeqAct_PhysXSwitch : public USequenceAction {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2199];

        return pClassPointer;
    };
};

UClass* USeqAct_PhysXSwitch::pClassPointer = NULL;

// Class Engine.SeqAct_PlayCameraAnim
// 0x0028 (0x0178 - 0x0150)
class USeqAct_PlayCameraAnim : public USequenceAction {
   public:
    class UCameraAnim* CameraAnim;  // 0x0150 (0x0008) [0x0000000000000000]
    DWORD bLoop : 1;  // 0x0158 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bRandomStartTime : 1;  // 0x0158 (0x0004) [0x0000000000000000]
                                 // [0x00000002]
    float BlendInTime;           // 0x015C (0x0004) [0x0000000000000000]
    float BlendOutTime;          // 0x0160 (0x0004) [0x0000000000000000]
    float Rate;                  // 0x0164 (0x0004) [0x0000000000000000]
    float IntensityScale;        // 0x0168 (0x0004) [0x0000000000000000]
    unsigned char PlaySpace;     // 0x016C (0x0001) [0x0000000000000000]
    class AActor*
        UserDefinedSpaceActor;  // 0x0170 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2201];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_PlayCameraAnim::pClassPointer = NULL;

// Class Engine.SeqAct_PlayFaceFXAnim
// 0x0038 (0x0188 - 0x0150)
class USeqAct_PlayFaceFXAnim : public USequenceAction {
   public:
    class UFaceFXAnimSet*
        FaceFXAnimSetRef;             // 0x0150 (0x0008) [0x0000000000000000]
    struct FString FaceFXGroupName;   // 0x0158 (0x0010) [0x0000000000000000]
    struct FString FaceFXAnimName;    // 0x0168 (0x0010) [0x0000000000000000]
    class USoundCue* SoundCueToPlay;  // 0x0178 (0x0008) [0x0000000000000000]
    class UAkEvent* AkEventToPlay;    // 0x0180 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2203];

        return pClassPointer;
    };
};

UClass* USeqAct_PlayFaceFXAnim::pClassPointer = NULL;

// Class Engine.SeqAct_PlayMusicTrack
// 0x002C (0x017C - 0x0150)
class USeqAct_PlayMusicTrack : public USequenceAction {
   public:
    struct FMusicTrackStruct
        MusicTrack;  // 0x0150 (0x002C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2205];

        return pClassPointer;
    };
};

UClass* USeqAct_PlayMusicTrack::pClassPointer = NULL;

// Class Engine.SeqAct_Possess
// 0x000C (0x015C - 0x0150)
class USeqAct_Possess : public USequenceAction {
   public:
    class APawn* PawnToPossess;  // 0x0150 (0x0008) [0x0000000000000000]
    DWORD
        bKillOldPawn : 1;  // 0x0158 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bTryToLeaveVehicle : 1;  // 0x0158 (0x0004) [0x0000000000000000]
                                   // [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2207];

        return pClassPointer;
    };
};

UClass* USeqAct_Possess::pClassPointer = NULL;

// Class Engine.SeqAct_RangeSwitch
// 0x0010 (0x0160 - 0x0150)
class USeqAct_RangeSwitch : public USequenceAction {
   public:
    TArray<struct FSwitchRange> Ranges;  // 0x0150 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2209];

        return pClassPointer;
    };
};

UClass* USeqAct_RangeSwitch::pClassPointer = NULL;

// Class Engine.SeqAct_SetActiveAnimChild
// 0x0010 (0x0160 - 0x0150)
class USeqAct_SetActiveAnimChild : public USequenceAction {
   public:
    struct FName NodeName;  // 0x0150 (0x0008) [0x0000000000000000]
    int ChildIndex;         // 0x0158 (0x0004) [0x0000000000000000]
    float BlendTime;        // 0x015C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2211];

        return pClassPointer;
    };
};

UClass* USeqAct_SetActiveAnimChild::pClassPointer = NULL;

// Class Engine.SeqAct_SetApexClothingParam
// 0x0004 (0x0154 - 0x0150)
class USeqAct_SetApexClothingParam : public USequenceAction {
   public:
    DWORD
        bEnableApexClothingSimulation : 1;  // 0x0150 (0x0004)
                                            // [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2213];

        return pClassPointer;
    };
};

UClass* USeqAct_SetApexClothingParam::pClassPointer = NULL;

// Class Engine.SeqAct_SetBlockRigidBody
// 0x0000 (0x0150 - 0x0150)
class USeqAct_SetBlockRigidBody : public USequenceAction {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2215];

        return pClassPointer;
    };
};

UClass* USeqAct_SetBlockRigidBody::pClassPointer = NULL;

// Class Engine.SeqAct_SetCameraTarget
// 0x0018 (0x0168 - 0x0150)
class USeqAct_SetCameraTarget : public USequenceAction {
   public:
    class AActor* CameraTarget;  // 0x0150 (0x0008) [0x0000000000000000]
    struct FViewTargetTransitionParams
        TransitionParams;  // 0x0158 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2217];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_SetCameraTarget::pClassPointer = NULL;

// Class Engine.SeqAct_SetMaterial
// 0x000C (0x015C - 0x0150)
class USeqAct_SetMaterial : public USequenceAction {
   public:
    class UMaterialInterface*
        NewMaterial;    // 0x0150 (0x0008) [0x0000000000000000]
    int MaterialIndex;  // 0x0158 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2219];

        return pClassPointer;
    };
};

UClass* USeqAct_SetMaterial::pClassPointer = NULL;

// Class Engine.SeqAct_SetMatInstScalarParam
// 0x0014 (0x0164 - 0x0150)
class USeqAct_SetMatInstScalarParam : public USequenceAction {
   public:
    class UMaterialInstanceConstant*
        MatInst;             // 0x0150 (0x0008) [0x0000000000000000]
    struct FName ParamName;  // 0x0158 (0x0008) [0x0000000000000000]
    float ScalarValue;       // 0x0160 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2221];

        return pClassPointer;
    };
};

UClass* USeqAct_SetMatInstScalarParam::pClassPointer = NULL;

// Class Engine.SeqAct_SetMesh
// 0x0018 (0x0168 - 0x0150)
class USeqAct_SetMesh : public USequenceAction {
   public:
    class USkeletalMesh*
        NewSkeletalMesh;               // 0x0150 (0x0008) [0x0000000000000000]
    class UStaticMesh* NewStaticMesh;  // 0x0158 (0x0008) [0x0000000000000000]
    unsigned char MeshType;            // 0x0160 (0x0001) [0x0000000000000000]
    DWORD bIsAllowedToMove : 1;        // 0x0164 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bAllowDecalsToReattach : 1;  // 0x0164 (0x0004) [0x0000000000000000]
                                       // [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2223];

        return pClassPointer;
    };
};

UClass* USeqAct_SetMesh::pClassPointer = NULL;

// Class Engine.SeqAct_SetPhysics
// 0x0001 (0x0151 - 0x0150)
class USeqAct_SetPhysics : public USequenceAction {
   public:
    unsigned char newPhysics;  // 0x0150 (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2225];

        return pClassPointer;
    };
};

UClass* USeqAct_SetPhysics::pClassPointer = NULL;

// Class Engine.SeqAct_SetRigidBodyIgnoreVehicles
// 0x0000 (0x0150 - 0x0150)
class USeqAct_SetRigidBodyIgnoreVehicles : public USequenceAction {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2227];

        return pClassPointer;
    };
};

UClass* USeqAct_SetRigidBodyIgnoreVehicles::pClassPointer = NULL;

// Class Engine.SeqAct_SetSequenceVariable
// 0x0000 (0x0150 - 0x0150)
class USeqAct_SetSequenceVariable : public USequenceAction {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2229];

        return pClassPointer;
    };
};

UClass* USeqAct_SetSequenceVariable::pClassPointer = NULL;

// Class Engine.SeqAct_AccessObjectList
// 0x000C (0x015C - 0x0150)
class USeqAct_AccessObjectList : public USeqAct_SetSequenceVariable {
   public:
    class UObject* OutputObject;  // 0x0150 (0x0008) [0x0000000000000000]
    int ObjectIndex;              // 0x0158 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2231];

        return pClassPointer;
    };
};

UClass* USeqAct_AccessObjectList::pClassPointer = NULL;

// Class Engine.SeqAct_AddFloat
// 0x0010 (0x0160 - 0x0150)
class USeqAct_AddFloat : public USeqAct_SetSequenceVariable {
   public:
    float ValueA;       // 0x0150 (0x0004) [0x0000000000000000]
    float ValueB;       // 0x0154 (0x0004) [0x0000000000000000]
    float FloatResult;  // 0x0158 (0x0004) [0x0000000000000000]
    int IntResult;      // 0x015C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2233];

        return pClassPointer;
    };
};

UClass* USeqAct_AddFloat::pClassPointer = NULL;

// Class Engine.SeqAct_AddInt
// 0x0010 (0x0160 - 0x0150)
class USeqAct_AddInt : public USeqAct_SetSequenceVariable {
   public:
    int ValueA;         // 0x0150 (0x0004) [0x0000000000000000]
    int ValueB;         // 0x0154 (0x0004) [0x0000000000000000]
    float FloatResult;  // 0x0158 (0x0004) [0x0000000000000000]
    int IntResult;      // 0x015C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2235];

        return pClassPointer;
    };
};

UClass* USeqAct_AddInt::pClassPointer = NULL;

// Class Engine.SeqAct_CastToFloat
// 0x0008 (0x0158 - 0x0150)
class USeqAct_CastToFloat : public USeqAct_SetSequenceVariable {
   public:
    int Value;          // 0x0150 (0x0004) [0x0000000000000000]
    float FloatResult;  // 0x0154 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2237];

        return pClassPointer;
    };
};

UClass* USeqAct_CastToFloat::pClassPointer = NULL;

// Class Engine.SeqAct_CastToInt
// 0x000C (0x015C - 0x0150)
class USeqAct_CastToInt : public USeqAct_SetSequenceVariable {
   public:
    DWORD bTruncate : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000001]
    float Value;          // 0x0154 (0x0004) [0x0000000000000000]
    int IntResult;        // 0x0158 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2239];

        return pClassPointer;
    };
};

UClass* USeqAct_CastToInt::pClassPointer = NULL;

// Class Engine.SeqAct_DivideFloat
// 0x0010 (0x0160 - 0x0150)
class USeqAct_DivideFloat : public USeqAct_SetSequenceVariable {
   public:
    float ValueA;       // 0x0150 (0x0004) [0x0000000000000000]
    float ValueB;       // 0x0154 (0x0004) [0x0000000000000000]
    float FloatResult;  // 0x0158 (0x0004) [0x0000000000000000]
    int IntResult;      // 0x015C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2241];

        return pClassPointer;
    };
};

UClass* USeqAct_DivideFloat::pClassPointer = NULL;

// Class Engine.SeqAct_DivideInt
// 0x0010 (0x0160 - 0x0150)
class USeqAct_DivideInt : public USeqAct_SetSequenceVariable {
   public:
    int ValueA;         // 0x0150 (0x0004) [0x0000000000000000]
    int ValueB;         // 0x0154 (0x0004) [0x0000000000000000]
    float FloatResult;  // 0x0158 (0x0004) [0x0000000000000000]
    int IntResult;      // 0x015C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2243];

        return pClassPointer;
    };
};

UClass* USeqAct_DivideInt::pClassPointer = NULL;

// Class Engine.SeqAct_ModifyObjectList
// 0x0004 (0x0154 - 0x0150)
class USeqAct_ModifyObjectList : public USeqAct_SetSequenceVariable {
   public:
    int ListEntriesCount;  // 0x0150 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2245];

        return pClassPointer;
    };
};

UClass* USeqAct_ModifyObjectList::pClassPointer = NULL;

// Class Engine.SeqAct_MultiplyFloat
// 0x0010 (0x0160 - 0x0150)
class USeqAct_MultiplyFloat : public USeqAct_SetSequenceVariable {
   public:
    float ValueA;       // 0x0150 (0x0004) [0x0000000000000000]
    float ValueB;       // 0x0154 (0x0004) [0x0000000000000000]
    float FloatResult;  // 0x0158 (0x0004) [0x0000000000000000]
    int IntResult;      // 0x015C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2247];

        return pClassPointer;
    };
};

UClass* USeqAct_MultiplyFloat::pClassPointer = NULL;

// Class Engine.SeqAct_MultiplyInt
// 0x0010 (0x0160 - 0x0150)
class USeqAct_MultiplyInt : public USeqAct_SetSequenceVariable {
   public:
    int ValueA;         // 0x0150 (0x0004) [0x0000000000000000]
    int ValueB;         // 0x0154 (0x0004) [0x0000000000000000]
    float FloatResult;  // 0x0158 (0x0004) [0x0000000000000000]
    int IntResult;      // 0x015C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2249];

        return pClassPointer;
    };
};

UClass* USeqAct_MultiplyInt::pClassPointer = NULL;

// Class Engine.SeqAct_SetBool
// 0x0004 (0x0154 - 0x0150)
class USeqAct_SetBool : public USeqAct_SetSequenceVariable {
   public:
    DWORD
        DefaultValue : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2251];

        return pClassPointer;
    };
};

UClass* USeqAct_SetBool::pClassPointer = NULL;

// Class Engine.SeqAct_SetFloat
// 0x0014 (0x0164 - 0x0150)
class USeqAct_SetFloat : public USeqAct_SetSequenceVariable {
   public:
    float Target;         // 0x0150 (0x0004) [0x0000000000000000]
    TArray<float> Value;  // 0x0154 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2253];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_SetFloat::pClassPointer = NULL;

// Class Engine.SeqAct_SetInt
// 0x0014 (0x0164 - 0x0150)
class USeqAct_SetInt : public USeqAct_SetSequenceVariable {
   public:
    int Target;         // 0x0150 (0x0004) [0x0000000000000000]
    TArray<int> Value;  // 0x0154 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2255];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_SetInt::pClassPointer = NULL;

// Class Engine.SeqAct_SetLocation
// 0x0024 (0x0174 - 0x0150)
class USeqAct_SetLocation : public USeqAct_SetSequenceVariable {
   public:
    DWORD
        bSetLocation : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD
        bSetRotation : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000002]
    struct FVector LocationValue;   // 0x0154 (0x000C) [0x0000000000000000]
    struct FRotator RotationValue;  // 0x0160 (0x000C) [0x0000000000000000]
    class UObject* Target;          // 0x016C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2257];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_SetLocation::pClassPointer = NULL;

// Class Engine.SeqAct_SetObject
// 0x0010 (0x0160 - 0x0150)
class USeqAct_SetObject : public USeqAct_SetSequenceVariable {
   public:
    class UObject* DefaultValue;  // 0x0150 (0x0008) [0x0000000000000000]
    class UObject* Value;         // 0x0158 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2259];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_SetObject::pClassPointer = NULL;

// Class Engine.SeqAct_SetString
// 0x0020 (0x0170 - 0x0150)
class USeqAct_SetString : public USeqAct_SetSequenceVariable {
   public:
    struct FString Target;  // 0x0150 (0x0010) [0x0000000000000000]
    struct FString Value;   // 0x0160 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2261];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_SetString::pClassPointer = NULL;

// Class Engine.SeqAct_SubtractFloat
// 0x0010 (0x0160 - 0x0150)
class USeqAct_SubtractFloat : public USeqAct_SetSequenceVariable {
   public:
    float ValueA;       // 0x0150 (0x0004) [0x0000000000000000]
    float ValueB;       // 0x0154 (0x0004) [0x0000000000000000]
    float FloatResult;  // 0x0158 (0x0004) [0x0000000000000000]
    int IntResult;      // 0x015C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2263];

        return pClassPointer;
    };
};

UClass* USeqAct_SubtractFloat::pClassPointer = NULL;

// Class Engine.SeqAct_SubtractInt
// 0x0010 (0x0160 - 0x0150)
class USeqAct_SubtractInt : public USeqAct_SetSequenceVariable {
   public:
    int ValueA;         // 0x0150 (0x0004) [0x0000000000000000]
    int ValueB;         // 0x0154 (0x0004) [0x0000000000000000]
    float FloatResult;  // 0x0158 (0x0004) [0x0000000000000000]
    int IntResult;      // 0x015C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2265];

        return pClassPointer;
    };
};

UClass* USeqAct_SubtractInt::pClassPointer = NULL;

// Class Engine.SeqAct_SetVectorComponents
// 0x0018 (0x0168 - 0x0150)
class USeqAct_SetVectorComponents : public USequenceAction {
   public:
    struct FVector OutVector;  // 0x0150 (0x000C) [0x0000000000000000]
    float X;                   // 0x015C (0x0004) [0x0000000000000000]
    float Y;                   // 0x0160 (0x0004) [0x0000000000000000]
    float Z;                   // 0x0164 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2267];

        return pClassPointer;
    };
};

UClass* USeqAct_SetVectorComponents::pClassPointer = NULL;

// Class Engine.SeqAct_SetWorldAttractorParam
// 0x0084 (0x01D4 - 0x0150)
class USeqAct_SetWorldAttractorParam : public USequenceAction {
   public:
    TArray<class AWorldAttractor*>
        Attractor;  // 0x0150 (0x0010) [0x0000000000000000]
    DWORD
        bEnabledField : 1;  // 0x0160 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bFalloffTypeField : 1;      // 0x0160 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bFalloffExponentField : 1;  // 0x0160 (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    DWORD bRangeField : 1;  // 0x0160 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bStrengthField : 1;  // 0x0160 (0x0004) [0x0000000000000000]
                               // [0x00000010]
    DWORD bEnabled : 1;  // 0x0160 (0x0004) [0x0000000000000000] [0x00000020]
    unsigned char FalloffType;  // 0x0164 (0x0001) [0x0000000000000000]
    struct FRawDistributionFloat
        FalloffExponent;                 // 0x0168 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat Range;  // 0x018C (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        Strength;  // 0x01B0 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2269];

        return pClassPointer;
    };
};

UClass* USeqAct_SetWorldAttractorParam::pClassPointer = NULL;

// Class Engine.SeqAct_Switch
// 0x001C (0x016C - 0x0150)
class USeqAct_Switch : public USequenceAction {
   public:
    int LinkCount;        // 0x0150 (0x0004) [0x0000000000000000]
    int IncrementAmount;  // 0x0154 (0x0004) [0x0000000000000000]
    DWORD bLooping : 1;   // 0x0158 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bAutoDisableLinks : 1;  // 0x0158 (0x0004) [0x0000000000000000]
                                  // [0x00000002]
    TArray<int> Indices;          // 0x015C (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2271];

        return pClassPointer;
    };
};

UClass* USeqAct_Switch::pClassPointer = NULL;

// Class Engine.SeqAct_RandomSwitch
// 0x0010 (0x017C - 0x016C)
class USeqAct_RandomSwitch : public USeqAct_Switch {
   public:
    TArray<int> AutoDisabledIndices;  // 0x016C (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2273];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_RandomSwitch::pClassPointer = NULL;

// Class Engine.SeqAct_Timer
// 0x0008 (0x0158 - 0x0150)
class USeqAct_Timer : public USequenceAction {
   public:
    float ActivationTime;  // 0x0150 (0x0004) [0x0000000000000000]
    float Time;            // 0x0154 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2275];

        return pClassPointer;
    };
};

UClass* USeqAct_Timer::pClassPointer = NULL;

// Class Engine.SeqAct_Toggle
// 0x0000 (0x0150 - 0x0150)
class USeqAct_Toggle : public USequenceAction {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2277];

        return pClassPointer;
    };
};

UClass* USeqAct_Toggle::pClassPointer = NULL;

// Class Engine.SeqAct_Trace
// 0x0040 (0x0190 - 0x0150)
class USeqAct_Trace : public USequenceAction {
   public:
    DWORD
        bTraceActors : 1;   // 0x0150 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bTraceWorld : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000002]
    struct FVector TraceExtent;  // 0x0154 (0x000C) [0x0000000000000000]
    struct FVector StartOffset;  // 0x0160 (0x000C) [0x0000000000000000]
    struct FVector EndOffset;    // 0x016C (0x000C) [0x0000000000000000]
    class UObject* HitObject;    // 0x0178 (0x0008) [0x0000000000000000]
    float Distance;              // 0x0180 (0x0004) [0x0000000000000000]
    struct FVector HitLocation;  // 0x0184 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2279];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_Trace::pClassPointer = NULL;

// Class Engine.SequenceCondition
// 0x0000 (0x0134 - 0x0134)
class USequenceCondition : public USequenceOp {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2281];

        return pClassPointer;
    };
};

UClass* USequenceCondition::pClassPointer = NULL;

// Class Engine.SeqCond_CompareBool
// 0x0004 (0x0138 - 0x0134)
class USeqCond_CompareBool : public USequenceCondition {
   public:
    DWORD bResult : 1;  // 0x0134 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2283];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqCond_CompareBool::pClassPointer = NULL;

// Class Engine.SeqCond_CompareFloat
// 0x0008 (0x013C - 0x0134)
class USeqCond_CompareFloat : public USequenceCondition {
   public:
    float ValueA;  // 0x0134 (0x0004) [0x0000000000000000]
    float ValueB;  // 0x0138 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2285];

        return pClassPointer;
    };
};

UClass* USeqCond_CompareFloat::pClassPointer = NULL;

// Class Engine.SeqCond_CompareInt
// 0x0008 (0x013C - 0x0134)
class USeqCond_CompareInt : public USequenceCondition {
   public:
    int ValueA;  // 0x0134 (0x0004) [0x0000000000000000]
    int ValueB;  // 0x0138 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2287];

        return pClassPointer;
    };
};

UClass* USeqCond_CompareInt::pClassPointer = NULL;

// Class Engine.SeqCond_CompareObject
// 0x0000 (0x0134 - 0x0134)
class USeqCond_CompareObject : public USequenceCondition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2289];

        return pClassPointer;
    };
};

UClass* USeqCond_CompareObject::pClassPointer = NULL;

// Class Engine.SeqCond_GetServerType
// 0x0000 (0x0134 - 0x0134)
class USeqCond_GetServerType : public USequenceCondition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2291];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqCond_GetServerType::pClassPointer = NULL;

// Class Engine.SeqCond_Increment
// 0x000C (0x0140 - 0x0134)
class USeqCond_Increment : public USequenceCondition {
   public:
    int IncrementAmount;  // 0x0134 (0x0004) [0x0000000000000000]
    int ValueA;           // 0x0138 (0x0004) [0x0000000000000000]
    int ValueB;           // 0x013C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2293];

        return pClassPointer;
    };
};

UClass* USeqCond_Increment::pClassPointer = NULL;

// Class Engine.SeqCond_IncrementFloat
// 0x000C (0x0140 - 0x0134)
class USeqCond_IncrementFloat : public USequenceCondition {
   public:
    float IncrementAmount;  // 0x0134 (0x0004) [0x0000000000000000]
    float ValueA;           // 0x0138 (0x0004) [0x0000000000000000]
    float ValueB;           // 0x013C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2295];

        return pClassPointer;
    };
};

UClass* USeqCond_IncrementFloat::pClassPointer = NULL;

// Class Engine.SeqCond_IsAlive
// 0x0000 (0x0134 - 0x0134)
class USeqCond_IsAlive : public USequenceCondition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2297];

        return pClassPointer;
    };
};

UClass* USeqCond_IsAlive::pClassPointer = NULL;

// Class Engine.SeqCond_IsBenchmarking
// 0x0000 (0x0134 - 0x0134)
class USeqCond_IsBenchmarking : public USequenceCondition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2299];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqCond_IsBenchmarking::pClassPointer = NULL;

// Class Engine.SeqCond_IsConsole
// 0x0000 (0x0134 - 0x0134)
class USeqCond_IsConsole : public USequenceCondition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2301];

        return pClassPointer;
    };
};

UClass* USeqCond_IsConsole::pClassPointer = NULL;

// Class Engine.SeqCond_IsInCombat
// 0x0000 (0x0134 - 0x0134)
class USeqCond_IsInCombat : public USequenceCondition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2303];

        return pClassPointer;
    };
};

UClass* USeqCond_IsInCombat::pClassPointer = NULL;

// Class Engine.SeqCond_IsLoggedIn
// 0x0004 (0x0138 - 0x0134)
class USeqCond_IsLoggedIn : public USequenceCondition {
   public:
    int NumNeededLoggedIn;  // 0x0134 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2305];

        return pClassPointer;
    };

    void eventCheckLogins();
};

UClass* USeqCond_IsLoggedIn::pClassPointer = NULL;

// Class Engine.SeqCond_IsPIE
// 0x0000 (0x0134 - 0x0134)
class USeqCond_IsPIE : public USequenceCondition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2307];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqCond_IsPIE::pClassPointer = NULL;

// Class Engine.SeqCond_IsSameTeam
// 0x0000 (0x0134 - 0x0134)
class USeqCond_IsSameTeam : public USequenceCondition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2309];

        return pClassPointer;
    };
};

UClass* USeqCond_IsSameTeam::pClassPointer = NULL;

// Class Engine.SeqCond_MatureLanguage
// 0x0000 (0x0134 - 0x0134)
class USeqCond_MatureLanguage : public USequenceCondition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2311];

        return pClassPointer;
    };
};

UClass* USeqCond_MatureLanguage::pClassPointer = NULL;

// Class Engine.SeqCond_ShowGore
// 0x0000 (0x0134 - 0x0134)
class USeqCond_ShowGore : public USequenceCondition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2313];

        return pClassPointer;
    };
};

UClass* USeqCond_ShowGore::pClassPointer = NULL;

// Class Engine.SeqCond_SwitchBase
// 0x0000 (0x0134 - 0x0134)
class USeqCond_SwitchBase : public USequenceCondition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2315];

        return pClassPointer;
    };

    void eventRemoveValueEntry();
    void eventInsertValueEntry();
    void eventIsFallThruEnabled();
    void eventVerifyDefaultCaseValue();
};

UClass* USeqCond_SwitchBase::pClassPointer = NULL;

// Class Engine.SeqCond_SwitchClass
// 0x0010 (0x0144 - 0x0134)
class USeqCond_SwitchClass : public USeqCond_SwitchBase {
   public:
    TArray<struct FSwitchClassInfo>
        ClassArray;  // 0x0134 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2317];

        return pClassPointer;
    };

    void eventRemoveValueEntry();
    void eventInsertValueEntry();
    void eventIsFallThruEnabled();
    void eventVerifyDefaultCaseValue();
};

UClass* USeqCond_SwitchClass::pClassPointer = NULL;

// Class Engine.SeqCond_SwitchObject
// 0x0010 (0x0144 - 0x0134)
class USeqCond_SwitchObject : public USeqCond_SwitchBase {
   public:
    TArray<struct FSwitchObjectCase>
        SupportedValues;  // 0x0134 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2319];

        return pClassPointer;
    };

    void eventRemoveValueEntry();
    void eventInsertValueEntry();
    void eventIsFallThruEnabled();
    void eventVerifyDefaultCaseValue();
};

UClass* USeqCond_SwitchObject::pClassPointer = NULL;

// Class Engine.SeqCond_SwitchPlatform
// 0x0000 (0x0134 - 0x0134)
class USeqCond_SwitchPlatform : public USequenceCondition {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2321];

        return pClassPointer;
    };
};

UClass* USeqCond_SwitchPlatform::pClassPointer = NULL;

// Class Engine.SequenceEvent
// 0x003C (0x0170 - 0x0134)
class USequenceEvent : public USequenceOp {
   public:
    TArray<class USequenceEvent*>
        DuplicateEvts;         // 0x0134 (0x0010) [0x0000000000000000]
    class AActor* Originator;  // 0x0144 (0x0008) [0x0000000000000000]
    class AActor* Instigator;  // 0x014C (0x0008) [0x0000000000000000]
    float ActivationTime;      // 0x0154 (0x0004) [0x0000000000000000]
    int TriggerCount;          // 0x0158 (0x0004) [0x0000000000000000]
    int MaxTriggerCount;       // 0x015C (0x0004) [0x0000000000000000]
    float ReTriggerDelay;      // 0x0160 (0x0004) [0x0000000000000000]
    DWORD bEnabled : 1;     // 0x0164 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bPlayerOnly : 1;  // 0x0164 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bRegistered : 1;  // 0x0164 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bClientSideOnly : 1;  // 0x0164 (0x0004) [0x0000000000000000]
                                // [0x00000008]
    unsigned char Priority;     // 0x0168 (0x0001) [0x0000000000000000]
    int MaxWidth;               // 0x016C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2323];

        return pClassPointer;
    };

    void eventToggled();
    void Reset();
    void CheckActivate();
    void eventRegisterEvent();
};

UClass* USequenceEvent::pClassPointer = NULL;

// Class Engine.SeqEvent_AISeeEnemy
// 0x0004 (0x0174 - 0x0170)
class USeqEvent_AISeeEnemy : public USequenceEvent {
   public:
    float MaxSightDistance;  // 0x0170 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2325];

        return pClassPointer;
    };
};

UClass* USeqEvent_AISeeEnemy::pClassPointer = NULL;

// Class Engine.SeqEvent_AnalogInput
// 0x0018 (0x0188 - 0x0170)
class USeqEvent_AnalogInput : public USequenceEvent {
   public:
    DWORD bTrapInput : 1;  // 0x0170 (0x0004) [0x0000000000000000] [0x00000001]
    int AllowedPlayerIndex;           // 0x0174 (0x0004) [0x0000000000000000]
    TArray<struct FName> InputNames;  // 0x0178 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2327];

        return pClassPointer;
    };
};

UClass* USeqEvent_AnalogInput::pClassPointer = NULL;

// Class Engine.SeqEvent_AnimNotify
// 0x0008 (0x0178 - 0x0170)
class USeqEvent_AnimNotify : public USequenceEvent {
   public:
    struct FName NotifyName;  // 0x0170 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2329];

        return pClassPointer;
    };
};

UClass* USeqEvent_AnimNotify::pClassPointer = NULL;

// Class Engine.SeqEvent_Console
// 0x0018 (0x0188 - 0x0170)
class USeqEvent_Console : public USequenceEvent {
   public:
    struct FName ConsoleEventName;  // 0x0170 (0x0008) [0x0000000000000000]
    struct FString EventDesc;       // 0x0178 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2331];

        return pClassPointer;
    };
};

UClass* USeqEvent_Console::pClassPointer = NULL;

// Class Engine.SeqEvent_ConstraintBroken
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_ConstraintBroken : public USequenceEvent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2333];

        return pClassPointer;
    };
};

UClass* USeqEvent_ConstraintBroken::pClassPointer = NULL;

// Class Engine.SeqEvent_Destroyed
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_Destroyed : public USequenceEvent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2335];

        return pClassPointer;
    };
};

UClass* USeqEvent_Destroyed::pClassPointer = NULL;

// Class Engine.SeqEvent_GetInventory
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_GetInventory : public USequenceEvent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2337];

        return pClassPointer;
    };
};

UClass* USeqEvent_GetInventory::pClassPointer = NULL;

// Class Engine.SeqEvent_Input
// 0x0018 (0x0188 - 0x0170)
class USeqEvent_Input : public USequenceEvent {
   public:
    DWORD bTrapInput : 1;  // 0x0170 (0x0004) [0x0000000000000000] [0x00000001]
    int AllowedPlayerIndex;           // 0x0174 (0x0004) [0x0000000000000000]
    TArray<struct FName> InputNames;  // 0x0178 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2339];

        return pClassPointer;
    };
};

UClass* USeqEvent_Input::pClassPointer = NULL;

// Class Engine.SeqEvent_LevelBeginning
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_LevelBeginning : public USequenceEvent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2341];

        return pClassPointer;
    };
};

UClass* USeqEvent_LevelBeginning::pClassPointer = NULL;

// Class Engine.SeqEvent_LevelLoaded
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_LevelLoaded : public USequenceEvent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2343];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqEvent_LevelLoaded::pClassPointer = NULL;

// Class Engine.SeqEvent_LevelStartup
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_LevelStartup : public USequenceEvent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2345];

        return pClassPointer;
    };
};

UClass* USeqEvent_LevelStartup::pClassPointer = NULL;

// Class Engine.SeqEvent_Mover
// 0x0004 (0x0174 - 0x0170)
class USeqEvent_Mover : public USequenceEvent {
   public:
    float StayOpenTime;  // 0x0170 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2347];

        return pClassPointer;
    };

    void NotifyFinishedOpen();
    void NotifyDetached();
    void NotifyAttached();
    void NotifyEncroachingOn();
    void eventRegisterEvent();
};

UClass* USeqEvent_Mover::pClassPointer = NULL;

// Class Engine.SeqEvent_ParticleEvent
// 0x0034 (0x01A4 - 0x0170)
class USeqEvent_ParticleEvent : public USequenceEvent {
   public:
    unsigned char EventType;             // 0x0170 (0x0001) [0x0000000000000000]
    struct FVector EventPosition;        // 0x0174 (0x000C) [0x0000000000000000]
    float EventEmitterTime;              // 0x0180 (0x0004) [0x0000000000000000]
    struct FVector EventVelocity;        // 0x0184 (0x000C) [0x0000000000000000]
    float EventParticleTime;             // 0x0190 (0x0004) [0x0000000000000000]
    struct FVector EventNormal;          // 0x0194 (0x000C) [0x0000000000000000]
    DWORD UseRelfectedImpactVector : 1;  // 0x01A0 (0x0004) [0x0000000000000000]
                                         // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2349];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqEvent_ParticleEvent::pClassPointer = NULL;

// Class Engine.SeqEvent_ProjectileLanded
// 0x0004 (0x0174 - 0x0170)
class USeqEvent_ProjectileLanded : public USequenceEvent {
   public:
    float MaxDistance;  // 0x0170 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2351];

        return pClassPointer;
    };
};

UClass* USeqEvent_ProjectileLanded::pClassPointer = NULL;

// Class Engine.SeqEvent_RemoteEvent
// 0x000C (0x017C - 0x0170)
class USeqEvent_RemoteEvent : public USequenceEvent {
   public:
    struct FName EventName;  // 0x0170 (0x0008) [0x0000000000000000]
    DWORD bStatusIsOk : 1;  // 0x0178 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2353];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqEvent_RemoteEvent::pClassPointer = NULL;

// Class Engine.SeqEvent_RigidBodyCollision
// 0x0004 (0x0174 - 0x0170)
class USeqEvent_RigidBodyCollision : public USequenceEvent {
   public:
    float MinCollisionVelocity;  // 0x0170 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2355];

        return pClassPointer;
    };
};

UClass* USeqEvent_RigidBodyCollision::pClassPointer = NULL;

// Class Engine.SeqEvent_SeeDeath
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_SeeDeath : public USequenceEvent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2357];

        return pClassPointer;
    };
};

UClass* USeqEvent_SeeDeath::pClassPointer = NULL;

// Class Engine.SeqEvent_SequenceActivated
// 0x0010 (0x0180 - 0x0170)
class USeqEvent_SequenceActivated : public USequenceEvent {
   public:
    struct FString InputLabel;  // 0x0170 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2359];

        return pClassPointer;
    };
};

UClass* USeqEvent_SequenceActivated::pClassPointer = NULL;

// Class Engine.SeqEvent_TakeDamage
// 0x0030 (0x01A0 - 0x0170)
class USeqEvent_TakeDamage : public USequenceEvent {
   public:
    float MinDamageAmount;              // 0x0170 (0x0004) [0x0000000000000000]
    float DamageThreshold;              // 0x0174 (0x0004) [0x0000000000000000]
    TArray<class UClass*> DamageTypes;  // 0x0178 (0x0010) [0x0000000000000000]
    TArray<class UClass*>
        IgnoreDamageTypes;           // 0x0188 (0x0010) [0x0000000000000000]
    float CurrentDamage;             // 0x0198 (0x0004) [0x0000000000000000]
    DWORD bResetDamageOnToggle : 1;  // 0x019C (0x0004) [0x0000000000000000]
                                     // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2361];

        return pClassPointer;
    };

    void eventToggled();
    void eventGetObjClassVersion();
    void Reset();
    void HandleDamage();
    void IsValidDamageType();
};

UClass* USeqEvent_TakeDamage::pClassPointer = NULL;

// Class Engine.SeqEvent_Touch
// 0x0034 (0x01A4 - 0x0170)
class USeqEvent_Touch : public USequenceEvent {
   public:
    TArray<class UClass*>
        ClassProximityTypes;  // 0x0170 (0x0010) [0x0000000000000000]
    TArray<class UClass*>
        IgnoredClassProximityTypes;     // 0x0180 (0x0010) [0x0000000000000000]
    DWORD bForceOverlapping : 1;        // 0x0190 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bUseInstigator : 1;           // 0x0190 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bAllowDeadPawns : 1;          // 0x0190 (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    TArray<class AActor*> TouchedList;  // 0x0194 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2363];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
    void NotifyTouchingPawnDied();
    void eventToggled();
    void CheckUnTouchActivate();
    void CheckTouchActivate();
};

UClass* USeqEvent_Touch::pClassPointer = NULL;

// Class Engine.SeqEvent_TouchInput
// 0x0010 (0x0180 - 0x0170)
class USeqEvent_TouchInput : public USequenceEvent {
   public:
    DWORD bTrapInput : 1;  // 0x0170 (0x0004) [0x0000000000000000] [0x00000001]
    int AllowedPlayerIndex;    // 0x0174 (0x0004) [0x0000000000000000]
    int AllowedTouchIndex;     // 0x0178 (0x0004) [0x0000000000000000]
    int AllowedTouchpadIndex;  // 0x017C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2365];

        return pClassPointer;
    };
};

UClass* USeqEvent_TouchInput::pClassPointer = NULL;

// Class Engine.SeqEvent_Used
// 0x0040 (0x01B0 - 0x0170)
class USeqEvent_Used : public USequenceEvent {
   public:
    DWORD bAimToInteract : 1;  // 0x0170 (0x0004) [0x0000000000000000]
                               // [0x00000001]
    DWORD
        bUseLineCheck : 1;  // 0x0170 (0x0004) [0x0000000000000000] [0x00000002]
    float InteractDistance;          // 0x0174 (0x0004) [0x0000000000000000]
    struct FString InteractText;     // 0x0178 (0x0010) [0x0000000000000000]
    class UTexture2D* InteractIcon;  // 0x0188 (0x0008) [0x0000000000000000]
    TArray<class UClass*>
        ClassProximityTypes;  // 0x0190 (0x0010) [0x0000000000000000]
    TArray<class UClass*>
        IgnoredClassProximityTypes;  // 0x01A0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2367];

        return pClassPointer;
    };
};

UClass* USeqEvent_Used::pClassPointer = NULL;

// Class Engine.SequenceVariable
// 0x0008 (0x00D4 - 0x00CC)
class USequenceVariable : public USequenceObject {
   public:
    struct FName VarName;  // 0x00CC (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2369];

        return pClassPointer;
    };
};

UClass* USequenceVariable::pClassPointer = NULL;

// Class Engine.InterpData
// 0x006C (0x0140 - 0x00D4)
class UInterpData : public USequenceVariable {
   public:
    float InterpLength;   // 0x00D4 (0x0004) [0x0000000000000000]
    float PathBuildTime;  // 0x00D8 (0x0004) [0x0000000000000000]
    TArray<class UInterpGroup*>
        InterpGroups;  // 0x00DC (0x0010) [0x0000000000000000]
    class UInterpCurveEdSetup*
        CurveEdSetup;  // 0x00EC (0x0008) [0x0000000000000000]
    TArray<class UInterpFilter*>
        InterpFilters;  // 0x00F4 (0x0010) [0x0000000000000000]
    class UInterpFilter*
        SelectedFilter;  // 0x0104 (0x0008) [0x0000000000000000]
    TArray<class UInterpFilter*>
        DefaultFilters;             // 0x010C (0x0010) [0x0000000000000000]
    float EdSectionStart;           // 0x011C (0x0004) [0x0000000000000000]
    float EdSectionEnd;             // 0x0120 (0x0004) [0x0000000000000000]
    DWORD bShouldBakeAndPrune : 1;  // 0x0124 (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    TArray<struct FAnimSetBakeAndPruneStatus>
        BakeAndPruneStatus;  // 0x0128 (0x0010) [0x0000000000000000]
    class UInterpGroupDirector*
        CachedDirectorGroup;  // 0x0138 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2371];

        return pClassPointer;
    };
};

UClass* UInterpData::pClassPointer = NULL;

// Class Engine.SeqVar_Bool
// 0x0004 (0x00D8 - 0x00D4)
class USeqVar_Bool : public USequenceVariable {
   public:
    int bValue;  // 0x00D4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2373];

        return pClassPointer;
    };
};

UClass* USeqVar_Bool::pClassPointer = NULL;

// Class Engine.SeqVar_External
// 0x0018 (0x00EC - 0x00D4)
class USeqVar_External : public USequenceVariable {
   public:
    class UClass* ExpectedType;    // 0x00D4 (0x0008) [0x0000000000000000]
    struct FString VariableLabel;  // 0x00DC (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2375];

        return pClassPointer;
    };
};

UClass* USeqVar_External::pClassPointer = NULL;

// Class Engine.SeqVar_Float
// 0x0004 (0x00D8 - 0x00D4)
class USeqVar_Float : public USequenceVariable {
   public:
    float FloatValue;  // 0x00D4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2377];

        return pClassPointer;
    };
};

UClass* USeqVar_Float::pClassPointer = NULL;

// Class Engine.SeqVar_RandomFloat
// 0x0008 (0x00E0 - 0x00D8)
class USeqVar_RandomFloat : public USeqVar_Float {
   public:
    float Min;  // 0x00D8 (0x0004) [0x0000000000000000]
    float Max;  // 0x00DC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2379];

        return pClassPointer;
    };
};

UClass* USeqVar_RandomFloat::pClassPointer = NULL;

// Class Engine.SeqVar_Int
// 0x0004 (0x00D8 - 0x00D4)
class USeqVar_Int : public USequenceVariable {
   public:
    int IntValue;  // 0x00D4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2381];

        return pClassPointer;
    };
};

UClass* USeqVar_Int::pClassPointer = NULL;

// Class Engine.SeqVar_RandomInt
// 0x0008 (0x00E0 - 0x00D8)
class USeqVar_RandomInt : public USeqVar_Int {
   public:
    int Min;  // 0x00D8 (0x0004) [0x0000000000000000]
    int Max;  // 0x00DC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2383];

        return pClassPointer;
    };
};

UClass* USeqVar_RandomInt::pClassPointer = NULL;

// Class Engine.SeqVar_Named
// 0x0014 (0x00E8 - 0x00D4)
class USeqVar_Named : public USequenceVariable {
   public:
    class UClass* ExpectedType;  // 0x00D4 (0x0008) [0x0000000000000000]
    struct FName FindVarName;    // 0x00DC (0x0008) [0x0000000000000000]
    DWORD bStatusIsOk : 1;  // 0x00E4 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2385];

        return pClassPointer;
    };
};

UClass* USeqVar_Named::pClassPointer = NULL;

// Class Engine.SeqVar_Object
// 0x0024 (0x00F8 - 0x00D4)
class USeqVar_Object : public USequenceVariable {
   public:
    class UObject* ObjValue;       // 0x00D4 (0x0008) [0x0000000000000000]
    struct FVector ActorLocation;  // 0x00DC (0x000C) [0x0000000000000000]
    TArray<class UClass*>
        SupportedClasses;  // 0x00E8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2387];

        return pClassPointer;
    };

    void SetObjectValue();
    void GetObjectValue();
};

UClass* USeqVar_Object::pClassPointer = NULL;

// Class Engine.SeqVar_Character
// 0x0008 (0x0100 - 0x00F8)
class USeqVar_Character : public USeqVar_Object {
   public:
    class UClass* PawnClass;  // 0x00F8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2389];

        return pClassPointer;
    };
};

UClass* USeqVar_Character::pClassPointer = NULL;

// Class Engine.SeqVar_Group
// 0x001C (0x0114 - 0x00F8)
class USeqVar_Group : public USeqVar_Object {
   public:
    struct FName GroupName;  // 0x00F8 (0x0008) [0x0000000000000000]
    DWORD bCachedList : 1;  // 0x0100 (0x0004) [0x0000000000000000] [0x00000001]
    TArray<class UObject*> Actors;  // 0x0104 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2391];

        return pClassPointer;
    };
};

UClass* USeqVar_Group::pClassPointer = NULL;

// Class Engine.SeqVar_ObjectList
// 0x0010 (0x0108 - 0x00F8)
class USeqVar_ObjectList : public USeqVar_Object {
   public:
    TArray<class UObject*> ObjList;  // 0x00F8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2393];

        return pClassPointer;
    };

    void SetObjectValue();
    void GetObjectValue();
};

UClass* USeqVar_ObjectList::pClassPointer = NULL;

// Class Engine.SeqVar_ObjectVolume
// 0x0028 (0x0120 - 0x00F8)
class USeqVar_ObjectVolume : public USeqVar_Object {
   public:
    float LastUpdateTime;  // 0x00F8 (0x0004) [0x0000000000000000]
    TArray<class UObject*>
        ContainedObjects;  // 0x00FC (0x0010) [0x0000000000000000]
    TArray<class UClass*>
        ExcludeClassList;      // 0x010C (0x0010) [0x0000000000000000]
    DWORD bCollidingOnly : 1;  // 0x011C (0x0004) [0x0000000000000000]
                               // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2395];

        return pClassPointer;
    };
};

UClass* USeqVar_ObjectVolume::pClassPointer = NULL;

// Class Engine.SeqVar_Player
// 0x0018 (0x0110 - 0x00F8)
class USeqVar_Player : public USeqVar_Object {
   public:
    TArray<class UObject*> Players;  // 0x00F8 (0x0010) [0x0000000000000000]
    DWORD bAllPlayers : 1;  // 0x0108 (0x0004) [0x0000000000000000] [0x00000001]
    int PlayerIdx;          // 0x010C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2397];

        return pClassPointer;
    };

    void GetObjectValue();
    void UpdatePlayersList();
};

UClass* USeqVar_Player::pClassPointer = NULL;

// Class Engine.SeqVar_String
// 0x0010 (0x00E4 - 0x00D4)
class USeqVar_String : public USequenceVariable {
   public:
    struct FString StrValue;  // 0x00D4 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2399];

        return pClassPointer;
    };
};

UClass* USeqVar_String::pClassPointer = NULL;

// Class Engine.SeqVar_Vector
// 0x000C (0x00E0 - 0x00D4)
class USeqVar_Vector : public USequenceVariable {
   public:
    struct FVector VectValue;  // 0x00D4 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2401];

        return pClassPointer;
    };
};

UClass* USeqVar_Vector::pClassPointer = NULL;

// Class Engine.AmbientSound
// 0x000C (0x0258 - 0x024C)
class AAmbientSound : public AKeypoint {
   public:
    DWORD bAutoPlay : 1;   // 0x024C (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bIsPlaying : 1;  // 0x024C (0x0004) [0x0000000000000000] [0x00000002]
    class UAudioComponent*
        AudioComponent;  // 0x0250 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2403];

        return pClassPointer;
    };
};

UClass* AAmbientSound::pClassPointer = NULL;

// Class Engine.AmbientSoundMovable
// 0x0000 (0x0258 - 0x0258)
class AAmbientSoundMovable : public AAmbientSound {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2405];

        return pClassPointer;
    };
};

UClass* AAmbientSoundMovable::pClassPointer = NULL;

// Class Engine.AmbientSoundSimple
// 0x0018 (0x0270 - 0x0258)
class AAmbientSoundSimple : public AAmbientSound {
   public:
    class USoundNodeAmbient*
        AmbientProperties;              // 0x0258 (0x0008) [0x0000000000000000]
    class USoundCue* SoundCueInstance;  // 0x0260 (0x0008) [0x0000000000000000]
    class USoundNodeAmbient*
        SoundNodeInstance;  // 0x0268 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2407];

        return pClassPointer;
    };
};

UClass* AAmbientSoundSimple::pClassPointer = NULL;

// Class Engine.AmbientSoundNonLoop
// 0x0000 (0x0270 - 0x0270)
class AAmbientSoundNonLoop : public AAmbientSoundSimple {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2409];

        return pClassPointer;
    };
};

UClass* AAmbientSoundNonLoop::pClassPointer = NULL;

// Class Engine.AmbientSoundSimpleToggleable
// 0x0014 (0x0284 - 0x0270)
class AAmbientSoundSimpleToggleable : public AAmbientSoundSimple {
   public:
    DWORD bCurrentlyPlaying : 1;  // 0x0270 (0x0004) [0x0000000000150000]
                                  // [0x00000001] ( CPF_Travel |
                                  // CPF_GlobalConfig )
    DWORD
        bFadeOnToggle : 1;  // 0x0270 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bIgnoreAutoPlay : 1;  // 0x0270 (0x0004) [0x0000000000000000]
                                // [0x00000004]
    float FadeInDuration;       // 0x0274 (0x0004) [0x0000000000000000]
    float FadeInVolumeLevel;    // 0x0278 (0x0004) [0x0000000000000000]
    float FadeOutDuration;      // 0x027C (0x0004) [0x0000000000000000]
    float FadeOutVolumeLevel;   // 0x0280 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2411];

        return pClassPointer;
    };

    void ApplyCheckpointRecord();
    void CreateCheckpointRecord();
    void OnToggle();
    void StopPlaying();
    void StartPlaying();
    void eventReplicatedEvent();
    void eventPostBeginPlay();
};

UClass* AAmbientSoundSimpleToggleable::pClassPointer = NULL;

// Class Engine.AmbientSoundNonLoopingToggleable
// 0x0000 (0x0284 - 0x0284)
class AAmbientSoundNonLoopingToggleable : public AAmbientSoundSimpleToggleable {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2413];

        return pClassPointer;
    };
};

UClass* AAmbientSoundNonLoopingToggleable::pClassPointer = NULL;

// Class Engine.AmbientSoundSpline
// 0x0018 (0x0270 - 0x0258)
class AAmbientSoundSpline : public AAmbientSound {
   public:
    float DistanceBetweenPoints;  // 0x0258 (0x0004) [0x0000000000000000]
    class USplineComponent*
        SplineComponent;       // 0x025C (0x0008) [0x0000000000000000]
    struct FVector TestPoint;  // 0x0264 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2415];

        return pClassPointer;
    };
};

UClass* AAmbientSoundSpline::pClassPointer = NULL;

// Class Engine.AmbientSoundSimpleSpline
// 0x0004 (0x0274 - 0x0270)
class AAmbientSoundSimpleSpline : public AAmbientSoundSpline {
   public:
    int EditedSlot;  // 0x0270 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2417];

        return pClassPointer;
    };
};

UClass* AAmbientSoundSimpleSpline::pClassPointer = NULL;

// Class Engine.AmbientSoundSplineMultiCue
// 0x0004 (0x0274 - 0x0270)
class AAmbientSoundSplineMultiCue : public AAmbientSoundSpline {
   public:
    int EditedSlot;  // 0x0270 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2419];

        return pClassPointer;
    };
};

UClass* AAmbientSoundSplineMultiCue::pClassPointer = NULL;

// Class Engine.DistributionFloatSoundParameter
// 0x0003 (0x009C - 0x0099)
class UDistributionFloatSoundParameter
    : public UDistributionFloatParameterBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2421];

        return pClassPointer;
    };
};

UClass* UDistributionFloatSoundParameter::pClassPointer = NULL;

// Class Engine.SoundNode
// 0x0014 (0x0074 - 0x0060)
class USoundNode : public UObject {
   public:
    int NodeUpdateHint;  // 0x0060 (0x0004) [0x0000000000000000]
    TArray<class USoundNode*>
        ChildNodes;  // 0x0064 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2423];

        return pClassPointer;
    };
};

UClass* USoundNode::pClassPointer = NULL;

// Class Engine.ForcedLoopSoundNode
// 0x0000 (0x0074 - 0x0074)
class UForcedLoopSoundNode : public USoundNode {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2425];

        return pClassPointer;
    };
};

UClass* UForcedLoopSoundNode::pClassPointer = NULL;

// Class Engine.SoundNodeAmbient
// 0x003C (0x00B0 - 0x0074)
class USoundNodeAmbient : public USoundNode {
   public:
    DWORD bAttenuate : 1;   // 0x0074 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bSpatialize : 1;  // 0x0074 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bAttenuateWithLPF : 1;  // 0x0074 (0x0004) [0x0000000000000000]
                                  // [0x00000004]
    float dBAttenuationAtMax;     // 0x0078 (0x0004) [0x0000000000000000]
    unsigned char DistanceModel;  // 0x007C (0x0001) [0x0000000000000000]
    float RadiusMin;              // 0x0080 (0x0004) [0x0000000000000000]
    float RadiusMax;              // 0x0084 (0x0004) [0x0000000000000000]
    float LPFRadiusMin;           // 0x0088 (0x0004) [0x0000000000000000]
    float LPFRadiusMax;           // 0x008C (0x0004) [0x0000000000000000]
    float PitchMin;               // 0x0090 (0x0004) [0x0000000000000000]
    float PitchMax;               // 0x0094 (0x0004) [0x0000000000000000]
    float VolumeMin;              // 0x0098 (0x0004) [0x0000000000000000]
    float VolumeMax;              // 0x009C (0x0004) [0x0000000000000000]
    TArray<struct FAmbientSoundSlot>
        SoundSlots;  // 0x00A0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2427];

        return pClassPointer;
    };
};

UClass* USoundNodeAmbient::pClassPointer = NULL;

// Class Engine.SoundNodeAmbientNonLoop
// 0x002C (0x00DC - 0x00B0)
class USoundNodeAmbientNonLoop : public USoundNodeAmbient {
   public:
    float DelayMin;  // 0x00B0 (0x0004) [0x0000000000000000]
    float DelayMax;  // 0x00B4 (0x0004) [0x0000000000000000]
    struct FRawDistributionFloat
        DelayTime;  // 0x00B8 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2429];

        return pClassPointer;
    };
};

UClass* USoundNodeAmbientNonLoop::pClassPointer = NULL;

// Class Engine.SoundNodeAmbientNonLoopToggle
// 0x0000 (0x00DC - 0x00DC)
class USoundNodeAmbientNonLoopToggle : public USoundNodeAmbientNonLoop {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2431];

        return pClassPointer;
    };
};

UClass* USoundNodeAmbientNonLoopToggle::pClassPointer = NULL;

// Class Engine.SoundNodeAttenuation
// 0x0020 (0x0094 - 0x0074)
class USoundNodeAttenuation : public USoundNode {
   public:
    DWORD bAttenuate : 1;   // 0x0074 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bSpatialize : 1;  // 0x0074 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bAttenuateWithLPF : 1;      // 0x0074 (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    float dBAttenuationAtMax;         // 0x0078 (0x0004) [0x0000000000000000]
    float OmniRadius;                 // 0x007C (0x0004) [0x0000000000000000]
    unsigned char DistanceAlgorithm;  // 0x0080 (0x0001) [0x0000000000000000]
    unsigned char DistanceType;       // 0x0081 (0x0001) [0x0000000000000000]
    float RadiusMin;                  // 0x0084 (0x0004) [0x0000000000000000]
    float RadiusMax;                  // 0x0088 (0x0004) [0x0000000000000000]
    float LPFRadiusMin;               // 0x008C (0x0004) [0x0000000000000000]
    float LPFRadiusMax;               // 0x0090 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2433];

        return pClassPointer;
    };
};

UClass* USoundNodeAttenuation::pClassPointer = NULL;

// Class Engine.SoundNodeAttenuationAndGain
// 0x0030 (0x00A4 - 0x0074)
class USoundNodeAttenuationAndGain : public USoundNode {
   public:
    DWORD bAttenuate : 1;   // 0x0074 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bSpatialize : 1;  // 0x0074 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bAttenuateWithLPF : 1;  // 0x0074 (0x0004) [0x0000000000000000]
                                  // [0x00000004]
    float dBAttenuationAtMax;     // 0x0078 (0x0004) [0x0000000000000000]
    float OmniRadius;             // 0x007C (0x0004) [0x0000000000000000]
    unsigned char
        GainDistanceAlgorithm;  // 0x0080 (0x0001) [0x0000000000000000]
    unsigned char
        AttenuateDistanceAlgorithm;  // 0x0081 (0x0001) [0x0000000000000000]
    unsigned char DistanceType;      // 0x0082 (0x0001) [0x0000000000000000]
    float MinimalVolume;             // 0x0084 (0x0004) [0x0000000000000000]
    float RadiusMin;                 // 0x0088 (0x0004) [0x0000000000000000]
    float RadiusPeak;                // 0x008C (0x0004) [0x0000000000000000]
    float RadiusMax;                 // 0x0090 (0x0004) [0x0000000000000000]
    float LPFMinimal;                // 0x0094 (0x0004) [0x0000000000000000]
    float LPFRadiusMin;              // 0x0098 (0x0004) [0x0000000000000000]
    float LPFRadiusPeak;             // 0x009C (0x0004) [0x0000000000000000]
    float LPFRadiusMax;              // 0x00A0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2435];

        return pClassPointer;
    };
};

UClass* USoundNodeAttenuationAndGain::pClassPointer = NULL;

// Class Engine.SoundNodeConcatenator
// 0x0010 (0x0084 - 0x0074)
class USoundNodeConcatenator : public USoundNode {
   public:
    TArray<float> InputVolume;  // 0x0074 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2437];

        return pClassPointer;
    };
};

UClass* USoundNodeConcatenator::pClassPointer = NULL;

// Class Engine.SoundNodeConcatenatorRadio
// 0x0000 (0x0074 - 0x0074)
class USoundNodeConcatenatorRadio : public USoundNode {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2439];

        return pClassPointer;
    };
};

UClass* USoundNodeConcatenatorRadio::pClassPointer = NULL;

// Class Engine.SoundNodeDelay
// 0x002C (0x00A0 - 0x0074)
class USoundNodeDelay : public USoundNode {
   public:
    float DelayMin;  // 0x0074 (0x0004) [0x0000000000000000]
    float DelayMax;  // 0x0078 (0x0004) [0x0000000000000000]
    struct FRawDistributionFloat
        DelayDuration;  // 0x007C (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2441];

        return pClassPointer;
    };
};

UClass* USoundNodeDelay::pClassPointer = NULL;

// Class Engine.SoundNodeDistanceCrossFade
// 0x0010 (0x0084 - 0x0074)
class USoundNodeDistanceCrossFade : public USoundNode {
   public:
    TArray<struct FDistanceDatum>
        CrossFadeInput;  // 0x0074 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2443];

        return pClassPointer;
    };
};

UClass* USoundNodeDistanceCrossFade::pClassPointer = NULL;

// Class Engine.SoundNodeDoppler
// 0x0004 (0x0078 - 0x0074)
class USoundNodeDoppler : public USoundNode {
   public:
    float DopplerIntensity;  // 0x0074 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2445];

        return pClassPointer;
    };
};

UClass* USoundNodeDoppler::pClassPointer = NULL;

// Class Engine.SoundNodeEnveloper
// 0x0024 (0x0098 - 0x0074)
class USoundNodeEnveloper : public USoundNode {
   public:
    float LoopStart;              // 0x0074 (0x0004) [0x0000000000000000]
    float LoopEnd;                // 0x0078 (0x0004) [0x0000000000000000]
    float DurationAfterLoop;      // 0x007C (0x0004) [0x0000000000000000]
    int LoopCount;                // 0x0080 (0x0004) [0x0000000000000000]
    DWORD bLoopIndefinitely : 1;  // 0x0084 (0x0004) [0x0000000000000000]
                                  // [0x00000001]
    DWORD bLoop : 1;  // 0x0084 (0x0004) [0x0000000000000000] [0x00000002]
    class UDistributionFloatConstantCurve*
        VolumeInterpCurve;  // 0x0088 (0x0008) [0x0000000000000000]
    class UDistributionFloatConstantCurve*
        PitchInterpCurve;  // 0x0090 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2447];

        return pClassPointer;
    };
};

UClass* USoundNodeEnveloper::pClassPointer = NULL;

// Class Engine.SoundNodeLooping
// 0x0030 (0x00A4 - 0x0074)
class USoundNodeLooping : public USoundNode {
   public:
    DWORD bLoopIndefinitely : 1;  // 0x0074 (0x0004) [0x0000000000000000]
                                  // [0x00000001]
    float LoopCountMin;           // 0x0078 (0x0004) [0x0000000000000000]
    float LoopCountMax;           // 0x007C (0x0004) [0x0000000000000000]
    struct FRawDistributionFloat
        LoopCount;  // 0x0080 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2449];

        return pClassPointer;
    };
};

UClass* USoundNodeLooping::pClassPointer = NULL;

// Class Engine.SoundNodeMature
// 0x0000 (0x0074 - 0x0074)
class USoundNodeMature : public USoundNode {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2451];

        return pClassPointer;
    };
};

UClass* USoundNodeMature::pClassPointer = NULL;

// Class Engine.SoundNodeMixer
// 0x0010 (0x0084 - 0x0074)
class USoundNodeMixer : public USoundNode {
   public:
    TArray<float> InputVolume;  // 0x0074 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2453];

        return pClassPointer;
    };
};

UClass* USoundNodeMixer::pClassPointer = NULL;

// Class Engine.SoundNodeModulator
// 0x0058 (0x00CC - 0x0074)
class USoundNodeModulator : public USoundNode {
   public:
    float PitchMin;   // 0x0074 (0x0004) [0x0000000000000000]
    float PitchMax;   // 0x0078 (0x0004) [0x0000000000000000]
    float VolumeMin;  // 0x007C (0x0004) [0x0000000000000000]
    float VolumeMax;  // 0x0080 (0x0004) [0x0000000000000000]
    struct FRawDistributionFloat
        PitchModulation;  // 0x0084 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        VolumeModulation;  // 0x00A8 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2455];

        return pClassPointer;
    };
};

UClass* USoundNodeModulator::pClassPointer = NULL;

// Class Engine.SoundNodeModulatorContinuous
// 0x0048 (0x00BC - 0x0074)
class USoundNodeModulatorContinuous : public USoundNode {
   public:
    struct FRawDistributionFloat
        PitchModulation;  // 0x0074 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        VolumeModulation;  // 0x0098 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2457];

        return pClassPointer;
    };
};

UClass* USoundNodeModulatorContinuous::pClassPointer = NULL;

// Class Engine.SoundNodeOscillator
// 0x00B4 (0x0128 - 0x0074)
class USoundNodeOscillator : public USoundNode {
   public:
    DWORD bModulateVolume : 1;  // 0x0074 (0x0004) [0x0000000000000000]
                                // [0x00000001]
    DWORD bModulatePitch : 1;   // 0x0074 (0x0004) [0x0000000000000000]
                                // [0x00000002]
    float AmplitudeMin;         // 0x0078 (0x0004) [0x0000000000000000]
    float AmplitudeMax;         // 0x007C (0x0004) [0x0000000000000000]
    float FrequencyMin;         // 0x0080 (0x0004) [0x0000000000000000]
    float FrequencyMax;         // 0x0084 (0x0004) [0x0000000000000000]
    float OffsetMin;            // 0x0088 (0x0004) [0x0000000000000000]
    float OffsetMax;            // 0x008C (0x0004) [0x0000000000000000]
    float CenterMin;            // 0x0090 (0x0004) [0x0000000000000000]
    float CenterMax;            // 0x0094 (0x0004) [0x0000000000000000]
    struct FRawDistributionFloat
        Amplitude;  // 0x0098 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        Frequency;  // 0x00BC (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        Offset;  // 0x00E0 (0x0024) [0x0000000000000000]
    struct FRawDistributionFloat
        Center;  // 0x0104 (0x0024) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2459];

        return pClassPointer;
    };
};

UClass* USoundNodeOscillator::pClassPointer = NULL;

// Class Engine.SoundNodeRandom
// 0x002C (0x00A0 - 0x0074)
class USoundNodeRandom : public USoundNode {
   public:
    TArray<float> Weights;     // 0x0074 (0x0010) [0x0000000000000000]
    int PreselectAtLevelLoad;  // 0x0084 (0x0004) [0x0000000000000000]
    DWORD
        bRandomizeWithoutReplacement : 1;  // 0x0088 (0x0004)
                                           // [0x0000000000000000] [0x00000001]
    TArray<DWORD> HasBeenUsed;  // 0x008C (0x0010) [0x0000000000000000]
    int NumRandomUsed;          // 0x009C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2461];

        return pClassPointer;
    };
};

UClass* USoundNodeRandom::pClassPointer = NULL;

// Class Engine.SoundNodeWave
// 0x0304 (0x0378 - 0x0074)
class USoundNodeWave : public USoundNode {
   public:
    int CompressionQuality;  // 0x0074 (0x0004) [0x0000000000000000]
    DWORD bForceRealTimeDecompression : 1;  // 0x0078 (0x0004)
                                            // [0x0000000000000000] [0x00000001]
    DWORD
        bLoopingSound : 1;  // 0x0078 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bDynamicResource : 1;  // 0x0078 (0x0004) [0x0000000000000000]
                                 // [0x00000004]
    DWORD bUseTTS : 1;      // 0x0078 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bProcedural : 1;  // 0x0078 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bMature : 1;      // 0x0078 (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bManualWordWrap : 1;  // 0x0078 (0x0004) [0x0000000000000000]
                                // [0x00000040]
    DWORD bSingleLine : 1;  // 0x0078 (0x0004) [0x0000000000000000] [0x00000080]
    DWORD bIsVoIP : 1;      // 0x0078 (0x0004) [0x0000000000000000] [0x00000100]
    unsigned char TTSSpeaker;         // 0x007C (0x0001) [0x0000000000000000]
    unsigned char DecompressionType;  // 0x007D (0x0001) [0x0000000000000000]
    unsigned char MobileDetailMode;   // 0x007E (0x0001) [0x0000000000000000]
    struct FString SpokenText;        // 0x0080 (0x0010) [0x0000000000000000]
    float Volume;                     // 0x0090 (0x0004) [0x0000000000000000]
    float Pitch;                      // 0x0094 (0x0004) [0x0000000000000000]
    float Duration;                   // 0x0098 (0x0004) [0x0000000000000000]
    int NumChannels;                  // 0x009C (0x0004) [0x0000000000000000]
    int SampleRate;                   // 0x00A0 (0x0004) [0x0000000000000000]
    TArray<int> ChannelOffsets;       // 0x00A4 (0x0010) [0x0000000000000000]
    TArray<int> ChannelSizes;         // 0x00B4 (0x0010) [0x0000000000000000]
    struct FUntypedBulkData_Mirror
        RawData;                         // 0x00C4 (0x0040) [0x0000000000000000]
    struct FPointer VorbisDecompressor;  // 0x0104 (0x0008) [0x0000000000000000]
    struct FPointer RawPCMData;          // 0x010C (0x0008) [0x0000000000000000]
    int RawPCMDataSize;                  // 0x0114 (0x0004) [0x0000000000000000]
    struct FUntypedBulkData_Mirror
        CompressedPCData;  // 0x0118 (0x0040) [0x0000000000000000]
    struct FUntypedBulkData_Mirror
        CompressedXbox360Data;  // 0x0158 (0x0040) [0x0000000000000000]
    struct FUntypedBulkData_Mirror
        CompressedDingoData;  // 0x0198 (0x0040) [0x0000000000000000]
    struct FUntypedBulkData_Mirror
        CompressedPS3Data;  // 0x01D8 (0x0040) [0x0000000000000000]
    struct FUntypedBulkData_Mirror
        CompressedWiiUData;  // 0x0218 (0x0040) [0x0000000000000000]
    struct FUntypedBulkData_Mirror
        CompressedIPhoneData;  // 0x0258 (0x0040) [0x0000000000000000]
    struct FUntypedBulkData_Mirror
        CompressedFlashData;  // 0x0298 (0x0040) [0x0000000000000000]
    struct FUntypedBulkData_Mirror
        CompressedOrbisData;       // 0x02D8 (0x0040) [0x0000000000000000]
    int ResourceID;                // 0x0318 (0x0004) [0x0000000000000000]
    int ResourceSize;              // 0x031C (0x0004) [0x0000000000000000]
    struct FPointer ResourceData;  // 0x0320 (0x0008) [0x0000000000000000]
    TArray<struct FSubtitleCue>
        Subtitles;           // 0x0328 (0x0010) [0x0000000000000000]
    struct FString Comment;  // 0x0338 (0x0010) [0x0000000000000000]
    TArray<struct FLocalizedSubtitle>
        LocalizedSubtitles;              // 0x0348 (0x0010) [0x0000000000000000]
    struct FString SourceFilePath;       // 0x0358 (0x0010) [0x0000000000000000]
    struct FString SourceFileTimestamp;  // 0x0368 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2463];

        return pClassPointer;
    };

    void eventGeneratePCMData();
};

UClass* USoundNodeWave::pClassPointer = NULL;

// Class Engine.SoundNodeWaveStreaming
// 0x0014 (0x038C - 0x0378)
class USoundNodeWaveStreaming : public USoundNodeWave {
   public:
    TArray<unsigned char> QueuedAudio;  // 0x0378 (0x0010) [0x0000000000000000]
    float InactiveDuration;             // 0x0388 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2465];

        return pClassPointer;
    };

    void eventGeneratePCMData();
    void eventAvailableAudioBytes();
    void eventResetAudio();
    void eventQueueSilence();
    void eventQueueAudio();
};

UClass* USoundNodeWaveStreaming::pClassPointer = NULL;

// Class Engine.SoundNodeWaveParam
// 0x0008 (0x007C - 0x0074)
class USoundNodeWaveParam : public USoundNode {
   public:
    struct FName WaveParameterName;  // 0x0074 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2467];

        return pClassPointer;
    };
};

UClass* USoundNodeWaveParam::pClassPointer = NULL;

// Class Engine.LandscapeProxy
// 0x0134 (0x0378 - 0x0244)
class ALandscapeProxy : public AInfo {
   public:
    struct FGuid LandscapeGuid;  // 0x0244 (0x0010) [0x0000000000000000]
    int MaxLODLevel;             // 0x0254 (0x0004) [0x0000000000000000]
    class UPhysicalMaterial*
        DefaultPhysMaterial;            // 0x0258 (0x0008) [0x0000000000000000]
    float StreamingDistanceMultiplier;  // 0x0260 (0x0004) [0x0000000000000000]
    class UMaterialInterface*
        LandscapeMaterial;    // 0x0264 (0x0008) [0x0000000000000000]
    float LODDistanceFactor;  // 0x026C (0x0004) [0x0000000000000000]
    TArray<class ULandscapeComponent*>
        LandscapeComponents;  // 0x0270 (0x0010) [0x0000000000000000]
    TArray<class ULandscapeHeightfieldCollisionComponent*>
        CollisionComponents;  // 0x0280 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00
        [0x48];  // 0x0290 (0x0048) UNKNOWN PROPERTY: MapProperty
                 // Engine.LandscapeProxy.MaterialInstanceConstantMap
    unsigned char
        UnknownData01[0x48];  // 0x02D8 (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.LandscapeProxy.WeightmapUsageMap
    float StaticLightingResolution;  // 0x0320 (0x0004) [0x0000000000000000]
    float SplatterMapResolution;     // 0x0324 (0x0004) [0x0000000000000000]
    struct FLightingChannelContainer
        LightingChannels;              // 0x0328 (0x0004) [0x0000000000000000]
    class ALandscape* LandscapeActor;  // 0x032C (0x0008) [0x0000000000000000]
    DWORD bIsProxy : 1;  // 0x0334 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bIsSetup : 1;  // 0x0334 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bResetup : 1;  // 0x0334 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bIsMovingToLevel : 1;  // 0x0334 (0x0004) [0x0000000000000000]
                                 // [0x00000008]
    struct FLightmassPrimitiveSettings
        LightmassSettings;  // 0x0338 (0x001C) [0x0000000000000000]
    int CollisionMipLevel;  // 0x0354 (0x0004) [0x0000000000000000]
    int MobileLODBias;      // 0x0358 (0x0004) [0x0000000000000000]
    TArray<struct FLandscapeLayerStruct>
        LayerInfoObjs;        // 0x035C (0x0010) [0x0000000000000000]
    int ComponentSizeQuads;   // 0x036C (0x0004) [0x0000000000000000]
    int SubsectionSizeQuads;  // 0x0370 (0x0004) [0x0000000000000000]
    int NumSubsections;       // 0x0374 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2469];

        return pClassPointer;
    };
};

UClass* ALandscapeProxy::pClassPointer = NULL;

// Class Engine.Landscape
// 0x0020 (0x0398 - 0x0378)
class ALandscape : public ALandscapeProxy {
   public:
    TArray<struct FName> LayerNames;  // 0x0378 (0x0010) [0x0000000000000000]
    TArray<struct FLandscapeLayerInfo>
        LayerInfos;  // 0x0388 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2471];

        return pClassPointer;
    };
};

UClass* ALandscape::pClassPointer = NULL;

// Class Engine.Terrain
// 0x0134 (0x0378 - 0x0244)
class ATerrain : public AInfo {
   public:
    TArray<struct FTerrainHeight>
        Heights;  // 0x0244 (0x0010) [0x0000000000000000]
    TArray<struct FTerrainInfoData>
        InfoData;  // 0x0254 (0x0010) [0x0000000000000000]
    TArray<struct FTerrainLayer>
        Layers;          // 0x0264 (0x0010) [0x0000000000000000]
    int NormalMapLayer;  // 0x0274 (0x0004) [0x0000000000000000]
    TArray<struct FTerrainDecoLayer>
        DecoLayers;                      // 0x0278 (0x0010) [0x0000000000000000]
    TArray<struct FAlphaMap> AlphaMaps;  // 0x0288 (0x0010) [0x0000000000000000]
    TArray<class UTerrainComponent*>
        TerrainComponents;  // 0x0298 (0x0010) [0x0000000000000000]
    int NumSectionsX;       // 0x02A8 (0x0004) [0x0000000000000000]
    int NumSectionsY;       // 0x02AC (0x0004) [0x0000000000000000]
    TArray<struct ATerrain_FTerrainWeightedMaterial>
        WeightedMaterials;  // 0x02B0 (0x0010) [0x0000000000000000]
    TArray<class UTerrainWeightMapTexture*>
        WeightedTextureMaps;          // 0x02C0 (0x0010) [0x0000000000000000]
    int MaxTesselationLevel;          // 0x02D0 (0x0004) [0x0000000000000000]
    int MinTessellationLevel;         // 0x02D4 (0x0004) [0x0000000000000000]
    float TesselationDistanceScale;   // 0x02D8 (0x0004) [0x0000000000000000]
    float TessellationCheckDistance;  // 0x02DC (0x0004) [0x0000000000000000]
    int CollisionTesselationLevel;    // 0x02E0 (0x0004) [0x0000000000000000]
    struct FCachedTerrainMaterialArray
        CachedTerrainMaterials[0x2];  // 0x02E4 (0x0020) [0x0000000000000000]
    int NumVerticesX;                 // 0x0304 (0x0004) [0x0000000000000000]
    int NumVerticesY;                 // 0x0308 (0x0004) [0x0000000000000000]
    int NumPatchesX;                  // 0x030C (0x0004) [0x0000000000000000]
    int NumPatchesY;                  // 0x0310 (0x0004) [0x0000000000000000]
    int MaxComponentSize;             // 0x0314 (0x0004) [0x0000000000000000]
    int StaticLightingResolution;     // 0x0318 (0x0004) [0x0000000000000000]
    DWORD
        bIsOverridingLightResolution : 1;  // 0x031C (0x0004)
                                           // [0x0000000000000000] [0x00000001]
    DWORD bBilinearFilterLightmapGeneration : 1;  // 0x031C (0x0004)
                                                  // [0x0000000000000000]
                                                  // [0x00000002]
    DWORD bCastShadow : 1;  // 0x031C (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bForceDirectLightMap : 1;  // 0x031C (0x0004) [0x0000000000000000]
                                     // [0x00000008]
    DWORD bCastDynamicShadow : 1;    // 0x031C (0x0004) [0x0000000000000000]
                                     // [0x00000010]
    DWORD bEnableSpecular : 1;       // 0x031C (0x0004) [0x0000000000000000]
                                     // [0x00000020]
    DWORD bBlockRigidBody : 1;       // 0x031C (0x0004) [0x0000000000000000]
                                     // [0x00000040]
    DWORD bAllowRigidBodyUnderneath : 1;  // 0x031C (0x0004)
                                          // [0x0000000000000000] [0x00000080]
    DWORD bAcceptsDynamicLights : 1;  // 0x031C (0x0004) [0x0000000000000000]
                                      // [0x00000100]
    DWORD bMorphingEnabled : 1;       // 0x031C (0x0004) [0x0000000000000000]
                                      // [0x00000200]
    DWORD bMorphingGradientsEnabled : 1;  // 0x031C (0x0004)
                                          // [0x0000000000000000] [0x00000400]
    DWORD bLocked : 1;  // 0x031C (0x0004) [0x0000000000000000] [0x00000800]
    DWORD bHeightmapLocked : 1;   // 0x031C (0x0004) [0x0000000000000000]
                                  // [0x00001000]
    DWORD bShowingCollision : 1;  // 0x031C (0x0004) [0x0000000000000000]
                                  // [0x00002000]
    DWORD bUseWorldOriginTextureUVs : 1;  // 0x031C (0x0004)
                                          // [0x0000000000000000] [0x00004000]
    DWORD bShowWireframe : 1;  // 0x031C (0x0004) [0x0000000000000000]
                               // [0x00008000]
    class UPhysicalMaterial*
        TerrainPhysMaterialOverride;  // 0x0320 (0x0008) [0x0000000000000000]
    struct FLightingChannelContainer
        LightingChannels;  // 0x0328 (0x0004) [0x0000000000000000]
    struct FLightmassPrimitiveSettings
        LightmassSettings;  // 0x032C (0x001C) [0x0000000000000000]
    struct FPointer
        ReleaseResourcesFence;    // 0x0348 (0x0008) [0x0000000000000000]
    int EditorTessellationLevel;  // 0x0350 (0x0004) [0x0000000000000000]
    TArray<struct FSelectedTerrainVertex>
        SelectedVertices;          // 0x0354 (0x0010) [0x0000000000000000]
    struct FColor WireframeColor;  // 0x0364 (0x0004) [0x0000000000000000]
    struct FGuid LightingGuid;     // 0x0368 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2473];

        return pClassPointer;
    };

    void eventPostBeginPlay();
    void CalcLayerBounds();
};

UClass* ATerrain::pClassPointer = NULL;

// Class Engine.LandscapeGizmoActor
// 0x0020 (0x0264 - 0x0244)
class ALandscapeGizmoActor : public AActor {
   public:
    float Width;           // 0x0244 (0x0004) [0x0000000000000000]
    float Height;          // 0x0248 (0x0004) [0x0000000000000000]
    float LengthZ;         // 0x024C (0x0004) [0x0000000000000000]
    float MarginZ;         // 0x0250 (0x0004) [0x0000000000000000]
    float MinRelativeZ;    // 0x0254 (0x0004) [0x0000000000000000]
    float RelativeScaleZ;  // 0x0258 (0x0004) [0x0000000000000000]
    class ULandscapeInfo*
        TargetLandscapeInfo;  // 0x025C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2475];

        return pClassPointer;
    };
};

UClass* ALandscapeGizmoActor::pClassPointer = NULL;

// Class Engine.LandscapeGizmoActiveActor
// 0x0120 (0x0384 - 0x0264)
class ALandscapeGizmoActiveActor : public ALandscapeGizmoActor {
   public:
    unsigned char DataType;  // 0x0264 (0x0001) [0x0000000000000000]
    unsigned char
        UnknownData00[0x48];  // 0x0268 (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.LandscapeGizmoActiveActor.SelectedData
    class UTexture2D* GizmoTexture;  // 0x02B0 (0x0008) [0x0000000000000000]
    struct FVector2D TextureScale;   // 0x02B8 (0x0008) [0x0000000000000000]
    TArray<struct FVector>
        SampledHeight;  // 0x02C0 (0x0010) [0x0000000000000000]
    TArray<struct FVector>
        SampledNormal;                 // 0x02D0 (0x0010) [0x0000000000000000]
    int SampleSizeX;                   // 0x02E0 (0x0004) [0x0000000000000000]
    int SampleSizeY;                   // 0x02E4 (0x0004) [0x0000000000000000]
    float CachedWidth;                 // 0x02E8 (0x0004) [0x0000000000000000]
    float CachedHeight;                // 0x02EC (0x0004) [0x0000000000000000]
    float CachedScaleXY;               // 0x02F0 (0x0004) [0x0000000000000000]
    struct FVector FrustumVerts[0x8];  // 0x02F4 (0x0060) [0x0000000000000000]
    class UMaterial* GizmoMaterial;    // 0x0354 (0x0008) [0x0000000000000000]
    class UMaterialInstance*
        GizmoDataMaterial;               // 0x035C (0x0008) [0x0000000000000000]
    class UMaterial* GizmoMeshMaterial;  // 0x0364 (0x0008) [0x0000000000000000]
    class UMaterial*
        GizmoMeshMaterial2;           // 0x036C (0x0008) [0x0000000000000000]
    TArray<struct FName> LayerNames;  // 0x0374 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2477];

        return pClassPointer;
    };
};

UClass* ALandscapeGizmoActiveActor::pClassPointer = NULL;

// Class Engine.LandscapeComponent
// 0x0130 (0x0368 - 0x0238)
class ULandscapeComponent : public UPrimitiveComponent {
   public:
    int SectionBaseX;         // 0x0238 (0x0004) [0x0000000000000000]
    int SectionBaseY;         // 0x023C (0x0004) [0x0000000000000000]
    int ComponentSizeQuads;   // 0x0240 (0x0004) [0x0000000000000000]
    int SubsectionSizeQuads;  // 0x0244 (0x0004) [0x0000000000000000]
    int NumSubsections;       // 0x0248 (0x0004) [0x0000000000000000]
    class UMaterialInterface*
        OverrideMaterial;  // 0x024C (0x0008) [0x0000000000000000]
    class UMaterialInstanceConstant*
        MaterialInstance;  // 0x0254 (0x0008) [0x0000000000000000]
    TArray<struct FWeightmapLayerAllocationInfo>
        WeightmapLayerAllocations;  // 0x025C (0x0010) [0x0000000000000000]
    TArray<class UTexture2D*>
        WeightmapTextures;               // 0x026C (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x4];    // 0x027C (0x0004) MISSED OFFSET
    struct FVector4 WeightmapScaleBias;  // 0x0280 (0x0010) [0x0000000000000000]
    float WeightmapSubsectionOffset;     // 0x0290 (0x0004) [0x0000000000000000]
    unsigned char UnknownData01[0xC];    // 0x0294 (0x000C) MISSED OFFSET
    struct FVector4 HeightmapScaleBias;  // 0x02A0 (0x0010) [0x0000000000000000]
    class UTexture2D* HeightmapTexture;  // 0x02B0 (0x0008) [0x0000000000000000]
    struct FBoxSphereBounds
        CachedBoxSphereBounds;   // 0x02B8 (0x001C) [0x0000000000000000]
    struct FBox CachedLocalBox;  // 0x02D4 (0x001C) [0x0000000000000000]
    struct FGuid LightingGuid;   // 0x02F0 (0x0010) [0x0000000000000000]
    TArray<class UShadowMap2D*>
        ShadowMaps;  // 0x0300 (0x0010) [0x0000000000000000]
    TArray<struct FGuid>
        IrrelevantLights;          // 0x0310 (0x0010) [0x0000000000000000]
    struct FLightMapRef LightMap;  // 0x0320 (0x0008) [0x0000000000000000]
    int SplatterMapRes;            // 0x0328 (0x0004) [0x0000000000000000]
    class UTWSplatterMap2D*
        SplatterMap;                     // 0x032C (0x0008) [0x0000000000000000]
    struct FPointer EditToolRenderData;  // 0x0334 (0x0008) [0x0000000000000000]
    int CollisionMipLevel;               // 0x033C (0x0004) [0x0000000000000000]
    struct FPointer PlatformData;        // 0x0340 (0x0008) [0x0000000000000000]
    int PlatformDataSize;                // 0x0348 (0x0004) [0x0000000000000000]
    DWORD
        bNeedPostUndo : 1;  // 0x034C (0x0004) [0x0000000000000000] [0x00000001]
    int ForcedLOD;          // 0x0350 (0x0004) [0x0000000000000000]
    unsigned char NeighborLOD[0x8];      // 0x0354 (0x0008) [0x0000000000000000]
    unsigned char NeighborLODBias[0x8];  // 0x035C (0x0008) [0x0000000000000000]
    int LODBias;                         // 0x0364 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2479];

        return pClassPointer;
    };
};

UClass* ULandscapeComponent::pClassPointer = NULL;

// Class Engine.LandscapeGizmoRenderComponent
// 0x0000 (0x0238 - 0x0238)
class ULandscapeGizmoRenderComponent : public UPrimitiveComponent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2481];

        return pClassPointer;
    };
};

UClass* ULandscapeGizmoRenderComponent::pClassPointer = NULL;

// Class Engine.LandscapeHeightfieldCollisionComponent
// 0x0100 (0x0338 - 0x0238)
class ULandscapeHeightfieldCollisionComponent : public UPrimitiveComponent {
   public:
    struct FUntypedBulkData_Mirror
        CollisionHeightData;  // 0x0238 (0x0040) [0x0000000000000000]
    TArray<struct FName>
        ComponentLayers;  // 0x0278 (0x0010) [0x0000000000000000]
    struct FUntypedBulkData_Mirror
        DominantLayerData;   // 0x0288 (0x0040) [0x0000000000000000]
    int SectionBaseX;        // 0x02C8 (0x0004) [0x0000000000000000]
    int SectionBaseY;        // 0x02CC (0x0004) [0x0000000000000000]
    int CollisionSizeQuads;  // 0x02D0 (0x0004) [0x0000000000000000]
    float CollisionScale;    // 0x02D4 (0x0004) [0x0000000000000000]
    TArray<unsigned char>
        CollisionQuadFlags;  // 0x02D8 (0x0010) [0x0000000000000000]
    TArray<class UPhysicalMaterial*>
        PhysicalMaterials;          // 0x02E8 (0x0010) [0x0000000000000000]
    struct FPointer RBHeightfield;  // 0x02F8 (0x0008) [0x0000000000000000]
    struct FBoxSphereBounds
        CachedBoxSphereBounds;  // 0x0300 (0x001C) [0x0000000000000000]
    DWORD
        bIncludeHoles : 1;  // 0x031C (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bHeightFieldDataHasHole : 1;  // 0x031C (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    struct FVector4
        LandscapeLightmapScaleBias;  // 0x0320 (0x0010) [0x0000000000000000]
    class UTWSplatterMap2D*
        SplatterMap;  // 0x0330 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2483];

        return pClassPointer;
    };
};

UClass* ULandscapeHeightfieldCollisionComponent::pClassPointer = NULL;

// Class Engine.TerrainComponent
// 0x0098 (0x02D0 - 0x0238)
class UTerrainComponent : public UPrimitiveComponent {
   public:
    TArray<class UShadowMap2D*>
        ShadowMaps;  // 0x0238 (0x0010) [0x0000000000000000]
    TArray<struct FGuid>
        IrrelevantLights;           // 0x0248 (0x0010) [0x0000000000000000]
    struct FPointer TerrainObject;  // 0x0258 (0x0008) [0x0000000000000000]
    int SectionBaseX;               // 0x0260 (0x0004) [0x0000000000000000]
    int SectionBaseY;               // 0x0264 (0x0004) [0x0000000000000000]
    int SectionSizeX;               // 0x0268 (0x0004) [0x0000000000000000]
    int SectionSizeY;               // 0x026C (0x0004) [0x0000000000000000]
    int TrueSectionSizeX;           // 0x0270 (0x0004) [0x0000000000000000]
    int TrueSectionSizeY;           // 0x0274 (0x0004) [0x0000000000000000]
    struct FLightMapRef LightMap;   // 0x0278 (0x0008) [0x0000000000000000]
    TArray<struct FTerrainPatchBounds>
        PatchBounds;  // 0x0280 (0x0010) [0x0000000000000000]
    TArray<struct FTerrainMaterialMask>
        BatchMaterials;            // 0x0290 (0x0010) [0x0000000000000000]
    int FullBatch;                 // 0x02A0 (0x0004) [0x0000000000000000]
    struct FTerrainBVTree BVTree;  // 0x02A4 (0x0010) [0x0000000000000000]
    TArray<struct FVector>
        CollisionVertices;             // 0x02B4 (0x0010) [0x0000000000000000]
    struct FPointer RBHeightfield;     // 0x02C4 (0x0008) [0x0000000000000000]
    DWORD bDisplayCollisionLevel : 1;  // 0x02CC (0x0004) [0x0000000000000000]
                                       // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2485];

        return pClassPointer;
    };
};

UClass* UTerrainComponent::pClassPointer = NULL;

// Class Engine.LandscapeInfo
// 0x02BC (0x031C - 0x0060)
class ULandscapeInfo : public UObject {
   public:
    struct FGuid LandscapeGuid;  // 0x0060 (0x0010) [0x0000000000000000]
    unsigned char
        UnknownData00[0x48];  // 0x0070 (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.LandscapeInfo.LayerInfoMap
    struct FPointer DataInterface;  // 0x00B8 (0x0008) [0x0000000000000000]
    unsigned char
        UnknownData01[0x48];  // 0x00C0 (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.LandscapeInfo.XYtoComponentMap
    unsigned char
        UnknownData02[0x48];  // 0x0108 (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.LandscapeInfo.XYtoCollisionComponentMap
    class ALandscapeProxy*
        LandscapeProxy;  // 0x0150 (0x0008) [0x0000000000000000]
    unsigned char
        UnknownData03[0x48];  // 0x0158 (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.LandscapeInfo.XYtoAddCollisionMap
    struct FSet_Mirror Proxies;  // 0x01A0 (0x0048) [0x0000000000000000]
    struct FSet_Mirror
        SelectedComponents;  // 0x01E8 (0x0048) [0x0000000000000000]
    struct FSet_Mirror
        SelectedCollisionComponents;  // 0x0230 (0x0048) [0x0000000000000000]
    struct FSet_Mirror
        SelectedRegionComponents;  // 0x0278 (0x0048) [0x0000000000000000]
    unsigned char
        UnknownData04[0x48];  // 0x02C0 (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.LandscapeInfo.SelectedRegion
    struct FString HeightmapFilePath;  // 0x0308 (0x0010) [0x0000000000000000]
    DWORD bIsValid : 1;  // 0x0318 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2487];

        return pClassPointer;
    };
};

UClass* ULandscapeInfo::pClassPointer = NULL;

// Class Engine.LandscapeLayerInfoObject
// 0x0018 (0x0078 - 0x0060)
class ULandscapeLayerInfoObject : public UObject {
   public:
    struct FName LayerName;  // 0x0060 (0x0008) [0x0000000000000000]
    class UPhysicalMaterial*
        PhysMaterial;          // 0x0068 (0x0008) [0x0000000000000000]
    float Hardness;            // 0x0070 (0x0004) [0x0000000000000000]
    DWORD bNoWeightBlend : 1;  // 0x0074 (0x0004) [0x0000000000000000]
                               // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2489];

        return pClassPointer;
    };
};

UClass* ULandscapeLayerInfoObject::pClassPointer = NULL;

// Class Engine.TerrainWeightMapTexture
// 0x0018 (0x0258 - 0x0240)
class UTerrainWeightMapTexture : public UTexture2D {
   public:
    class ATerrain* ParentTerrain;  // 0x0240 (0x0008) [0x0000000000000000]
    TArray<struct FPointer>
        WeightedMaterials;  // 0x0248 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2491];

        return pClassPointer;
    };
};

UClass* UTerrainWeightMapTexture::pClassPointer = NULL;

// Class Engine.TerrainLayerSetup
// 0x0010 (0x0070 - 0x0060)
class UTerrainLayerSetup : public UObject {
   public:
    TArray<struct FTerrainFilteredMaterial>
        Materials;  // 0x0060 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2493];

        return pClassPointer;
    };

    void PostBeginPlay();
};

UClass* UTerrainLayerSetup::pClassPointer = NULL;

// Class Engine.TerrainMaterial
// 0x0068 (0x00C8 - 0x0060)
class UTerrainMaterial : public UObject {
   public:
    struct FMatrix LocalToMapping;       // 0x0060 (0x0040) [0x0000000000000000]
    unsigned char MappingType;           // 0x00A0 (0x0001) [0x0000000000000000]
    float MappingScale;                  // 0x00A4 (0x0004) [0x0000000000000000]
    float MappingRotation;               // 0x00A8 (0x0004) [0x0000000000000000]
    float MappingPanU;                   // 0x00AC (0x0004) [0x0000000000000000]
    float MappingPanV;                   // 0x00B0 (0x0004) [0x0000000000000000]
    class UMaterialInterface* Material;  // 0x00B4 (0x0008) [0x0000000000000000]
    class UTexture2D* DisplacementMap;   // 0x00BC (0x0008) [0x0000000000000000]
    float DisplacementScale;             // 0x00C4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2495];

        return pClassPointer;
    };
};

UClass* UTerrainMaterial::pClassPointer = NULL;

// Class Engine.DataStoreClient
// 0x0050 (0x00C0 - 0x0070)
class UDataStoreClient : public UUIRoot {
   public:
    TArray<struct FString>
        GlobalDataStoreClasses;  // 0x0070 (0x0010) [0x0000000000000000]
    TArray<class UUIDataStore*>
        GlobalDataStores;  // 0x0080 (0x0010) [0x0000000000000000]
    TArray<struct FString>
        PlayerDataStoreClassNames;  // 0x0090 (0x0010) [0x0000000000000000]
    TArray<class UClass*>
        PlayerDataStoreClasses;  // 0x00A0 (0x0010) [0x0000000000000000]
    TArray<struct FPlayerDataStoreGroup>
        PlayerDataStores;  // 0x00B0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2497];

        return pClassPointer;
    };

    void DebugDumpDataStoreInfo();
    void eventNotifyGameSessionEnded();
    void FindDataStoreClass();
    void GetPlayerDataStoreClasses();
    void FindPlayerDataStoreIndex();
    void UnregisterDataStore();
    void RegisterDataStore();
    void CreateDataStore();
    void FindDataStore();
};

UClass* UDataStoreClient::pClassPointer = NULL;

// Class Engine.Console
// 0x01C0 (0x0270 - 0x00B0)
class UConsole : public UInteraction {
   public:
    class ULocalPlayer*
        ConsoleTargetPlayer;  // 0x00B0 (0x0008) [0x0000000000000000]
    class UTexture2D*
        DefaultTexture_Black;  // 0x00B8 (0x0008) [0x0000000000000000]
    class UTexture2D*
        DefaultTexture_White;           // 0x00C0 (0x0008) [0x0000000000000000]
    struct FName ConsoleKey;            // 0x00C8 (0x0008) [0x0000000000000000]
    struct FName TypeKey;               // 0x00D0 (0x0008) [0x0000000000000000]
    int MaxScrollbackSize;              // 0x00D8 (0x0004) [0x0000000000000000]
    TArray<struct FString> Scrollback;  // 0x00DC (0x0010) [0x0000000000000000]
    int SBHead;                         // 0x00EC (0x0004) [0x0000000000000000]
    int SBPos;                          // 0x00F0 (0x0004) [0x0000000000000000]
    int HistoryTop;                     // 0x00F4 (0x0004) [0x0000000000000000]
    int HistoryBot;                     // 0x00F8 (0x0004) [0x0000000000000000]
    int HistoryCur;                     // 0x00FC (0x0004) [0x0000000000000000]
    struct FString History[0x10];       // 0x0100 (0x0100) [0x0000000000000000]
    DWORD bNavigatingHistory : 1;       // 0x0200 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bCaptureKeyInput : 1;         // 0x0200 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bCtrl : 1;      // 0x0200 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bEnableUI : 1;  // 0x0200 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bAutoCompleteLocked : 1;  // 0x0200 (0x0004) [0x0000000000000000]
                                    // [0x00000010]
    DWORD bRequireCtrlToNavigateAutoComplete : 1;  // 0x0200 (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00000020]
    DWORD bIsRuntimeAutoCompleteUpToDate : 1;      // 0x0200 (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00000040]
    struct FString TypedStr;  // 0x0204 (0x0010) [0x0000000000000000]
    int TypedStrPos;          // 0x0214 (0x0004) [0x0000000000000000]
    TArray<struct FAutoCompleteCommand>
        ManualAutoCompleteList;  // 0x0218 (0x0010) [0x0000000000000000]
    TArray<struct FAutoCompleteCommand>
        AutoCompleteList;   // 0x0228 (0x0010) [0x0000000000000000]
    int AutoCompleteIndex;  // 0x0238 (0x0004) [0x0000000000000000]
    struct FAutoCompleteNode
        AutoCompleteTree;             // 0x023C (0x0024) [0x0000000000000000]
    TArray<int> AutoCompleteIndices;  // 0x0260 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2499];

        return pClassPointer;
    };

    void UpdateCompleteIndices();
    void BuildRuntimeAutoCompleteList();
    void AppendInputText();
    void ProcessControlKey();
    void FlushPlayerInput();
    void InputChar();
    void InputKey();
    void PostRender_Console();
    void StartTyping();
    void eventOutputText();
    void OutputTextLine();
    void ClearOutput();
    void ConsoleCommand();
    void PurgeCommandFromHistory();
    void SetCursorPos();
    void SetInputText();
    void Initialized();
};

UClass* UConsole::pClassPointer = NULL;

// Class Engine.Input
// 0x00C8 (0x0178 - 0x00B0)
class UInput : public UInteraction {
   public:
    TArray<struct FKeyBind> Bindings;   // 0x00B0 (0x0010) [0x0000000000000000]
    TArray<struct FName> PressedKeys;   // 0x00C0 (0x0010) [0x0000000000000000]
    int CurrentControllerId;            // 0x00D0 (0x0004) [0x0000000000000000]
    unsigned char CurrentEvent;         // 0x00D4 (0x0001) [0x0000000000000000]
    float CurrentDelta;                 // 0x00D8 (0x0004) [0x0000000000000000]
    float CurrentDeltaTime;             // 0x00DC (0x0004) [0x0000000000000000]
    unsigned char UnknownData00[0x48];  // 0x00E0 (0x0048) UNKNOWN PROPERTY:
                                        // MapProperty Engine.Input.NameToPtr
    TArray<struct FPointer> AxisArray;  // 0x0128 (0x0010) [0x0000000000000000]
    TArray<class USeqEvent_Input*>
        CachedInputEvents;  // 0x0138 (0x0010) [0x0000000000000000]
    TArray<class USeqEvent_AnalogInput*>
        CachedAnalogInputEvents;  // 0x0148 (0x0010) [0x0000000000000000]
    TArray<class USeqEvent_TouchInput*>
        CachedTouchInputEvents;  // 0x0158 (0x0010) [0x0000000000000000]
    TArray<struct FTouchTracker>
        CurrentTouches;  // 0x0168 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2501];

        return pClassPointer;
    };

    void SetBind();
    void GetBind();
    void ResetInput();
};

UClass* UInput::pClassPointer = NULL;

// Class Engine.PlayerInput
// 0x0148 (0x02C0 - 0x0178)
class UPlayerInput : public UInput {
   public:
    DWORD
        bUsingGamepad : 1;  // 0x0178 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD
        bInvertMouse : 1;   // 0x0178 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bInvertTurn : 1;  // 0x0178 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bWasForward : 1;  // 0x0178 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bWasBack : 1;     // 0x0178 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bWasLeft : 1;     // 0x0178 (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bWasRight : 1;    // 0x0178 (0x0004) [0x0000000000000000] [0x00000040]
    DWORD
        bEdgeForward : 1;  // 0x0178 (0x0004) [0x0000000000000000] [0x00000080]
    DWORD bEdgeBack : 1;   // 0x0178 (0x0004) [0x0000000000000000] [0x00000100]
    DWORD bEdgeLeft : 1;   // 0x0178 (0x0004) [0x0000000000000000] [0x00000200]
    DWORD bEdgeRight : 1;  // 0x0178 (0x0004) [0x0000000000000000] [0x00000400]
    DWORD bEnableMouseSmoothing : 1;  // 0x0178 (0x0004) [0x0000000000000000]
                                      // [0x00000800]
    DWORD bEnableFOVScaling : 1;      // 0x0178 (0x0004) [0x0000000000000000]
                                      // [0x00001000]
    DWORD bLockTurnUntilRelease : 1;  // 0x0178 (0x0004) [0x0000000000000000]
                                      // [0x00002000]
    struct FName LastAxisKeyName;     // 0x017C (0x0008) [0x0000000000000000]
    float DoubleClickTimer;           // 0x0184 (0x0004) [0x0000000000000000]
    float DoubleClickTime;            // 0x0188 (0x0004) [0x0000000000000000]
    float MouseSensitivity;           // 0x018C (0x0004) [0x0000000000000000]
    float aBaseX;                     // 0x0190 (0x0004) [0x0000000000000000]
    float aBaseY;                     // 0x0194 (0x0004) [0x0000000000000000]
    float aBaseZ;                     // 0x0198 (0x0004) [0x0000000000000000]
    float aMouseX;                    // 0x019C (0x0004) [0x0000000000000000]
    float aMouseY;                    // 0x01A0 (0x0004) [0x0000000000000000]
    float aForward;                   // 0x01A4 (0x0004) [0x0000000000000000]
    float aTurn;                      // 0x01A8 (0x0004) [0x0000000000000000]
    float aStrafe;                    // 0x01AC (0x0004) [0x0000000000000000]
    float aUp;                        // 0x01B0 (0x0004) [0x0000000000000000]
    float aLookUp;                    // 0x01B4 (0x0004) [0x0000000000000000]
    float aRightAnalogTrigger;        // 0x01B8 (0x0004) [0x0000000000000000]
    float aLeftAnalogTrigger;         // 0x01BC (0x0004) [0x0000000000000000]
    float aPS3AccelX;                 // 0x01C0 (0x0004) [0x0000000000000000]
    float aPS3AccelY;                 // 0x01C4 (0x0004) [0x0000000000000000]
    float aPS3AccelZ;                 // 0x01C8 (0x0004) [0x0000000000000000]
    float aPS3Gyro;                   // 0x01CC (0x0004) [0x0000000000000000]
    float aWiiUPointerX;              // 0x01D0 (0x0004) [0x0000000000000000]
    float aWiiUPointerY;              // 0x01D4 (0x0004) [0x0000000000000000]
    struct FVector aTilt;             // 0x01D8 (0x000C) [0x0000000000000000]
    struct FVector aRotationRate;     // 0x01E4 (0x000C) [0x0000000000000000]
    struct FVector aGravity;          // 0x01F0 (0x000C) [0x0000000000000000]
    struct FVector aAcceleration;     // 0x01FC (0x000C) [0x0000000000000000]
    struct FVector aTouch[0x5];       // 0x0208 (0x003C) [0x0000000000000000]
    struct FVector aBackTouch[0x5];   // 0x0244 (0x003C) [0x0000000000000000]
    float RawJoyUp;                   // 0x0280 (0x0004) [0x0000000000000000]
    float RawJoyRight;                // 0x0284 (0x0004) [0x0000000000000000]
    float RawJoyLookRight;            // 0x0288 (0x0004) [0x0000000000000000]
    float RawJoyLookUp;               // 0x028C (0x0004) [0x0000000000000000]
    float MoveForwardSpeed;           // 0x0290 (0x0004) [0x0000000000000000]
    float MoveStrafeSpeed;            // 0x0294 (0x0004) [0x0000000000000000]
    float LookRightScale;             // 0x0298 (0x0004) [0x0000000000000000]
    float LookUpScale;                // 0x029C (0x0004) [0x0000000000000000]
    unsigned char bStrafe;            // 0x02A0 (0x0001) [0x0000000000000000]
    unsigned char bXAxis;             // 0x02A1 (0x0001) [0x0000000000000000]
    unsigned char bYAxis;             // 0x02A2 (0x0001) [0x0000000000000000]
    float ZeroTime[0x2];              // 0x02A4 (0x0008) [0x0000000000000000]
    float SmoothedMouse[0x2];         // 0x02AC (0x0008) [0x0000000000000000]
    int MouseSamples;                 // 0x02B4 (0x0004) [0x0000000000000000]
    float MouseSamplingTotal;         // 0x02B8 (0x0004) [0x0000000000000000]
    float AutoUnlockTurnTime;         // 0x02BC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2503];

        return pClassPointer;
    };

    void PreClientTravel();
    void ClientInitInputSystem();
    void InitInputSystem();
    void SmoothMouse();
    void ClearSmoothing();
    void SmartJump();
    void Jump();
    void ProcessInputMatching();
    void CheckForDoubleClickMove();
    void CatchDoubleClickInput();
    void eventPlayerInput();
    void AdjustMouseSensitivity();
    void PostProcessInput();
    void PreProcessInput();
    void DrawHUD();
    void SetSensitivity();
    void InvertTurn();
    void InvertMouse();
    void CancelMobileInput();
};

UClass* UPlayerInput::pClassPointer = NULL;

// Class Engine.PlayerManagerInteraction
// 0x0000 (0x00B0 - 0x00B0)
class UPlayerManagerInteraction : public UInteraction {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2505];

        return pClassPointer;
    };
};

UClass* UPlayerManagerInteraction::pClassPointer = NULL;

// Class Engine.UISceneClient
// 0x00AC (0x011C - 0x0070)
class UUISceneClient : public UUIRoot {
   public:
    struct FPointer VfTable_FExec;   // 0x0070 (0x0008) [0x0000000000000000]
    struct FPointer RenderViewport;  // 0x0078 (0x0008) [0x0000000000000000]
    struct FIntPoint MousePosition;  // 0x0080 (0x0008) [0x0000000000000000]
    class UDataStoreClient*
        DataStoreManager;              // 0x0088 (0x0008) [0x0000000000000000]
    struct FMatrix CanvasToScreen;     // 0x0090 (0x0040) [0x0000000000000000]
    struct FMatrix InvCanvasToScreen;  // 0x00D0 (0x0040) [0x0000000000000000]
    class UPostProcessChain*
        UIScenePostProcess;        // 0x0110 (0x0008) [0x0000000000000000]
    DWORD bEnablePostProcess : 1;  // 0x0118 (0x0004) [0x0000000000000000]
                                   // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2507];

        return pClassPointer;
    };

    void eventInitializeSceneClient();
    void GetInverseCanvasToScreen();
    void GetCanvasToScreen();
    void IsUIActive();
};

UClass* UUISceneClient::pClassPointer = NULL;

// Class Engine.UISoundTheme
// 0x0010 (0x0070 - 0x0060)
class UUISoundTheme : public UObject {
   public:
    TArray<struct FSoundEventMapping>
        SoundEventBindings;  // 0x0060 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2509];

        return pClassPointer;
    };

    void eventProcessSoundEvent();
};

UClass* UUISoundTheme::pClassPointer = NULL;

// Class Engine.UIDataStoreSubscriber
// 0x0000 (0x0060 - 0x0060)
class UUIDataStoreSubscriber : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2511];

        return pClassPointer;
    };

    void ClearBoundDataStores();
    void GetBoundDataStores();
    void NotifyDataStoreValueUpdated();
    void RefreshSubscriberValue();
    void GetDataStoreBinding();
    void SetDataStoreBinding();
};

UClass* UUIDataStoreSubscriber::pClassPointer = NULL;

// Class Engine.UIDataStorePublisher
// 0x0000 (0x0060 - 0x0060)
class UUIDataStorePublisher : public UUIDataStoreSubscriber {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2513];

        return pClassPointer;
    };

    void SaveSubscriberValue();
};

UClass* UUIDataStorePublisher::pClassPointer = NULL;

// Class Engine.UIDataProvider
// 0x0000 (0x0070 - 0x0070)
class UUIDataProvider : public UUIRoot {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2515];

        return pClassPointer;
    };
};

UClass* UUIDataProvider::pClassPointer = NULL;

// Class Engine.UIDataProvider_OnlinePlayerDataBase
// 0x0004 (0x0074 - 0x0070)
class UUIDataProvider_OnlinePlayerDataBase : public UUIDataProvider {
   public:
    int PlayerControllerId;  // 0x0070 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2517];

        return pClassPointer;
    };

    void eventOnUnregister();
    void eventOnRegister();
};

UClass* UUIDataProvider_OnlinePlayerDataBase::pClassPointer = NULL;

// Class Engine.UIDataProvider_OnlineFriendMessages
// 0x0070 (0x00E4 - 0x0074)
class UUIDataProvider_OnlineFriendMessages
    : public UUIDataProvider_OnlinePlayerDataBase {
   public:
    TArray<struct FOnlineFriendMessage>
        Messages;  // 0x0074 (0x0010) [0x0000000000000000]
    struct FString
        SendingPlayerNameCol;           // 0x0084 (0x0010) [0x0000000000000000]
    struct FString bIsFriendInviteCol;  // 0x0094 (0x0010) [0x0000000000000000]
    struct FString bWasAcceptedCol;     // 0x00A4 (0x0010) [0x0000000000000000]
    struct FString bWasDeniedCol;       // 0x00B4 (0x0010) [0x0000000000000000]
    struct FString MessageCol;          // 0x00C4 (0x0010) [0x0000000000000000]
    struct FString LastInviteFrom;      // 0x00D4 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2519];

        return pClassPointer;
    };

    void OnGameInviteReceived();
    void OnLoginChange();
    void OnFriendMessageReceived();
    void OnFriendInviteReceived();
    void ReadMessages();
    void eventOnUnregister();
    void eventOnRegister();
};

UClass* UUIDataProvider_OnlineFriendMessages::pClassPointer = NULL;

// Class Engine.UIDataProvider_OnlineFriends
// 0x00F0 (0x0164 - 0x0074)
class UUIDataProvider_OnlineFriends
    : public UUIDataProvider_OnlinePlayerDataBase {
   public:
    TArray<struct FOnlineFriend>
        FriendsList;                 // 0x0074 (0x0010) [0x0000000000000000]
    struct FString NickNameCol;      // 0x0084 (0x0010) [0x0000000000000000]
    struct FString PresenceInfoCol;  // 0x0094 (0x0010) [0x0000000000000000]
    struct FString FriendStateCol;   // 0x00A4 (0x0010) [0x0000000000000000]
    struct FString bIsOnlineCol;     // 0x00B4 (0x0010) [0x0000000000000000]
    struct FString bIsPlayingCol;    // 0x00C4 (0x0010) [0x0000000000000000]
    struct FString
        bIsPlayingThisGameCol;           // 0x00D4 (0x0010) [0x0000000000000000]
    struct FString bIsJoinableCol;       // 0x00E4 (0x0010) [0x0000000000000000]
    struct FString bHasVoiceSupportCol;  // 0x00F4 (0x0010) [0x0000000000000000]
    struct FString bHaveInvitedCol;      // 0x0104 (0x0010) [0x0000000000000000]
    struct FString bHasInvitedYouCol;    // 0x0114 (0x0010) [0x0000000000000000]
    struct FString OfflineText;          // 0x0124 (0x0010) [0x0000000000000000]
    struct FString OnlineText;           // 0x0134 (0x0010) [0x0000000000000000]
    struct FString AwayText;             // 0x0144 (0x0010) [0x0000000000000000]
    struct FString BusyText;             // 0x0154 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2521];

        return pClassPointer;
    };

    void eventRefreshFriendsList();
    void OnLoginChange();
    void OnFriendsReadComplete();
    void eventOnUnregister();
    void eventOnRegister();
};

UClass* UUIDataProvider_OnlineFriends::pClassPointer = NULL;

// Class Engine.UIDataProvider_OnlinePartyChatList
// 0x0090 (0x0104 - 0x0074)
class UUIDataProvider_OnlinePartyChatList
    : public UUIDataProvider_OnlinePlayerDataBase {
   public:
    TArray<struct FOnlinePartyMember>
        PartyMembersList;               // 0x0074 (0x0010) [0x0000000000000000]
    TArray<struct FString> NatTypes;    // 0x0084 (0x0010) [0x0000000000000000]
    struct FString NickNameCol;         // 0x0094 (0x0010) [0x0000000000000000]
    struct FString NatTypeCol;          // 0x00A4 (0x0010) [0x0000000000000000]
    struct FString IsLocalCol;          // 0x00B4 (0x0010) [0x0000000000000000]
    struct FString IsInPartyVoiceCol;   // 0x00C4 (0x0010) [0x0000000000000000]
    struct FString IsTalkingCol;        // 0x00D4 (0x0010) [0x0000000000000000]
    struct FString IsInGameSessionCol;  // 0x00E4 (0x0010) [0x0000000000000000]
    struct FString
        IsPlayingThisGameCol;  // 0x00F4 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2523];

        return pClassPointer;
    };

    void eventRefreshMembersList();
    void OnLoginChange();
    void eventOnUnregister();
    void eventOnRegister();
};

UClass* UUIDataProvider_OnlinePartyChatList::pClassPointer = NULL;

// Class Engine.UIDataProvider_OnlinePlayerStorage
// 0x0028 (0x009C - 0x0074)
class UUIDataProvider_OnlinePlayerStorage
    : public UUIDataProvider_OnlinePlayerDataBase {
   public:
    class UOnlinePlayerStorage*
        Profile;                      // 0x0074 (0x0008) [0x0000000000000000]
    struct FName ProviderName;        // 0x007C (0x0008) [0x0000000000000000]
    DWORD bWasErrorLastRead : 1;      // 0x0084 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bIsExternalUIOpen : 1;      // 0x0084 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bNeedsDeferredRefresh : 1;  // 0x0084 (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    TArray<struct FPlayerStorageArrayProvider>
        PlayerStorageArrayProviders;  // 0x0088 (0x0010) [0x0000000000000000]
    int DeviceStorageSizeNeeded;      // 0x0098 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2525];

        return pClassPointer;
    };

    void OnExternalUIChange();
    void OnStorageDeviceChange();
    void OnDeviceSelectionComplete();
    void ShowDeviceSelection();
    void RefreshStorageData();
    void OnLoginChange();
    void OnReadStorageComplete();
    void eventOnUnregister();
    void eventOnRegister();
    void ClearReadCompleteDelegate();
    void AddReadCompleteDelegate();
    void GetData();
    void WriteData();
    void ReadData();
};

UClass* UUIDataProvider_OnlinePlayerStorage::pClassPointer = NULL;

// Class Engine.UIDataProvider_OnlineProfileSettings
// 0x0000 (0x009C - 0x009C)
class UUIDataProvider_OnlineProfileSettings
    : public UUIDataProvider_OnlinePlayerStorage {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2527];

        return pClassPointer;
    };

    void OnStorageDeviceChange();
    void RefreshStorageData();
    void ClearReadCompleteDelegate();
    void AddReadCompleteDelegate();
    void GetData();
    void WriteData();
    void ReadData();
};

UClass* UUIDataProvider_OnlineProfileSettings::pClassPointer = NULL;

// Class Engine.UIDataProvider_PlayerAchievements
// 0x0010 (0x0084 - 0x0074)
class UUIDataProvider_PlayerAchievements
    : public UUIDataProvider_OnlinePlayerDataBase {
   public:
    TArray<struct FAchievementDetails>
        Achievements;  // 0x0074 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2529];

        return pClassPointer;
    };

    void UpdateAchievements();
    void OnLoginChange();
    void eventOnUnregister();
    void eventOnRegister();
    void OnPlayerAchievementUnlocked();
    void OnPlayerAchievementsChanged();
    void GetAchievementDetails();
    void GetAchievementIconPathName();
    void PopulateAchievementIcons();
    void GetMaxTotalGamerScore();
    void GetTotalGamerScore();
};

UClass* UUIDataProvider_PlayerAchievements::pClassPointer = NULL;

// Class Engine.UIDataProvider_OnlinePlayerStorageArray
// 0x002C (0x009C - 0x0070)
class UUIDataProvider_OnlinePlayerStorageArray : public UUIDataProvider {
   public:
    class UOnlinePlayerStorage*
        PlayerStorage;                // 0x0070 (0x0008) [0x0000000000000000]
    int PlayerStorageId;              // 0x0078 (0x0004) [0x0000000000000000]
    struct FString ColumnHeaderText;  // 0x007C (0x0010) [0x0000000000000000]
    TArray<struct FName> Values;      // 0x008C (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2531];

        return pClassPointer;
    };
};

UClass* UUIDataProvider_OnlinePlayerStorageArray::pClassPointer = NULL;

// Class Engine.UIDataProvider_SettingsArray
// 0x0034 (0x00A4 - 0x0070)
class UUIDataProvider_SettingsArray : public UUIDataProvider {
   public:
    class USettings* Settings;        // 0x0070 (0x0008) [0x0000000000000000]
    int SettingsId;                   // 0x0078 (0x0004) [0x0000000000000000]
    struct FName SettingsName;        // 0x007C (0x0008) [0x0000000000000000]
    struct FString ColumnHeaderText;  // 0x0084 (0x0010) [0x0000000000000000]
    TArray<struct FIdToStringMapping>
        Values;  // 0x0094 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2533];

        return pClassPointer;
    };
};

UClass* UUIDataProvider_SettingsArray::pClassPointer = NULL;

// Class Engine.UIDataStore
// 0x0028 (0x0098 - 0x0070)
class UUIDataStore : public UUIDataProvider {
   public:
    struct FName Tag;  // 0x0070 (0x0008) [0x0000000000000000]
    TArray<struct FScriptDelegate>
        RefreshSubscriberNotifies;  // 0x0078 (0x0010) [0x0000000000000000]
    struct FScriptDelegate
        __OnDataStoreValueUpdated__Delegate;  // 0x0088 (0x0010)
                                              // [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x008C (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2535];

        return pClassPointer;
    };

    void GetDataStoreClient();
    void eventRefreshSubscribers();
    void NotifyGameSessionEnded();
    void eventSubscriberDetached();
    void eventSubscriberAttached();
    void eventUnregistered();
    void eventRegistered();
    void OnDataStoreValueUpdated();
};

UClass* UUIDataStore::pClassPointer = NULL;

// Class Engine.UIDataStore_DynamicResource
// 0x0068 (0x0100 - 0x0098)
class UUIDataStore_DynamicResource : public UUIDataStore {
   public:
    class UUIDataProvider_OnlineProfileSettings*
        ProfileProvider;  // 0x0098 (0x0008) [0x0000000000000000]
    class UUIDataStore_GameResource*
        GameResourceDataStore;  // 0x00A0 (0x0008) [0x0000000000000000]
    TArray<struct FDynamicResourceProviderDefinition>
        ResourceProviderDefinitions;  // 0x00A8 (0x0010) [0x0000000000000000]
    struct FMultiMap_Mirror
        ResourceProviders;  // 0x00B8 (0x0048) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2537];

        return pClassPointer;
    };

    void eventUnregistered();
    void eventRegistered();
    void OnLoginChange();
    void GetResourceProviders();
    void FindProviderTypeIndex();
};

UClass* UUIDataStore_DynamicResource::pClassPointer = NULL;

// Class Engine.UIDataStore_Fonts
// 0x0000 (0x0098 - 0x0098)
class UUIDataStore_Fonts : public UUIDataStore {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2539];

        return pClassPointer;
    };
};

UClass* UUIDataStore_Fonts::pClassPointer = NULL;

// Class Engine.UIDataStore_GameResource
// 0x0058 (0x00F0 - 0x0098)
class UUIDataStore_GameResource : public UUIDataStore {
   public:
    TArray<struct FGameResourceDataProvider>
        ElementProviderTypes;  // 0x0098 (0x0010) [0x0000000000000000]
    struct FMultiMap_Mirror
        ListElementProviders;  // 0x00A8 (0x0048) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2541];

        return pClassPointer;
    };

    void GetResourceProviders();
    void FindProviderTypeIndex();
};

UClass* UUIDataStore_GameResource::pClassPointer = NULL;

// Class Engine.UIDataStore_MenuItems
// 0x0060 (0x0150 - 0x00F0)
class UUIDataStore_MenuItems : public UUIDataStore_GameResource {
   public:
    struct FName
        CurrentGameSettingsTag;  // 0x00F0 (0x0008) [0x0000000000000000]
    struct FMultiMap_Mirror
        OptionProviders;  // 0x00F8 (0x0048) [0x0000000000000000]
    TArray<class UUIDataProvider_MenuItem*>
        DynamicProviders;  // 0x0140 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2543];

        return pClassPointer;
    };

    void eventUnregistered();
    void eventRegistered();
    void OnGameSettingsChanged();
};

UClass* UUIDataStore_MenuItems::pClassPointer = NULL;

// Class Engine.UIDataStore_GameState
// 0x0010 (0x00A8 - 0x0098)
class UUIDataStore_GameState : public UUIDataStore {
   public:
    struct FScriptDelegate
        __OnRefreshDataFieldValue__Delegate;  // 0x0098 (0x0010)
                                              // [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x009C (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2545];

        return pClassPointer;
    };

    void NotifyGameSessionEnded();
    void OnRefreshDataFieldValue();
};

UClass* UUIDataStore_GameState::pClassPointer = NULL;

// Class Engine.UIDataStore_Registry
// 0x0010 (0x00A8 - 0x0098)
class UUIDataStore_Registry : public UUIDataStore {
   public:
    TArray<struct FRegistryKeyValuePair>
        RegistryData;  // 0x0098 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2547];

        return pClassPointer;
    };

    void eventSetData();
    void eventGetData();
};

UClass* UUIDataStore_Registry::pClassPointer = NULL;

// Class Engine.UIDataStore_Remote
// 0x0000 (0x0098 - 0x0098)
class UUIDataStore_Remote : public UUIDataStore {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2549];

        return pClassPointer;
    };
};

UClass* UUIDataStore_Remote::pClassPointer = NULL;

// Class Engine.UIDataStore_OnlineGameSearch
// 0x0038 (0x00D0 - 0x0098)
class UUIDataStore_OnlineGameSearch : public UUIDataStore_Remote {
   public:
    struct FName SearchResultsName;     // 0x0098 (0x0008) [0x0000000000000000]
    class UOnlineSubsystem* OnlineSub;  // 0x00A0 (0x0008) [0x0000000000000000]
    class UOnlineGameInterface*
        GameInterface;                 // 0x00A8 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x8];  // 0x00B0 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    TArray<struct FGameSearchCfg>
        GameSearchCfgList;  // 0x00B8 (0x0010) [0x0000000000000000]
    int SelectedIndex;      // 0x00C8 (0x0004) [0x0000000000000000]
    int ActiveSearchIndex;  // 0x00CC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2551];

        return pClassPointer;
    };

    void ClearAllSearchResults();
    void eventMoveToPrevious();
    void eventMoveToNext();
    void eventSetCurrentByName();
    void eventSetCurrentByIndex();
    void FindSearchConfigurationIndex();
    void eventGetActiveGameSearch();
    void eventGetCurrentGameSearch();
    void eventShowHostGamercard();
    void eventGetSearchResultFromIndex();
    void OnSearchComplete();
    void OverrideQuerySubmission();
    void eventSubmitGameSearch();
    void InvalidateCurrentSearchResults();
    void eventInit();
};

UClass* UUIDataStore_OnlineGameSearch::pClassPointer = NULL;

// Class Engine.UIDataStore_OnlinePlayerData
// 0x0104 (0x019C - 0x0098)
class UUIDataStore_OnlinePlayerData : public UUIDataStore_Remote {
   public:
    class UUIDataProvider_OnlineFriends*
        FriendsProvider;        // 0x0098 (0x0008) [0x0000000000000000]
    int PlayerControllerId;     // 0x00A0 (0x0004) [0x0000000000000000]
    struct FString PlayerNick;  // 0x00A4 (0x0010) [0x0000000000000000]
    struct FString
        ProfileSettingsClassName;        // 0x00B4 (0x0010) [0x0000000000000000]
    class UClass* ProfileSettingsClass;  // 0x00C4 (0x0008) [0x0000000000000000]
    class UUIDataProvider_OnlineProfileSettings*
        ProfileProvider;  // 0x00CC (0x0008) [0x0000000000000000]
    struct FString
        ProfileProviderClassName;        // 0x00D4 (0x0010) [0x0000000000000000]
    class UClass* ProfileProviderClass;  // 0x00E4 (0x0008) [0x0000000000000000]
    struct FString
        PlayerStorageClassName;        // 0x00EC (0x0010) [0x0000000000000000]
    class UClass* PlayerStorageClass;  // 0x00FC (0x0008) [0x0000000000000000]
    class UUIDataProvider_OnlinePlayerStorage*
        StorageProvider;  // 0x0104 (0x0008) [0x0000000000000000]
    struct FString
        StorageProviderClassName;        // 0x010C (0x0010) [0x0000000000000000]
    class UClass* StorageProviderClass;  // 0x011C (0x0008) [0x0000000000000000]
    class UUIDataProvider_OnlineFriendMessages*
        FriendMessagesProvider;  // 0x0124 (0x0008) [0x0000000000000000]
    class UUIDataProvider_PlayerAchievements*
        AchievementsProvider;  // 0x012C (0x0008) [0x0000000000000000]
    struct FString
        FriendsProviderClassName;        // 0x0134 (0x0010) [0x0000000000000000]
    class UClass* FriendsProviderClass;  // 0x0144 (0x0008) [0x0000000000000000]
    struct FString FriendMessagesProviderClassName;  // 0x014C (0x0010)
                                                     // [0x0000000000000000]
    class UClass*
        FriendMessagesProviderClass;  // 0x015C (0x0008) [0x0000000000000000]
    struct FString
        AchievementsProviderClassName;  // 0x0164 (0x0010) [0x0000000000000000]
    class UClass*
        AchievementsProviderClass;  // 0x0174 (0x0008) [0x0000000000000000]
    struct FString
        PartyChatProviderClassName;  // 0x017C (0x0010) [0x0000000000000000]
    class UClass*
        PartyChatProviderClass;  // 0x018C (0x0008) [0x0000000000000000]
    class UUIDataProvider_OnlinePartyChatList*
        PartyChatProvider;  // 0x0194 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2553];

        return pClassPointer;
    };

    void eventGetCachedPlayerStorage();
    void eventGetCachedPlayerProfile();
    void ClearDelegates();
    void RegisterDelegates();
    void OnPlayerDataChange();
    void OnLoginChange();
    void eventOnUnregister();
    void eventOnRegister();
};

UClass* UUIDataStore_OnlinePlayerData::pClassPointer = NULL;

// Class Engine.UIDataStore_OnlineStats
// 0x008C (0x0124 - 0x0098)
class UUIDataStore_OnlineStats : public UUIDataStore_Remote {
   public:
    TArray<class UClass*>
        StatsReadClasses;        // 0x0098 (0x0010) [0x0000000000000000]
    struct FName StatsReadName;  // 0x00A8 (0x0008) [0x0000000000000000]
    struct FPlayerNickMetaData
        PlayerNickData;  // 0x00B0 (0x0018) [0x0000000000000000]
    struct FRankMetaData
        RankNameMetaData;        // 0x00C8 (0x0018) [0x0000000000000000]
    struct FName TotalRowsName;  // 0x00E0 (0x0008) [0x0000000000000000]
    TArray<class UOnlineStatsRead*>
        StatsReadObjects;               // 0x00E8 (0x0010) [0x0000000000000000]
    class UOnlineStatsRead* StatsRead;  // 0x00F8 (0x0008) [0x0000000000000000]
    unsigned char CurrentReadType;      // 0x0100 (0x0001) [0x0000000000000000]
    class UOnlineStatsInterface*
        StatsInterface;                // 0x0104 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x8];  // 0x010C (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    class UOnlinePlayerInterface*
        PlayerInterface;               // 0x0114 (0x0010) [0x0000000000000000]
    unsigned char UnknownData01[0x8];  // 0x011C (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2555];

        return pClassPointer;
    };

    void SortResultsByRank();
    void OnReadComplete();
    void eventShowGamercard();
    void eventRefreshStats();
    void SetStatsReadInfo();
    void eventInit();
};

UClass* UUIDataStore_OnlineStats::pClassPointer = NULL;

// Class Engine.UIDataStore_Settings
// 0x0000 (0x0098 - 0x0098)
class UUIDataStore_Settings : public UUIDataStore {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2557];

        return pClassPointer;
    };
};

UClass* UUIDataStore_Settings::pClassPointer = NULL;

// Class Engine.UIDataStore_OnlineGameSettings
// 0x001C (0x00B4 - 0x0098)
class UUIDataStore_OnlineGameSettings : public UUIDataStore_Settings {
   public:
    TArray<struct FGameSettingsCfg>
        GameSettingsCfgList;  // 0x0098 (0x0010) [0x0000000000000000]
    class UClass*
        SettingsProviderClass;  // 0x00A8 (0x0008) [0x0000000000000000]
    int SelectedIndex;          // 0x00B0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2559];

        return pClassPointer;
    };

    void eventUnregistered();
    void eventRegistered();
    void eventMoveToPrevious();
    void eventMoveToNext();
    void eventSetCurrentByName();
    void eventSetCurrentByIndex();
    void eventGetCurrentProvider();
    void eventGetCurrentGameSettings();
    void eventCreateGame();
};

UClass* UUIDataStore_OnlineGameSettings::pClassPointer = NULL;

// Class Engine.UIDataStore_StringBase
// 0x0000 (0x0098 - 0x0098)
class UUIDataStore_StringBase : public UUIDataStore {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2561];

        return pClassPointer;
    };
};

UClass* UUIDataStore_StringBase::pClassPointer = NULL;

// Class Engine.UIDataStore_InputAlias
// 0x0058 (0x00F0 - 0x0098)
class UUIDataStore_InputAlias : public UUIDataStore_StringBase {
   public:
    TArray<struct FUIDataStoreInputAlias>
        InputAliases;  // 0x0098 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00
        [0x48];  // 0x00A8 (0x0048) UNKNOWN PROPERTY: MapProperty
                 // Engine.UIDataStore_InputAlias.InputAliasLookupMap

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2563];

        return pClassPointer;
    };

    void HasAliasMappingForPlatform();
    void FindInputAliasIndex();
    void GetAliasInputKeyDataByIndex();
    void GetAliasInputKeyData();
    void GetAliasInputKeyNameByIndex();
    void GetAliasInputKeyName();
    void GetAliasFontMarkupByIndex();
    void GetAliasFontMarkup();
};

UClass* UUIDataStore_InputAlias::pClassPointer = NULL;

// Class Engine.UIDataStore_StringAliasMap
// 0x005C (0x00F4 - 0x0098)
class UUIDataStore_StringAliasMap : public UUIDataStore_StringBase {
   public:
    TArray<struct FUIMenuInputMap>
        MenuInputMapArray;             // 0x0098 (0x0010) [0x0000000000000000]
    struct FMap_Mirror MenuInputSets;  // 0x00A8 (0x0048) [0x0000000000000000]
    int PlayerIndex;                   // 0x00F0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2565];

        return pClassPointer;
    };

    void GetStringWithFieldName();
    void FindMappingWithFieldName();
    void GetPlayerOwner();
};

UClass* UUIDataStore_StringAliasMap::pClassPointer = NULL;

// Class Engine.UIPropertyDataProvider
// 0x0020 (0x0090 - 0x0070)
class UUIPropertyDataProvider : public UUIDataProvider {
   public:
    TArray<class UClass*>
        ComplexPropertyTypes;  // 0x0070 (0x0010) [0x0000000000000000]
    struct FScriptDelegate
        __CanSupportComplexPropertyType__Delegate;  // 0x0080 (0x0010)
                                                    // [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x0084 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2567];

        return pClassPointer;
    };

    void CanSupportComplexPropertyType();
};

UClass* UUIPropertyDataProvider::pClassPointer = NULL;

// Class Engine.UIDataProvider_Settings
// 0x000C (0x009C - 0x0090)
class UUIDataProvider_Settings : public UUIPropertyDataProvider {
   public:
    class USettings* Settings;  // 0x0090 (0x0008) [0x0000000000000000]
    DWORD bIsAListRow : 1;  // 0x0098 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2569];

        return pClassPointer;
    };
};

UClass* UUIDataProvider_Settings::pClassPointer = NULL;

// Class Engine.UIResourceDataProvider
// 0x0004 (0x0094 - 0x0090)
class UUIResourceDataProvider : public UUIPropertyDataProvider {
   public:
    DWORD bSkipDuringEnumeration : 1;  // 0x0090 (0x0004) [0x0000000000000000]
                                       // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2571];

        return pClassPointer;
    };

    void eventInitializeProvider();
};

UClass* UUIResourceDataProvider::pClassPointer = NULL;

// Class Engine.UIDataProvider_MenuItem
// 0x00A8 (0x013C - 0x0094)
class UUIDataProvider_MenuItem : public UUIResourceDataProvider {
   public:
    unsigned char OptionType;           // 0x0094 (0x0001) [0x0000000000000000]
    TArray<struct FName> OptionSet;     // 0x0098 (0x0010) [0x0000000000000000]
    struct FString DataStoreMarkup;     // 0x00A8 (0x0010) [0x0000000000000000]
    struct FString DescriptionMarkup;   // 0x00B8 (0x0010) [0x0000000000000000]
    struct FName RequiredGameMode;      // 0x00C8 (0x0008) [0x0000000000000000]
    struct FString FriendlyName;        // 0x00D0 (0x0010) [0x0000000000000000]
    struct FString CustomFriendlyName;  // 0x00E0 (0x0010) [0x0000000000000000]
    struct FString Description;         // 0x00F0 (0x0010) [0x0000000000000000]
    DWORD bEditableCombo : 1;           // 0x0100 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD
        bNumericCombo : 1;  // 0x0100 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bKeyboardOrMouseOption : 1;  // 0x0100 (0x0004) [0x0000000000000000]
                                       // [0x00000004]
    DWORD bOnlineOnly : 1;  // 0x0100 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD
        bOfflineOnly : 1;  // 0x0100 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bSearchAllInis : 1;  // 0x0100 (0x0004) [0x0000000000000000]
                               // [0x00000020]
    DWORD
        bRemoveOn360 : 1;   // 0x0100 (0x0004) [0x0000000000000000] [0x00000040]
    DWORD bRemoveOnPC : 1;  // 0x0100 (0x0004) [0x0000000000000000] [0x00000080]
    DWORD
        bRemoveOnPS3 : 1;  // 0x0100 (0x0004) [0x0000000000000000] [0x00000100]
    DWORD bRemoveOnDingo : 1;       // 0x0100 (0x0004) [0x0000000000000000]
                                    // [0x00000200]
    int EditBoxMaxLength;           // 0x0104 (0x0004) [0x0000000000000000]
    struct FUIRangeData RangeData;  // 0x0108 (0x0014) [0x0000000000000000]
    TArray<struct FName>
        SchemaCellFields;    // 0x011C (0x0010) [0x0000000000000000]
    struct FString IniName;  // 0x012C (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2573];

        return pClassPointer;
    };
};

UClass* UUIDataProvider_MenuItem::pClassPointer = NULL;

// Class Engine.UIResourceCombinationProvider
// 0x0010 (0x0080 - 0x0070)
class UUIResourceCombinationProvider : public UUIDataProvider {
   public:
    class UUIResourceDataProvider*
        StaticDataProvider;  // 0x0070 (0x0008) [0x0000000000000000]
    class UUIDataProvider_OnlineProfileSettings*
        ProfileProvider;  // 0x0078 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2575];

        return pClassPointer;
    };

    void ClearProviderReferences();
    void eventInitializeProvider();
};

UClass* UUIResourceCombinationProvider::pClassPointer = NULL;

// Class Engine.GameUISceneClient
// 0x0080 (0x019C - 0x011C)
class UGameUISceneClient : public UUISceneClient {
   public:
    float LatestDeltaTime;  // 0x011C (0x0004) [0x0000000000000000]
    struct FDouble
        DoubleClickStartTime;  // 0x0120 (0x0008) [0x0000000000000000]
    struct FIntPoint
        DoubleClickStartPosition;  // 0x0128 (0x0008) [0x0000000000000000]
    struct FMap_Mirror
        InitialPressedKeys;  // 0x0130 (0x0048) [0x0000000000000000]
    DWORD
        bUpdateInputProcessingStatus : 1;  // 0x0178 (0x0004)
                                           // [0x0000000000000000] [0x00000001]
    DWORD bUpdateSceneViewportSizes : 1;   // 0x0178 (0x0004)
                                           // [0x0000000000000000] [0x00000002]
    DWORD bEnableDebugInput : 1;         // 0x0178 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD bRenderDebugInfo : 1;          // 0x0178 (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    DWORD bCaptureUnprocessedInput : 1;  // 0x0178 (0x0004) [0x0000000000000000]
                                         // [0x00000010]
    TArray<struct FName> NavAliases;     // 0x017C (0x0010) [0x0000000000000000]
    TArray<struct FName> AxisInputKeys;  // 0x018C (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2577];

        return pClassPointer;
    };

    void FindLocalPlayerIndex();
    void NotifyPlayerRemoved();
    void NotifyPlayerAdded();
    void NotifyGameSessionEnded();
    void NotifyClientTravel();
    void eventPauseGame();
    void CanUnpauseInternalUI();
    void RequestInputProcessingUpdate();
    void GetCurrentNetMode();
};

UClass* UGameUISceneClient::pClassPointer = NULL;

// Class Engine.Scene
// 0x0000 (0x0060 - 0x0060)
class UScene : public UObject {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2579];

        return pClassPointer;
    };
};

UClass* UScene::pClassPointer = NULL;

// Class Engine.InstancedFoliageActor
// 0x0060 (0x02A4 - 0x0244)
class AInstancedFoliageActor : public AActor {
   public:
    struct FMap_Mirror FoliageMeshes;  // 0x0244 (0x0048) [0x0000000000000000]
    class UStaticMesh* SelectedMesh;   // 0x028C (0x0008) [0x0000000000000000]
    TArray<class UInstancedStaticMeshComponent*>
        InstancedStaticMeshComponents;  // 0x0294 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2581];

        return pClassPointer;
    };
};

UClass* AInstancedFoliageActor::pClassPointer = NULL;

// Class Engine.InteractiveFoliageActor
// 0x005C (0x030C - 0x02B0)
class AInteractiveFoliageActor : public AStaticMeshActor {
   public:
    class UCylinderComponent*
        CylinderComponent;  // 0x02B0 (0x0008) [0x0000000000000000]
    struct FVector
        TouchingActorEntryPosition;   // 0x02B8 (0x000C) [0x0000000000000000]
    struct FVector FoliageVelocity;   // 0x02C4 (0x000C) [0x0000000000000000]
    struct FVector FoliageForce;      // 0x02D0 (0x000C) [0x0000000000000000]
    struct FVector FoliagePosition;   // 0x02DC (0x000C) [0x0000000000000000]
    float FoliageDamageImpulseScale;  // 0x02E8 (0x0004) [0x0000000000000000]
    float FoliageTouchImpulseScale;   // 0x02EC (0x0004) [0x0000000000000000]
    float FoliageStiffness;           // 0x02F0 (0x0004) [0x0000000000000000]
    float FoliageStiffnessQuadratic;  // 0x02F4 (0x0004) [0x0000000000000000]
    float FoliageDamping;             // 0x02F8 (0x0004) [0x0000000000000000]
    float MaxDamageImpulse;           // 0x02FC (0x0004) [0x0000000000000000]
    float MaxTouchImpulse;            // 0x0300 (0x0004) [0x0000000000000000]
    float MaxForce;                   // 0x0304 (0x0004) [0x0000000000000000]
    float Mass;                       // 0x0308 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2583];

        return pClassPointer;
    };

    void eventTouch();
    void eventTakeDamage();
};

UClass* AInteractiveFoliageActor::pClassPointer = NULL;

// Class Engine.InteractiveFoliageComponent
// 0x0008 (0x02E4 - 0x02DC)
class UInteractiveFoliageComponent : public UStaticMeshComponent {
   public:
    struct FPointer FoliageSceneProxy;  // 0x02DC (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2585];

        return pClassPointer;
    };
};

UClass* UInteractiveFoliageComponent::pClassPointer = NULL;

// Class Engine.ActorFactoryInteractiveFoliage
// 0x0000 (0x00B0 - 0x00B0)
class UActorFactoryInteractiveFoliage : public UActorFactoryStaticMesh {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2587];

        return pClassPointer;
    };
};

UClass* UActorFactoryInteractiveFoliage::pClassPointer = NULL;

// Class Engine.FluidInfluenceActor
// 0x001C (0x0260 - 0x0244)
class AFluidInfluenceActor : public AActor {
   public:
    class UArrowComponent*
        FlowDirection;               // 0x0244 (0x0008) [0x0000000000000000]
    class USpriteComponent* Sprite;  // 0x024C (0x0008) [0x0000000000000000]
    class UFluidInfluenceComponent*
        InfluenceComponent;  // 0x0254 (0x0008) [0x0000000000000000]
    DWORD bActive : 1;   // 0x025C (0x0004) [0x0000000000150000] [0x00000001] (
                         // CPF_Travel | CPF_GlobalConfig )
    DWORD bToggled : 1;  // 0x025C (0x0004) [0x0000000000160000] [0x00000002] (
                         // CPF_EditConst | CPF_GlobalConfig )

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2589];

        return pClassPointer;
    };

    void eventReplicatedEvent();
    void OnToggle();
};

UClass* AFluidInfluenceActor::pClassPointer = NULL;

// Class Engine.FluidSurfaceActor
// 0x0010 (0x0254 - 0x0244)
class AFluidSurfaceActor : public AActor {
   public:
    class UFluidSurfaceComponent*
        FluidComponent;  // 0x0244 (0x0008) [0x0000000000000000]
    class UParticleSystem*
        ProjectileEntryEffect;  // 0x024C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2591];

        return pClassPointer;
    };

    void eventTouch();
    void eventTakeDamage();
};

UClass* AFluidSurfaceActor::pClassPointer = NULL;

// Class Engine.FluidSurfaceActorMovable
// 0x0000 (0x0254 - 0x0254)
class AFluidSurfaceActorMovable : public AFluidSurfaceActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2593];

        return pClassPointer;
    };
};

UClass* AFluidSurfaceActorMovable::pClassPointer = NULL;

// Class Engine.FluidInfluenceComponent
// 0x0068 (0x02A0 - 0x0238)
class UFluidInfluenceComponent : public UPrimitiveComponent {
   public:
    DWORD bActive : 1;  // 0x0238 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD RaindropFillEntireFluid : 1;  // 0x0238 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bIsToggleTriggered : 1;       // 0x0238 (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    class AFluidSurfaceActor*
        FluidActor;               // 0x023C (0x0008) [0x0000000000000000]
    unsigned char InfluenceType;  // 0x0244 (0x0001) [0x0000000000000000]
    float MaxDistance;            // 0x0248 (0x0004) [0x0000000000000000]
    float WaveStrength;           // 0x024C (0x0004) [0x0000000000000000]
    float WaveFrequency;          // 0x0250 (0x0004) [0x0000000000000000]
    float WavePhase;              // 0x0254 (0x0004) [0x0000000000000000]
    float WaveRadius;             // 0x0258 (0x0004) [0x0000000000000000]
    float RaindropAreaRadius;     // 0x025C (0x0004) [0x0000000000000000]
    float RaindropRadius;         // 0x0260 (0x0004) [0x0000000000000000]
    float RaindropStrength;       // 0x0264 (0x0004) [0x0000000000000000]
    float RaindropRate;           // 0x0268 (0x0004) [0x0000000000000000]
    float FlowSpeed;              // 0x026C (0x0004) [0x0000000000000000]
    int FlowNumRipples;           // 0x0270 (0x0004) [0x0000000000000000]
    float FlowSideMotionRadius;   // 0x0274 (0x0004) [0x0000000000000000]
    float FlowWaveRadius;         // 0x0278 (0x0004) [0x0000000000000000]
    float FlowStrength;           // 0x027C (0x0004) [0x0000000000000000]
    float FlowFrequency;          // 0x0280 (0x0004) [0x0000000000000000]
    float SphereOuterRadius;      // 0x0284 (0x0004) [0x0000000000000000]
    float SphereInnerRadius;      // 0x0288 (0x0004) [0x0000000000000000]
    float SphereStrength;         // 0x028C (0x0004) [0x0000000000000000]
    float CurrentAngle;           // 0x0290 (0x0004) [0x0000000000000000]
    float CurrentTimer;           // 0x0294 (0x0004) [0x0000000000000000]
    class AFluidSurfaceActor*
        CurrentFluidActor;  // 0x0298 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2595];

        return pClassPointer;
    };
};

UClass* UFluidInfluenceComponent::pClassPointer = NULL;

// Class Engine.FluidSurfaceComponent
// 0x00FC (0x0334 - 0x0238)
class UFluidSurfaceComponent : public UPrimitiveComponent {
   public:
    class UMaterialInterface*
        FluidMaterial;       // 0x0238 (0x0008) [0x0000000000000000]
    int LightMapResolution;  // 0x0240 (0x0004) [0x0000000000000000]
    struct FLightmassPrimitiveSettings
        LightmassSettings;       // 0x0244 (0x001C) [0x0000000000000000]
    DWORD EnableSimulation : 1;  // 0x0260 (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    DWORD
        EnableDetail : 1;  // 0x0260 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bTiling : 1;     // 0x0260 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bPause : 1;      // 0x0260 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bShowSimulationNormals : 1;   // 0x0260 (0x0004) [0x0000000000000000]
                                        // [0x00000010]
    DWORD bShowSimulationPosition : 1;  // 0x0260 (0x0004) [0x0000000000000000]
                                        // [0x00000020]
    DWORD bShowDetailNormals : 1;       // 0x0260 (0x0004) [0x0000000000000000]
                                        // [0x00000040]
    DWORD bShowDetailPosition : 1;      // 0x0260 (0x0004) [0x0000000000000000]
                                        // [0x00000080]
    DWORD bShowFluidSimulation : 1;     // 0x0260 (0x0004) [0x0000000000000000]
                                        // [0x00000100]
    DWORD bShowFluidDetail : 1;         // 0x0260 (0x0004) [0x0000000000000000]
                                        // [0x00000200]
    DWORD bTestRipple : 1;  // 0x0260 (0x0004) [0x0000000000000000] [0x00000400]
    DWORD bTestRippleCenterOnDetail : 1;  // 0x0260 (0x0004)
                                          // [0x0000000000000000] [0x00000800]
    int SimulationQuadsX;               // 0x0264 (0x0004) [0x0000000000000000]
    int SimulationQuadsY;               // 0x0268 (0x0004) [0x0000000000000000]
    float GridSpacing;                  // 0x026C (0x0004) [0x0000000000000000]
    float GridSpacingLowRes;            // 0x0270 (0x0004) [0x0000000000000000]
    class AActor* TargetSimulation;     // 0x0274 (0x0008) [0x0000000000000000]
    float GPUTessellationFactor;        // 0x027C (0x0004) [0x0000000000000000]
    float FluidDamping;                 // 0x0280 (0x0004) [0x0000000000000000]
    float FluidTravelSpeed;             // 0x0284 (0x0004) [0x0000000000000000]
    float FluidHeightScale;             // 0x0288 (0x0004) [0x0000000000000000]
    float FluidUpdateRate;              // 0x028C (0x0004) [0x0000000000000000]
    float ForceImpact;                  // 0x0290 (0x0004) [0x0000000000000000]
    float ForceContinuous;              // 0x0294 (0x0004) [0x0000000000000000]
    float LightingContrast;             // 0x0298 (0x0004) [0x0000000000000000]
    class AActor* TargetDetail;         // 0x029C (0x0008) [0x0000000000000000]
    float DeactivationDistance;         // 0x02A4 (0x0004) [0x0000000000000000]
    int DetailResolution;               // 0x02A8 (0x0004) [0x0000000000000000]
    float DetailSize;                   // 0x02AC (0x0004) [0x0000000000000000]
    float DetailDamping;                // 0x02B0 (0x0004) [0x0000000000000000]
    float DetailTravelSpeed;            // 0x02B4 (0x0004) [0x0000000000000000]
    float DetailTransfer;               // 0x02B8 (0x0004) [0x0000000000000000]
    float DetailHeightScale;            // 0x02BC (0x0004) [0x0000000000000000]
    float DetailUpdateRate;             // 0x02C0 (0x0004) [0x0000000000000000]
    float NormalLength;                 // 0x02C4 (0x0004) [0x0000000000000000]
    float TestRippleSpeed;              // 0x02C8 (0x0004) [0x0000000000000000]
    float TestRippleFrequency;          // 0x02CC (0x0004) [0x0000000000000000]
    float TestRippleRadius;             // 0x02D0 (0x0004) [0x0000000000000000]
    float FluidWidth;                   // 0x02D4 (0x0004) [0x0000000000000000]
    float FluidHeight;                  // 0x02D8 (0x0004) [0x0000000000000000]
    float TestRippleTime;               // 0x02DC (0x0004) [0x0000000000000000]
    float TestRippleAngle;              // 0x02E0 (0x0004) [0x0000000000000000]
    float DeactivationTimer;            // 0x02E4 (0x0004) [0x0000000000000000]
    float ViewDistance;                 // 0x02E8 (0x0004) [0x0000000000000000]
    struct FVector SimulationPosition;  // 0x02EC (0x000C) [0x0000000000000000]
    struct FVector DetailPosition;      // 0x02F8 (0x000C) [0x0000000000000000]
    TArray<unsigned char> ClampMap;     // 0x0304 (0x0010) [0x0000000000000000]
    TArray<class UShadowMap2D*>
        ShadowMaps;                   // 0x0314 (0x0010) [0x0000000000000000]
    struct FLightMapRef LightMap;     // 0x0324 (0x0008) [0x0000000000000000]
    struct FPointer FluidSimulation;  // 0x032C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2597];

        return pClassPointer;
    };

    void SetSimulationPosition();
    void SetDetailPosition();
    void ApplyForce();
};

UClass* UFluidSurfaceComponent::pClassPointer = NULL;

// Class Engine.SpeedTreeActor
// 0x0008 (0x024C - 0x0244)
class ASpeedTreeActor : public AActor {
   public:
    class USpeedTreeComponent*
        SpeedTreeComponent;  // 0x0244 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2599];

        return pClassPointer;
    };
};

UClass* ASpeedTreeActor::pClassPointer = NULL;

// Class Engine.SpeedTreeComponent
// 0x00F4 (0x032C - 0x0238)
class USpeedTreeComponent : public UPrimitiveComponent {
   public:
    class USpeedTree* SpeedTree;  // 0x0238 (0x0008) [0x0000000000000000]
    DWORD
        bUseLeafCards : 1;  // 0x0240 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bUseLeafMeshes : 1;  // 0x0240 (0x0004) [0x0000000000000000]
                               // [0x00000002]
    DWORD
        bUseBranches : 1;  // 0x0240 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bUseFronds : 1;  // 0x0240 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bUseBillboards : 1;  // 0x0240 (0x0004) [0x0000000000000000]
                               // [0x00000010]
    float Lod3DStart;          // 0x0244 (0x0004) [0x0000000000000000]
    float Lod3DEnd;            // 0x0248 (0x0004) [0x0000000000000000]
    float LodBillboardStart;   // 0x024C (0x0004) [0x0000000000000000]
    float LodBillboardEnd;     // 0x0250 (0x0004) [0x0000000000000000]
    float LodLevelOverride;    // 0x0254 (0x0004) [0x0000000000000000]
    class UMaterialInterface*
        Branch1Material;  // 0x0258 (0x0008) [0x0000000000000000]
    class UMaterialInterface*
        Branch2Material;  // 0x0260 (0x0008) [0x0000000000000000]
    class UMaterialInterface*
        FrondMaterial;  // 0x0268 (0x0008) [0x0000000000000000]
    class UMaterialInterface*
        LeafCardMaterial;  // 0x0270 (0x0008) [0x0000000000000000]
    class UMaterialInterface*
        LeafMeshMaterial;  // 0x0278 (0x0008) [0x0000000000000000]
    class UMaterialInterface*
        BillboardMaterial;            // 0x0280 (0x0008) [0x0000000000000000]
    class UTexture2D* SpeedTreeIcon;  // 0x0288 (0x0008) [0x0000000000000000]
    TArray<struct FSpeedTreeStaticLight>
        StaticLights;                    // 0x0290 (0x0010) [0x0000000000000000]
    struct FLightMapRef BranchLightMap;  // 0x02A0 (0x0008) [0x0000000000000000]
    struct FLightMapRef FrondLightMap;   // 0x02A8 (0x0008) [0x0000000000000000]
    struct FLightMapRef
        LeafMeshLightMap;  // 0x02B0 (0x0008) [0x0000000000000000]
    struct FLightMapRef
        LeafCardLightMap;  // 0x02B8 (0x0008) [0x0000000000000000]
    struct FLightMapRef
        BillboardLightMap;              // 0x02C0 (0x0008) [0x0000000000000000]
    unsigned char UnknownData00[0x8];   // 0x02C8 (0x0008) MISSED OFFSET
    struct FMatrix RotationOnlyMatrix;  // 0x02D0 (0x0040) [0x0000000000000000]
    struct FLightmassPrimitiveSettings
        LightmassSettings;  // 0x0310 (0x001C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2601];

        return pClassPointer;
    };

    void SetMaterial();
    void GetMaterial();
};

UClass* USpeedTreeComponent::pClassPointer = NULL;

// Class Engine.SpeedTreeActorFactory
// 0x0008 (0x00A4 - 0x009C)
class USpeedTreeActorFactory : public UActorFactory {
   public:
    class USpeedTree* SpeedTree;  // 0x009C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2603];

        return pClassPointer;
    };
};

UClass* USpeedTreeActorFactory::pClassPointer = NULL;

// Class Engine.SpeedTreeComponentFactory
// 0x0008 (0x006C - 0x0064)
class USpeedTreeComponentFactory : public UPrimitiveComponentFactory {
   public:
    class USpeedTreeComponent*
        SpeedTreeComponent;  // 0x0064 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2605];

        return pClassPointer;
    };
};

UClass* USpeedTreeComponentFactory::pClassPointer = NULL;

// Class Engine.SpeedTree
// 0x0060 (0x00C0 - 0x0060)
class USpeedTree : public UObject {
   public:
    DWORD bLegacySpeedTree : 1;     // 0x0060 (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    struct FPointer SRH;            // 0x0064 (0x0008) [0x0000000000000000]
    float LeafStaticShadowOpacity;  // 0x006C (0x0004) [0x0000000000000000]
    class UMaterialInterface*
        Branch1Material;  // 0x0070 (0x0008) [0x0000000000000000]
    class UMaterialInterface*
        Branch2Material;  // 0x0078 (0x0008) [0x0000000000000000]
    class UMaterialInterface*
        FrondMaterial;  // 0x0080 (0x0008) [0x0000000000000000]
    class UMaterialInterface*
        LeafCardMaterial;  // 0x0088 (0x0008) [0x0000000000000000]
    class UMaterialInterface*
        LeafMeshMaterial;  // 0x0090 (0x0008) [0x0000000000000000]
    class UMaterialInterface*
        BillboardMaterial;         // 0x0098 (0x0008) [0x0000000000000000]
    float WindStrength;            // 0x00A0 (0x0004) [0x0000000000000000]
    struct FVector WindDirection;  // 0x00A4 (0x000C) [0x0000000000000000]
    struct FGuid LightingGuid;     // 0x00B0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2607];

        return pClassPointer;
    };
};

UClass* USpeedTree::pClassPointer = NULL;

// Class Engine.LensFlareSource
// 0x000C (0x0250 - 0x0244)
class ALensFlareSource : public AActor {
   public:
    class ULensFlareComponent*
        LensFlareComp;  // 0x0244 (0x0008) [0x0000000000000000]
    DWORD
        bCurrentlyActive : 1;  // 0x024C (0x0004) [0x0000000000150000]
                               // [0x00000001] ( CPF_Travel | CPF_GlobalConfig )

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2609];

        return pClassPointer;
    };

    void SetActorParameter();
    void SetExtColorParameter();
    void SetColorParameter();
    void SetVectorParameter();
    void SetFloatParameter();
    void eventReplicatedEvent();
    void OnToggle();
    void eventPostBeginPlay();
    void SetTemplate();
};

UClass* ALensFlareSource::pClassPointer = NULL;

// Class Engine.LensFlareComponent
// 0x0064 (0x029C - 0x0238)
class ULensFlareComponent : public UPrimitiveComponent {
   public:
    class ULensFlare* Template;  // 0x0238 (0x0008) [0x0000000000000000]
    class UDrawLightConeComponent*
        PreviewInnerCone;  // 0x0240 (0x0008) [0x0000000000000000]
    class UDrawLightConeComponent*
        PreviewOuterCone;  // 0x0248 (0x0008) [0x0000000000000000]
    class UDrawLightRadiusComponent*
        PreviewRadius;  // 0x0250 (0x0008) [0x0000000000000000]
    DWORD
        bAutoActivate : 1;  // 0x0258 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bIsActive : 1;    // 0x0258 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bHasTranslucency : 1;          // 0x0258 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD bHasUnlitTranslucency : 1;     // 0x0258 (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    DWORD bHasUnlitDistortion : 1;       // 0x0258 (0x0004) [0x0000000000000000]
                                         // [0x00000010]
    DWORD bUsesSceneColor : 1;           // 0x0258 (0x0004) [0x0000000000000000]
                                         // [0x00000020]
    DWORD bHasSeparateTranslucency : 1;  // 0x0258 (0x0004) [0x0000000000000000]
                                         // [0x00000040]
    DWORD bUseTrueConeCalculation : 1;   // 0x0258 (0x0004) [0x0000000000000000]
                                         // [0x00000080]
    DWORD bVisibleForMobile : 1;         // 0x0258 (0x0004) [0x0000000000000000]
                                         // [0x00000100]
    float OuterCone;                     // 0x025C (0x0004) [0x0000000000000000]
    float InnerCone;                     // 0x0260 (0x0004) [0x0000000000000000]
    float ConeFudgeFactor;               // 0x0264 (0x0004) [0x0000000000000000]
    float Radius;                        // 0x0268 (0x0004) [0x0000000000000000]
    float MinStrength;                   // 0x026C (0x0004) [0x0000000000000000]
    struct FLinearColor SourceColor;     // 0x0270 (0x0010) [0x0000000000000000]
    TArray<struct FLensFlareElementMaterials>
        Materials;  // 0x0280 (0x0010) [0x0000000000000000]
    struct FPointer
        ReleaseResourcesFence;  // 0x0290 (0x0008) [0x0000000000000000]
    float NextTraceTime;        // 0x0298 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2611];

        return pClassPointer;
    };

    void CreateAndSetMaterialInstanceConstant();
    void GetNumMaterials();
    void SetMaterial();
    void GetMaterial();
    void SetIsActive();
    void SetSourceColor();
    void SetTemplate();
};

UClass* ULensFlareComponent::pClassPointer = NULL;

// Class Engine.LensFlare
// 0x0230 (0x0290 - 0x0060)
class ULensFlare : public UObject {
   public:
    struct FLensFlareElement
        SourceElement;              // 0x0060 (0x0198) [0x0000000000000000]
    class UStaticMesh* SourceMesh;  // 0x01F8 (0x0008) [0x0000000000000000]
    unsigned char SourceDPG;        // 0x0200 (0x0001) [0x0000000000000000]
    unsigned char ReflectionsDPG;   // 0x0201 (0x0001) [0x0000000000000000]
    TArray<struct FLensFlareElement>
        Reflections;                    // 0x0204 (0x0010) [0x0000000000000000]
    float OuterCone;                    // 0x0214 (0x0004) [0x0000000000000000]
    float InnerCone;                    // 0x0218 (0x0004) [0x0000000000000000]
    float ConeFudgeFactor;              // 0x021C (0x0004) [0x0000000000000000]
    float Radius;                       // 0x0220 (0x0004) [0x0000000000000000]
    DWORD bUseTrueConeCalculation : 1;  // 0x0224 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD
        bUseFixedRelativeBoundingBox : 1;  // 0x0224 (0x0004)
                                           // [0x0000000000000000] [0x00000002]
    DWORD bRenderDebugLines : 1;        // 0x0224 (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    DWORD ThumbnailImageOutOfDate : 1;  // 0x0224 (0x0004) [0x0000000000000000]
                                        // [0x00000008]
    float MinStrength;                  // 0x0228 (0x0004) [0x0000000000000000]
    struct FRawDistributionFloat
        ScreenPercentageMap;  // 0x022C (0x0024) [0x0000000000000000]
    struct FBox
        FixedRelativeBoundingBox;  // 0x0250 (0x001C) [0x0000000000000000]
    class UInterpCurveEdSetup*
        CurveEdSetup;                  // 0x026C (0x0008) [0x0000000000000000]
    int ReflectionCount;               // 0x0274 (0x0004) [0x0000000000000000]
    struct FRotator ThumbnailAngle;    // 0x0278 (0x000C) [0x0000000000000000]
    float ThumbnailDistance;           // 0x0284 (0x0004) [0x0000000000000000]
    class UTexture2D* ThumbnailImage;  // 0x0288 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2613];

        return pClassPointer;
    };
};

UClass* ULensFlare::pClassPointer = NULL;

// Class Engine.TextureFlipBook
// 0x0048 (0x0288 - 0x0240)
class UTextureFlipBook : public UTexture2D {
   public:
    struct FPointer
        VfTable_FTickableObject;  // 0x0240 (0x0008) [0x0000000000000000]
    float TimeIntoMovie;          // 0x0248 (0x0004) [0x0000000000000000]
    float TimeSinceLastFrame;     // 0x024C (0x0004) [0x0000000000000000]
    float HorizontalScale;        // 0x0250 (0x0004) [0x0000000000000000]
    float VerticalScale;          // 0x0254 (0x0004) [0x0000000000000000]
    DWORD bPaused : 1;     // 0x0258 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bStopped : 1;    // 0x0258 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bLooping : 1;    // 0x0258 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bAutoPlay : 1;   // 0x0258 (0x0004) [0x0000000000000000] [0x00000008]
    int HorizontalImages;  // 0x025C (0x0004) [0x0000000000000000]
    int VerticalImages;    // 0x0260 (0x0004) [0x0000000000000000]
    unsigned char FBMethod;  // 0x0264 (0x0001) [0x0000000000000000]
    float FrameRate;         // 0x0268 (0x0004) [0x0000000000000000]
    float FrameTime;         // 0x026C (0x0004) [0x0000000000000000]
    int CurrentRow;          // 0x0270 (0x0004) [0x0000000000000000]
    int CurrentColumn;       // 0x0274 (0x0004) [0x0000000000000000]
    float RenderOffsetU;     // 0x0278 (0x0004) [0x0000000000000000]
    float RenderOffsetV;     // 0x027C (0x0004) [0x0000000000000000]
    struct FPointer
        ReleaseResourcesFence;  // 0x0280 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2615];

        return pClassPointer;
    };

    void SetCurrentFrame();
    void Stop();
    void Pause();
    void Play();
};

UClass* UTextureFlipBook::pClassPointer = NULL;

// Class Engine.Texture2DComposite
// 0x001C (0x014C - 0x0130)
class UTexture2DComposite : public UTexture {
   public:
    TArray<struct FSourceTexture2DRegion>
        SourceRegions;   // 0x0130 (0x0010) [0x0000000000000000]
    int MaxTextureSize;  // 0x0140 (0x0004) [0x0000000000000000]
    int DestSizeX;       // 0x0144 (0x0004) [0x0000000000000000]
    int DestSizeY;       // 0x0148 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2617];

        return pClassPointer;
    };

    void ResetSourceRegions();
    void UpdateCompositeTexture();
    void SourceTexturesFullyStreamedIn();
};

UClass* UTexture2DComposite::pClassPointer = NULL;

// Class Engine.Texture2DDynamic
// 0x0014 (0x0144 - 0x0130)
class UTexture2DDynamic : public UTexture {
   public:
    int SizeX;                   // 0x0130 (0x0004) [0x0000000000000000]
    int SizeY;                   // 0x0134 (0x0004) [0x0000000000000000]
    unsigned char Format;        // 0x0138 (0x0001) [0x0000000000000000]
    int NumMips;                 // 0x013C (0x0004) [0x0000000000000000]
    DWORD bIsResolveTarget : 1;  // 0x0140 (0x0004) [0x0000000000000000]
                                 // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2619];

        return pClassPointer;
    };

    void Create();
    void UpdateMipFromPNG();
    void UpdateMipFromJPEG();
    void UpdateMip();
    void Init();
};

UClass* UTexture2DDynamic::pClassPointer = NULL;

// Class Engine.TextureCube
// 0x0044 (0x0174 - 0x0130)
class UTextureCube : public UTexture {
   public:
    int SizeX;                   // 0x0130 (0x0004) [0x0000000000000000]
    int SizeY;                   // 0x0134 (0x0004) [0x0000000000000000]
    unsigned char Format;        // 0x0138 (0x0001) [0x0000000000000000]
    int NumMips;                 // 0x013C (0x0004) [0x0000000000000000]
    DWORD bIsCubemapValid : 1;   // 0x0140 (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    class UTexture2D* FacePosX;  // 0x0144 (0x0008) [0x0000000000000000]
    class UTexture2D* FaceNegX;  // 0x014C (0x0008) [0x0000000000000000]
    class UTexture2D* FacePosY;  // 0x0154 (0x0008) [0x0000000000000000]
    class UTexture2D* FaceNegY;  // 0x015C (0x0008) [0x0000000000000000]
    class UTexture2D* FacePosZ;  // 0x0164 (0x0008) [0x0000000000000000]
    class UTexture2D* FaceNegZ;  // 0x016C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2621];

        return pClassPointer;
    };
};

UClass* UTextureCube::pClassPointer = NULL;

// Class Engine.TextureMovie
// 0x0078 (0x01A8 - 0x0130)
class UTextureMovie : public UTexture {
   public:
    int SizeX;                        // 0x0130 (0x0004) [0x0000000000000000]
    int SizeY;                        // 0x0134 (0x0004) [0x0000000000000000]
    unsigned char Format;             // 0x0138 (0x0001) [0x0000000000000000]
    unsigned char AddressX;           // 0x0139 (0x0001) [0x0000000000000000]
    unsigned char AddressY;           // 0x013A (0x0001) [0x0000000000000000]
    unsigned char MovieStreamSource;  // 0x013B (0x0001) [0x0000000000000000]
    class UClass* DecoderClass;       // 0x013C (0x0008) [0x0000000000000000]
    class UCodecMovie* Decoder;       // 0x0144 (0x0008) [0x0000000000000000]
    DWORD Paused : 1;   // 0x014C (0x0004) [0x0000000000000000] [0x00000001]
    DWORD Stopped : 1;  // 0x014C (0x0004) [0x0000000000000000] [0x00000002]
    DWORD Looping : 1;  // 0x014C (0x0004) [0x0000000000000000] [0x00000004]
    DWORD ResetOnLastFrame : 1;  // 0x014C (0x0004) [0x0000000000000000]
                                 // [0x00000008]
    DWORD AutoPlay : 1;  // 0x014C (0x0004) [0x0000000000000000] [0x00000010]
    struct FUntypedBulkData_Mirror
        Data;                            // 0x0150 (0x0040) [0x0000000000000000]
    struct FPointer ReleaseCodecFence;   // 0x0190 (0x0008) [0x0000000000000000]
    struct FString MovieStreamFilename;  // 0x0198 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2623];

        return pClassPointer;
    };

    void Stop();
    void Pause();
    void Play();
};

UClass* UTextureMovie::pClassPointer = NULL;

// Class Engine.TextureRenderTarget
// 0x0008 (0x0138 - 0x0130)
class UTextureRenderTarget : public UTexture {
   public:
    DWORD bUpdateImmediate : 1;  // 0x0130 (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    DWORD bNeedsTwoCopies : 1;   // 0x0130 (0x0004) [0x0000000000000000]
                                 // [0x00000002]
    DWORD bRenderOnce : 1;  // 0x0130 (0x0004) [0x0000000000000000] [0x00000004]
    float TargetGamma;      // 0x0134 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2625];

        return pClassPointer;
    };
};

UClass* UTextureRenderTarget::pClassPointer = NULL;

// Class Engine.TextureRenderTarget2D
// 0x0020 (0x0158 - 0x0138)
class UTextureRenderTarget2D : public UTextureRenderTarget {
   public:
    int SizeX;                       // 0x0138 (0x0004) [0x0000000000000000]
    int SizeY;                       // 0x013C (0x0004) [0x0000000000000000]
    unsigned char Format;            // 0x0140 (0x0001) [0x0000000000000000]
    unsigned char AddressX;          // 0x0141 (0x0001) [0x0000000000000000]
    unsigned char AddressY;          // 0x0142 (0x0001) [0x0000000000000000]
    struct FLinearColor ClearColor;  // 0x0144 (0x0010) [0x0000000000000000]
    DWORD bForceLinearGamma : 1;     // 0x0154 (0x0004) [0x0000000000000000]
                                     // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2627];

        return pClassPointer;
    };

    void Create();
};

UClass* UTextureRenderTarget2D::pClassPointer = NULL;

// Class Engine.ScriptedTexture
// 0x0014 (0x016C - 0x0158)
class UScriptedTexture : public UTextureRenderTarget2D {
   public:
    DWORD
        bNeedsUpdate : 1;  // 0x0158 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bSkipNextClear : 1;  // 0x0158 (0x0004) [0x0000000000000000]
                               // [0x00000002]
    struct FScriptDelegate
        __Render__Delegate;            // 0x015C (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x0160 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2629];

        return pClassPointer;
    };

    void Render();
};

UClass* UScriptedTexture::pClassPointer = NULL;

// Class Engine.TextureRenderTargetCube
// 0x0005 (0x013D - 0x0138)
class UTextureRenderTargetCube : public UTextureRenderTarget {
   public:
    int SizeX;             // 0x0138 (0x0004) [0x0000000000000000]
    unsigned char Format;  // 0x013C (0x0001) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2631];

        return pClassPointer;
    };
};

UClass* UTextureRenderTargetCube::pClassPointer = NULL;

// Class Engine.AudioDevice
// 0x0300 (0x0368 - 0x0068)
class UAudioDevice : public USubsystem {
   public:
    int MaxChannels;                    // 0x0068 (0x0004) [0x0000000000000000]
    int CommonAudioPoolSize;            // 0x006C (0x0004) [0x0000000000000000]
    float LowPassFilterResonance;       // 0x0070 (0x0004) [0x0000000000000000]
    float MinCompressedDurationEditor;  // 0x0074 (0x0004) [0x0000000000000000]
    float MinCompressedDurationGame;    // 0x0078 (0x0004) [0x0000000000000000]
    struct FString
        ChirpInSoundNodeWaveName;  // 0x007C (0x0010) [0x0000000000000000]
    class USoundNodeWave*
        ChirpInSoundNodeWave;  // 0x008C (0x0008) [0x0000000000000000]
    struct FString
        ChirpOutSoundNodeWaveName;  // 0x0094 (0x0010) [0x0000000000000000]
    class USoundNodeWave*
        ChirpOutSoundNodeWave;        // 0x00A4 (0x0008) [0x0000000000000000]
    struct FPointer CommonAudioPool;  // 0x00AC (0x0008) [0x0000000000000000]
    int CommonAudioPoolFreeBytes;     // 0x00B4 (0x0004) [0x0000000000000000]
    TArray<class UAudioComponent*>
        AudioComponents;              // 0x00B8 (0x0010) [0x0000000000000000]
    TArray<struct FPointer> Sources;  // 0x00C8 (0x0010) [0x0000000000000000]
    TArray<struct FPointer>
        FreeSources;  // 0x00D8 (0x0010) [0x0000000000000000]
    unsigned char
        UnknownData00[0x48];    // 0x00E8 (0x0048) UNKNOWN PROPERTY: MapProperty
                                // Engine.AudioDevice.WaveInstanceSourceMap
    DWORD bGameWasTicking : 1;  // 0x0130 (0x0004) [0x0000000000000000]
                                // [0x00000001]
    DWORD bSoundSpawningEnabled : 1;     // 0x0130 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    TArray<struct FListener> Listeners;  // 0x0134 (0x0010) [0x0000000000000000]
    struct FQWord CurrentTick;           // 0x0144 (0x0008) [0x0000000000000000]
    unsigned char
        UnknownData01[0x48];  // 0x014C (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.AudioDevice.SoundClasses
    unsigned char
        UnknownData02[0x48];  // 0x0194 (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.AudioDevice.SourceSoundClasses
    unsigned char
        UnknownData03[0x48];  // 0x01DC (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.AudioDevice.CurrentSoundClasses
    unsigned char
        UnknownData04[0x48];  // 0x0224 (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.AudioDevice.DestinationSoundClasses
    unsigned char
        UnknownData05[0x48];  // 0x026C (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.AudioDevice.SoundModes
    struct FPointer Effects;  // 0x02B4 (0x0008) [0x0000000000000000]
    struct FName BaseSoundModeName;     // 0x02BC (0x0008) [0x0000000000000000]
    class USoundMode* CurrentMode;      // 0x02C4 (0x0008) [0x0000000000000000]
    struct FDouble SoundModeStartTime;  // 0x02CC (0x0008) [0x0000000000000000]
    struct FDouble
        SoundModeFadeInStartTime;  // 0x02D4 (0x0008) [0x0000000000000000]
    struct FDouble
        SoundModeFadeInEndTime;       // 0x02DC (0x0008) [0x0000000000000000]
    struct FDouble SoundModeEndTime;  // 0x02E4 (0x0008) [0x0000000000000000]
    int ListenerVolumeIndex;          // 0x02EC (0x0004) [0x0000000000000000]
    struct FInteriorSettings
        ListenerInteriorSettings;       // 0x02F0 (0x0024) [0x0000000000000000]
    struct FDouble InteriorStartTime;   // 0x0314 (0x0008) [0x0000000000000000]
    struct FDouble InteriorEndTime;     // 0x031C (0x0008) [0x0000000000000000]
    struct FDouble ExteriorEndTime;     // 0x0324 (0x0008) [0x0000000000000000]
    struct FDouble InteriorLPFEndTime;  // 0x032C (0x0008) [0x0000000000000000]
    struct FDouble ExteriorLPFEndTime;  // 0x0334 (0x0008) [0x0000000000000000]
    float InteriorVolumeInterp;         // 0x033C (0x0004) [0x0000000000000000]
    float InteriorLPFInterp;            // 0x0340 (0x0004) [0x0000000000000000]
    float ExteriorVolumeInterp;         // 0x0344 (0x0004) [0x0000000000000000]
    float ExteriorLPFInterp;            // 0x0348 (0x0004) [0x0000000000000000]
    class UAudioComponent*
        TestAudioComponent;        // 0x034C (0x0008) [0x0000000000000000]
    struct FPointer TextToSpeech;  // 0x0354 (0x0008) [0x0000000000000000]
    unsigned char DebugState;      // 0x035C (0x0001) [0x0000000000000000]
    float TransientMasterVolume;   // 0x0360 (0x0004) [0x0000000000000000]
    float LastUpdateTime;          // 0x0364 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2633];

        return pClassPointer;
    };

    void FindSoundClass();
    void SetSoundMode();
};

UClass* UAudioDevice::pClassPointer = NULL;

// Class Engine.SoundClass
// 0x0080 (0x00E0 - 0x0060)
class USoundClass : public UObject {
   public:
    struct FSoundClassProperties
        Properties;  // 0x0060 (0x0020) [0x0000000000000000]
    TArray<struct FName>
        ChildClassNames;  // 0x0080 (0x0010) [0x0000000000000000]
    DWORD bIsChild : 1;   // 0x0090 (0x0004) [0x0000000000000000] [0x00000001]
    int MenuID;           // 0x0094 (0x0004) [0x0000000000000000]
    unsigned char
        UnknownData00[0x48];  // 0x0098 (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.SoundClass.EditorData

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2635];

        return pClassPointer;
    };
};

UClass* USoundClass::pClassPointer = NULL;

// Class Engine.SoundMode
// 0x0048 (0x00A8 - 0x0060)
class USoundMode : public UObject {
   public:
    DWORD bApplyEQ : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000001]
    struct FAudioEQEffect EQSettings;  // 0x0064 (0x0024) [0x0000000000000000]
    TArray<struct FSoundClassAdjuster>
        SoundClassEffects;  // 0x0088 (0x0010) [0x0000000000000000]
    float InitialDelay;     // 0x0098 (0x0004) [0x0000000000000000]
    float FadeInTime;       // 0x009C (0x0004) [0x0000000000000000]
    float Duration;         // 0x00A0 (0x0004) [0x0000000000000000]
    float FadeOutTime;      // 0x00A4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2637];

        return pClassPointer;
    };
};

UClass* USoundMode::pClassPointer = NULL;

// Class Engine.MatineePawn
// 0x0008 (0x0560 - 0x0558)
class AMatineePawn : public APawn {
   public:
    class USkeletalMesh* PreviewMesh;  // 0x0558 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2639];

        return pClassPointer;
    };
};

UClass* AMatineePawn::pClassPointer = NULL;

// Class Engine.Scout
// 0x0098 (0x05F0 - 0x0558)
class AScout : public APawn {
   public:
    TArray<struct FPathSizeInfo>
        PathSizes;             // 0x0558 (0x0010) [0x0000000000000000]
    float TestJumpZ;           // 0x0568 (0x0004) [0x0000000000000000]
    float TestGroundSpeed;     // 0x056C (0x0004) [0x0000000000000000]
    float TestMaxFallSpeed;    // 0x0570 (0x0004) [0x0000000000000000]
    float TestFallSpeed;       // 0x0574 (0x0004) [0x0000000000000000]
    float MaxLandingVelocity;  // 0x0578 (0x0004) [0x0000000000000000]
    int MinNumPlayerStarts;    // 0x057C (0x0004) [0x0000000000000000]
    class UClass*
        DefaultReachSpecClass;  // 0x0580 (0x0008) [0x0000000000000000]
    TArray<struct FColor>
        EdgePathColors;                 // 0x0588 (0x0010) [0x0000000000000000]
    float NavMeshGen_StepSize;          // 0x0598 (0x0004) [0x0000000000000000]
    float NavMeshGen_EntityHalfHeight;  // 0x059C (0x0004) [0x0000000000000000]
    float NavMeshGen_StartingHeightOffset;  // 0x05A0 (0x0004)
                                            // [0x0000000000000000]
    float NavMeshGen_MaxDropHeight;  // 0x05A4 (0x0004) [0x0000000000000000]
    float NavMeshGen_MaxStepHeight;  // 0x05A8 (0x0004) [0x0000000000000000]
    float NavMeshGen_VertZDeltaSnapThresh;  // 0x05AC (0x0004)
                                            // [0x0000000000000000]
    float NavMeshGen_MinPolyArea;  // 0x05B0 (0x0004) [0x0000000000000000]
    float NavMeshGen_BorderBackfill_CheckDist;  // 0x05B4 (0x0004)
                                                // [0x0000000000000000]
    float NavMeshGen_MinMergeDotAreaThreshold;  // 0x05B8 (0x0004)
                                                // [0x0000000000000000]
    float NavMeshGen_MinMergeDotSmallArea;      // 0x05BC (0x0004)
                                                // [0x0000000000000000]
    float NavMeshGen_MinMergeDotLargeArea;      // 0x05C0 (0x0004)
                                                // [0x0000000000000000]
    float NavMeshGen_MaxPolyHeight;  // 0x05C4 (0x0004) [0x0000000000000000]
    float NavMeshGen_HeightMergeThreshold;  // 0x05C8 (0x0004)
                                            // [0x0000000000000000]
    float NavMeshGen_EdgeMaxDelta;  // 0x05CC (0x0004) [0x0000000000000000]
    float
        NavMeshGen_MaxGroundCheckSize;  // 0x05D0 (0x0004) [0x0000000000000000]
    float NavMeshGen_MinEdgeLength;     // 0x05D4 (0x0004) [0x0000000000000000]
    DWORD NavMeshGen_ExpansionDoObstacleMeshSimplification : 1;  // 0x05D8
                                                                 // (0x0004)
                                                                 // [0x0000000000000000]
                                                                 // [0x00000001]
    DWORD bHightlightOneWayReachSpecs : 1;  // 0x05D8 (0x0004)
                                            // [0x0000000000000000] [0x00000002]
    float MinMantleFallDist;     // 0x05DC (0x0004) [0x0000000000000000]
    float MaxMantleFallDist;     // 0x05E0 (0x0004) [0x0000000000000000]
    float MinMantleLateralDist;  // 0x05E4 (0x0004) [0x0000000000000000]
    float MaxMantleLateralDist;  // 0x05E8 (0x0004) [0x0000000000000000]
    float MaxMantleFallTime;     // 0x05EC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2641];

        return pClassPointer;
    };

    void eventPreBeginPlay();
};

UClass* AScout::pClassPointer = NULL;

// Class Engine.Light
// 0x0064 (0x02A8 - 0x0244)
class ALight : public AActor {
   public:
    class ULightComponent*
        LightComponent;           // 0x0244 (0x0008) [0x0000000000000000]
    float MaxBrightness;          // 0x024C (0x0004) [0x0000000000000000]
    float MinBrightness;          // 0x0250 (0x0004) [0x0000000000000000]
    unsigned char AnimationType;  // 0x0254 (0x0001) [0x0000000000000000]
    float AnimationFrequency;     // 0x0258 (0x0004) [0x0000000000000000]
    float AnimationTimeOffset;    // 0x025C (0x0004) [0x0000000000000000]
    class UStaticMeshComponent*
        LightMesh;  // 0x0260 (0x0008) [0x0000000000000000]
    TArray<class UMaterialInstanceConstant*>
        LightMeshMICs;  // 0x0268 (0x0010) [0x0000000000000000]
    TArray<class UMaterialInstanceConstant*>
        BaseMeshMICs;  // 0x0278 (0x0010) [0x0000000000000000]
    class ULensFlareComponent*
        LensFlareComp;  // 0x0288 (0x0008) [0x0000000000000000]
    TArray<class UMaterialInstanceConstant*>
        LensFlareMICs;       // 0x0290 (0x0010) [0x0000000000000000]
    float CurveOutputValue;  // 0x02A0 (0x0004) [0x0000000000000000]
    DWORD bEnabled : 1;  // 0x02A4 (0x0004) [0x0000000000150000] [0x00000001] (
                         // CPF_Travel | CPF_GlobalConfig )

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2643];

        return pClassPointer;
    };

    void eventTriggerFlickerEvent();
    void eventPostBeginPlay();
    void HasVolumetricLightMesh();
    void OnToggle();
    void eventReplicatedEvent();
    void AreLightFunctionsSupported();
    void IsVolumetricLightingSupported();
};

UClass* ALight::pClassPointer = NULL;

// Class Engine.DirectionalLight
// 0x0000 (0x02A8 - 0x02A8)
class ADirectionalLight : public ALight {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2645];

        return pClassPointer;
    };
};

UClass* ADirectionalLight::pClassPointer = NULL;

// Class Engine.DirectionalLightToggleable
// 0x0000 (0x02A8 - 0x02A8)
class ADirectionalLightToggleable : public ADirectionalLight {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2647];

        return pClassPointer;
    };
};

UClass* ADirectionalLightToggleable::pClassPointer = NULL;

// Class Engine.DominantDirectionalLight
// 0x0000 (0x02A8 - 0x02A8)
class ADominantDirectionalLight : public ADirectionalLight {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2649];

        return pClassPointer;
    };
};

UClass* ADominantDirectionalLight::pClassPointer = NULL;

// Class Engine.DominantDirectionalLightMovable
// 0x0000 (0x02A8 - 0x02A8)
class ADominantDirectionalLightMovable : public ADominantDirectionalLight {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2651];

        return pClassPointer;
    };
};

UClass* ADominantDirectionalLightMovable::pClassPointer = NULL;

// Class Engine.PointLight
// 0x0000 (0x02A8 - 0x02A8)
class APointLight : public ALight {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2653];

        return pClassPointer;
    };
};

UClass* APointLight::pClassPointer = NULL;

// Class Engine.DominantPointLight
// 0x0000 (0x02A8 - 0x02A8)
class ADominantPointLight : public APointLight {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2655];

        return pClassPointer;
    };
};

UClass* ADominantPointLight::pClassPointer = NULL;

// Class Engine.PointLightMovable
// 0x0000 (0x02A8 - 0x02A8)
class APointLightMovable : public APointLight {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2657];

        return pClassPointer;
    };
};

UClass* APointLightMovable::pClassPointer = NULL;

// Class Engine.PointLightToggleable
// 0x0000 (0x02A8 - 0x02A8)
class APointLightToggleable : public APointLight {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2659];

        return pClassPointer;
    };

    void ApplyCheckpointRecord();
    void CreateCheckpointRecord();
    void ShouldSaveForCheckpoint();
};

UClass* APointLightToggleable::pClassPointer = NULL;

// Class Engine.SkyLight
// 0x0000 (0x02A8 - 0x02A8)
class ASkyLight : public ALight {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2661];

        return pClassPointer;
    };
};

UClass* ASkyLight::pClassPointer = NULL;

// Class Engine.SkyLightToggleable
// 0x0000 (0x02A8 - 0x02A8)
class ASkyLightToggleable : public ASkyLight {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2663];

        return pClassPointer;
    };
};

UClass* ASkyLightToggleable::pClassPointer = NULL;

// Class Engine.SpotLight
// 0x0000 (0x02A8 - 0x02A8)
class ASpotLight : public ALight {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2665];

        return pClassPointer;
    };
};

UClass* ASpotLight::pClassPointer = NULL;

// Class Engine.DominantSpotLight
// 0x0000 (0x02A8 - 0x02A8)
class ADominantSpotLight : public ASpotLight {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2667];

        return pClassPointer;
    };
};

UClass* ADominantSpotLight::pClassPointer = NULL;

// Class Engine.GeneratedMeshAreaLight
// 0x0000 (0x02A8 - 0x02A8)
class AGeneratedMeshAreaLight : public ASpotLight {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2669];

        return pClassPointer;
    };
};

UClass* AGeneratedMeshAreaLight::pClassPointer = NULL;

// Class Engine.SpotLightMovable
// 0x0000 (0x02A8 - 0x02A8)
class ASpotLightMovable : public ASpotLight {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2671];

        return pClassPointer;
    };
};

UClass* ASpotLightMovable::pClassPointer = NULL;

// Class Engine.SpotLightToggleable
// 0x0000 (0x02A8 - 0x02A8)
class ASpotLightToggleable : public ASpotLight {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2673];

        return pClassPointer;
    };

    void ApplyCheckpointRecord();
    void CreateCheckpointRecord();
    void ShouldSaveForCheckpoint();
};

UClass* ASpotLightToggleable::pClassPointer = NULL;

// Class Engine.StaticLightCollectionActor
// 0x0014 (0x02BC - 0x02A8)
class AStaticLightCollectionActor : public ALight {
   public:
    TArray<class ULightComponent*>
        LightComponents;     // 0x02A8 (0x0010) [0x0000000000000000]
    int MaxLightComponents;  // 0x02B8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2675];

        return pClassPointer;
    };
};

UClass* AStaticLightCollectionActor::pClassPointer = NULL;

// Class Engine.LightComponent
// 0x013F (0x01C4 - 0x0085)
class ULightComponent : public UActorComponent {
   public:
    struct FPointer SceneInfo;       // 0x0088 (0x0008) [0x0000000000000000]
    struct FMatrix WorldToLight;     // 0x0090 (0x0040) [0x0000000000000000]
    struct FMatrix LightToWorld;     // 0x00D0 (0x0040) [0x0000000000000000]
    struct FGuid LightGuid;          // 0x0110 (0x0010) [0x0000000000000000]
    struct FGuid LightmapGuid;       // 0x0120 (0x0010) [0x0000000000000000]
    float Brightness;                // 0x0130 (0x0004) [0x0000000000000000]
    struct FColor LightColor;        // 0x0134 (0x0004) [0x0000000000000000]
    float Hardness;                  // 0x0138 (0x0004) [0x0000000000000000]
    class ULightFunction* Function;  // 0x013C (0x0008) [0x0000000000000000]
    DWORD bEnabled : 1;     // 0x0144 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD CastShadows : 1;  // 0x0144 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD CastStaticShadows : 1;        // 0x0144 (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    DWORD CastDynamicShadows : 1;       // 0x0144 (0x0004) [0x0000000000000000]
                                        // [0x00000008]
    DWORD ForceCastDynamicShadows : 1;  // 0x0144 (0x0004) [0x0000000000000000]
                                        // [0x00000010]
    DWORD bCastCompositeShadow : 1;     // 0x0144 (0x0004) [0x0000000000000000]
                                        // [0x00000020]
    DWORD bAffectCompositeShadowDirection : 1;  // 0x0144 (0x0004)
                                                // [0x0000000000000000]
                                                // [0x00000040]
    DWORD bNonModulatedSelfShadowing : 1;       // 0x0144 (0x0004)
                                           // [0x0000000000000000] [0x00000080]
    DWORD bSelfShadowOnly : 1;     // 0x0144 (0x0004) [0x0000000000000000]
                                   // [0x00000100]
    DWORD bAllowPreShadow : 1;     // 0x0144 (0x0004) [0x0000000000000000]
                                   // [0x00000200]
    DWORD bForceDynamicLight : 1;  // 0x0144 (0x0004) [0x0000000000000000]
                                   // [0x00000400]
    DWORD UseDirectLightMap : 1;   // 0x0144 (0x0004) [0x0000000000000000]
                                   // [0x00000800]
    DWORD bHasLightEverBeenBuiltIntoLightMap : 1;  // 0x0144 (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00001000]
    DWORD bCanAffectDynamicPrimitivesOutsideDynamicChannel : 1;  // 0x0144
                                                                 // (0x0004)
                                                                 // [0x0000000000000000]
                                                                 // [0x00002000]
    DWORD bRenderLightShafts : 1;  // 0x0144 (0x0004) [0x0000000000000000]
                                   // [0x00004000]
    DWORD bUseImageReflectionSpecular : 1;  // 0x0144 (0x0004)
                                            // [0x0000000000000000] [0x00008000]
    DWORD bPrecomputedLightingIsValid : 1;  // 0x0144 (0x0004)
                                            // [0x0000000000000000] [0x00010000]
    DWORD bExplicitlyAssignedLight : 1;  // 0x0144 (0x0004) [0x0000000000000000]
                                         // [0x00020000]
    DWORD bAllowCompositingIntoDLE : 1;  // 0x0144 (0x0004) [0x0000000000000000]
                                         // [0x00040000]
    DWORD bCastPerObjectShadows : 1;     // 0x0144 (0x0004) [0x0000000000000000]
                                         // [0x00080000]
    DWORD
        bOverrideAutoLightingChannels : 1;  // 0x0144 (0x0004)
                                            // [0x0000000000000000] [0x00100000]
    DWORD bDisableSpecular : 1;        // 0x0144 (0x0004) [0x0000000000000000]
                                       // [0x00200000]
    DWORD bOverrideLightAnimTick : 1;  // 0x0144 (0x0004) [0x0000000000000000]
                                       // [0x00400000]
    DWORD bUpdateOwnerRenderTime : 1;  // 0x0144 (0x0004) [0x0000000000000000]
                                       // [0x00800000]
    class ULightEnvironmentComponent*
        LightEnvironment;  // 0x0148 (0x0008) [0x0000000000000000]
    struct FLightingChannelContainer
        LightingChannels;  // 0x0150 (0x0004) [0x0000000000000000]
    unsigned char
        LightAffectsClassification;      // 0x0154 (0x0001) [0x0000000000000000]
    unsigned char LightShadowMode;       // 0x0155 (0x0001) [0x0000000000000000]
    struct FLinearColor ModShadowColor;  // 0x0158 (0x0010) [0x0000000000000000]
    float ModShadowFadeoutTime;          // 0x0168 (0x0004) [0x0000000000000000]
    float ModShadowFadeoutExponent;      // 0x016C (0x0004) [0x0000000000000000]
    int LightListIndex;                  // 0x0170 (0x0004) [0x0000000000000000]
    unsigned char
        ShadowProjectionTechnique;       // 0x0174 (0x0001) [0x0000000000000000]
    unsigned char ShadowFilterQuality;   // 0x0175 (0x0001) [0x0000000000000000]
    int MinShadowResolution;             // 0x0178 (0x0004) [0x0000000000000000]
    int MaxShadowResolution;             // 0x017C (0x0004) [0x0000000000000000]
    int ShadowFadeResolution;            // 0x0180 (0x0004) [0x0000000000000000]
    float OcclusionDepthRange;           // 0x0184 (0x0004) [0x0000000000000000]
    float BloomScale;                    // 0x0188 (0x0004) [0x0000000000000000]
    float BloomThreshold;                // 0x018C (0x0004) [0x0000000000000000]
    float BloomScreenBlendThreshold;     // 0x0190 (0x0004) [0x0000000000000000]
    struct FColor BloomTint;             // 0x0194 (0x0004) [0x0000000000000000]
    float RadialBlurPercent;             // 0x0198 (0x0004) [0x0000000000000000]
    float OcclusionMaskDarkness;         // 0x019C (0x0004) [0x0000000000000000]
    float ReflectionSpecularBrightness;  // 0x01A0 (0x0004) [0x0000000000000000]
    float MaxDrawDistance;               // 0x01A4 (0x0004) [0x0000000000000000]
    float MaxBrightness;                 // 0x01A8 (0x0004) [0x0000000000000000]
    float MinBrightness;                 // 0x01AC (0x0004) [0x0000000000000000]
    unsigned char AnimationType;         // 0x01B0 (0x0001) [0x0000000000000000]
    float AnimationFrequency;            // 0x01B4 (0x0004) [0x0000000000000000]
    float AnimationTimeOffset;           // 0x01B8 (0x0004) [0x0000000000000000]
    int LightAnimFrameCount;             // 0x01BC (0x0004) [0x0000000000000000]
    float LastRenderTime;                // 0x01C0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2677];

        return pClassPointer;
    };

    void OnUpdatePropertyLightColor();
    void OnUpdatePropertyBrightness();
    void OnUpdatePropertyOcclusionMaskDarkness();
    void OnUpdatePropertyBloomTint();
    void OnUpdatePropertyBloomScale();
    void UpdateLightShaftParameters();
    void UpdateColorAndBrightness();
    void GetDirection();
    void GetOrigin();
    void SetLightProperties();
    void SetEnabled();
};

UClass* ULightComponent::pClassPointer = NULL;

// Class Engine.DirectionalLightComponent
// 0x0020 (0x01E4 - 0x01C4)
class UDirectionalLightComponent : public ULightComponent {
   public:
    float TraceDistance;  // 0x01C4 (0x0004) [0x0000000000000000]
    float
        WholeSceneDynamicShadowRadius;  // 0x01C8 (0x0004) [0x0000000000000000]
    int NumWholeSceneDynamicShadowCascades;  // 0x01CC (0x0004)
                                             // [0x0000000000000000]
    float CascadeDistributionExponent;  // 0x01D0 (0x0004) [0x0000000000000000]
    struct FLightmassDirectionalLightSettings
        LightmassSettings;  // 0x01D4 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2679];

        return pClassPointer;
    };

    void OnUpdatePropertyBrightness();
    void OnUpdatePropertyLightColor();
};

UClass* UDirectionalLightComponent::pClassPointer = NULL;

// Class Engine.DominantDirectionalLightComponent
// 0x00CC (0x02B0 - 0x01E4)
class UDominantDirectionalLightComponent : public UDirectionalLightComponent {
   public:
    unsigned char UnknownData00[0xC];  // 0x01E4 (0x000C) MISSED OFFSET
    struct FDominantShadowInfo
        DominantLightShadowInfo;  // 0x01F0 (0x00B0) [0x0000000000000000]
    struct FArray_Mirror
        DominantLightShadowMap;  // 0x02A0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2681];

        return pClassPointer;
    };
};

UClass* UDominantDirectionalLightComponent::pClassPointer = NULL;

// Class Engine.PointLightComponent
// 0x00A8 (0x026C - 0x01C4)
class UPointLightComponent : public ULightComponent {
   public:
    float ShadowRadiusMultiplier;        // 0x01C4 (0x0004) [0x0000000000000000]
    float Radius;                        // 0x01C8 (0x0004) [0x0000000000000000]
    float FalloffExponent;               // 0x01CC (0x0004) [0x0000000000000000]
    float ShadowFalloffExponent;         // 0x01D0 (0x0004) [0x0000000000000000]
    float MinShadowFalloffRadius;        // 0x01D4 (0x0004) [0x0000000000000000]
    unsigned char UnknownData00[0x8];    // 0x01D8 (0x0008) MISSED OFFSET
    struct FMatrix CachedParentToWorld;  // 0x01E0 (0x0040) [0x0000000000000000]
    struct FVector Translation;          // 0x0220 (0x000C) [0x0000000000000000]
    unsigned char UnknownData01[0x4];    // 0x022C (0x0004) MISSED OFFSET
    struct FPlane ShadowPlane;           // 0x0230 (0x0010) [0x0000000000000000]
    class UDrawLightRadiusComponent*
        PreviewLightRadius;  // 0x0240 (0x0008) [0x0000000000000000]
    struct FLightmassPointLightSettings
        LightmassSettings;  // 0x0248 (0x0010) [0x0000000000000000]
    class UDrawLightRadiusComponent*
        PreviewLightSourceRadius;  // 0x0258 (0x0008) [0x0000000000000000]
    class USpriteComponent*
        LightSprite;                // 0x0260 (0x0008) [0x0000000000000000]
    DWORD bAIIgnoreLuminosity : 1;  // 0x0268 (0x0004) [0x0000000000000000]
                                    // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2683];

        return pClassPointer;
    };

    void OnUpdatePropertyBrightness();
    void OnUpdatePropertyLightColor();
    void SetRadius();
    void SetTranslation();
};

UClass* UPointLightComponent::pClassPointer = NULL;

// Class Engine.DominantPointLightComponent
// 0x0000 (0x026C - 0x026C)
class UDominantPointLightComponent : public UPointLightComponent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2685];

        return pClassPointer;
    };
};

UClass* UDominantPointLightComponent::pClassPointer = NULL;

// Class Engine.SpotLightComponent
// 0x0028 (0x0294 - 0x026C)
class USpotLightComponent : public UPointLightComponent {
   public:
    float InnerConeAngle;       // 0x026C (0x0004) [0x0000000000000000]
    float OuterConeAngle;       // 0x0270 (0x0004) [0x0000000000000000]
    float LightShaftConeAngle;  // 0x0274 (0x0004) [0x0000000000000000]
    class UDrawLightConeComponent*
        PreviewInnerCone;  // 0x0278 (0x0008) [0x0000000000000000]
    class UDrawLightConeComponent*
        PreviewOuterCone;      // 0x0280 (0x0008) [0x0000000000000000]
    struct FRotator Rotation;  // 0x0288 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2687];

        return pClassPointer;
    };

    void SetRotation();
};

UClass* USpotLightComponent::pClassPointer = NULL;

// Class Engine.DominantSpotLightComponent
// 0x00CC (0x0360 - 0x0294)
class UDominantSpotLightComponent : public USpotLightComponent {
   public:
    unsigned char UnknownData00[0xC];  // 0x0294 (0x000C) MISSED OFFSET
    struct FDominantShadowInfo
        DominantLightShadowInfo;  // 0x02A0 (0x00B0) [0x0000000000000000]
    struct FArray_Mirror
        DominantLightShadowMap;  // 0x0350 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2689];

        return pClassPointer;
    };
};

UClass* UDominantSpotLightComponent::pClassPointer = NULL;

// Class Engine.SkyLightComponent
// 0x0008 (0x01CC - 0x01C4)
class USkyLightComponent : public ULightComponent {
   public:
    float LowerBrightness;     // 0x01C4 (0x0004) [0x0000000000000000]
    struct FColor LowerColor;  // 0x01C8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2691];

        return pClassPointer;
    };
};

UClass* USkyLightComponent::pClassPointer = NULL;

// Class Engine.SphericalHarmonicLightComponent
// 0x00A0 (0x0264 - 0x01C4)
class USphericalHarmonicLightComponent : public ULightComponent {
   public:
    unsigned char UnknownData00[0xC];  // 0x01C4 (0x000C) MISSED OFFSET
    struct FSHVectorRGB
        WorldSpaceIncidentLighting;     // 0x01D0 (0x0090) [0x0000000000000000]
    DWORD bRenderBeforeModShadows : 1;  // 0x0260 (0x0004) [0x0000000000000000]
                                        // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2693];

        return pClassPointer;
    };
};

UClass* USphericalHarmonicLightComponent::pClassPointer = NULL;

// Class Engine.LightEnvironmentComponent
// 0x0023 (0x00A8 - 0x0085)
class ULightEnvironmentComponent : public UActorComponent {
   public:
    DWORD bEnabled : 1;  // 0x0088 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bForceNonCompositeDynamicLights : 1;     // 0x0088 (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00000002]
    DWORD bAllowDynamicShadowsOnTranslucency : 1;  // 0x0088 (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00000004]
    DWORD bAllowPreShadow : 1;        // 0x0088 (0x0004) [0x0000000000000000]
                                      // [0x00000008]
    DWORD bTranslucencyShadowed : 1;  // 0x0088 (0x0004) [0x0000000000000000]
                                      // [0x00000010]
    float DominantShadowFactor;       // 0x008C (0x0004) [0x0000000000000000]
    class ULightComponent*
        AffectingDominantLight;  // 0x0090 (0x0008) [0x0000000000000000]
    TArray<class UPrimitiveComponent*>
        AffectedComponents;  // 0x0098 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2695];

        return pClassPointer;
    };

    void IsEnabled();
    void SetEnabled();
};

UClass* ULightEnvironmentComponent::pClassPointer = NULL;

// Class Engine.DynamicLightEnvironmentComponent
// 0x00B0 (0x0158 - 0x00A8)
class UDynamicLightEnvironmentComponent : public ULightEnvironmentComponent {
   public:
    struct FPointer State;            // 0x00A8 (0x0008) [0x0000000000000000]
    float InvisibleUpdateTime;        // 0x00B0 (0x0004) [0x0000000000000000]
    float MinTimeBetweenFullUpdates;  // 0x00B4 (0x0004) [0x0000000000000000]
    float VelocityUpdateTimeScale;    // 0x00B8 (0x0004) [0x0000000000000000]
    float ShadowInterpolationSpeed;   // 0x00BC (0x0004) [0x0000000000000000]
    int NumVolumeVisibilitySamples;   // 0x00C0 (0x0004) [0x0000000000000000]
    float LightingBoundsScale;        // 0x00C4 (0x0004) [0x0000000000000000]
    struct FLinearColor
        AmbientShadowColor;  // 0x00C8 (0x0010) [0x0000000000000000]
    struct FVector
        AmbientShadowSourceDirection;  // 0x00D8 (0x000C) [0x0000000000000000]
    struct FLinearColor AmbientGlow;   // 0x00E4 (0x0010) [0x0000000000000000]
    float LightDistance;               // 0x00F4 (0x0004) [0x0000000000000000]
    float ShadowDistance;              // 0x00F8 (0x0004) [0x0000000000000000]
    DWORD
        bCastShadows : 1;  // 0x00FC (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bCompositeShadowsFromDynamicLights : 1;  // 0x00FC (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00000002]
    DWORD bForceCompositeAllLights : 1;  // 0x00FC (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD
        bAffectedBySmallDynamicLights : 1;  // 0x00FC (0x0004)
                                            // [0x0000000000000000] [0x00000008]
    DWORD bUseBooleanEnvironmentShadowing : 1;  // 0x00FC (0x0004)
                                                // [0x0000000000000000]
                                                // [0x00000010]
    DWORD bShadowFromEnvironment : 1;  // 0x00FC (0x0004) [0x0000000000000000]
                                       // [0x00000020]
    DWORD bDynamic : 1;  // 0x00FC (0x0004) [0x0000000000000000] [0x00000040]
    DWORD bSynthesizeDirectionalLight : 1;  // 0x00FC (0x0004)
                                            // [0x0000000000000000] [0x00000080]
    DWORD bSynthesizeSHLight : 1;  // 0x00FC (0x0004) [0x0000000000000000]
                                   // [0x00000100]
    DWORD bRequiresNonLatentUpdates : 1;  // 0x00FC (0x0004)
                                          // [0x0000000000000000] [0x00000200]
    DWORD
        bTraceFromClosestBoundsPoint : 1;  // 0x00FC (0x0004)
                                           // [0x0000000000000000] [0x00000400]
    DWORD
        bIsCharacterLightEnvironment : 1;  // 0x00FC (0x0004)
                                           // [0x0000000000000000] [0x00000800]
    DWORD bOverrideOwnerLightingChannels : 1;  // 0x00FC (0x0004)
                                               // [0x0000000000000000]
                                               // [0x00001000]
    DWORD bAlwaysInfluencedByDominantDirectionalLight : 1;  // 0x00FC (0x0004)
                                                            // [0x0000000000000000]
                                                            // [0x00002000]
    float ModShadowFadeoutTime;      // 0x0100 (0x0004) [0x0000000000000000]
    float ModShadowFadeoutExponent;  // 0x0104 (0x0004) [0x0000000000000000]
    struct FLinearColor
        MaxModulatedShadowColor;  // 0x0108 (0x0010) [0x0000000000000000]
    float DominantShadowTransitionStartDistance;  // 0x0118 (0x0004)
                                                  // [0x0000000000000000]
    float DominantShadowTransitionEndDistance;    // 0x011C (0x0004)
                                                  // [0x0000000000000000]
    float MinShadowAngle;        // 0x0120 (0x0004) [0x0000000000000000]
    unsigned char BoundsMethod;  // 0x0124 (0x0001) [0x0000000000000000]
    struct FBoxSphereBounds
        OverriddenBounds;  // 0x0128 (0x001C) [0x0000000000000000]
    struct FLightingChannelContainer
        OverriddenLightingChannels;  // 0x0144 (0x0004) [0x0000000000000000]
    TArray<class ULightComponent*>
        OverriddenLightComponents;  // 0x0148 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2697];

        return pClassPointer;
    };

    void ResetEnvironment();
};

UClass* UDynamicLightEnvironmentComponent::pClassPointer = NULL;

// Class Engine.ParticleLightEnvironmentComponent
// 0x001C (0x0174 - 0x0158)
class UParticleLightEnvironmentComponent
    : public UDynamicLightEnvironmentComponent {
   public:
    int ReferenceCount;              // 0x0158 (0x0004) [0x0000000000000000]
    int NumPooledReuses;             // 0x015C (0x0004) [0x0000000000000000]
    class AActor* SharedInstigator;  // 0x0160 (0x0008) [0x0000000000000000]
    class UParticleSystem*
        SharedParticleSystem;    // 0x0168 (0x0008) [0x0000000000000000]
    DWORD bAllowDLESharing : 1;  // 0x0170 (0x0004) [0x0000000000000000]
                                 // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2699];

        return pClassPointer;
    };
};

UClass* UParticleLightEnvironmentComponent::pClassPointer = NULL;

// Class Engine.DrawLightConeComponent
// 0x0000 (0x0248 - 0x0248)
class UDrawLightConeComponent : public UDrawConeComponent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2701];

        return pClassPointer;
    };
};

UClass* UDrawLightConeComponent::pClassPointer = NULL;

// Class Engine.DrawLightRadiusComponent
// 0x0000 (0x0250 - 0x0250)
class UDrawLightRadiusComponent : public UDrawSphereComponent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2703];

        return pClassPointer;
    };
};

UClass* UDrawLightRadiusComponent::pClassPointer = NULL;

// Class Engine.LightFunction
// 0x0018 (0x0078 - 0x0060)
class ULightFunction : public UObject {
   public:
    class UMaterialInterface*
        SourceMaterial;        // 0x0060 (0x0008) [0x0000000000000000]
    struct FVector Scale;      // 0x0068 (0x000C) [0x0000000000000000]
    float DisabledBrightness;  // 0x0074 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2705];

        return pClassPointer;
    };
};

UClass* ULightFunction::pClassPointer = NULL;

// Class Engine.SkeletalMeshComponent
// 0x05D8 (0x0820 - 0x0248)
class USkeletalMeshComponent : public UMeshComponent {
   public:
    class USkeletalMesh* SkeletalMesh;  // 0x0248 (0x0008) [0x0000000000000000]
    class USkeletalMeshComponent*
        AttachedToSkelComponent;        // 0x0250 (0x0008) [0x0000000000000000]
    class UAnimTree* AnimTreeTemplate;  // 0x0258 (0x0008) [0x0000000000000000]
    class UAnimNode* Animations;        // 0x0260 (0x0008) [0x0000000000000000]
    TArray<class UAnimNode*>
        AnimTickArray;  // 0x0268 (0x0010) [0x0000000000000000]
    TArray<class UAnimNode*>
        AnimAlwaysTickArray;             // 0x0278 (0x0010) [0x0000000000000000]
    TArray<int> AnimTickRelevancyArray;  // 0x0288 (0x0010) [0x0000000000000000]
    TArray<float> AnimTickWeightsArray;  // 0x0298 (0x0010) [0x0000000000000000]
    TArray<class USkelControlBase*>
        SkelControlTickArray;           // 0x02A8 (0x0010) [0x0000000000000000]
    class UPhysicsAsset* PhysicsAsset;  // 0x02B8 (0x0008) [0x0000000000000000]
    class UPhysicsAssetInstance*
        PhysicsAssetInstance;  // 0x02C0 (0x0008) [0x0000000000000000]
    class UPhysicsAsset*
        PhysicsAssetForFlex;  // 0x02C8 (0x0008) [0x0000000000000000]
    class UPhysicsAssetInstance*
        PhysicsAssetInstanceForFlex;  // 0x02D0 (0x0008) [0x0000000000000000]
    DWORD bUpdateFlexKinematicBonesFromAnimation : 1;  // 0x02D8 (0x0004)
                                                       // [0x0000000000000000]
                                                       // [0x00000001]
    struct FPointer ApexClothing;       // 0x02DC (0x0008) [0x0000000000000000]
    float PhysicsWeight;                // 0x02E4 (0x0004) [0x0000000000000000]
    float GlobalAnimRateScale;          // 0x02E8 (0x0004) [0x0000000000000000]
    float StreamingDistanceMultiplier;  // 0x02EC (0x0004) [0x0000000000000000]
    struct FPointer MeshObject;         // 0x02F0 (0x0008) [0x0000000000000000]
    struct FColor WireframeColor;       // 0x02F8 (0x0004) [0x0000000000000000]
    TArray<struct FBoneAtom>
        SpaceBases;  // 0x02FC (0x0010) [0x0000000000000000]
    TArray<struct FBoneAtom>
        LocalAtoms;  // 0x030C (0x0010) [0x0000000000000000]
    TArray<struct FBoneAtom>
        CachedLocalAtoms;  // 0x031C (0x0010) [0x0000000000000000]
    TArray<struct FBoneAtom>
        CachedSpaceBases;    // 0x032C (0x0010) [0x0000000000000000]
    int LowUpdateFrameRate;  // 0x033C (0x0004) [0x0000000000000000]
    TArray<unsigned char>
        RequiredBones;  // 0x0340 (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        ComposeOrderedRequiredBones;  // 0x0350 (0x0010) [0x0000000000000000]
    class USkeletalMeshComponent*
        ParentAnimComponent;           // 0x0360 (0x0008) [0x0000000000000000]
    TArray<int> ParentBoneMap;         // 0x0368 (0x0010) [0x0000000000000000]
    TArray<class UAnimSet*> AnimSets;  // 0x0378 (0x0010) [0x0000000000000000]
    TArray<class UAnimSet*>
        TemporarySavedAnimSets;  // 0x0388 (0x0010) [0x0000000000000000]
    TArray<class UMorphTargetSet*>
        MorphSets;  // 0x0398 (0x0010) [0x0000000000000000]
    TArray<struct FActiveMorph>
        ActiveMorphs;  // 0x03A8 (0x0010) [0x0000000000000000]
    TArray<struct FActiveMorph>
        ActiveCurveMorphs;  // 0x03B8 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00
        [0x48];  // 0x03C8 (0x0048) UNKNOWN PROPERTY: MapProperty
                 // Engine.SkeletalMeshComponent.MorphTargetIndexMap
    TArray<struct FAttachment>
        Attachments;  // 0x0410 (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        SkelControlIndex;  // 0x0420 (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        PostPhysSkelControlIndex;      // 0x0430 (0x0010) [0x0000000000000000]
    int ForcedLodModel;                // 0x0440 (0x0004) [0x0000000000000000]
    int MinLodModel;                   // 0x0444 (0x0004) [0x0000000000000000]
    int PredictedLODLevel;             // 0x0448 (0x0004) [0x0000000000000000]
    int OldPredictedLODLevel;          // 0x044C (0x0004) [0x0000000000000000]
    float AnimationLODDistanceFactor;  // 0x0450 (0x0004) [0x0000000000000000]
    int AnimationLODFrameRate;         // 0x0454 (0x0004) [0x0000000000000000]
    float MaxDistanceFactor;           // 0x0458 (0x0004) [0x0000000000000000]
    int ChunkIndexPreview;             // 0x045C (0x0004) [0x0000000000000000]
    int SectionIndexPreview;           // 0x0460 (0x0004) [0x0000000000000000]
    int bForceWireframe;               // 0x0464 (0x0004) [0x0000000000000000]
    int bForceRefpose;                 // 0x0468 (0x0004) [0x0000000000000000]
    int bOldForceRefPose;              // 0x046C (0x0004) [0x0000000000000000]
    DWORD bNoSkeletonUpdate : 1;       // 0x0470 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    int bDisplayBones;                 // 0x0474 (0x0004) [0x0000000000000000]
    int bShowPrePhysBones;             // 0x0478 (0x0004) [0x0000000000000000]
    int bHideSkin;                     // 0x047C (0x0004) [0x0000000000000000]
    int bForceRawOffset;               // 0x0480 (0x0004) [0x0000000000000000]
    int bIgnoreControllers;            // 0x0484 (0x0004) [0x0000000000000000]
    int bTransformFromAnimParent;      // 0x0488 (0x0004) [0x0000000000000000]
    int TickTag;                       // 0x048C (0x0004) [0x0000000000000000]
    int InitTag;                       // 0x0490 (0x0004) [0x0000000000000000]
    int CachedAtomsTag;                // 0x0494 (0x0004) [0x0000000000000000]
    int bUseSingleBodyPhysics;         // 0x0498 (0x0004) [0x0000000000000000]
    int bRequiredBonesUpToDate;        // 0x049C (0x0004) [0x0000000000000000]
    float MinDistFactorForKinematicUpdate;  // 0x04A0 (0x0004)
                                            // [0x0000000000000000]
    int FramesPhysicsAsleep;  // 0x04A4 (0x0004) [0x0000000000000000]
    int SkipRateForTickAnimNodesAndGetBoneAtoms;  // 0x04A8 (0x0004)
                                                  // [0x0000000000000000]
    DWORD bSkipTickAnimNodes : 1;     // 0x04AC (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bSkipGetBoneAtoms : 1;      // 0x04AC (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bInterpolateBoneAtoms : 1;  // 0x04AC (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    DWORD bHasValidBodies : 1;        // 0x04AC (0x0004) [0x0000000000000000]
                                      // [0x00000008]
    DWORD bSkipAllUpdateWhenPhysicsAsleep : 1;  // 0x04AC (0x0004)
                                                // [0x0000000000000000]
                                                // [0x00000010]
    DWORD
        bComponentUseFixedSkelBounds : 1;  // 0x04AC (0x0004)
                                           // [0x0000000000000000] [0x00000020]
    DWORD bUseBoundsFromParentAnimComponent : 1;  // 0x04AC (0x0004)
                                                  // [0x0000000000000000]
                                                  // [0x00000040]
    DWORD bConsiderAllBodiesForBounds : 1;        // 0x04AC (0x0004)
                                            // [0x0000000000000000] [0x00000080]
    DWORD bUpdateSkelWhenNotRendered : 1;  // 0x04AC (0x0004)
                                           // [0x0000000000000000] [0x00000100]
    DWORD bIgnoreControllersWhenNotRendered : 1;  // 0x04AC (0x0004)
                                                  // [0x0000000000000000]
                                                  // [0x00000200]
    DWORD
        bTickAnimNodesWhenNotRendered : 1;  // 0x04AC (0x0004)
                                            // [0x0000000000000000] [0x00000400]
    DWORD bNotUpdatingKinematicDueToDistance : 1;  // 0x04AC (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00000800]
    DWORD bForceDiscardRootMotion : 1;  // 0x04AC (0x0004) [0x0000000000000000]
                                        // [0x00001000]
    DWORD bNotifyRootMotionProcessed : 1;   // 0x04AC (0x0004)
                                            // [0x0000000000000000] [0x00002000]
    DWORD bRootMotionModeChangeNotify : 1;  // 0x04AC (0x0004)
                                            // [0x0000000000000000] [0x00004000]
    DWORD bRootMotionExtractedNotify : 1;   // 0x04AC (0x0004)
                                            // [0x0000000000000000] [0x00008000]
    DWORD bProcessingRootMotion : 1;  // 0x04AC (0x0004) [0x0000000000000000]
                                      // [0x00010000]
    DWORD bDisableFaceFXMaterialInstanceCreation : 1;  // 0x04AC (0x0004)
                                                       // [0x0000000000000000]
                                                       // [0x00020000]
    DWORD bDisableFaceFX : 1;            // 0x04AC (0x0004) [0x0000000000000000]
                                         // [0x00040000]
    DWORD bAnimTreeInitialised : 1;      // 0x04AC (0x0004) [0x0000000000000000]
                                         // [0x00080000]
    DWORD bForceMeshObjectUpdate : 1;    // 0x04AC (0x0004) [0x0000000000000000]
                                         // [0x00100000]
    DWORD bHasPhysicsAssetInstance : 1;  // 0x04AC (0x0004) [0x0000000000000000]
                                         // [0x00200000]
    DWORD bUpdateKinematicBonesFromAnimation : 1;  // 0x04AC (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00400000]
    DWORD bUpdateJointsFromAnimation : 1;          // 0x04AC (0x0004)
                                           // [0x0000000000000000] [0x00800000]
    DWORD bSkelCompFixed : 1;           // 0x04AC (0x0004) [0x0000000000000000]
                                        // [0x01000000]
    DWORD bHasHadPhysicsBlendedIn : 1;  // 0x04AC (0x0004) [0x0000000000000000]
                                        // [0x02000000]
    DWORD
        bForceUpdateAttachmentsInTick : 1;  // 0x04AC (0x0004)
                                            // [0x0000000000000000] [0x04000000]
    DWORD bEnableFullAnimWeightBodies : 1;  // 0x04AC (0x0004)
                                            // [0x0000000000000000] [0x08000000]
    DWORD bPerBoneVolumeEffects : 1;  // 0x04AC (0x0004) [0x0000000000000000]
                                      // [0x10000000]
    DWORD bPerBoneMotionBlur : 1;     // 0x04AC (0x0004) [0x0000000000000000]
                                      // [0x20000000]
    DWORD bSyncActorLocationToRootRigidBody : 1;  // 0x04AC (0x0004)
                                                  // [0x0000000000000000]
                                                  // [0x40000000]
    DWORD bUseRawData : 1;  // 0x04AC (0x0004) [0x0000000000000000] [0x80000000]
    DWORD bDisableWarningWhenAnimNotFound : 1;     // 0x04B0 (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00000001]
    DWORD bOverrideAttachmentOwnerVisibility : 1;  // 0x04B0 (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00000002]
    DWORD bNeedsToDeleteHitMask : 1;  // 0x04B0 (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    DWORD bPauseAnims : 1;  // 0x04B0 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bChartDistanceFactor : 1;  // 0x04B0 (0x0004) [0x0000000000000000]
                                     // [0x00000010]
    DWORD bEnableLineCheckWithBounds : 1;  // 0x04B0 (0x0004)
                                           // [0x0000000000000000] [0x00000020]
    DWORD
        bCanHighlightSelectedSections : 1;  // 0x04B0 (0x0004)
                                            // [0x0000000000000000] [0x00000040]
    DWORD bUpdateMorphWhenParentAnimComponentExists : 1;  // 0x04B0 (0x0004)
                                                          // [0x0000000000000000]
                                                          // [0x00000080]
    struct FVector
        LineCheckBoundsScale;          // 0x04B4 (0x000C) [0x0000000000000000]
    DWORD bEnableClothSimulation : 1;  // 0x04C0 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bDisableClothCollision : 1;  // 0x04C0 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD
        bClothFrozen : 1;  // 0x04C0 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bAutoFreezeClothWhenNotRendered : 1;  // 0x04C0 (0x0004)
                                                // [0x0000000000000000]
                                                // [0x00000008]
    DWORD bClothAwakeOnStartup : 1;  // 0x04C0 (0x0004) [0x0000000000000000]
                                     // [0x00000010]
    DWORD bClothBaseVelClamp : 1;    // 0x04C0 (0x0004) [0x0000000000000000]
                                     // [0x00000020]
    DWORD bClothBaseVelInterp : 1;   // 0x04C0 (0x0004) [0x0000000000000000]
                                     // [0x00000040]
    DWORD bAttachClothVertsToBaseBody : 1;  // 0x04C0 (0x0004)
                                            // [0x0000000000000000] [0x00000080]
    DWORD bIsClothOnStaticObject : 1;   // 0x04C0 (0x0004) [0x0000000000000000]
                                        // [0x00000100]
    DWORD bUpdatedFixedClothVerts : 1;  // 0x04C0 (0x0004) [0x0000000000000000]
                                        // [0x00000200]
    DWORD bClothPositionalDampening : 1;  // 0x04C0 (0x0004)
                                          // [0x0000000000000000] [0x00000400]
    DWORD bClothWindRelativeToOwner : 1;  // 0x04C0 (0x0004)
                                          // [0x0000000000000000] [0x00000800]
    DWORD bRecentlyRendered : 1;        // 0x04C0 (0x0004) [0x0000000000000000]
                                        // [0x00001000]
    DWORD bCacheAnimSequenceNodes : 1;  // 0x04C0 (0x0004) [0x0000000000000000]
                                        // [0x00002000]
    DWORD bNeedsInstanceWeightUpdate : 1;  // 0x04C0 (0x0004)
                                           // [0x0000000000000000] [0x00004000]
    DWORD bAlwaysUseInstanceWeights : 1;   // 0x04C0 (0x0004)
                                           // [0x0000000000000000] [0x00008000]
    DWORD
        bUpdateComposeSkeletonPasses : 1;  // 0x04C0 (0x0004)
                                           // [0x0000000000000000] [0x00010000]
    DWORD
        bValidTemporarySavedAnimSets : 1;  // 0x04C0 (0x0004)
                                           // [0x0000000000000000] [0x00020000]
    TArray<struct FBonePair>
        InstanceVertexWeightBones;  // 0x04C4 (0x0010) [0x0000000000000000]
    TArray<struct FSkelMeshComponentLODInfo>
        LODInfo;  // 0x04D4 (0x0010) [0x0000000000000000]
    struct FVector
        FrozenLocalToWorldPos;  // 0x04E4 (0x000C) [0x0000000000000000]
    struct FRotator
        FrozenLocalToWorldRot;          // 0x04F0 (0x000C) [0x0000000000000000]
    struct FVector ClothExternalForce;  // 0x04FC (0x000C) [0x0000000000000000]
    struct FVector ClothWind;           // 0x0508 (0x000C) [0x0000000000000000]
    float ClothWindBlendTime;           // 0x0514 (0x0004) [0x0000000000000000]
    float ClothWindDirectionDeviationAngle;      // 0x0518 (0x0004)
                                                 // [0x0000000000000000]
    float ClothWindDirectionOscillationPeriod;   // 0x051C (0x0004)
                                                 // [0x0000000000000000]
    float ClothWindStrengthDeviationPercentage;  // 0x0520 (0x0004)
                                                 // [0x0000000000000000]
    float ClothWindStrengthOscillationPeriod;    // 0x0524 (0x0004)
                                                 // [0x0000000000000000]
    struct FPointer
        ClothWindDirectionVO1;  // 0x0528 (0x0008) [0x0000000000000000]
    struct FPointer
        ClothWindDirectionVO2;  // 0x0530 (0x0008) [0x0000000000000000]
    struct FPointer
        ClothWindStrengthVO;  // 0x0538 (0x0008) [0x0000000000000000]
    struct FMatrix
        ClothWindDirectionMatrix;  // 0x0540 (0x0040) [0x0000000000000000]
    float ClothWindStrength;       // 0x0580 (0x0004) [0x0000000000000000]
    struct FVector
        ClothBaseVelClampRange;         // 0x0584 (0x000C) [0x0000000000000000]
    float ClothBlendWeight;             // 0x0590 (0x0004) [0x0000000000000000]
    float ClothDynamicBlendWeight;      // 0x0594 (0x0004) [0x0000000000000000]
    float ClothBlendMinDistanceFactor;  // 0x0598 (0x0004) [0x0000000000000000]
    float ClothBlendMaxDistanceFactor;  // 0x059C (0x0004) [0x0000000000000000]
    struct FVector MinPosDampRange;     // 0x05A0 (0x000C) [0x0000000000000000]
    struct FVector MaxPosDampRange;     // 0x05AC (0x000C) [0x0000000000000000]
    struct FVector MinPosDampScale;     // 0x05B8 (0x000C) [0x0000000000000000]
    struct FVector MaxPosDampScale;     // 0x05C4 (0x000C) [0x0000000000000000]
    struct FPointer ClothSim;           // 0x05D0 (0x0008) [0x0000000000000000]
    int SceneIndex;                     // 0x05D8 (0x0004) [0x0000000000000000]
    TArray<struct FVector>
        ClothMeshPosData;  // 0x05DC (0x0010) [0x0000000000000000]
    TArray<struct FVector>
        ClothMeshNormalData;          // 0x05EC (0x0010) [0x0000000000000000]
    TArray<int> ClothMeshIndexData;   // 0x05FC (0x0010) [0x0000000000000000]
    int NumClothMeshVerts;            // 0x060C (0x0004) [0x0000000000000000]
    int NumClothMeshIndices;          // 0x0610 (0x0004) [0x0000000000000000]
    TArray<int> ClothMeshParentData;  // 0x0614 (0x0010) [0x0000000000000000]
    int NumClothMeshParentIndices;    // 0x0624 (0x0004) [0x0000000000000000]
    TArray<struct FVector>
        ClothMeshWeldedPosData;  // 0x0628 (0x0010) [0x0000000000000000]
    TArray<struct FVector>
        ClothMeshWeldedNormalData;  // 0x0638 (0x0010) [0x0000000000000000]
    TArray<int>
        ClothMeshWeldedIndexData;  // 0x0648 (0x0010) [0x0000000000000000]
    int ClothDirtyBufferFlag;      // 0x0658 (0x0004) [0x0000000000000000]
    unsigned char ClothRBChannel;  // 0x065C (0x0001) [0x0000000000000000]
    struct FRBCollisionChannelContainer
        ClothRBCollideWithChannels;     // 0x0660 (0x0004) [0x0000000000000000]
    float ClothForceScale;              // 0x0664 (0x0004) [0x0000000000000000]
    float ClothImpulseScale;            // 0x0668 (0x0004) [0x0000000000000000]
    float ClothAttachmentTearFactor;    // 0x066C (0x0004) [0x0000000000000000]
    DWORD bClothUseCompartment : 1;     // 0x0670 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bClothUseSceneCollision : 1;  // 0x0670 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    float MinDistanceForClothReset;     // 0x0674 (0x0004) [0x0000000000000000]
    struct FVector LastClothLocation;   // 0x0678 (0x000C) [0x0000000000000000]
    unsigned char
        ApexClothingRBChannel;  // 0x0684 (0x0001) [0x0000000000000000]
    struct FRBCollisionChannelContainer
        ApexClothingRBCollideWithChannels;  // 0x0688 (0x0004)
                                            // [0x0000000000000000]
    unsigned char
        ApexClothingCollisionRBChannel;  // 0x068C (0x0001) [0x0000000000000000]
    DWORD bAutoFreezeApexClothingWhenNotRendered : 1;  // 0x0690 (0x0004)
                                                       // [0x0000000000000000]
                                                       // [0x00000001]
    DWORD bLocalSpaceWind : 1;        // 0x0690 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    struct FVector WindVelocity;      // 0x0694 (0x000C) [0x0000000000000000]
    float WindVelocityBlendTime;      // 0x06A0 (0x0004) [0x0000000000000000]
    float WindStrengthNoiseBounds;    // 0x06A4 (0x0004) [0x0000000000000000]
    float WindStrengthNoiseStepSize;  // 0x06A8 (0x0004) [0x0000000000000000]
    DWORD bWindStrengthNoiseCentered : 1;  // 0x06AC (0x0004)
                                           // [0x0000000000000000] [0x00000001]
    float WindDirNoiseBounds;            // 0x06B0 (0x0004) [0x0000000000000000]
    float WindDirNoiseStepSize;          // 0x06B4 (0x0004) [0x0000000000000000]
    DWORD bWindDirNoiseCentered : 1;     // 0x06B8 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    float WindCurrentStrengthNoise;      // 0x06BC (0x0004) [0x0000000000000000]
    struct FVector WindCurrentDirNoise;  // 0x06C0 (0x000C) [0x0000000000000000]
    DWORD bSkipInitClothing : 1;         // 0x06CC (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    struct FPointer SoftBodySim;         // 0x06D0 (0x0008) [0x0000000000000000]
    int SoftBodySceneIndex;              // 0x06D8 (0x0004) [0x0000000000000000]
    DWORD bEnableSoftBodySimulation : 1;  // 0x06DC (0x0004)
                                          // [0x0000000000000000] [0x00000001]
    TArray<struct FVector>
        SoftBodyTetraPosData;            // 0x06E0 (0x0010) [0x0000000000000000]
    TArray<int> SoftBodyTetraIndexData;  // 0x06F0 (0x0010) [0x0000000000000000]
    int NumSoftBodyTetraVerts;           // 0x0700 (0x0004) [0x0000000000000000]
    int NumSoftBodyTetraIndices;         // 0x0704 (0x0004) [0x0000000000000000]
    float SoftBodyImpulseScale;          // 0x0708 (0x0004) [0x0000000000000000]
    DWORD bSoftBodyFrozen : 1;           // 0x070C (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bAutoFreezeSoftBodyWhenNotRendered : 1;  // 0x070C (0x0004)
                                                   // [0x0000000000000000]
                                                   // [0x00000002]
    DWORD bSoftBodyAwakeOnStartup : 1;  // 0x070C (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    DWORD bSoftBodyUseCompartment : 1;  // 0x070C (0x0004) [0x0000000000000000]
                                        // [0x00000008]
    unsigned char SoftBodyRBChannel;    // 0x0710 (0x0001) [0x0000000000000000]
    struct FRBCollisionChannelContainer
        SoftBodyRBCollideWithChannels;   // 0x0714 (0x0004) [0x0000000000000000]
    struct FPointer SoftBodyASVPlane;    // 0x0718 (0x0008) [0x0000000000000000]
    class UMaterial* LimitMaterial;      // 0x0720 (0x0008) [0x0000000000000000]
    unsigned char UnknownData01[0x8];    // 0x0728 (0x0008) MISSED OFFSET
    struct FBoneAtom RootMotionDelta;    // 0x0730 (0x0020) [0x0000000000000000]
    struct FVector RootMotionVelocity;   // 0x0750 (0x000C) [0x0000000000000000]
    struct FVector RootBoneTranslation;  // 0x075C (0x000C) [0x0000000000000000]
    struct FVector
        RootMotionAccelScale;      // 0x0768 (0x000C) [0x0000000000000000]
    unsigned char RootMotionMode;  // 0x0774 (0x0001) [0x0000000000000000]
    unsigned char PreviousRMM;     // 0x0775 (0x0001) [0x0000000000000000]
    unsigned char PendingRMM;      // 0x0776 (0x0001) [0x0000000000000000]
    unsigned char OldPendingRMM;   // 0x0777 (0x0001) [0x0000000000000000]
    int bRMMOneFrameDelay;         // 0x0778 (0x0004) [0x0000000000000000]
    unsigned char
        RootMotionRotationMode;      // 0x077C (0x0001) [0x0000000000000000]
    unsigned char AnimRotationOnly;  // 0x077D (0x0001) [0x0000000000000000]
    unsigned char FaceFXBlendMode;   // 0x077E (0x0001) [0x0000000000000000]
    struct FPointer
        FaceFXActorInstance;  // 0x0780 (0x0008) [0x0000000000000000]
    class UAudioComponent*
        CachedFaceFXAudioComp;  // 0x0788 (0x0008) [0x0000000000000000]
    TArray<unsigned char>
        BoneVisibilityStates;  // 0x0790 (0x0010) [0x0000000000000000]
    class UAkEvent*
        CachedFaceFxAkEvent;           // 0x07A0 (0x0008) [0x0000000000000000]
    unsigned char UnknownData02[0x8];  // 0x07A8 (0x0008) MISSED OFFSET
    struct FBoneAtom
        LocalToWorldBoneAtom;          // 0x07B0 (0x0020) [0x0000000000000000]
    float ProgressiveDrawingFraction;  // 0x07D0 (0x0004) [0x0000000000000000]
    unsigned char
        CustomSortAlternateIndexMode;  // 0x07D4 (0x0001) [0x0000000000000000]
    TArray<struct FName>
        MorphTargetsQueried;  // 0x07D8 (0x0010) [0x0000000000000000]
    class USkeletalMeshComponent*
        LODParent;                      // 0x07E8 (0x0008) [0x0000000000000000]
    DWORD bAllowBooleanPreshadows : 1;  // 0x07F0 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    float InterpolatedBooleanPreshadowFactor;  // 0x07F4 (0x0004)
                                               // [0x0000000000000000]
    float
        CurrentBooleanPreshadowFactor;  // 0x07F8 (0x0004) [0x0000000000000000]
    float LastBooleanPreshadowFactor;   // 0x07FC (0x0004) [0x0000000000000000]
    struct FDouble
        LastBooleanPreshadowUpdateTime;  // 0x0800 (0x0008) [0x0000000000000000]
    DWORD bUseTickOptimization : 1;      // 0x0808 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    int TickCount;                       // 0x080C (0x0004) [0x0000000000000000]
    int LastDropRate;                    // 0x0810 (0x0004) [0x0000000000000000]
    float LastDropRateChange;            // 0x0814 (0x0004) [0x0000000000000000]
    float AccumulatedDroppedDeltaTime;   // 0x0818 (0x0004) [0x0000000000000000]
    float ComponentDroppedDeltaTime;     // 0x081C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2707];

        return pClassPointer;
    };

    void SetLODParent();
    void SetMaterial();
    void GetRotation();
    void GetPosition();
    void IsBrokenConstraint();
    void BreakConstraint();
    void ToggleAlternateBoneWeights();
    void SkelMeshCompOnParticleSystemFinished();
    void eventPlayParticleEffect();
    void eventCreateForceField();
    void StopAnim();
    void PlayAnim();
    void ShowMaterialSection();
    void UpdateMeshForBrokenConstraints();
    void UnHideBoneByName();
    void HideBoneByName();
    void IsBoneHidden();
    void UnHideBone();
    void HideBone();
    void SetFaceFXRegisterEx();
    void SetFaceFXRegister();
    void GetFaceFXRegister();
    void DeclareFaceFXRegister();
    void IsPlayingFaceFXAnim();
    void StopFaceFXAnim();
    void PlayFaceFXAnim();
    void ToggleInstanceVertexWeights();
    void UpdateInstanceVertexWeightBones();
    void FindInstanceVertexweightBonePair();
    void RemoveInstanceVertexWeightBoneParented();
    void AddInstanceVertexWeightBoneParented();
    void GetBonesWithinRadius();
    void UpdateAnimations();
    void ForceSkelUpdate();
    void UpdateRBBonesFromSpaceBases();
    void SetHasPhysicsAssetInstance();
    void FindBodyInstanceNamed();
    void FindConstraintBoneName();
    void FindConstraintIndex();
    void InitMorphTargets();
    void InitSkelControls();
    void UpdateParentBoneMap();
    void SetParentAnimComponent();
    void SetAnimTreeTemplate();
    void GetClosestCollidingBoneLocation();
    void FindClosestBones();
    void FindClosestBone();
    void TransformFromBoneSpace();
    void TransformToBoneSpace();
    void GetBoneAxis();
    void GetRefPosePosition();
    void BoneIsChildOf();
    void GetBoneNames();
    void GetParentBone();
    void GetBoneMatrix();
    void GetBoneName();
    void MatchRefBone();
    void GetBoneLocation();
    void GetBoneQuaternion();
    void FindMorphNode();
    void FindSkelControl();
    void AllAnimNodes();
    void FindAnimNode();
    void FindMorphTarget();
    void GetAnimLength();
    void GetAnimRateByDuration();
    void RestoreSavedAnimSets();
    void SaveAnimSets();
    void FindAnimSequence();
    void WakeSoftBody();
    void SetSoftBodyFrozen();
    void UpdateSoftBodyParams();
    void SetClothValidBounds();
    void EnableClothValidBounds();
    void AttachClothToCollidingShapes();
    void SetClothVelocity();
    void SetClothPosition();
    void SetClothSleep();
    void SetClothThickness();
    void SetClothTearFactor();
    void SetClothStretchingStiffness();
    void SetClothSolverIterations();
    void SetClothSleepLinearVelocity();
    void SetClothPressure();
    void SetClothFriction();
    void SetClothFlags();
    void SetClothDampingCoefficient();
    void SetClothCollisionResponseCoefficient();
    void SetClothBendingStiffness();
    void SetClothAttachmentTearFactor();
    void SetClothAttachmentResponseCoefficient();
    void GetClothThickness();
    void GetClothTearFactor();
    void GetClothStretchingStiffness();
    void GetClothSolverIterations();
    void GetClothSleepLinearVelocity();
    void GetClothPressure();
    void GetClothFriction();
    void GetClothFlags();
    void GetClothDampingCoefficient();
    void GetClothCollisionResponseCoefficient();
    void GetClothBendingStiffness();
    void GetClothAttachmentTearFactor();
    void GetClothAttachmentResponseCoefficient();
    void ForceApexClothingTeleport();
    void ForceApexClothingTeleportAndReset();
    void ResetClothVertsToRefPose();
    void SetAttachClothVertsToBaseBody();
    void SetClothExternalForce();
    void UpdateClothParams();
    void SetEnableClothingSimulation();
    void SetClothFrozen();
    void SetEnableClothSimulation();
    void SetForceRefPose();
    void SetPhysicsAsset();
    void SetSkeletalMesh();
    void GetTransformMatrix();
    void AttachedComponents();
    void IsComponentAttached();
    void FindComponentAttachedToBone();
    void GetSocketBoneName();
    void GetSocketByName();
    void GetSocketMatrix();
    void GetSocketWorldLocationAndRotation();
    void AttachComponentToSocket();
    void DetachComponent();
    void AttachComponent();
};

UClass* USkeletalMeshComponent::pClassPointer = NULL;

// Class Engine.SkeletalMesh
// 0x0470 (0x04D0 - 0x0060)
class USkeletalMesh : public UObject {
   public:
    struct FBoxSphereBounds Bounds;  // 0x0060 (0x001C) [0x0000000000000000]
    TArray<class UMaterialInterface*>
        Materials;  // 0x007C (0x0010) [0x0000000000000000]
    TArray<class UApexClothingAsset*>
        ClothingAssets;  // 0x008C (0x0010) [0x0000000000000000]
    TArray<struct FApexClothingAssetInfo>
        ClothingLodMap;         // 0x009C (0x0010) [0x0000000000000000]
    struct FVector Origin;      // 0x00AC (0x000C) [0x0000000000000000]
    struct FRotator RotOrigin;  // 0x00B8 (0x000C) [0x0000000000000000]
    TArray<int> RefSkeleton;    // 0x00C4 (0x0010) [0x0000000000000000]
    int SkeletalDepth;          // 0x00D4 (0x0004) [0x0000000000000000]
    unsigned char
        UnknownData00[0x48];  // 0x00D8 (0x0048) UNKNOWN PROPERTY: MapProperty
                              // Engine.SkeletalMesh.NameIndexMap
    struct FIndirectArray_Mirror
        LODModels;               // 0x0120 (0x0010) [0x0000000000000000]
    struct FPointer SourceData;  // 0x0130 (0x0008) [0x0000000000000000]
    TArray<struct FBoneAtom>
        RefBasesInvMatrix;  // 0x0138 (0x0010) [0x0000000000000000]
    TArray<struct FBoneMirrorInfo>
        SkelMirrorTable;               // 0x0148 (0x0010) [0x0000000000000000]
    unsigned char SkelMirrorAxis;      // 0x0158 (0x0001) [0x0000000000000000]
    unsigned char SkelMirrorFlipAxis;  // 0x0159 (0x0001) [0x0000000000000000]
    TArray<class USkeletalMeshSocket*>
        Sockets;  // 0x015C (0x0010) [0x0000000000000000]
    TArray<struct FString>
        BoneBreakNames;  // 0x016C (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        BoneBreakOptions;  // 0x017C (0x0010) [0x0000000000000000]
    TArray<struct FSkeletalMeshLODInfo>
        LODInfo;  // 0x018C (0x0010) [0x0000000000000000]
    TArray<struct FSkeletalMeshOptimizationSettings>
        OptimizationSettings;  // 0x019C (0x0010) [0x0000000000000000]
    TArray<struct FName>
        PerPolyCollisionBones;  // 0x01AC (0x0010) [0x0000000000000000]
    TArray<struct FName>
        AddToParentPerPolyCollisionBone;  // 0x01BC (0x0010)
                                          // [0x0000000000000000]
    TArray<int> PerPolyBoneKDOPs;        // 0x01CC (0x0010) [0x0000000000000000]
    DWORD bPerPolyUseSoftWeighting : 1;  // 0x01DC (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bUseSimpleLineCollision : 1;   // 0x01DC (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bUseSimpleBoxCollision : 1;    // 0x01DC (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD bForceCPUSkinning : 1;         // 0x01DC (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    DWORD bUseFullPrecisionUVs : 1;      // 0x01DC (0x0004) [0x0000000000000000]
                                         // [0x00000010]
    DWORD bHasBeenSimplified : 1;        // 0x01DC (0x0004) [0x0000000000000000]
                                         // [0x00000020]
    class UFaceFXAsset* FaceFXAsset;     // 0x01E0 (0x0008) [0x0000000000000000]
    class UPhysicsAsset*
        BoundsPreviewAsset;  // 0x01E8 (0x0008) [0x0000000000000000]
    TArray<class UMorphTargetSet*>
        PreviewMorphSets;                // 0x01F0 (0x0010) [0x0000000000000000]
    int LODBiasPC;                       // 0x0200 (0x0004) [0x0000000000000000]
    int LODBiasPS3;                      // 0x0204 (0x0004) [0x0000000000000000]
    int LODBiasXbox360;                  // 0x0208 (0x0004) [0x0000000000000000]
    int LODBiasOrbis;                    // 0x020C (0x0004) [0x0000000000000000]
    struct FString SourceFilePath;       // 0x0210 (0x0010) [0x0000000000000000]
    struct FString SourceFileTimestamp;  // 0x0220 (0x0010) [0x0000000000000000]
    TArray<struct FPointer> ClothMesh;   // 0x0230 (0x0010) [0x0000000000000000]
    TArray<float> ClothMeshScale;        // 0x0240 (0x0010) [0x0000000000000000]
    TArray<int> ClothToGraphicsVertMap;  // 0x0250 (0x0010) [0x0000000000000000]
    TArray<float> ClothMovementScale;    // 0x0260 (0x0010) [0x0000000000000000]
    unsigned char
        ClothMovementScaleGenMode;    // 0x0270 (0x0001) [0x0000000000000000]
    float ClothToAnimMeshMaxDist;     // 0x0274 (0x0004) [0x0000000000000000]
    DWORD bLimitClothToAnimMesh : 1;  // 0x0278 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    TArray<int> ClothWeldingMap;      // 0x027C (0x0010) [0x0000000000000000]
    int ClothWeldingDomain;           // 0x028C (0x0004) [0x0000000000000000]
    TArray<int> ClothWeldedIndices;   // 0x0290 (0x0010) [0x0000000000000000]
    DWORD bForceNoWelding : 1;        // 0x02A0 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    int NumFreeClothVerts;            // 0x02A4 (0x0004) [0x0000000000000000]
    TArray<int> ClothIndexBuffer;     // 0x02A8 (0x0010) [0x0000000000000000]
    TArray<struct FName> ClothBones;  // 0x02B8 (0x0010) [0x0000000000000000]
    int ClothHierarchyLevels;         // 0x02C8 (0x0004) [0x0000000000000000]
    DWORD bEnableClothBendConstraints : 1;  // 0x02CC (0x0004)
                                            // [0x0000000000000000] [0x00000001]
    DWORD bEnableClothDamping : 1;    // 0x02CC (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD bUseClothCOMDamping : 1;    // 0x02CC (0x0004) [0x0000000000000000]
                                      // [0x00000004]
    float ClothStretchStiffness;      // 0x02D0 (0x0004) [0x0000000000000000]
    float ClothBendStiffness;         // 0x02D4 (0x0004) [0x0000000000000000]
    float ClothDensity;               // 0x02D8 (0x0004) [0x0000000000000000]
    float ClothThickness;             // 0x02DC (0x0004) [0x0000000000000000]
    float ClothDamping;               // 0x02E0 (0x0004) [0x0000000000000000]
    int ClothIterations;              // 0x02E4 (0x0004) [0x0000000000000000]
    int ClothHierarchicalIterations;  // 0x02E8 (0x0004) [0x0000000000000000]
    float ClothFriction;              // 0x02EC (0x0004) [0x0000000000000000]
    float ClothRelativeGridSpacing;   // 0x02F0 (0x0004) [0x0000000000000000]
    float ClothPressure;              // 0x02F4 (0x0004) [0x0000000000000000]
    float ClothCollisionResponseCoefficient;   // 0x02F8 (0x0004)
                                               // [0x0000000000000000]
    float ClothAttachmentResponseCoefficient;  // 0x02FC (0x0004)
                                               // [0x0000000000000000]
    float ClothAttachmentTearFactor;  // 0x0300 (0x0004) [0x0000000000000000]
    float ClothSleepLinearVelocity;   // 0x0304 (0x0004) [0x0000000000000000]
    float HardStretchLimitFactor;     // 0x0308 (0x0004) [0x0000000000000000]
    DWORD bHardStretchLimit : 1;      // 0x030C (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bEnableClothOrthoBendConstraints : 1;  // 0x030C (0x0004)
                                                 // [0x0000000000000000]
                                                 // [0x00000002]
    DWORD bEnableClothSelfCollision : 1;         // 0x030C (0x0004)
                                          // [0x0000000000000000] [0x00000004]
    DWORD bEnableClothPressure : 1;  // 0x030C (0x0004) [0x0000000000000000]
                                     // [0x00000008]
    DWORD bEnableClothTwoWayCollision : 1;  // 0x030C (0x0004)
                                            // [0x0000000000000000] [0x00000010]
    TArray<struct FClothSpecialBoneInfo>
        ClothSpecialBones;             // 0x0310 (0x0010) [0x0000000000000000]
    DWORD bEnableClothLineChecks : 1;  // 0x0320 (0x0004) [0x0000000000000000]
                                       // [0x00000001]
    DWORD bClothMetal : 1;  // 0x0320 (0x0004) [0x0000000000000000] [0x00000002]
    float ClothMetalImpulseThreshold;  // 0x0324 (0x0004) [0x0000000000000000]
    float ClothMetalPenetrationDepth;  // 0x0328 (0x0004) [0x0000000000000000]
    float ClothMetalMaxDeformationDistance;  // 0x032C (0x0004)
                                             // [0x0000000000000000]
    DWORD bEnableClothTearing : 1;  // 0x0330 (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    float ClothTearFactor;          // 0x0334 (0x0004) [0x0000000000000000]
    int ClothTearReserve;           // 0x0338 (0x0004) [0x0000000000000000]
    DWORD bEnableValidBounds : 1;   // 0x033C (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    struct FVector ValidBoundsMin;  // 0x0340 (0x000C) [0x0000000000000000]
    struct FVector ValidBoundsMax;  // 0x034C (0x000C) [0x0000000000000000]
    TArray<struct FSphere>
        ClothCollisionSpheres;  // 0x0358 (0x0010) [0x0000000000000000]
    TArray<int>
        ClothCollisionCapsuleIndices;    // 0x0368 (0x0010) [0x0000000000000000]
    struct FMap_Mirror ClothTornTriMap;  // 0x0378 (0x0048) [0x0000000000000000]
    TArray<int> SoftBodySurfaceToGraphicsVertMap;  // 0x03C0 (0x0010)
                                                   // [0x0000000000000000]
    TArray<int> SoftBodySurfaceIndices;  // 0x03D0 (0x0010) [0x0000000000000000]
    TArray<struct FVector>
        SoftBodyTetraVertsUnscaled;    // 0x03E0 (0x0010) [0x0000000000000000]
    TArray<int> SoftBodyTetraIndices;  // 0x03F0 (0x0010) [0x0000000000000000]
    TArray<struct FSoftBodyTetraLink>
        SoftBodyTetraLinks;  // 0x0400 (0x0010) [0x0000000000000000]
    TArray<struct FPointer>
        CachedSoftBodyMeshes;  // 0x0410 (0x0010) [0x0000000000000000]
    TArray<float>
        CachedSoftBodyMeshScales;        // 0x0420 (0x0010) [0x0000000000000000]
    TArray<struct FName> SoftBodyBones;  // 0x0430 (0x0010) [0x0000000000000000]
    TArray<struct FSoftBodySpecialBoneInfo>
        SoftBodySpecialBones;           // 0x0440 (0x0010) [0x0000000000000000]
    float SoftBodyVolumeStiffness;      // 0x0450 (0x0004) [0x0000000000000000]
    float SoftBodyStretchingStiffness;  // 0x0454 (0x0004) [0x0000000000000000]
    float SoftBodyDensity;              // 0x0458 (0x0004) [0x0000000000000000]
    float SoftBodyParticleRadius;       // 0x045C (0x0004) [0x0000000000000000]
    float SoftBodyDamping;              // 0x0460 (0x0004) [0x0000000000000000]
    int SoftBodySolverIterations;       // 0x0464 (0x0004) [0x0000000000000000]
    float SoftBodyFriction;             // 0x0468 (0x0004) [0x0000000000000000]
    float SoftBodyRelativeGridSpacing;  // 0x046C (0x0004) [0x0000000000000000]
    float SoftBodySleepLinearVelocity;  // 0x0470 (0x0004) [0x0000000000000000]
    DWORD
        bEnableSoftBodySelfCollision : 1;  // 0x0474 (0x0004)
                                           // [0x0000000000000000] [0x00000001]
    float SoftBodyAttachmentResponse;   // 0x0478 (0x0004) [0x0000000000000000]
    float SoftBodyCollisionResponse;    // 0x047C (0x0004) [0x0000000000000000]
    float SoftBodyDetailLevel;          // 0x0480 (0x0004) [0x0000000000000000]
    int SoftBodySubdivisionLevel;       // 0x0484 (0x0004) [0x0000000000000000]
    DWORD bSoftBodyIsoSurface : 1;      // 0x0488 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bEnableSoftBodyDamping : 1;   // 0x0488 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bUseSoftBodyCOMDamping : 1;   // 0x0488 (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    float SoftBodyAttachmentThreshold;  // 0x048C (0x0004) [0x0000000000000000]
    DWORD bEnableSoftBodyTwoWayCollision : 1;  // 0x0490 (0x0004)
                                               // [0x0000000000000000]
                                               // [0x00000001]
    float SoftBodyAttachmentTearFactor;  // 0x0494 (0x0004) [0x0000000000000000]
    DWORD bEnableSoftBodyLineChecks : 1;  // 0x0498 (0x0004)
                                          // [0x0000000000000000] [0x00000001]
    DWORD bHasVertexColors : 1;          // 0x0498 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    TArray<DWORD> GraphicsIndexIsCloth;  // 0x049C (0x0010) [0x0000000000000000]
    TArray<float>
        CachedStreamingTextureFactors;  // 0x04AC (0x0010) [0x0000000000000000]
    float StreamingDistanceMultiplier;  // 0x04BC (0x0004) [0x0000000000000000]
    int ReleaseResourcesFence;          // 0x04C0 (0x0004) [0x0000000000000000]
    struct FQWord SkelMeshRUID;         // 0x04C4 (0x0008) [0x0000000000000000]
    DWORD bUseClothingAssetMaterial : 1;  // 0x04CC (0x0004)
                                          // [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2709];

        return pClassPointer;
    };
};

UClass* USkeletalMesh::pClassPointer = NULL;

// Class Engine.SkeletalMeshSocket
// 0x0054 (0x00B4 - 0x0060)
class USkeletalMeshSocket : public UObject {
   public:
    struct FName SocketName;           // 0x0060 (0x0008) [0x0000000000000000]
    struct FName BoneName;             // 0x0068 (0x0008) [0x0000000000000000]
    struct FVector RelativeLocation;   // 0x0070 (0x000C) [0x0000000000000000]
    struct FRotator RelativeRotation;  // 0x007C (0x000C) [0x0000000000000000]
    struct FVector RelativeScale;      // 0x0088 (0x000C) [0x0000000000000000]
    class USkeletalMesh*
        PreviewSkelMesh;  // 0x0094 (0x0008) [0x0000000000000000]
    class USkeletalMeshComponent*
        PreviewSkelComp;  // 0x009C (0x0008) [0x0000000000000000]
    class UStaticMesh*
        PreviewStaticMesh;  // 0x00A4 (0x0008) [0x0000000000000000]
    class UParticleSystem*
        PreviewParticleSystem;  // 0x00AC (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2711];

        return pClassPointer;
    };
};

UClass* USkeletalMeshSocket::pClassPointer = NULL;

// Class Engine.SplineActor
// 0x0068 (0x02AC - 0x0244)
class ASplineActor : public AActor {
   public:
    TArray<struct FSplineConnection>
        Connections;                    // 0x0244 (0x0010) [0x0000000000000000]
    struct FVector SplineActorTangent;  // 0x0254 (0x000C) [0x0000000000000000]
    struct FColor SplineColor;          // 0x0260 (0x0004) [0x0000000000000000]
    DWORD bDisableDestination : 1;      // 0x0264 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bAlreadyVisited : 1;          // 0x0264 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    TArray<class ASplineActor*>
        LinksFrom;                     // 0x0268 (0x0010) [0x0000000000000000]
    class ASplineActor* nextOrdered;   // 0x0278 (0x0008) [0x0000000000000000]
    class ASplineActor* prevOrdered;   // 0x0280 (0x0008) [0x0000000000000000]
    class ASplineActor* previousPath;  // 0x0288 (0x0008) [0x0000000000000000]
    int bestPathWeight;                // 0x0290 (0x0004) [0x0000000000000000]
    int visitedWeight;                 // 0x0294 (0x0004) [0x0000000000000000]
    struct FInterpCurveFloat
        SplineVelocityOverTime;  // 0x0298 (0x0014) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2713];

        return pClassPointer;
    };

    void OnToggleHidden();
    void OnToggle();
    void GetAllConnectedSplineActors();
    void FindSplinePathTo();
    void GetBestConnectionInDirection();
    void GetRandomConnection();
    void BreakAllConnectionsFrom();
    void BreakAllConnections();
    void BreakConnectionTo();
    void FindTargetForComponent();
    void FindSplineComponentTo();
    void IsConnectedTo();
    void AddConnectionTo();
    void UpdateConnectedSplineComponents();
    void UpdateSplineComponents();
    void GetWorldSpaceTangent();
};

UClass* ASplineActor::pClassPointer = NULL;

// Class Engine.SplineLoftActor
// 0x0058 (0x0304 - 0x02AC)
class ASplineLoftActor : public ASplineActor {
   public:
    float ScaleX;  // 0x02AC (0x0004) [0x0000000000000000]
    float ScaleY;  // 0x02B0 (0x0004) [0x0000000000000000]
    TArray<class USplineMeshComponent*>
        SplineMeshComps;            // 0x02B4 (0x0010) [0x0000000000000000]
    class UStaticMesh* DeformMesh;  // 0x02C4 (0x0008) [0x0000000000000000]
    TArray<class UMaterialInterface*>
        DeformMeshMaterials;   // 0x02CC (0x0010) [0x0000000000000000]
    float Roll;                // 0x02DC (0x0004) [0x0000000000000000]
    struct FVector WorldXDir;  // 0x02E0 (0x000C) [0x0000000000000000]
    struct FVector2D Offset;   // 0x02EC (0x0008) [0x0000000000000000]
    DWORD bSmoothInterpRollAndScale : 1;  // 0x02F4 (0x0004)
                                          // [0x0000000000000000] [0x00000001]
    DWORD bAcceptsLights : 1;  // 0x02F4 (0x0004) [0x0000000000000000]
                               // [0x00000002]
    class UDynamicLightEnvironmentComponent*
        MeshLightEnvironment;   // 0x02F8 (0x0008) [0x0000000000000000]
    float MeshMaxDrawDistance;  // 0x0300 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2715];

        return pClassPointer;
    };

    void UpdateSplineParams();
    void ClearLoftMesh();
};

UClass* ASplineLoftActor::pClassPointer = NULL;

// Class Engine.SplineLoftActorMovable
// 0x0000 (0x0304 - 0x0304)
class ASplineLoftActorMovable : public ASplineLoftActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2717];

        return pClassPointer;
    };
};

UClass* ASplineLoftActorMovable::pClassPointer = NULL;

// Class Engine.SplineComponent
// 0x003C (0x0274 - 0x0238)
class USplineComponent : public UPrimitiveComponent {
   public:
    struct FInterpCurveVector
        SplineInfo;             // 0x0238 (0x0014) [0x0000000000000000]
    float SplineCurviness;      // 0x024C (0x0004) [0x0000000000000000]
    struct FColor SplineColor;  // 0x0250 (0x0004) [0x0000000000000000]
    float SplineDrawRes;        // 0x0254 (0x0004) [0x0000000000000000]
    float SplineArrowSize;      // 0x0258 (0x0004) [0x0000000000000000]
    DWORD bSplineDisabled : 1;  // 0x025C (0x0004) [0x0000000000000000]
                                // [0x00000001]
    struct FInterpCurveFloat
        SplineReparamTable;  // 0x0260 (0x0014) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2719];

        return pClassPointer;
    };

    void GetTangentAtDistanceAlongSpline();
    void GetLocationAtDistanceAlongSpline();
    void GetSplineLength();
    void UpdateSplineReparamTable();
    void UpdateSplineCurviness();
};

UClass* USplineComponent::pClassPointer = NULL;

// Class Engine.ProcBuilding
// 0x0118 (0x0398 - 0x0280)
class AProcBuilding : public AVolume {
   public:
    class UProcBuildingRuleset*
        Ruleset;  // 0x0280 (0x0008) [0x0000000000000000]
    TArray<struct FPBMeshCompInfo>
        BuildingMeshCompInfos;  // 0x0288 (0x0010) [0x0000000000000000]
    TArray<struct FPBFracMeshCompInfo>
        BuildingFracMeshCompInfos;  // 0x0298 (0x0010) [0x0000000000000000]
    class UStaticMeshComponent*
        SimpleMeshComp;                 // 0x02A8 (0x0008) [0x0000000000000000]
    DWORD bGenerateRoofMesh : 1;        // 0x02B0 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bGenerateFloorMesh : 1;       // 0x02B0 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    DWORD bApplyRulesToRoof : 1;        // 0x02B0 (0x0004) [0x0000000000000000]
                                        // [0x00000004]
    DWORD bApplyRulesToFloor : 1;       // 0x02B0 (0x0004) [0x0000000000000000]
                                        // [0x00000008]
    DWORD bSplitWallsAtRoofLevels : 1;  // 0x02B0 (0x0004) [0x0000000000000000]
                                        // [0x00000010]
    DWORD bSplitWallsAtWallEdges : 1;   // 0x02B0 (0x0004) [0x0000000000000000]
                                        // [0x00000020]
    DWORD
        bQuickEdited : 1;  // 0x02B0 (0x0004) [0x0000000000000000] [0x00000040]
    DWORD bBuildingBrushCollision : 1;  // 0x02B0 (0x0004) [0x0000000000000000]
                                        // [0x00000080]
    DWORD bDebugDrawEdgeInfo : 1;       // 0x02B0 (0x0004) [0x0000000000000000]
                                        // [0x00000100]
    DWORD bDebugDrawScopes : 1;         // 0x02B0 (0x0004) [0x0000000000000000]
                                        // [0x00000200]
    TArray<class UStaticMeshComponent*>
        LODMeshComps;  // 0x02B4 (0x0010) [0x0000000000000000]
    TArray<struct FPBFaceUVInfo>
        LODMeshUVInfos;  // 0x02C4 (0x0010) [0x0000000000000000]
    TArray<struct FPBScope2D>
        TopLevelScopes;           // 0x02D4 (0x0010) [0x0000000000000000]
    int NumMeshedTopLevelScopes;  // 0x02E4 (0x0004) [0x0000000000000000]
    TArray<struct FPBFaceUVInfo>
        TopLevelScopeUVInfos;  // 0x02E8 (0x0010) [0x0000000000000000]
    TArray<struct FPBScopeProcessInfo>
        TopLevelScopeInfos;  // 0x02F8 (0x0010) [0x0000000000000000]
    TArray<struct FPBEdgeInfo>
        EdgeInfos;     // 0x0308 (0x0010) [0x0000000000000000]
    float MaxFacadeZ;  // 0x0318 (0x0004) [0x0000000000000000]
    float MinFacadeZ;  // 0x031C (0x0004) [0x0000000000000000]
    TArray<class AProcBuilding*>
        OverlappingBuildings;            // 0x0320 (0x0010) [0x0000000000000000]
    float SimpleMeshMassiveLODDistance;  // 0x0330 (0x0004) [0x0000000000000000]
    float
        RenderToTexturePullBackAmount;  // 0x0334 (0x0004) [0x0000000000000000]
    int RoofLightmapRes;                // 0x0338 (0x0004) [0x0000000000000000]
    int NonRectWallLightmapRes;         // 0x033C (0x0004) [0x0000000000000000]
    float LODRenderToTextureScale;      // 0x0340 (0x0004) [0x0000000000000000]
    struct FName ParamSwatchName;       // 0x0344 (0x0008) [0x0000000000000000]
    TArray<struct FPBMaterialParam>
        BuildingMaterialParams;  // 0x034C (0x0010) [0x0000000000000000]
    TArray<class UMaterialInstanceConstant*>
        BuildingMatParamMICs;  // 0x035C (0x0010) [0x0000000000000000]
    class AStaticMeshActor*
        LowLODPersistentActor;  // 0x036C (0x0008) [0x0000000000000000]
    class UStaticMeshComponent*
        CurrentSimpleMeshComp;  // 0x0374 (0x0008) [0x0000000000000000]
    class AActor*
        CurrentSimpleMeshActor;  // 0x037C (0x0008) [0x0000000000000000]
    TArray<class AProcBuilding*>
        AttachedBuildings;        // 0x0384 (0x0010) [0x0000000000000000]
    int BuildingInstanceVersion;  // 0x0394 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2721];

        return pClassPointer;
    };

    void FindEdgeForTopLevelScope();
    void BreakFractureComponent();
    void GetAllGroupedProcBuildings();
    void GetBaseMostBuilding();
    void FindComponentsForTopLevelScope();
    void ClearBuildingMeshes();
};

UClass* AProcBuilding::pClassPointer = NULL;

// Class Engine.ProcBuilding_SimpleLODActor
// 0x0000 (0x02B0 - 0x02B0)
class AProcBuilding_SimpleLODActor : public AStaticMeshActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2723];

        return pClassPointer;
    };
};

UClass* AProcBuilding_SimpleLODActor::pClassPointer = NULL;

// Class Engine.PBRuleNodeBase
// 0x0034 (0x0094 - 0x0060)
class UPBRuleNodeBase : public UObject {
   public:
    TArray<struct FPBRuleLink>
        NextRules;           // 0x0060 (0x0010) [0x0000000000000000]
    struct FString Comment;  // 0x0070 (0x0010) [0x0000000000000000]
    int RulePosX;            // 0x0080 (0x0004) [0x0000000000000000]
    int RulePosY;            // 0x0084 (0x0004) [0x0000000000000000]
    int InDrawY;             // 0x0088 (0x0004) [0x0000000000000000]
    int DrawWidth;           // 0x008C (0x0004) [0x0000000000000000]
    int DrawHeight;          // 0x0090 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2725];

        return pClassPointer;
    };
};

UClass* UPBRuleNodeBase::pClassPointer = NULL;

// Class Engine.PBRuleNodeAlternate
// 0x0010 (0x00A4 - 0x0094)
class UPBRuleNodeAlternate : public UPBRuleNodeBase {
   public:
    unsigned char RepeatAxis;       // 0x0094 (0x0001) [0x0000000000000000]
    float ASize;                    // 0x0098 (0x0004) [0x0000000000000000]
    float BMaxSize;                 // 0x009C (0x0004) [0x0000000000000000]
    DWORD bInvertPatternOrder : 1;  // 0x00A0 (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    DWORD
        bEqualSizeAB : 1;  // 0x00A0 (0x0004) [0x0000000000000000] [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2727];

        return pClassPointer;
    };
};

UClass* UPBRuleNodeAlternate::pClassPointer = NULL;

// Class Engine.PBRuleNodeComment
// 0x0018 (0x00AC - 0x0094)
class UPBRuleNodeComment : public UPBRuleNodeBase {
   public:
    int SizeX;                  // 0x0094 (0x0004) [0x0000000000000000]
    int SizeY;                  // 0x0098 (0x0004) [0x0000000000000000]
    int BorderWidth;            // 0x009C (0x0004) [0x0000000000000000]
    struct FColor BorderColor;  // 0x00A0 (0x0004) [0x0000000000000000]
    DWORD bFilled : 1;  // 0x00A4 (0x0004) [0x0000000000000000] [0x00000001]
    struct FColor FillColor;  // 0x00A8 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2729];

        return pClassPointer;
    };
};

UClass* UPBRuleNodeComment::pClassPointer = NULL;

// Class Engine.PBRuleNodeCorner
// 0x002C (0x00C0 - 0x0094)
class UPBRuleNodeCorner : public UPBRuleNodeBase {
   public:
    float CornerSize;  // 0x0094 (0x0004) [0x0000000000000000]
    TArray<struct FRBCornerAngleInfo>
        Angles;                          // 0x0098 (0x0010) [0x0000000000000000]
    float FlatThreshold;                 // 0x00A8 (0x0004) [0x0000000000000000]
    DWORD bNoMeshForConcaveCorners : 1;  // 0x00AC (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bUseAdjacentRulesetForRightGap : 1;  // 0x00AC (0x0004)
                                               // [0x0000000000000000]
                                               // [0x00000002]
    unsigned char CornerType;  // 0x00B0 (0x0001) [0x0000000000000000]
    float CornerShapeOffset;   // 0x00B4 (0x0004) [0x0000000000000000]
    int RoundTesselation;      // 0x00B8 (0x0004) [0x0000000000000000]
    float RoundCurvature;      // 0x00BC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2731];

        return pClassPointer;
    };
};

UClass* UPBRuleNodeCorner::pClassPointer = NULL;

// Class Engine.PBRuleNodeCycle
// 0x0010 (0x00A4 - 0x0094)
class UPBRuleNodeCycle : public UPBRuleNodeBase {
   public:
    unsigned char RepeatAxis;  // 0x0094 (0x0001) [0x0000000000000000]
    float RepeatSize;          // 0x0098 (0x0004) [0x0000000000000000]
    int CycleSize;             // 0x009C (0x0004) [0x0000000000000000]
    DWORD bFixRepeatSize : 1;  // 0x00A0 (0x0004) [0x0000000000000000]
                               // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2733];

        return pClassPointer;
    };
};

UClass* UPBRuleNodeCycle::pClassPointer = NULL;

// Class Engine.PBRuleNodeEdgeAngle
// 0x0014 (0x00A8 - 0x0094)
class UPBRuleNodeEdgeAngle : public UPBRuleNodeBase {
   public:
    unsigned char Edge;  // 0x0094 (0x0001) [0x0000000000000000]
    TArray<struct FRBEdgeAngleInfo>
        Angles;  // 0x0098 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2735];

        return pClassPointer;
    };
};

UClass* UPBRuleNodeEdgeAngle::pClassPointer = NULL;

// Class Engine.PBRuleNodeEdgeMesh
// 0x0008 (0x009C - 0x0094)
class UPBRuleNodeEdgeMesh : public UPBRuleNodeBase {
   public:
    float FlatThreshold;  // 0x0094 (0x0004) [0x0000000000000000]
    float MainXPullIn;    // 0x0098 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2737];

        return pClassPointer;
    };
};

UClass* UPBRuleNodeEdgeMesh::pClassPointer = NULL;

// Class Engine.PBRuleNodeExtractTopBottom
// 0x0010 (0x00A4 - 0x0094)
class UPBRuleNodeExtractTopBottom : public UPBRuleNodeBase {
   public:
    float ExtractTopZ;        // 0x0094 (0x0004) [0x0000000000000000]
    float ExtractNotTopZ;     // 0x0098 (0x0004) [0x0000000000000000]
    float ExtractBottomZ;     // 0x009C (0x0004) [0x0000000000000000]
    float ExtractNotBottomZ;  // 0x00A0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2739];

        return pClassPointer;
    };
};

UClass* UPBRuleNodeExtractTopBottom::pClassPointer = NULL;

// Class Engine.PBRuleNodeLODQuad
// 0x0004 (0x0098 - 0x0094)
class UPBRuleNodeLODQuad : public UPBRuleNodeBase {
   public:
    float MassiveLODDistanceScale;  // 0x0094 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2741];

        return pClassPointer;
    };
};

UClass* UPBRuleNodeLODQuad::pClassPointer = NULL;

// Class Engine.PBRuleNodeMesh
// 0x0060 (0x00F4 - 0x0094)
class UPBRuleNodeMesh : public UPBRuleNodeBase {
   public:
    TArray<struct FBuildingMeshInfo>
        BuildingMeshes;  // 0x0094 (0x0010) [0x0000000000000000]
    struct FBuildingMeshInfo
        PartialOccludedBuildingMesh;  // 0x00A4 (0x004C) [0x0000000000000000]
    DWORD bDoOcclusionTest : 1;       // 0x00F0 (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    DWORD bBlockAll : 1;  // 0x00F0 (0x0004) [0x0000000000000000] [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2743];

        return pClassPointer;
    };

    void PickRandomBuildingMesh();
};

UClass* UPBRuleNodeMesh::pClassPointer = NULL;

// Class Engine.PBRuleNodeOcclusion
// 0x0000 (0x0094 - 0x0094)
class UPBRuleNodeOcclusion : public UPBRuleNodeBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2745];

        return pClassPointer;
    };
};

UClass* UPBRuleNodeOcclusion::pClassPointer = NULL;

// Class Engine.PBRuleNodeQuad
// 0x001C (0x00B0 - 0x0094)
class UPBRuleNodeQuad : public UPBRuleNodeBase {
   public:
    class UMaterialInterface* Material;  // 0x0094 (0x0008) [0x0000000000000000]
    float RepeatMaxSizeX;                // 0x009C (0x0004) [0x0000000000000000]
    float RepeatMaxSizeZ;                // 0x00A0 (0x0004) [0x0000000000000000]
    int QuadLightmapRes;                 // 0x00A4 (0x0004) [0x0000000000000000]
    float YOffset;                       // 0x00A8 (0x0004) [0x0000000000000000]
    DWORD bDisableMaterialRepeat : 1;    // 0x00AC (0x0004) [0x0000000000000000]
                                         // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2747];

        return pClassPointer;
    };
};

UClass* UPBRuleNodeQuad::pClassPointer = NULL;

// Class Engine.PBRuleNodeRandom
// 0x000C (0x00A0 - 0x0094)
class UPBRuleNodeRandom : public UPBRuleNodeBase {
   public:
    int NumOutputs;      // 0x0094 (0x0004) [0x0000000000000000]
    int MinNumExecuted;  // 0x0098 (0x0004) [0x0000000000000000]
    int MaxNumExecuted;  // 0x009C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2749];

        return pClassPointer;
    };
};

UClass* UPBRuleNodeRandom::pClassPointer = NULL;

// Class Engine.PBRuleNodeRepeat
// 0x0008 (0x009C - 0x0094)
class UPBRuleNodeRepeat : public UPBRuleNodeBase {
   public:
    unsigned char RepeatAxis;  // 0x0094 (0x0001) [0x0000000000000000]
    float RepeatMaxSize;       // 0x0098 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2751];

        return pClassPointer;
    };
};

UClass* UPBRuleNodeRepeat::pClassPointer = NULL;

// Class Engine.PBRuleNodeSize
// 0x000C (0x00A0 - 0x0094)
class UPBRuleNodeSize : public UPBRuleNodeBase {
   public:
    unsigned char SizeAxis;           // 0x0094 (0x0001) [0x0000000000000000]
    float DecisionSize;               // 0x0098 (0x0004) [0x0000000000000000]
    DWORD bUseTopLevelScopeSize : 1;  // 0x009C (0x0004) [0x0000000000000000]
                                      // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2753];

        return pClassPointer;
    };
};

UClass* UPBRuleNodeSize::pClassPointer = NULL;

// Class Engine.PBRuleNodeSplit
// 0x0014 (0x00A8 - 0x0094)
class UPBRuleNodeSplit : public UPBRuleNodeBase {
   public:
    unsigned char SplitAxis;  // 0x0094 (0x0001) [0x0000000000000000]
    TArray<struct FRBSplitInfo>
        SplitSetup;  // 0x0098 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2755];

        return pClassPointer;
    };
};

UClass* UPBRuleNodeSplit::pClassPointer = NULL;

// Class Engine.PBRuleNodeSubRuleset
// 0x0008 (0x009C - 0x0094)
class UPBRuleNodeSubRuleset : public UPBRuleNodeBase {
   public:
    class UProcBuildingRuleset*
        SubRuleset;  // 0x0094 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2757];

        return pClassPointer;
    };
};

UClass* UPBRuleNodeSubRuleset::pClassPointer = NULL;

// Class Engine.PBRuleNodeTransform
// 0x0018 (0x00AC - 0x0094)
class UPBRuleNodeTransform : public UPBRuleNodeBase {
   public:
    class UDistributionVector*
        Translation;  // 0x0094 (0x0008) [0x0000000000000000]
    class UDistributionVector*
        Rotation;                      // 0x009C (0x0008) [0x0000000000000000]
    class UDistributionVector* Scale;  // 0x00A4 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2759];

        return pClassPointer;
    };
};

UClass* UPBRuleNodeTransform::pClassPointer = NULL;

// Class Engine.PBRuleNodeVariation
// 0x0004 (0x0098 - 0x0094)
class UPBRuleNodeVariation : public UPBRuleNodeBase {
   public:
    DWORD bVariationOfScopeOnLeft : 1;  // 0x0094 (0x0004) [0x0000000000000000]
                                        // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2761];

        return pClassPointer;
    };
};

UClass* UPBRuleNodeVariation::pClassPointer = NULL;

// Class Engine.PBRuleNodeWindowWall
// 0x0028 (0x00BC - 0x0094)
class UPBRuleNodeWindowWall : public UPBRuleNodeBase {
   public:
    float CellMaxSizeX;                  // 0x0094 (0x0004) [0x0000000000000000]
    float CellMaxSizeZ;                  // 0x0098 (0x0004) [0x0000000000000000]
    float WindowSizeX;                   // 0x009C (0x0004) [0x0000000000000000]
    float WindowSizeZ;                   // 0x00A0 (0x0004) [0x0000000000000000]
    float WindowPosX;                    // 0x00A4 (0x0004) [0x0000000000000000]
    float WindowPosZ;                    // 0x00A8 (0x0004) [0x0000000000000000]
    DWORD bScaleWindowWithCell : 1;      // 0x00AC (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    float YOffset;                       // 0x00B0 (0x0004) [0x0000000000000000]
    class UMaterialInterface* Material;  // 0x00B4 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2763];

        return pClassPointer;
    };
};

UClass* UPBRuleNodeWindowWall::pClassPointer = NULL;

// Class Engine.ProcBuildingRuleset
// 0x0084 (0x00E4 - 0x0060)
class UProcBuildingRuleset : public UObject {
   public:
    class UPBRuleNodeBase* RootRule;  // 0x0060 (0x0008) [0x0000000000000000]
    DWORD
        bBeingEdited : 1;  // 0x0068 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bEnableInteriorTexture : 1;  // 0x0068 (0x0004) [0x0000000000000000]
                                       // [0x00000002]
    DWORD
        bLODOnlyRoof : 1;  // 0x0068 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bPickRandomSwatch : 1;  // 0x0068 (0x0004) [0x0000000000000000]
                                  // [0x00000008]
    class UMaterialInterface*
        DefaultRoofMaterial;  // 0x006C (0x0008) [0x0000000000000000]
    class UMaterialInterface*
        DefaultFloorMaterial;  // 0x0074 (0x0008) [0x0000000000000000]
    class UMaterialInterface*
        DefaultNonRectWallMaterial;   // 0x007C (0x0008) [0x0000000000000000]
    float RoofZOffset;                // 0x0084 (0x0004) [0x0000000000000000]
    float NotRoofZOffset;             // 0x0088 (0x0004) [0x0000000000000000]
    float FloorZOffset;               // 0x008C (0x0004) [0x0000000000000000]
    float NotFloorZOffset;            // 0x0090 (0x0004) [0x0000000000000000]
    float RoofPolyInset;              // 0x0094 (0x0004) [0x0000000000000000]
    float FloorPolyInset;             // 0x0098 (0x0004) [0x0000000000000000]
    float BuildingLODSpecular;        // 0x009C (0x0004) [0x0000000000000000]
    float RoofEdgeScopeRaise;         // 0x00A0 (0x0004) [0x0000000000000000]
    class UTexture* LODCubemap;       // 0x00A4 (0x0008) [0x0000000000000000]
    class UTexture* InteriorTexture;  // 0x00AC (0x0008) [0x0000000000000000]
    TArray<struct FPBVariationInfo>
        Variations;  // 0x00B4 (0x0010) [0x0000000000000000]
    TArray<struct FPBParamSwatch>
        ParamSwatches;  // 0x00C4 (0x0010) [0x0000000000000000]
    TArray<class UPBRuleNodeComment*>
        Comments;  // 0x00D4 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2765];

        return pClassPointer;
    };
};

UClass* UProcBuildingRuleset::pClassPointer = NULL;

// Class Engine.ReplicationInfo
// 0x0000 (0x0244 - 0x0244)
class AReplicationInfo : public AInfo {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2767];

        return pClassPointer;
    };
};

UClass* AReplicationInfo::pClassPointer = NULL;

// Class Engine.GameReplicationInfo
// 0x0068 (0x02AC - 0x0244)
class AGameReplicationInfo : public AReplicationInfo {
   public:
    class UClass* GameClass;  // 0x0244 (0x0008) [0x0000000000150025] ( CPF_Edit
                              // | CPF_Input | CPF_Net | CPF_Travel |
                              // CPF_GlobalConfig )
    DWORD bStopCountDown : 1;  // 0x024C (0x0004) [0x0000000000160000]
                               // [0x00000001] ( CPF_EditConst |
                               // CPF_GlobalConfig )
    DWORD bMatchHasBegun : 1;  // 0x024C (0x0004) [0x0000000000170000]
                               // [0x00000002] ( CPF_Travel | CPF_EditConst |
                               // CPF_GlobalConfig )
    DWORD bMatchIsOver : 1;    // 0x024C (0x0004) [0x0000000000180000]
                               // [0x00000004] ( CPF_Component )
    DWORD bRoundIsOver : 1;    // 0x024C (0x0004) [0x0000000000190000]
                               // [0x00000008] ( CPF_Travel | CPF_Component )
    DWORD bWaitingForAAR : 1;  // 0x024C (0x0004) [0x0000000000000000]
                               // [0x00000010]
    DWORD bPendingMusicTrackChange : 1;  // 0x024C (0x0004) [0x0000000000000000]
                                         // [0x00000020]
    int RemainingTime;    // 0x0250 (0x0004) [0x00000000001A0025]              (
                          // CPF_Edit | CPF_Input | CPF_Net | CPF_EditConst |
                          // CPF_Component )
    int ElapsedTime;      // 0x0254 (0x0004) [0x00000000001B0025]              (
                          // CPF_Edit | CPF_Input | CPF_Net | CPF_Travel |
                          // CPF_EditConst | CPF_Component )
    int RemainingMinute;  // 0x0258 (0x0004) [0x00000000001C000A]              (
                          // CPF_Const | CPF_ExportObject | CPF_GlobalConfig |
                          // CPF_Component )
    int GoalScore;        // 0x025C (0x0004) [0x00000000001D0025]              (
                          // CPF_Edit | CPF_Input | CPF_Net | CPF_Travel |
                          // CPF_GlobalConfig | CPF_Component )
    int TimeLimit;        // 0x0260 (0x0004) [0x00000000001E0025]              (
                          // CPF_Edit | CPF_Input | CPF_Net | CPF_EditConst |
                          // CPF_GlobalConfig | CPF_Component )
    TArray<class ATeamInfo*> Teams;  // 0x0264 (0x0010) [0x0000000000000000]
    struct FString
        ServerName;  // 0x0274 (0x0010) [0x00000000001F0025]              (
                     // CPF_Edit | CPF_Input | CPF_Net | CPF_Travel |
                     // CPF_EditConst | CPF_GlobalConfig | CPF_Component )
    class AActor* Winner;  // 0x0284 (0x0008) [0x0000000000200000]
    TArray<class APlayerReplicationInfo*>
        PRIArray;  // 0x028C (0x0010) [0x0000000000000000]
    TArray<class APlayerReplicationInfo*>
        InactivePRIArray;  // 0x029C (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2769];

        return pClassPointer;
    };

    void eventIsStatsSessionValid();
    void eventGetPRIByPlayfabId();
    void eventShouldShowGore();
    void IsCoopMultiplayerGame();
    void IsMultiplayerGame();
    void EndGame();
    void StartMatch();
    void SetTeam();
    void RemovePRI();
    void AddPRI();
    void OnSameTeam();
    void eventTimer();
    void Reset();
    void ReceivedGameClass();
    void eventReplicatedEvent();
    void eventPostBeginPlay();
};

UClass* AGameReplicationInfo::pClassPointer = NULL;

// Class Engine.PlayerReplicationInfo
// 0x00E0 (0x0324 - 0x0244)
class APlayerReplicationInfo : public AReplicationInfo {
   public:
    float Score;         // 0x0244 (0x0004) [0x0000000000150000]              (
                         // CPF_Travel | CPF_GlobalConfig )
    int Deaths;          // 0x0248 (0x0004) [0x0000000000160000]              (
                         // CPF_EditConst | CPF_GlobalConfig )
    unsigned char Ping;  // 0x024C (0x0001) [0x000000000017000A]              (
                         // CPF_Const | CPF_ExportObject | CPF_Travel |
                         // CPF_EditConst | CPF_GlobalConfig )
    unsigned char TTSSpeaker;   // 0x024D (0x0001) [0x0000000000000000]
    int NumLives;               // 0x0250 (0x0004) [0x0000000000000000]
    struct FString PlayerName;  // 0x0254 (0x0010) [0x0000000000180000] (
                                // CPF_Component )
    struct FString OldName;  // 0x0264 (0x0010) [0x0000000000000000]
    int PlayerID;  // 0x0274 (0x0004) [0x0000000000190025]              (
                   // CPF_Edit | CPF_Input | CPF_Net | CPF_Travel |
                   // CPF_Component )
    class ATeamInfo* Team;  // 0x0278 (0x0008) [0x00000000001A0000] (
                            // CPF_EditConst | CPF_Component )
    DWORD bAdmin : 1;  // 0x0280 (0x0004) [0x00000000001B0000] [0x00000001] (
                       // CPF_Travel | CPF_EditConst | CPF_Component )
    DWORD
        bIsSpectator : 1;  // 0x0280 (0x0004) [0x00000000001C0000] [0x00000002]
                           // ( CPF_GlobalConfig | CPF_Component )
    DWORD bOnlySpectator : 1;  // 0x0280 (0x0004) [0x00000000001D0000]
                               // [0x00000004] ( CPF_Travel | CPF_GlobalConfig |
                               // CPF_Component )
    DWORD bWaitingPlayer : 1;  // 0x0280 (0x0004) [0x00000000001E0000]
                               // [0x00000008] ( CPF_EditConst |
                               // CPF_GlobalConfig | CPF_Component )
    DWORD bReadyToPlay : 1;    // 0x0280 (0x0004) [0x00000000001F0000]
                               // [0x00000010] ( CPF_Travel | CPF_EditConst |
                               // CPF_GlobalConfig | CPF_Component )
    DWORD bOutOfLives : 1;  // 0x0280 (0x0004) [0x0000000000200000] [0x00000020]
    DWORD bBot : 1;  // 0x0280 (0x0004) [0x0000000000210025] [0x00000040] (
                     // CPF_Edit | CPF_Input | CPF_Net | CPF_Travel )
    DWORD bHasBeenWelcomed : 1;  // 0x0280 (0x0004) [0x0000000000000000]
                                 // [0x00000080]
    DWORD
        bIsInactive : 1;  // 0x0280 (0x0004) [0x0000000000220025] [0x00000100] (
                          // CPF_Edit | CPF_Input | CPF_Net | CPF_EditConst )
    DWORD
        bFromPreviousLevel : 1;  // 0x0280 (0x0004) [0x0000000000230000]
                                 // [0x00000200] ( CPF_Travel | CPF_EditConst )
    int StartTime;  // 0x0284 (0x0004) [0x0000000000240000]              (
                    // CPF_GlobalConfig )
    struct FString StringSpectating;  // 0x0288 (0x0010) [0x0000000000000000]
    struct FString StringUnknown;     // 0x0298 (0x0010) [0x0000000000000000]
    int Kills;  // 0x02A8 (0x0004) [0x0000000000250000]              (
                // CPF_Travel | CPF_GlobalConfig )
    class UClass* GameMessageClass;      // 0x02AC (0x0008) [0x0000000000000000]
    float ExactPing;                     // 0x02B4 (0x0004) [0x0000000000000000]
    struct FString SavedNetworkAddress;  // 0x02B8 (0x0010) [0x0000000000000000]
    struct FUniqueNetId UniqueId;  // 0x02C8 (0x0008) [0x0000000000260000] (
                                   // CPF_EditConst | CPF_GlobalConfig )
    struct FName SessionName;  // 0x02D0 (0x0008) [0x0000000000000000]
    struct FAutomatedTestingDatum
        AutomatedTestingData;  // 0x02D8 (0x0008) [0x0000000000000000]
    int StatConnectionCounts;  // 0x02E0 (0x0004) [0x0000000000000000]
    int StatPingTotals;        // 0x02E4 (0x0004) [0x0000000000000000]
    int StatPingMin;           // 0x02E8 (0x0004) [0x0000000000000000]
    int StatPingMax;           // 0x02EC (0x0004) [0x0000000000000000]
    int StatPKLTotal;          // 0x02F0 (0x0004) [0x0000000000000000]
    int StatPKLMin;            // 0x02F4 (0x0004) [0x0000000000000000]
    int StatPKLMax;            // 0x02F8 (0x0004) [0x0000000000000000]
    int StatMaxInBPS;          // 0x02FC (0x0004) [0x0000000000000000]
    int StatAvgInBPS;          // 0x0300 (0x0004) [0x0000000000000000]
    int StatMaxOutBPS;         // 0x0304 (0x0004) [0x0000000000000000]
    int StatAvgOutBPS;         // 0x0308 (0x0004) [0x0000000000000000]
    class UTexture2D* Avatar;  // 0x030C (0x0008) [0x0000000000000000]
    struct FString
        PlayfabPlayerId;  // 0x0314 (0x0010) [0x0000000000270000]              (
                          // CPF_Travel | CPF_EditConst | CPF_GlobalConfig )

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2771];

        return pClassPointer;
    };

    void HasHadInitialSpawn();
    void IsPrimaryPlayer();
    void UnregisterPlayerFromSession();
    void RegisterPlayerWithSession();
    void IsInvalidName();
    void GetTeamNum();
    void SetUniqueId();
    void SeamlessTravelTo();
    void IncrementDeaths();
    void CopyProperties();
    void OverrideWith();
    void Duplicate();
    void SetWaitingPlayer();
    void eventSetPlayerName();
    void DisplayDebug();
    void GetHumanReadableName();
    void Reset();
    void eventDestroyed();
    void ShouldBroadCastWelcomeMessage();
    void UpdatePing();
    void eventReplicatedEvent();
    void SetPlayerTeam();
    void ClientInitialize();
    void eventPostBeginPlay();
};

UClass* APlayerReplicationInfo::pClassPointer = NULL;

// Class Engine.TeamInfo
// 0x0020 (0x0264 - 0x0244)
class ATeamInfo : public AReplicationInfo {
   public:
    struct FString TeamName;  // 0x0244 (0x0010) [0x0000000000150020] ( CPF_Net
                              // | CPF_Travel | CPF_GlobalConfig )
    int Size;       // 0x0254 (0x0004) [0x0000000000000000]
    float Score;    // 0x0258 (0x0004) [0x0000000000160000]              (
                    // CPF_EditConst | CPF_GlobalConfig )
    int TeamIndex;  // 0x025C (0x0004) [0x0000000000170020]              (
                    // CPF_Net | CPF_Travel | CPF_EditConst | CPF_GlobalConfig )
    struct FColor TeamColor;  // 0x0260 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2773];

        return pClassPointer;
    };

    void GetTeamNum();
    void GetHumanReadableName();
    void RemoveFromTeam();
    void AddToTeam();
    void eventDestroyed();
    void eventReplicatedEvent();
};

UClass* ATeamInfo::pClassPointer = NULL;

// Class Engine.Camera
// 0x0408 (0x064C - 0x0244)
class ACamera : public AActor {
   public:
    class APlayerController* PCOwner;  // 0x0244 (0x0008) [0x0000000000000000]
    struct FName CameraStyle;          // 0x024C (0x0008) [0x0000000000000000]
    float DefaultFOV;                  // 0x0254 (0x0004) [0x0000000000000000]
    DWORD bLockedFOV : 1;  // 0x0258 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bConstrainAspectRatio : 1;  // 0x0258 (0x0004) [0x0000000000000000]
                                      // [0x00000002]
    DWORD
        bEnableFading : 1;  // 0x0258 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bFadeAudio : 1;   // 0x0258 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bForceDisableTemporalAA : 1;  // 0x0258 (0x0004) [0x0000000000000000]
                                        // [0x00000010]
    DWORD bEnableColorScaling : 1;      // 0x0258 (0x0004) [0x0000000000000000]
                                        // [0x00000020]
    DWORD bEnableColorScaleInterp : 1;  // 0x0258 (0x0004) [0x0000000000000000]
                                        // [0x00000040]
    DWORD bUseClientSideCameraUpdates : 1;  // 0x0258 (0x0004)
                                            // [0x0000000000000000] [0x00000080]
    DWORD bDebugClientSideCamera : 1;  // 0x0258 (0x0004) [0x0000000000000000]
                                       // [0x00000100]
    DWORD bShouldSendClientSideCameraUpdate : 1;  // 0x0258 (0x0004)
                                                  // [0x0000000000000000]
                                                  // [0x00000200]
    float LockedFOV;                    // 0x025C (0x0004) [0x0000000000000000]
    float UnmodifiedFOV;                // 0x0260 (0x0004) [0x0000000000000000]
    float ConstrainedAspectRatio;       // 0x0264 (0x0004) [0x0000000000000000]
    float DefaultAspectRatio;           // 0x0268 (0x0004) [0x0000000000000000]
    float OffAxisYawAngle;              // 0x026C (0x0004) [0x0000000000000000]
    float OffAxisPitchAngle;            // 0x0270 (0x0004) [0x0000000000000000]
    struct FColor FadeColor;            // 0x0274 (0x0004) [0x0000000000000000]
    float FadeAmount;                   // 0x0278 (0x0004) [0x0000000000000000]
    float CamOverridePostProcessAlpha;  // 0x027C (0x0004) [0x0000000000000000]
    struct FPostProcessSettings
        CamPostProcessSettings;  // 0x0280 (0x0220) [0x0000000000000000]
    struct FRenderingPerformanceOverrides
        RenderingOverrides;             // 0x04A0 (0x0004) [0x0000000000000000]
    struct FVector ColorScale;          // 0x04A4 (0x000C) [0x0000000000000000]
    struct FVector DesiredColorScale;   // 0x04B0 (0x000C) [0x0000000000000000]
    struct FVector OriginalColorScale;  // 0x04BC (0x000C) [0x0000000000000000]
    float ColorScaleInterpDuration;     // 0x04C8 (0x0004) [0x0000000000000000]
    float ColorScaleInterpStartTime;    // 0x04CC (0x0004) [0x0000000000000000]
    struct FTCameraCache CameraCache;   // 0x04D0 (0x0020) [0x0000000000000000]
    struct FTCameraCache
        LastFrameCameraCache;        // 0x04F0 (0x0020) [0x0000000000000000]
    struct FTViewTarget ViewTarget;  // 0x0510 (0x0038) [0x0000000000000000]
    struct FTViewTarget
        PendingViewTarget;  // 0x0548 (0x0038) [0x0000000000000000]
    float BlendTimeToGo;    // 0x0580 (0x0004) [0x0000000000000000]
    struct FViewTargetTransitionParams
        BlendParams;  // 0x0584 (0x0010) [0x0000000000000000]
    TArray<class UCameraModifier*>
        ModifierList;              // 0x0594 (0x0010) [0x0000000000000000]
    float FreeCamDistance;         // 0x05A4 (0x0004) [0x0000000000000000]
    struct FVector FreeCamOffset;  // 0x05A8 (0x000C) [0x0000000000000000]
    struct FVector2D FadeAlpha;    // 0x05B4 (0x0008) [0x0000000000000000]
    float FadeTime;                // 0x05BC (0x0004) [0x0000000000000000]
    float FadeTimeRemaining;       // 0x05C0 (0x0004) [0x0000000000000000]
    TArray<class AEmitterCameraLensEffectBase*>
        CameraLensEffects;  // 0x05C4 (0x0010) [0x0000000000000000]
    class UCameraModifier_CameraShake*
        CameraShakeCamMod;  // 0x05D4 (0x0008) [0x0000000000000000]
    class UClass*
        CameraShakeCamModClass;  // 0x05DC (0x0008) [0x0000000000000000]
    class UCameraAnimInst*
        AnimInstPool[0x8];  // 0x05E4 (0x0040) [0x0000000000000000]
    TArray<class UCameraAnimInst*>
        ActiveAnims;  // 0x0624 (0x0010) [0x0000000000000000]
    TArray<class UCameraAnimInst*>
        FreeAnims;  // 0x0634 (0x0010) [0x0000000000000000]
    class ADynamicCameraActor*
        AnimCameraActor;  // 0x0644 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2775];

        return pClassPointer;
    };

    void StopCameraAnim();
    void StopAllCameraAnimsByType();
    void StopAllCameraAnims();
    void PlayCameraAnim();
    void ClearAllCameraShakes();
    void PlayWorldCameraShake();
    void CalcRadialShakeScale();
    void StopCameraShake();
    void PlayCameraShake();
    void ClearCameraLensEffects();
    void RemoveCameraLensEffect();
    void AddCameraLensEffect();
    void FindCameraLensEffect();
    void DisplayDebug();
    void ProcessViewRotation();
    void SetViewTarget();
    void UpdateViewTarget();
    void CheckViewTarget();
    void FillCameraCache();
    void BlendViewTargets();
    void ApplyAudioFade();
    void DoUpdateCamera();
    void eventUpdateCamera();
    void SetDesiredColorScale();
    void GetCameraRotation();
    void GetCameraViewPoint();
    void GetActualFOV();
    void SetUnmodifiedFOV();
    void SetFOV();
    void GetFOVAngle();
    void InitializeFor();
    void ApplyCameraModifiers();
    void eventDestroyed();
    void PostBeginPlay();
    void CreateCameraModifier();
};

UClass* ACamera::pClassPointer = NULL;

// Class Engine.CameraActor
// 0x0240 (0x0484 - 0x0244)
class ACameraActor : public AActor {
   public:
    DWORD bConstrainAspectRatio : 1;    // 0x0244 (0x0004) [0x0000000000000000]
                                        // [0x00000001]
    DWORD bCamOverridePostProcess : 1;  // 0x0244 (0x0004) [0x0000000000000000]
                                        // [0x00000002]
    float AspectRatio;  // 0x0248 (0x0004) [0x0000000000150000]              (
                        // CPF_Travel | CPF_GlobalConfig )
    float FOVAngle;     // 0x024C (0x0004) [0x0000000000160000]              (
                        // CPF_EditConst | CPF_GlobalConfig )
    float CamOverridePostProcessAlpha;  // 0x0250 (0x0004) [0x0000000000000000]
    struct FPostProcessSettings
        CamOverridePostProcess;  // 0x0254 (0x0220) [0x0000000000000000]
    class UDrawFrustumComponent*
        DrawFrustum;  // 0x0474 (0x0008) [0x0000000000000000]
    class UStaticMeshComponent*
        MeshComp;  // 0x047C (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2777];

        return pClassPointer;
    };

    void DisplayDebug();
    void GetCameraView();
};

UClass* ACameraActor::pClassPointer = NULL;

// Class Engine.DynamicCameraActor
// 0x0000 (0x0484 - 0x0484)
class ADynamicCameraActor : public ACameraActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2779];

        return pClassPointer;
    };
};

UClass* ADynamicCameraActor::pClassPointer = NULL;

// Class Engine.CameraAnim
// 0x0258 (0x02B8 - 0x0060)
class UCameraAnim : public UObject {
   public:
    class UInterpGroupCamera*
        CameraInterpGroup;  // 0x0060 (0x0008) [0x0000000000000000]
    class UInterpGroup*
        PreviewInterpGroup;   // 0x0068 (0x0008) [0x0000000000000000]
    float AnimLength;         // 0x0070 (0x0004) [0x0000000000000000]
    struct FBox BoundingBox;  // 0x0074 (0x001C) [0x0000000000000000]
    struct FPostProcessSettings
        BasePPSettings;         // 0x0090 (0x0220) [0x0000000000000000]
    float BasePPSettingsAlpha;  // 0x02B0 (0x0004) [0x0000000000000000]
    float BaseFOV;              // 0x02B4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2781];

        return pClassPointer;
    };
};

UClass* UCameraAnim::pClassPointer = NULL;

// Class Engine.CameraAnimInst
// 0x02D0 (0x0330 - 0x0060)
class UCameraAnimInst : public UObject {
   public:
    class UCameraAnim* CamAnim;  // 0x0060 (0x0008) [0x0000000000000000]
    class UInterpGroupInst*
        InterpGroupInst;  // 0x0068 (0x0008) [0x0000000000000000]
    float CurTime;        // 0x0070 (0x0004) [0x0000000000000000]
    DWORD bLooping : 1;   // 0x0074 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bFinished : 1;  // 0x0074 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bAutoReleaseWhenFinished : 1;  // 0x0074 (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD bBlendingIn : 1;  // 0x0074 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD
        bBlendingOut : 1;   // 0x0074 (0x0004) [0x0000000000000000] [0x00000010]
    float BlendInTime;      // 0x0078 (0x0004) [0x0000000000000000]
    float BlendOutTime;     // 0x007C (0x0004) [0x0000000000000000]
    float CurBlendInTime;   // 0x0080 (0x0004) [0x0000000000000000]
    float CurBlendOutTime;  // 0x0084 (0x0004) [0x0000000000000000]
    float PlayRate;         // 0x0088 (0x0004) [0x0000000000000000]
    float BasePlayScale;    // 0x008C (0x0004) [0x0000000000000000]
    float TransientScaleModifier;       // 0x0090 (0x0004) [0x0000000000000000]
    float CurrentBlendWeight;           // 0x0094 (0x0004) [0x0000000000000000]
    float RemainingTime;                // 0x0098 (0x0004) [0x0000000000000000]
    class UInterpTrackMove* MoveTrack;  // 0x009C (0x0008) [0x0000000000000000]
    class UInterpTrackInstMove*
        MoveInst;  // 0x00A4 (0x0008) [0x0000000000000000]
    class UAnimNodeSequence*
        SourceAnimNode;                  // 0x00AC (0x0008) [0x0000000000000000]
    unsigned char PlaySpace;             // 0x00B4 (0x0001) [0x0000000000000000]
    unsigned char UnknownData00[0xB];    // 0x00B5 (0x000B) MISSED OFFSET
    struct FMatrix UserPlaySpaceMatrix;  // 0x00C0 (0x0040) [0x0000000000000000]
    struct FPostProcessSettings
        LastPPSettings;            // 0x0100 (0x0220) [0x0000000000000000]
    float LastPPSettingsAlpha;     // 0x0320 (0x0004) [0x0000000000000000]
    struct FVector LastCameraLoc;  // 0x0324 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2783];

        return pClassPointer;
    };

    void SetPlaySpace();
    void ApplyTransientScaling();
    void Stop();
    void AdvanceAnim();
    void Update();
    void Play();
};

UClass* UCameraAnimInst::pClassPointer = NULL;

// Class Engine.CameraModifier
// 0x0020 (0x0080 - 0x0060)
class UCameraModifier : public UObject {
   public:
    DWORD bDisabled : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bPendingDisable : 1;  // 0x0060 (0x0004) [0x0000000000000000]
                                // [0x00000002]
    DWORD bExclusive : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD bDebug : 1;      // 0x0060 (0x0004) [0x0000000000000000] [0x00000008]
    class ACamera* CameraOwner;  // 0x0064 (0x0008) [0x0000000000000000]
    unsigned char Priority;      // 0x006C (0x0001) [0x0000000000000000]
    float AlphaInTime;           // 0x0070 (0x0004) [0x0000000000000000]
    float AlphaOutTime;          // 0x0074 (0x0004) [0x0000000000000000]
    float Alpha;                 // 0x0078 (0x0004) [0x0000000000000000]
    float TargetAlpha;           // 0x007C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2785];

        return pClassPointer;
    };

    void UpdateAlpha();
    void ProcessViewRotation();
    void ToggleModifier();
    void EnableModifier();
    void eventDisableModifier();
    void RemoveCameraModifier();
    void AddCameraModifier();
    void IsDisabled();
    void ModifyCamera();
    void Init();
};

UClass* UCameraModifier::pClassPointer = NULL;

// Class Engine.CameraModifier_CameraShake
// 0x0014 (0x0094 - 0x0080)
class UCameraModifier_CameraShake : public UCameraModifier {
   public:
    TArray<struct FCameraShakeInstance>
        ActiveShakes;             // 0x0080 (0x0010) [0x0000000000000000]
    float SplitScreenShakeScale;  // 0x0090 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2787];

        return pClassPointer;
    };

    void ModifyCamera();
    void UpdateCameraShake();
    void RemoveAllCameraShakes();
    void RemoveCameraShake();
    void AddCameraShake();
    void InitializeShake();
    void ReinitShake();
    void InitializeOffset();
};

UClass* UCameraModifier_CameraShake::pClassPointer = NULL;

// Class Engine.CameraShake
// 0x0080 (0x00E0 - 0x0060)
class UCameraShake : public UObject {
   public:
    DWORD bSingleInstance : 1;           // 0x0060 (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bRandomAnimSegment : 1;        // 0x0060 (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    float OscillationDuration;           // 0x0064 (0x0004) [0x0000000000000000]
    float OscillationBlendInTime;        // 0x0068 (0x0004) [0x0000000000000000]
    float OscillationBlendOutTime;       // 0x006C (0x0004) [0x0000000000000000]
    struct FROscillator RotOscillation;  // 0x0070 (0x0024) [0x0000000000000000]
    struct FVOscillator LocOscillation;  // 0x0094 (0x0024) [0x0000000000000000]
    struct FFOscillator FOVOscillation;  // 0x00B8 (0x000C) [0x0000000000000000]
    class UCameraAnim* Anim;             // 0x00C4 (0x0008) [0x0000000000000000]
    float AnimPlayRate;                  // 0x00CC (0x0004) [0x0000000000000000]
    float AnimScale;                     // 0x00D0 (0x0004) [0x0000000000000000]
    float AnimBlendInTime;               // 0x00D4 (0x0004) [0x0000000000000000]
    float AnimBlendOutTime;              // 0x00D8 (0x0004) [0x0000000000000000]
    float RandomAnimSegmentDuration;     // 0x00DC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2789];

        return pClassPointer;
    };

    void GetLocOscillationMagnitude();
    void GetRotOscillationMagnitude();
};

UClass* UCameraShake::pClassPointer = NULL;

// Class Engine.CloudStorageUpgradeHelper
// 0x0000 (0x0060 - 0x0060)
class UCloudStorageUpgradeHelper : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2791];

        return pClassPointer;
    };

    void eventGetCloudUpgradeKeys();
    void eventHandleLocalKeyValue();
    void eventHandleLocalDocument();
};

UClass* UCloudStorageUpgradeHelper::pClassPointer = NULL;

// Class Engine.AnalyticEventsBase
// 0x0018 (0x0098 - 0x0080)
class UAnalyticEventsBase : public UPlatformInterfaceBase {
   public:
    DWORD bSessionInProgress : 1;  // 0x0080 (0x0004) [0x0000000000000000]
                                   // [0x00000001]
    DWORD bAutoStartSession : 1;   // 0x0080 (0x0004) [0x0000000000000000]
                                   // [0x00000002]
    int SessionPauseThresholdSec;  // 0x0084 (0x0004) [0x0000000000000000]
    struct FString UserId;         // 0x0088 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2793];

        return pClassPointer;
    };

    void eventSendCachedEvents();
    void eventLogCurrencyGivenEvent();
    void eventLogCurrencyPurchaseEvent();
    void eventLogItemPurchaseEvent();
    void eventLogUserAttributeUpdateArray();
    void eventLogUserAttributeUpdate();
    void eventLogErrorMessage();
    void eventEndStringEventParamArray();
    void eventLogStringEventParamArray();
    void eventEndStringEventParam();
    void eventLogStringEventParam();
    void eventEndStringEvent();
    void eventLogStringEvent();
    void eventEndSession();
    void eventStartSession();
    void eventSetUserId();
    void eventInit();
    void IsSessionInProgress();
};

UClass* UAnalyticEventsBase::pClassPointer = NULL;

// Class Engine.MultiProviderAnalytics
// 0x0020 (0x00B8 - 0x0098)
class UMultiProviderAnalytics : public UAnalyticEventsBase {
   public:
    TArray<struct FString>
        AnalyticsProviderClassNames;  // 0x0098 (0x0010) [0x0000000000000000]
    TArray<class UAnalyticEventsBase*>
        AnalyticsProviders;  // 0x00A8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2795];

        return pClassPointer;
    };

    void eventSendCachedEvents();
    void eventLogCurrencyGivenEvent();
    void eventLogCurrencyPurchaseEvent();
    void eventLogItemPurchaseEvent();
    void eventLogUserAttributeUpdateArray();
    void eventLogUserAttributeUpdate();
    void eventLogErrorMessage();
    void eventEndStringEventParamArray();
    void eventLogStringEventParamArray();
    void eventEndStringEventParam();
    void eventLogStringEventParam();
    void eventEndStringEvent();
    void eventLogStringEvent();
    void eventEndSession();
    void eventStartSession();
    void eventSetUserId();
    void Init();
};

UClass* UMultiProviderAnalytics::pClassPointer = NULL;

// Class Engine.AppNotificationsBase
// 0x004C (0x00CC - 0x0080)
class UAppNotificationsBase : public UPlatformInterfaceBase {
   public:
    struct FLaunchNotificationInfo
        AppLaunchNotification;  // 0x0080 (0x002C) [0x0000000000000000]
    struct FScriptDelegate
        __OnReceivedLocalNotification__Delegate;  // 0x00AC (0x0010)
                                                  // [0x0000000000000000]
    unsigned char UnknownData00[0x4];  // 0x00B0 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __OnReceivedRemoteNotification__Delegate;  // 0x00BC (0x0010)
                                                   // [0x0000000000000000]
    unsigned char UnknownData01[0x4];  // 0x00C0 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2797];

        return pClassPointer;
    };

    void DebugLogNotification();
    void OnReceivedRemoteNotification();
    void OnReceivedLocalNotification();
    void CancelAllScheduledLocalNotifications();
    void ScheduleLocalNotification();
    void WasLaunchedViaNotification();
    void eventInit();
};

UClass* UAppNotificationsBase::pClassPointer = NULL;

// Class Engine.CloudStorageBase
// 0x0014 (0x0094 - 0x0080)
class UCloudStorageBase : public UPlatformInterfaceBase {
   public:
    TArray<struct FString>
        LocalCloudFiles;               // 0x0080 (0x0010) [0x0000000000000000]
    DWORD bSuppressDelegateCalls : 1;  // 0x0090 (0x0004) [0x0000000000000000]
                                       // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2799];

        return pClassPointer;
    };

    void eventUpgradeLocalStorageToCloud();
    void eventResolveConflictWithVersionIndex();
    void eventResolveConflictWithNewestDocument();
    void eventWaitForWritesToFinish();
    void eventIsStillWritingFiles();
    void eventSaveDocumentWithObject();
    void eventSaveDocumentWithBytes();
    void eventSaveDocumentWithString();
    void eventWriteCloudDocument();
    void eventParseDocumentAsObject();
    void eventParseDocumentAsBytes();
    void eventParseDocumentAsString();
    void eventReadCloudDocument();
    void eventDeleteAllCloudDocuments();
    void eventCreateCloudDocument();
    void eventGetCloudDocumentName();
    void eventGetNumCloudDocuments();
    void eventQueryForCloudDocuments();
    void eventWriteKeyValue();
    void eventReadKeyValueFromLocalStore();
    void eventReadKeyValue();
    void IsUsingLocalStorage();
    void eventInit();
};

UClass* UCloudStorageBase::pClassPointer = NULL;

// Class Engine.FacebookIntegration
// 0x0060 (0x00E0 - 0x0080)
class UFacebookIntegration : public UPlatformInterfaceBase {
   public:
    struct FString AppID;                // 0x0080 (0x0010) [0x0000000000000000]
    TArray<struct FString> Permissions;  // 0x0090 (0x0010) [0x0000000000000000]
    struct FString UserName;             // 0x00A0 (0x0010) [0x0000000000000000]
    struct FString UserId;               // 0x00B0 (0x0010) [0x0000000000000000]
    struct FString AccessToken;          // 0x00C0 (0x0010) [0x0000000000000000]
    TArray<struct FFacebookFriend>
        FriendsList;  // 0x00D0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2801];

        return pClassPointer;
    };

    void eventDisconnect();
    void eventFacebookDialog();
    void eventFacebookRequest();
    void eventIsAuthorized();
    void eventAuthorize();
    void eventInit();
};

UClass* UFacebookIntegration::pClassPointer = NULL;

// Class Engine.InAppMessageBase
// 0x0000 (0x0080 - 0x0080)
class UInAppMessageBase : public UPlatformInterfaceBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2803];

        return pClassPointer;
    };

    void eventShowInAppEmailUI();
    void eventShowInAppSMSUI();
    void eventInit();
};

UClass* UInAppMessageBase::pClassPointer = NULL;

// Class Engine.InGameAdManager
// 0x0004 (0x0084 - 0x0080)
class UInGameAdManager : public UPlatformInterfaceBase {
   public:
    DWORD bShouldPauseWhileAdOpen : 1;  // 0x0080 (0x0004) [0x0000000000000000]
                                        // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2805];

        return pClassPointer;
    };

    void SetPauseWhileAdOpen();
    void ForceCloseAd();
    void HideBanner();
    void ShowBanner();
    void eventInit();
};

UClass* UInGameAdManager::pClassPointer = NULL;

// Class Engine.TwitterIntegrationBase
// 0x0000 (0x0080 - 0x0080)
class UTwitterIntegrationBase : public UPlatformInterfaceBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2807];

        return pClassPointer;
    };

    void eventTwitterRequest();
    void eventGetAccountId();
    void eventGetAccountName();
    void eventGetNumAccounts();
    void eventAuthorizeAccounts();
    void eventShowTweetUI();
    void eventCanShowTweetUI();
    void eventInit();
};

UClass* UTwitterIntegrationBase::pClassPointer = NULL;

// Class Engine.PlatformInterfaceWebResponse
// 0x0080 (0x00E0 - 0x0060)
class UPlatformInterfaceWebResponse : public UObject {
   public:
    struct FString OriginalURL;     // 0x0060 (0x0010) [0x0000000000000000]
    int ResponseCode;               // 0x0070 (0x0004) [0x0000000000000000]
    int Tag;                        // 0x0074 (0x0004) [0x0000000000000000]
    struct FMap_Mirror Headers;     // 0x0078 (0x0048) [0x0000000000000000]
    struct FString StringResponse;  // 0x00C0 (0x0010) [0x0000000000000000]
    TArray<unsigned char>
        BinaryResponse;  // 0x00D0 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2809];

        return pClassPointer;
    };

    void GetHeaderValue();
    void GetHeader();
    void GetNumHeaders();
};

UClass* UPlatformInterfaceWebResponse::pClassPointer = NULL;

// Class Engine.TWIndoorLightingVolume
// 0x0008 (0x0288 - 0x0280)
class ATWIndoorLightingVolume : public AVolume {
   public:
    struct FLightingChannelContainer
        IndoorLightingChannel;  // 0x0280 (0x0004) [0x0000000000000000]
    struct FLightingChannelContainer
        OutdoorLightingChannel;  // 0x0284 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2811];

        return pClassPointer;
    };

    void eventUnTouch();
    void eventTouch();
};

UClass* ATWIndoorLightingVolume::pClassPointer = NULL;

// Class Engine.TWOutdoorLightingVolume
// 0x0008 (0x0288 - 0x0280)
class ATWOutdoorLightingVolume : public AVolume {
   public:
    struct FLightingChannelContainer
        IndoorLightingChannel;  // 0x0280 (0x0004) [0x0000000000000000]
    struct FLightingChannelContainer
        OutdoorLightingChannel;  // 0x0284 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2813];

        return pClassPointer;
    };

    void eventUnTouch();
    void eventTouch();
};

UClass* ATWOutdoorLightingVolume::pClassPointer = NULL;

// Class Engine.TWDeferredWorkManager
// 0x0030 (0x0274 - 0x0244)
class ATWDeferredWorkManager : public AActor {
   public:
    TArray<struct FAnimNotifyData>
        AnimNotifyDataArray;  // 0x0244 (0x0010) [0x0000000000000000]
    TArray<struct FAnimNotifyTickData>
        AnimNotifyTickDataArray;  // 0x0254 (0x0010) [0x0000000000000000]
    TArray<struct FAnimNotifyEndData>
        AnimNotifyEndDataArray;  // 0x0264 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2815];

        return pClassPointer;
    };

    void DeferSpecialMoveAnimEnd();
    void DeferNotifyEnd();
    void DeferNotifyTick();
    void DeferNotify();
    void IsDuringAsyncWork();
};

UClass* ATWDeferredWorkManager::pClassPointer = NULL;

// Class Engine.TWSceneCapture2DDPGComponent
// 0x0004 (0x0174 - 0x0170)
class UTWSceneCapture2DDPGComponent : public USceneCapture2DComponent {
   public:
    DWORD bRenderForegroundDPG : 1;  // 0x0170 (0x0004) [0x0000000000000000]
                                     // [0x00000001]
    DWORD bRenderWorldDPG : 1;       // 0x0170 (0x0004) [0x0000000000000000]
                                     // [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2817];

        return pClassPointer;
    };
};

UClass* UTWSceneCapture2DDPGComponent::pClassPointer = NULL;

// Class Engine.TWMaterialExpressionLightBrightnessMultiplier
// 0x0000 (0x00DC - 0x00DC)
class UTWMaterialExpressionLightBrightnessMultiplier
    : public UMaterialExpressionScalarParameter {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[2819];

        return pClassPointer;
    };
};

UClass* UTWMaterialExpressionLightBrightnessMultiplier::pClassPointer = NULL;

// Class Engine.SeqEvent_MobileTouch
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_MobileTouch : public USequenceEvent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[6209];

        return pClassPointer;
    };
};

UClass* USeqEvent_MobileTouch::pClassPointer = NULL;

// Class Engine.SeqAct_AttachToActor
// 0x0024 (0x0174 - 0x0150)
class USeqAct_AttachToActor : public USequenceAction {
   public:
    DWORD bDetach : 1;      // 0x0150 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bHardAttach : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bUseRelativeOffset : 1;      // 0x0150 (0x0004) [0x0000000000000000]
                                       // [0x00000004]
    DWORD bUseRelativeRotation : 1;    // 0x0150 (0x0004) [0x0000000000000000]
                                       // [0x00000008]
    struct FName BoneName;             // 0x0154 (0x0008) [0x0000000000000000]
    struct FVector RelativeOffset;     // 0x015C (0x000C) [0x0000000000000000]
    struct FRotator RelativeRotation;  // 0x0168 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[6217];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_AttachToActor::pClassPointer = NULL;

// Class Engine.SeqAct_ToggleHidden
// 0x0014 (0x0164 - 0x0150)
class USeqAct_ToggleHidden : public USeqAct_Toggle {
   public:
    DWORD bToggleBasedActors : 1;  // 0x0150 (0x0004) [0x0000000000000000]
                                   // [0x00000001]
    TArray<class UClass*>
        IgnoreBasedClasses;  // 0x0154 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[6231];

        return pClassPointer;
    };
};

UClass* USeqAct_ToggleHidden::pClassPointer = NULL;

// Class Engine.SeqAct_SetVelocity
// 0x0014 (0x0164 - 0x0150)
class USeqAct_SetVelocity : public USequenceAction {
   public:
    struct FVector VelocityDir;  // 0x0150 (0x000C) [0x0000000000000000]
    float VelocityMag;           // 0x015C (0x0004) [0x0000000000000000]
    DWORD bVelocityRelativeToActorRotation : 1;  // 0x0160 (0x0004)
                                                 // [0x0000000000000000]
                                                 // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[6252];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_SetVelocity::pClassPointer = NULL;

// Class Engine.SeqAct_Teleport
// 0x0018 (0x0168 - 0x0150)
class USeqAct_Teleport : public USequenceAction {
   public:
    DWORD bUpdateRotation : 1;  // 0x0150 (0x0004) [0x0000000000000000]
                                // [0x00000001]
    DWORD
        bCheckOverlap : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000002]
    float TeleportDistance;  // 0x0154 (0x0004) [0x0000000000000000]
    TArray<class AVolume*>
        TeleportVolumes;  // 0x0158 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[6258];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
    void ShouldTeleport();
};

UClass* USeqAct_Teleport::pClassPointer = NULL;

// Class Engine.SeqAct_Destroy
// 0x0014 (0x0164 - 0x0150)
class USeqAct_Destroy : public USequenceAction {
   public:
    DWORD bDestroyBasedActors : 1;  // 0x0150 (0x0004) [0x0000000000000000]
                                    // [0x00000001]
    TArray<class UClass*>
        IgnoreBasedClasses;  // 0x0154 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[6274];

        return pClassPointer;
    };
};

UClass* USeqAct_Destroy::pClassPointer = NULL;

// Class Engine.LocalMessage
// 0x0014 (0x0074 - 0x0060)
class ULocalMessage : public UObject {
   public:
    DWORD bIsSpecial : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bIsUnique : 1;   // 0x0060 (0x0004) [0x0000000000000000] [0x00000002]
    DWORD bIsPartiallyUnique : 1;  // 0x0060 (0x0004) [0x0000000000000000]
                                   // [0x00000004]
    DWORD bIsConsoleMessage : 1;   // 0x0060 (0x0004) [0x0000000000000000]
                                   // [0x00000008]
    DWORD bBeep : 1;  // 0x0060 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bCountInstances : 1;  // 0x0060 (0x0004) [0x0000000000000000]
                                // [0x00000020]
    float Lifetime;             // 0x0064 (0x0004) [0x0000000000000000]
    struct FColor DrawColor;    // 0x0068 (0x0004) [0x0000000000000000]
    float PosY;                 // 0x006C (0x0004) [0x0000000000000000]
    int FontSize;               // 0x0070 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[6343];

        return pClassPointer;
    };

    void PartiallyDuplicates();
    void IsConsoleMessage();
    void GetLifeTime();
    void GetFontSize();
    void GetPos();
    void GetColor();
    void GetConsoleColor();
    void GetString();
    void ClientReceive();
};

UClass* ULocalMessage::pClassPointer = NULL;

// Class Engine.SeqEvent_HitWall
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_HitWall : public USequenceEvent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[6354];

        return pClassPointer;
    };
};

UClass* USeqEvent_HitWall::pClassPointer = NULL;

// Class Engine.OnlinePlayerInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlinePlayerInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[7153];

        return pClassPointer;
    };

    void GetAchievements();
    void ClearReadAchievementsCompleteDelegate();
    void AddReadAchievementsCompleteDelegate();
    void OnReadAchievementsComplete();
    void ReadAchievements();
    void ClearUnlockAchievementCompleteDelegate();
    void AddUnlockAchievementCompleteDelegate();
    void OnUnlockAchievementComplete();
    void UnlockAchievement();
    void DeleteMessage();
    void ClearFriendMessageReceivedDelegate();
    void AddFriendMessageReceivedDelegate();
    void OnFriendMessageReceived();
    void GetFriendMessages();
    void ClearJoinFriendGameCompleteDelegate();
    void AddJoinFriendGameCompleteDelegate();
    void OnJoinFriendGameComplete();
    void JoinFriendGame();
    void CheckForGameInviteOnLaunch();
    void ClearReceivedGameInviteByIdDelegate();
    void ClearReceivedGameInviteDelegate();
    void AddReceivedGameInviteByIdDelegate();
    void AddReceivedGameInviteDelegate();
    void OnReceivedGameInviteById();
    void OnReceivedGameInvite();
    void SendGameInviteToUsers();
    void SendGameInviteToFriends();
    void SendGameInviteToFriend();
    void SendMessageToFriend();
    void ClearFriendInviteReceivedDelegate();
    void AddFriendInviteReceivedDelegate();
    void OnFriendInviteReceived();
    void RemoveFriend();
    void DenyFriendInvite();
    void AcceptFriendInvite();
    void ClearAddFriendByNameCompleteDelegate();
    void AddAddFriendByNameCompleteDelegate();
    void OnAddFriendByNameComplete();
    void AddFriendByName();
    void AddFriend();
    void GetKeyboardInputResults();
    void ClearKeyboardInputDoneDelegate();
    void AddKeyboardInputDoneDelegate();
    void OnKeyboardInputComplete();
    void HideKeyboardUI();
    void ShowKeyboardUI();
    void SetOnlineStatus();
    void GetFriendsList();
    void ClearReadFriendsCompleteDelegate();
    void AddReadFriendsCompleteDelegate();
    void OnReadFriendsComplete();
    void ReadFriendsList();
    void ClearWritePlayerStorageCompleteDelegate();
    void AddWritePlayerStorageCompleteDelegate();
    void OnWritePlayerStorageComplete();
    void WritePlayerStorage();
    void GetPlayerStorage();
    void ClearReadPlayerStorageForNetIdCompleteDelegate();
    void AddReadPlayerStorageForNetIdCompleteDelegate();
    void OnReadPlayerStorageForNetIdComplete();
    void ReadPlayerStorageForNetId();
    void ClearReadPlayerStorageCompleteDelegate();
    void AddReadPlayerStorageCompleteDelegate();
    void OnReadPlayerStorageComplete();
    void ReadPlayerStorage();
    void ClearWriteProfileSettingsCompleteDelegate();
    void AddWriteProfileSettingsCompleteDelegate();
    void OnWriteProfileSettingsComplete();
    void WriteProfileSettings();
    void GetProfileSettings();
    void ClearReadProfileSettingsCompleteDelegate();
    void AddReadProfileSettingsCompleteDelegate();
    void OnReadProfileSettingsComplete();
    void ReadProfileSettings();
    void ClearFriendsChangeDelegate();
    void AddFriendsChangeDelegate();
    void ClearMutingChangeDelegate();
    void AddMutingChangeDelegate();
    void ClearCurrentUserChangedDelegate();
    void AddCurrentUserChangedDelegate();
    void ClearLoginCancelledDelegate();
    void AddLoginCancelledDelegate();
    void ClearLoginStatusChangeDelegate();
    void AddLoginStatusChangeDelegate();
    void OnLoginStatusChange();
    void ClearLoginChangeDelegate();
    void AddLoginChangeDelegate();
    void ShowFriendsUI();
    void IsMuted();
    void AreAnyFriends();
    void IsFriend();
    void CanUploadFitnessData();
    void CanShareKinectContent();
    void CanShareWithSocialNetwork();
    void CanBrowseInternet();
    void CanAccessPremiumVideoContent();
    void CanAccessPremiumContent();
    void CanUseCloudStorage();
    void CanRecordDVRClips();
    void CanShowPresenceInformation();
    void CanViewPlayerProfiles();
    void CanPurchaseContent();
    void CanShareUserCreatedContent();
    void CanCommunicateVoice();
    void CanCommunicateVideo();
    void CanCommunicateText();
    void CanPlayOnline();
    void ClearPrivilegeLevelCheckedDelegate();
    void AddPrivilegeLevelCheckedDelegate();
    void OnPrivilegeLevelChecked();
    void IsLocalLogin();
    void IsGuestLogin();
    void GetPlayerNickname();
    void GetControllerIdFromNetId();
    void GetUniquePlayerId();
    void GetLoginStatus();
    void PairUserAndControllerAtIndex();
    void ClearSystemUserContrllerPairingChangedDelegate();
    void AddSystemUserContrllerPairingChangedDelegate();
    void OnSystemUserControllerPairingChanged();
    void ClearLogoutCompletedDelegate();
    void AddLogoutCompletedDelegate();
    void OnLogoutCompleted();
    void Logout();
    void ClearLoginFailedDelegate();
    void AddLoginFailedDelegate();
    void OnLoginFailed();
    void AutoLogin();
    void ClearLoginCompleteDelegate();
    void AddLoginCompleteDelegate();
    void OnLoginComplete();
    void Login();
    void ShowLoginUI();
    void OnFriendsChange();
    void OnMutingChange();
    void ClearURLTokenRetrievedDelegate();
    void AddURLTokenRetrievedDelegate();
    void GetTokenAndSignatureForURL();
    void OnTokenAndSignatureRetrieved();
    void OnCurrentUserChanged();
    void OnLoginCancelled();
    void OnLoginChange();
};

UClass* UOnlinePlayerInterface::pClassPointer = NULL;

// Class Engine.OnlineCommunityContentInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineCommunityContentInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[7190];

        return pClassPointer;
    };

    void RateContent();
    void ClearGetContentPayloadCompleteDelegate();
    void AddGetContentPayloadCompleteDelegate();
    void OnGetContentPayloadComplete();
    void GetContentPayload();
    void ClearDownloadContentCompleteDelegate();
    void AddDownloadContentCompleteDelegate();
    void OnDownloadContentComplete();
    void DownloadContent();
    void ClearUploadContentCompleteDelegate();
    void AddUploadContentCompleteDelegate();
    void OnUploadContentComplete();
    void UploadContent();
    void GetFriendsContentList();
    void ClearReadFriendsContentListCompleteDelegate();
    void AddReadFriendsContentListCompleteDelegate();
    void OnReadFriendsContentListComplete();
    void ReadFriendsContentList();
    void GetContentList();
    void ClearReadContentListCompleteDelegate();
    void AddReadContentListCompleteDelegate();
    void OnReadContentListComplete();
    void ReadContentList();
    void Exit();
    void Init();
};

UClass* UOnlineCommunityContentInterface::pClassPointer = NULL;

// Class Engine.OnlineGameDVRInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineGameDVRInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[7195];

        return pClassPointer;
    };

    void CancelRecordingEvent();
    void RecordPreviousTimespan();
    void EndRecordingEvent();
    void ClearRecordEventCompleteDelegate();
    void AddRecordEventCompleteDelegate();
    void OnRecordEventComplete();
    void BeginRecordingEvent();
    void ClearReadRecordedClipsCompleteDelegate();
    void AddReadRecordedClipsCompleteDelegate();
    void ClearCachedRecordedClips();
    void OnReadRecordedClipsComplete();
    void ReadRecordedClips();
    void DisableRecording();
    void EnableRecording();
};

UClass* UOnlineGameDVRInterface::pClassPointer = NULL;

// Class Engine.SharedCloudFileInterface
// 0x0000 (0x0060 - 0x0060)
class USharedCloudFileInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[7200];

        return pClassPointer;
    };

    void ClearWriteSharedFileCompleteDelegate();
    void AddWriteSharedFileCompleteDelegate();
    void WriteSharedFile();
    void OnWriteSharedFileComplete();
    void ClearReadSharedFileCompleteDelegate();
    void AddReadSharedFileCompleteDelegate();
    void ReadSharedFile();
    void OnReadSharedFileComplete();
    void ClearSharedFile();
    void ClearSharedFiles();
    void GetSharedFileContents();
};

UClass* USharedCloudFileInterface::pClassPointer = NULL;

// Class Engine.UserCloudFileInterface
// 0x0000 (0x0060 - 0x0060)
class UUserCloudFileInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[7205];

        return pClassPointer;
    };

    void ClearAllDelegates();
    void ClearDeleteUserFileCompleteDelegate();
    void AddDeleteUserFileCompleteDelegate();
    void DeleteUserFile();
    void OnDeleteUserFileComplete();
    void ClearWriteUserFileCompleteDelegate();
    void AddWriteUserFileCompleteDelegate();
    void WriteUserFile();
    void OnWriteUserFileComplete();
    void ClearReadUserFileCompleteDelegate();
    void AddReadUserFileCompleteDelegate();
    void ReadUserFile();
    void OnReadUserFileComplete();
    void GetUserFileList();
    void ClearEnumerateUserFileCompleteDelegate();
    void AddEnumerateUserFileCompleteDelegate();
    void EnumerateUserFiles();
    void OnEnumerateUserFilesComplete();
    void ClearFile();
    void ClearFiles();
    void GetFileContents();
};

UClass* UUserCloudFileInterface::pClassPointer = NULL;

// Class Engine.OnlineSocialInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineSocialInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[7214];

        return pClassPointer;
    };

    void ClearPostLinkCompleted();
    void AddPostLinkCompleted();
    void OnPostLinkCompleted();
    void PostLink();
    void ClearPostImageCompleted();
    void AddPostImageCompleted();
    void OnPostImageCompleted();
    void PostImage();
    void ClearQuerySocialPostPrivilegesCompleted();
    void AddQuerySocialPostPrivilegesCompleted();
    void OnQuerySocialPostPrivilegesCompleted();
    void QuerySocialPostPrivileges();
};

UClass* UOnlineSocialInterface::pClassPointer = NULL;

// Class Engine.OnlineTitleFileCacheInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineTitleFileCacheInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[7219];

        return pClassPointer;
    };

    void DeleteTitleFile();
    void DeleteTitleFiles();
    void ClearCachedFile();
    void ClearCachedFiles();
    void GetTitleFileLogicalName();
    void GetTitleFileHash();
    void GetTitleFileState();
    void GetTitleFileContents();
    void ClearSaveTitleFileCompleteDelegate();
    void AddSaveTitleFileCompleteDelegate();
    void OnSaveTitleFileComplete();
    void SaveTitleFile();
    void ClearLoadTitleFileCompleteDelegate();
    void AddLoadTitleFileCompleteDelegate();
    void OnLoadTitleFileComplete();
    void LoadTitleFile();
};

UClass* UOnlineTitleFileCacheInterface::pClassPointer = NULL;

// Class Engine.OnlineTitleFileInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineTitleFileInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[7224];

        return pClassPointer;
    };

    void ClearRequestTitleFileListCompleteDelegate();
    void AddRequestTitleFileListCompleteDelegate();
    void OnRequestTitleFileListComplete();
    void RequestTitleFileList();
    void ClearDownloadedFile();
    void ClearDownloadedFiles();
    void GetTitleFileState();
    void GetTitleFileContents();
    void ClearReadTitleFileCompleteDelegate();
    void AddReadTitleFileCompleteDelegate();
    void ReadTitleFile();
    void OnReadTitleFileComplete();
};

UClass* UOnlineTitleFileInterface::pClassPointer = NULL;

// Class Engine.OnlinePartyInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlinePartyInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[7229];

        return pClassPointer;
    };

    void ClearNotifyLeaderChangedDelegate();
    void AddNotifyLeaderChangedDelegate();
    void OnNotifyLeaderChanged();
    void ClearNotifyPartyMembersUpdatedDelegate();
    void AddNotifyPartyMembersUpdatedDelegate();
    void OnNotifyPartyMembersUpdated();
    void ClearNotifyMessageReceivedDelegate();
    void AddNotifyMessageReceivedDelegate();
    void OnNotifyMessageReceived();
    void SendMessage();
    void LeaveParty();
    void CreateParty();
    void InviteToPartyByUserNames();
    void GetMyMemberId();
    void GetLeaderMemberId();
    void GetPartyMembers();
};

UClass* UOnlinePartyInterface::pClassPointer = NULL;

// Class Engine.OnlinePartyChatInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlinePartyChatInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[7234];

        return pClassPointer;
    };

    void IsInPartyChat();
    void ShowCommunitySessionsUI();
    void ShowVoiceChannelUI();
    void ShowPartyUI();
    void GetPartyBandwidth();
    void SetPartyMemberCustomData();
    void ClearPartyMembersInfoChangedDelegate();
    void AddPartyMembersInfoChangedDelegate();
    void OnPartyMembersInfoChanged();
    void ClearReservedPartyMemberListChangedDelegate();
    void AddReservedPartyMemberListChangedDelegate();
    void OnReservedPartyMemberListChanged();
    void ClearPartyMemberListChangedDelegate();
    void AddPartyMemberListChangedDelegate();
    void OnPartyMemberListChanged();
    void GetPartyMemberInformation();
    void GetPartyMembersInformation();
    void ClearSendPartyGameInvitesCompleteDelegate();
    void AddSendPartyGameInvitesCompleteDelegate();
    void OnSendPartyGameInvitesComplete();
    void SendPartyGameInvites();
};

UClass* UOnlinePartyChatInterface::pClassPointer = NULL;

// Class Engine.OnlineNewsInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineNewsInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[7239];

        return pClassPointer;
    };

    void GetNews();
    void ClearReadNewsCompletedDelegate();
    void AddReadNewsCompletedDelegate();
    void OnReadNewsCompleted();
    void ReadNews();
};

UClass* UOnlineNewsInterface::pClassPointer = NULL;

// Class Engine.OnlineStatsInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineStatsInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[7244];

        return pClassPointer;
    };

    void SendTestEvent();
    void SendPlayerSessionResume();
    void SendPlayerSessionPause();
    void SendPlayerSessionEnd();
    void SendPlayerSessionStart();
    void UnsubscribeToStatisticEvent();
    void SubscribeToStatisticEvent();
    void OnStatisticChanged();
    void CalcAggregateSkill();
    void RegisterStatGuid();
    void GetClientStatGuid();
    void ClearRegisterHostStatGuidCompleteDelegateDelegate();
    void AddRegisterHostStatGuidCompleteDelegate();
    void OnRegisterHostStatGuidComplete();
    void RegisterHostStatGuid();
    void GetHostStatGuid();
    void WriteOnlinePlayerScores();
    void ClearFlushOnlineStatsCompleteDelegate();
    void AddFlushOnlineStatsCompleteDelegate();
    void OnFlushOnlineStatsComplete();
    void FlushOnlineStats();
    void WriteOnlineStats();
    void FreeStats();
    void ClearReadOnlineStatsCompleteDelegate();
    void AddReadOnlineStatsCompleteDelegate();
    void OnReadOnlineStatsComplete();
    void ReadOnlineStatsByRankAroundPlayer();
    void ReadOnlineStatsByRank();
    void ReadOnlineStatsForFriends();
    void ReadOnlineStats();
    void ReadOnlineStatsForPlayer();
};

UClass* UOnlineStatsInterface::pClassPointer = NULL;

// Class Engine.OnlineVoiceInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineVoiceInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[7249];

        return pClassPointer;
    };

    void UnmuteAll();
    void MuteAll();
    void SetSpeechRecognitionObject();
    void SelectVocabulary();
    void ClearRecognitionCompleteDelegate();
    void AddRecognitionCompleteDelegate();
    void OnRecognitionComplete();
    void GetRecognitionResults();
    void StopSpeechRecognition();
    void StartSpeechRecognition();
    void StopNetworkedVoice();
    void StartNetworkedVoice();
    void ClearPlayerTalkingDelegate();
    void AddPlayerTalkingDelegate();
    void OnPlayerTalkingStateChange();
    void IsTalkerMuted();
    void UnmuteRemoteTalker();
    void MuteRemoteTalker();
    void UpdatePlayerMuteSetting();
    void SetRemoteTalkerPriority();
    void IsHeadsetPresent();
    void IsRemotePlayerTalking();
    void IsLocalPlayerTalking();
    void UnregisterRemoteTalker();
    void RegisterRemoteTalker();
    void ReceiveReliableVoicePacket();
    void AreAnyLocalTalkersRegistered();
    void UnregisterLocalTalker();
    void RegisterLocalTalker();
};

UClass* UOnlineVoiceInterface::pClassPointer = NULL;

// Class Engine.OnlineContentInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineContentInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[7254];

        return pClassPointer;
    };

    void GetDownloadableContentList();
    void ClearDownloadableContentList();
    void ReadDownloadableContentList();
    void ClearSaveGames();
    void DeleteSaveGame();
    void ClearWriteSaveGameDataComplete();
    void AddWriteSaveGameDataComplete();
    void OnWriteSaveGameDataComplete();
    void WriteSaveGameData();
    void ClearReadSaveGameDataComplete();
    void AddReadSaveGameDataComplete();
    void OnReadSaveGameDataComplete();
    void GetSaveGameData();
    void ReadSaveGameData();
    void GetAvailableDownloadCounts();
    void ClearQueryAvailableDownloadsComplete();
    void AddQueryAvailableDownloadsComplete();
    void OnQueryAvailableDownloadsComplete();
    void QueryAvailableDownloads();
    void ClearCrossTitleSaveGames();
    void ClearReadCrossTitleSaveGameDataComplete();
    void AddReadCrossTitleSaveGameDataComplete();
    void OnReadCrossTitleSaveGameDataComplete();
    void GetCrossTitleSaveGameData();
    void ReadCrossTitleSaveGameData();
    void ClearReadCrossTitleContentCompleteDelegate();
    void AddReadCrossTitleContentCompleteDelegate();
    void OnReadCrossTitleContentComplete();
    void GetCrossTitleContentList();
    void ClearCrossTitleContentList();
    void ReadCrossTitleContentList();
    void GetContentList();
    void ClearContentList();
    void ReadContentList();
    void ClearReadContentComplete();
    void AddReadContentComplete();
    void OnReadContentComplete();
    void ClearContentChangeDelegate();
    void AddContentChangeDelegate();
    void OnContentChange();
};

UClass* UOnlineContentInterface::pClassPointer = NULL;

// Class Engine.OnlineSystemInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineSystemInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[7263];

        return pClassPointer;
    };

    void GetLocale();
    void ClearStorageDeviceChangeDelegate();
    void AddStorageDeviceChangeDelegate();
    void OnStorageDeviceChange();
    void GetNATType();
    void ClearConnectionStatusChangeDelegate();
    void AddConnectionStatusChangeDelegate();
    void OnConnectionStatusChange();
    void GetCurrentConnectionStatus();
    void IsControllerConnected();
    void ClearControllerChangeDelegate();
    void AddControllerChangeDelegate();
    void OnControllerChange();
    void SetNetworkNotificationPosition();
    void GetNetworkNotificationPosition();
    void ClearExternalUIChangeDelegate();
    void AddExternalUIChangeDelegate();
    void OnExternalUIChange();
    void ClearLinkStatusChangeDelegate();
    void AddLinkStatusChangeDelegate();
    void OnLinkStatusChange();
    void HasLinkConnection();
};

UClass* UOnlineSystemInterface::pClassPointer = NULL;

// Class Engine.OnlineMarketplaceInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineMarketplaceInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[7268];

        return pClassPointer;
    };

    void ClearMarketplaceItemPurchasedDelegate();
    void AddMarketplaceItemPurchasedDelegate();
    void OnMarketplaceItemPurchased();
    void ClearConsumeInventoryItemCompleteDelegate();
    void AddConsumeInventoryItemCompleteDelegate();
    void OnConsumeInventoryItemComplete();
    void ConsumeInventoryItem();
    void ResetInventoryItems();
    void GetInventoryItems();
    void ClearReadInventoryItemsCompleteDelegate();
    void AddReadInventoryItemsCompleteDelegate();
    void OnReadInventoryItemsComplete();
    void ReadInventoryItems();
    void ClearReadAdditionalProductDetailsCompleteDelegate();
    void AddReadAdditionalProductDetailsCompleteDelegate();
    void OnReadAdditionalProductDetailsComplete();
    void ReadAdditionalDetailsForProducts();
    void ResetAvailableProducts();
    void GetAvailableProducts();
    void ClearReadAvailableProductsCompleteDelegate();
    void AddReadAvailableProductsCompleteDelegate();
    void OnReadAvailableProductsComplete();
    void ReadAvailableProducts();
};

UClass* UOnlineMarketplaceInterface::pClassPointer = NULL;

// Class Engine.OnlinePlayerInterfaceEx
// 0x0000 (0x0060 - 0x0060)
class UOnlinePlayerInterfaceEx : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[7273];

        return pClassPointer;
    };

    void ClearPlayerTalkingDelegate();
    void AddPlayerTalkingDelegate();
    void OnRemoteTalkerStatusChange();
    void ClearUnregisterRemoteTalkerCompleteDelegate();
    void AddUnregisterRemoteTalkerCompleteDelegate();
    void OnUnregisterRemoteTalkerComplete();
    void ClearUnregisterLocalTalkerCompleteDelegate();
    void AddUnregisterLocalTalkerCompleteDelegate();
    void OnUnregisterLocalTalkerComplete();
    void ClearRegisterLocalTalkerCompleteDelegate();
    void AddRegisterLocalTalkerCompleteDelegate();
    void OnRegisterLocalTalkerComplete();
    void ClearReadOnlineProfilesCompleteDelegate();
    void AddReadOnlineProfilesCompleteDelegate();
    void OnReadOnlineProfilesComplete();
    void ReadOnlineProfilesForPlayers();
    void GetPlayerIDForPlayerNickname();
    void GetPlayerNicknameForPlayerId();
    void ShowCustomErrorUI();
    void ShowSystemErrorUI();
    void UpsellPremiumOnlineService();
    void ClearOnEntitlementsReadDelegate();
    void AddOnEntitlementsReadDelegate();
    void OnEntitlementsRead();
    void ReadEntitlements();
    void ClearStoreDataReadCompleteDelegate();
    void AddStoreDataReadCompleteDelegate();
    void OnStoreDataRead();
    void ReadStoreData();
    void PostActivityFeedPerkLevelUp();
    void PostActivityFeedTeamAward();
    void PostActivityFeedBossKill();
    void ShowCustomMessageUI();
    void ClearCrossTitleProfileSettings();
    void GetCrossTitleProfileSettings();
    void ClearReadCrossTitleProfileSettingsCompleteDelegate();
    void AddReadCrossTitleProfileSettingsCompleteDelegate();
    void OnReadCrossTitleProfileSettingsComplete();
    void ReadCrossTitleProfileSettings();
    void UnlockAvatarAward();
    void AddInGamePost();
    void RecordPlayersRecentlyMet();
    void ShowCustomPlayersUI();
    void ShowPlayersUI();
    void ShowFriendsInviteUI();
    void ClearProfileDataChangedDelegate();
    void AddProfileDataChangedDelegate();
    void OnProfileDataChanged();
    void UnlockGamerPicture();
    void IsDeviceValid();
    void GetDeviceSelectionResults();
    void ClearDeviceSelectionDoneDelegate();
    void AddDeviceSelectionDoneDelegate();
    void OnDeviceSelectionComplete();
    void ShowDeviceSelectionUI();
    void ShowMembershipMarketplaceUI();
    void CloseCurrentContentUI();
    void ShowContentRedeemCodeUI();
    void ShowContentPurchaseUI();
    void ShowContentMarketplaceUI();
    void ShowProductDetailsUI();
    void ClearAcceptReceivedDataDelegate();
    void AddAcceptReceivedDataDelegate();
    void OnAcceptReceivedData();
    void ShowDataSendingUI();
    void ClearPeoplePickerCompleteDelegate();
    void AddPeoplePickerCompleteDelegate();
    void OnPeoplePickerComplete();
    void ShowPeoplePickerUI();
    void ShowInviteUI();
    void ShowAchievementsUI();
    void ShowMessagesUI();
    void ShowGamerCardUIByUsername();
    void ShowGamerCardUI();
    void ClearShowGamerCardCompleteDelegate();
    void AddShowGamerCardCompleteDelegate();
    void OnShowGamerCardComplete();
    void ShowVideo();
    void ClearShowHelpCompleteDelegate();
    void AddShowHelpCompleteDelegate();
    void OnShowHelpComplete();
    void ShowHelpForErrorUI();
    void ShowHelpUI();
    void ShowFeedbackUI();
};

UClass* UOnlinePlayerInterfaceEx::pClassPointer = NULL;

// Class Engine.OnlineAccountInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineAccountInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[7281];

        return pClassPointer;
    };

    void GetLocalAccountNames();
    void DeleteLocalAccount();
    void RenameLocalAccount();
    void CreateLocalAccount();
    void ClearCreateOnlineAccountCompletedDelegate();
    void AddCreateOnlineAccountCompletedDelegate();
    void OnCreateOnlineAccountCompleted();
    void CreateOnlineAccount();
};

UClass* UOnlineAccountInterface::pClassPointer = NULL;

// Class Engine.AccessControl
// 0x0164 (0x03A8 - 0x0244)
class AAccessControl : public AInfo {
   public:
    TArray<struct FString> IPPolicies;  // 0x0244 (0x0010) [0x0000000000000000]
    TArray<struct FUniqueNetId>
        BannedIDs;                       // 0x0254 (0x0010) [0x0000000000000000]
    struct FString IPBanned;             // 0x0264 (0x0010) [0x0000000000000000]
    struct FString WrongPassword;        // 0x0274 (0x0010) [0x0000000000000000]
    struct FString NeedPassword;         // 0x0284 (0x0010) [0x0000000000000000]
    struct FString SessionBanned;        // 0x0294 (0x0010) [0x0000000000000000]
    struct FString KickedMsg;            // 0x02A4 (0x0010) [0x0000000000000000]
    struct FString DefaultKickReason;    // 0x02B4 (0x0010) [0x0000000000000000]
    struct FString IdleKickReason;       // 0x02C4 (0x0010) [0x0000000000000000]
    class UClass* AdminClass;            // 0x02D4 (0x0008) [0x0000000000000000]
    struct FString AdminPassword;        // 0x02DC (0x0010) [0x0000000000000000]
    struct FString GamePassword;         // 0x02EC (0x0010) [0x0000000000000000]
    struct FString ACDisplayText[0x3];   // 0x02FC (0x0030) [0x0000000000000000]
    struct FString ACDescText[0x3];      // 0x032C (0x0030) [0x0000000000000000]
    DWORD bDontAddDefaultAdmin : 1;      // 0x035C (0x0004) [0x0000000000000000]
                                         // [0x00000001]
    DWORD bAuthenticateClients : 1;      // 0x035C (0x0004) [0x0000000000000000]
                                         // [0x00000002]
    DWORD bAuthenticateServer : 1;       // 0x035C (0x0004) [0x0000000000000000]
                                         // [0x00000004]
    DWORD bAuthenticateListenHost : 1;   // 0x035C (0x0004) [0x0000000000000000]
                                         // [0x00000008]
    DWORD bAuthDelegatesRegistered : 1;  // 0x035C (0x0004) [0x0000000000000000]
                                         // [0x00000010]
    DWORD bPendingListenAuth : 1;        // 0x035C (0x0004) [0x0000000000000000]
                                         // [0x00000020]
    int MaxAuthRetryCount;               // 0x0360 (0x0004) [0x0000000000000000]
    int AuthRetryDelay;                  // 0x0364 (0x0004) [0x0000000000000000]
    class UOnlineSubsystem* OnlineSub;   // 0x0368 (0x0008) [0x0000000000000000]
    class UOnlineAuthInterface*
        CachedAuthInt;                 // 0x0370 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x8];  // 0x0378 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    TArray<struct FPendingClientAuth>
        ClientsPendingAuth;  // 0x0380 (0x0010) [0x0000000000000000]
    TArray<struct FServerAuthRetry>
        ServerAuthRetries;     // 0x0390 (0x0010) [0x0000000000000000]
    int ListenAuthTicketUID;   // 0x03A0 (0x0004) [0x0000000000000000]
    int ListenAuthRetryCount;  // 0x03A4 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[7702];

        return pClassPointer;
    };

    void IsPendingAuth();
    void Cleanup();
    void NotifyExit();
    void NotifyGameEnding();
    void NotifyServerTravel();
    void OnDestroyOnlineGameComplete();
    void StaticOnClientConnectionClose();
    void OnClientConnectionClose();
    void ListenHostAuthTimeout();
    void EndListenHostAuth();
    void ContinueListenHostAuth();
    void BeginListenHostAuth();
    void ProcessServerAuthRetryRequest();
    void ProcessServerAuthRequest();
    void OnClientAuthComplete();
    void ProcessClientAuthResponse();
    void OnAuthReady();
    void PendingAuthTimer();
    void PostLogin();
    void eventPreLogin();
    void ClearAuthDelegates();
    void RegisterAuthDelegates();
    void InitAuthHooks();
    void IsIDBanned();
    void CheckIPPolicy();
    void ValidLogin();
    void ParseAdminOptions();
    void AdminExited();
    void AdminEntered();
    void AdminLogout();
    void AdminLogin();
    void KickPlayer();
    void ForceKickPlayer();
    void KickBan();
    void Kick();
    void GetControllerFromString();
    void RequiresPassword();
    void SetGamePassword();
    void SetAdminPassword();
    void IsAdmin();
    void Destroyed();
    void PostBeginPlay();
};

UClass* AAccessControl::pClassPointer = NULL;

// Class Engine.Admin
// 0x0000 (0x0770 - 0x0770)
class AAdmin : public APlayerController {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[8015];

        return pClassPointer;
    };

    void ServerSwitch();
    void Switch();
    void ServerRestartMap();
    void RestartMap();
    void PlayerList();
    void ServerKick();
    void Kick();
    void ServerKickBan();
    void KickBan();
    void ServerAdmin();
    void Admin();
    void eventPostBeginPlay();
};

UClass* AAdmin::pClassPointer = NULL;

// Class Engine.ApexDestructibleActorSpawnable
// 0x0000 (0x029C - 0x029C)
class AApexDestructibleActorSpawnable : public AApexDestructibleActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[8058];

        return pClassPointer;
    };
};

UClass* AApexDestructibleActorSpawnable::pClassPointer = NULL;

// Class Engine.EmitterSpawnable
// 0x0008 (0x0260 - 0x0258)
class AEmitterSpawnable : public AEmitter {
   public:
    class UParticleSystem*
        ParticleTemplate;  // 0x0258 (0x0008) [0x0000000000160000] (
                           // CPF_EditConst | CPF_GlobalConfig )

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[8070];

        return pClassPointer;
    };

    void eventReplicatedEvent();
    void eventSetTemplate();
};

UClass* AEmitterSpawnable::pClassPointer = NULL;

// Class Engine.KAssetSpawnable
// 0x0000 (0x0260 - 0x0260)
class AKAssetSpawnable : public AKAsset {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[8096];

        return pClassPointer;
    };
};

UClass* AKAssetSpawnable::pClassPointer = NULL;

// Class Engine.ActorFactorySkeletalMeshCinematic
// 0x0000 (0x00B4 - 0x00B4)
class UActorFactorySkeletalMeshCinematic : public UActorFactorySkeletalMesh {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[8107];

        return pClassPointer;
    };
};

UClass* UActorFactorySkeletalMeshCinematic::pClassPointer = NULL;

// Class Engine.ActorFactorySkeletalMeshMAT
// 0x0000 (0x00B4 - 0x00B4)
class UActorFactorySkeletalMeshMAT : public UActorFactorySkeletalMesh {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[8109];

        return pClassPointer;
    };
};

UClass* UActorFactorySkeletalMeshMAT::pClassPointer = NULL;

// Class Engine.SeqAct_ToggleGodMode
// 0x0000 (0x0150 - 0x0150)
class USeqAct_ToggleGodMode : public USequenceAction {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[8610];

        return pClassPointer;
    };
};

UClass* USeqAct_ToggleGodMode::pClassPointer = NULL;

// Class Engine.SeqEvent_Death
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_Death : public USequenceEvent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[8611];

        return pClassPointer;
    };
};

UClass* USeqEvent_Death::pClassPointer = NULL;

// Class Engine.SeqAct_ControlMovieTexture
// 0x0008 (0x0158 - 0x0150)
class USeqAct_ControlMovieTexture : public USequenceAction {
   public:
    class UTextureMovie* MovieTexture;  // 0x0150 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[9246];

        return pClassPointer;
    };

    void eventActivated();
};

UClass* USeqAct_ControlMovieTexture::pClassPointer = NULL;

// Class Engine.SeqAct_SetSoundMode
// 0x000C (0x015C - 0x0150)
class USeqAct_SetSoundMode : public USequenceAction {
   public:
    class USoundMode* SoundMode;  // 0x0150 (0x0008) [0x0000000000000000]
    DWORD
        bTopPriority : 1;  // 0x0158 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[12202];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
    void eventActivated();
};

UClass* USeqAct_SetSoundMode::pClassPointer = NULL;

// Class Engine.SeqAct_FlyThroughHasEnded
// 0x0000 (0x0150 - 0x0150)
class USeqAct_FlyThroughHasEnded : public USequenceAction {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[12220];

        return pClassPointer;
    };
};

UClass* USeqAct_FlyThroughHasEnded::pClassPointer = NULL;

// Class Engine.SeqAct_ConsoleCommand
// 0x0020 (0x0170 - 0x0150)
class USeqAct_ConsoleCommand : public USequenceAction {
   public:
    struct FString Command;           // 0x0150 (0x0010) [0x0000000000000000]
    TArray<struct FString> Commands;  // 0x0160 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[12304];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
    void VersionUpdated();
};

UClass* USeqAct_ConsoleCommand::pClassPointer = NULL;

// Class Engine.SeqAct_ToggleCinematicMode
// 0x0004 (0x0154 - 0x0150)
class USeqAct_ToggleCinematicMode : public USequenceAction {
   public:
    DWORD bDisableMovement : 1;  // 0x0150 (0x0004) [0x0000000000000000]
                                 // [0x00000001]
    DWORD bDisableTurning : 1;   // 0x0150 (0x0004) [0x0000000000000000]
                                 // [0x00000002]
    DWORD bHidePlayer : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000004]
    DWORD
        bDisableInput : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000008]
    DWORD bHideHUD : 1;     // 0x0150 (0x0004) [0x0000000000000000] [0x00000010]
    DWORD bDeadBodies : 1;  // 0x0150 (0x0004) [0x0000000000000000] [0x00000020]
    DWORD bDroppedPickups : 1;  // 0x0150 (0x0004) [0x0000000000000000]
                                // [0x00000040]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[12311];

        return pClassPointer;
    };

    void eventActivated();
};

UClass* USeqAct_ToggleCinematicMode::pClassPointer = NULL;

// Class Engine.SeqAct_ForceFeedback
// 0x0010 (0x0160 - 0x0150)
class USeqAct_ForceFeedback : public USequenceAction {
   public:
    class UForceFeedbackWaveform*
        FFWaveform;                    // 0x0150 (0x0008) [0x0000000000000000]
    class UClass* PredefinedWaveForm;  // 0x0158 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[12323];

        return pClassPointer;
    };
};

UClass* USeqAct_ForceFeedback::pClassPointer = NULL;

// Class Engine.SeqAct_ToggleHUD
// 0x0000 (0x0150 - 0x0150)
class USeqAct_ToggleHUD : public USequenceAction {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[12328];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_ToggleHUD::pClassPointer = NULL;

// Class Engine.SeqAct_ToggleInput
// 0x0004 (0x0154 - 0x0150)
class USeqAct_ToggleInput : public USeqAct_Toggle {
   public:
    DWORD bToggleMovement : 1;  // 0x0150 (0x0004) [0x0000000000000000]
                                // [0x00000001]
    DWORD bToggleTurning : 1;   // 0x0150 (0x0004) [0x0000000000000000]
                                // [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[12335];

        return pClassPointer;
    };
};

UClass* USeqAct_ToggleInput::pClassPointer = NULL;

// Class Engine.DmgType_Suicided
// 0x0000 (0x0090 - 0x0090)
class UDmgType_Suicided : public UKillZDamageType {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[12510];

        return pClassPointer;
    };
};

UClass* UDmgType_Suicided::pClassPointer = NULL;

// Class Engine.GameMessage
// 0x0170 (0x01E4 - 0x0074)
class UGameMessage : public ULocalMessage {
   public:
    struct FString SwitchLevelMessage;  // 0x0074 (0x0010) [0x0000000000000000]
    struct FString LeftMessage;         // 0x0084 (0x0010) [0x0000000000000000]
    struct FString FailedTeamMessage;   // 0x0094 (0x0010) [0x0000000000000000]
    struct FString FailedPlaceMessage;  // 0x00A4 (0x0010) [0x0000000000000000]
    struct FString FailedSpawnMessage;  // 0x00B4 (0x0010) [0x0000000000000000]
    struct FString EnteredMessage;      // 0x00C4 (0x0010) [0x0000000000000000]
    struct FString MaxedOutMessage;     // 0x00D4 (0x0010) [0x0000000000000000]
    struct FString ArbitrationMessage;  // 0x00E4 (0x0010) [0x0000000000000000]
    struct FString OvertimeMessage;     // 0x00F4 (0x0010) [0x0000000000000000]
    struct FString GlobalNameChange;    // 0x0104 (0x0010) [0x0000000000000000]
    struct FString NewTeamMessage;      // 0x0114 (0x0010) [0x0000000000000000]
    struct FString
        NewTeamMessageTrailer;          // 0x0124 (0x0010) [0x0000000000000000]
    struct FString NoNameChange;        // 0x0134 (0x0010) [0x0000000000000000]
    struct FString VoteStarted;         // 0x0144 (0x0010) [0x0000000000000000]
    struct FString VotePassed;          // 0x0154 (0x0010) [0x0000000000000000]
    struct FString MustHaveStats;       // 0x0164 (0x0010) [0x0000000000000000]
    struct FString CantBeSpectator;     // 0x0174 (0x0010) [0x0000000000000000]
    struct FString CantBePlayer;        // 0x0184 (0x0010) [0x0000000000000000]
    struct FString BecameSpectator;     // 0x0194 (0x0010) [0x0000000000000000]
    struct FString NewPlayerMessage;    // 0x01A4 (0x0010) [0x0000000000000000]
    struct FString KickWarning;         // 0x01B4 (0x0010) [0x0000000000000000]
    struct FString NewSpecMessage;      // 0x01C4 (0x0010) [0x0000000000000000]
    struct FString SpecEnteredMessage;  // 0x01D4 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[12556];

        return pClassPointer;
    };

    void GetString();
};

UClass* UGameMessage::pClassPointer = NULL;

// Class Engine.CoverReplicator
// 0x0010 (0x0254 - 0x0244)
class ACoverReplicator : public AReplicationInfo {
   public:
    TArray<struct FCoverReplicationInfo>
        CoverReplicationData;  // 0x0244 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[12579];

        return pClassPointer;
    };

    void ClientReceiveLinkDisabledState();
    void ServerSendLinkDisabledState();
    void NotifyLinkDisabledStateChange();
    void ClientReceiveManualCoverTypeSlots();
    void ServerSendManualCoverTypeSlots();
    void NotifySetManualCoverTypeForSlots();
    void ClientReceiveAdjustedSlots();
    void ServerSendAdjustedSlots();
    void NotifyAutoAdjustSlots();
    void ClientReceiveDisabledSlots();
    void ServerSendDisabledSlots();
    void NotifyDisabledSlots();
    void ClientReceiveEnabledSlots();
    void ServerSendEnabledSlots();
    void NotifyEnabledSlots();
    void ClientReceiveInitialCoverReplicationInfo();
    void ServerSendInitialCoverReplicationInfo();
    void ClientSetOwner();
    void ReplicateInitialCoverInfo();
    void PurgeOldEntries();
};

UClass* ACoverReplicator::pClassPointer = NULL;

// Class Engine.SplineComponentSimplified
// 0x0000 (0x0274 - 0x0274)
class USplineComponentSimplified : public USplineComponent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[13585];

        return pClassPointer;
    };
};

UClass* USplineComponentSimplified::pClassPointer = NULL;

// Class Engine.AmbientSoundSimpleSplineNonLoop
// 0x0000 (0x0274 - 0x0274)
class AAmbientSoundSimpleSplineNonLoop : public AAmbientSoundSimpleSpline {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[13640];

        return pClassPointer;
    };
};

UClass* AAmbientSoundSimpleSplineNonLoop::pClassPointer = NULL;

// Class Engine.AnimNotify_PlayFaceFXAnim
// 0x0040 (0x00A4 - 0x0064)
class UAnimNotify_PlayFaceFXAnim : public UAnimNotify_Scripted {
   public:
    class UFaceFXAnimSet*
        FaceFXAnimSetRef;             // 0x0064 (0x0008) [0x0000000000000000]
    struct FString GroupName;         // 0x006C (0x0010) [0x0000000000000000]
    struct FString AnimName;          // 0x007C (0x0010) [0x0000000000000000]
    class USoundCue* SoundCueToPlay;  // 0x008C (0x0008) [0x0000000000000000]
    class UAkEvent* AkEventToPlay;    // 0x0094 (0x0008) [0x0000000000000000]
    DWORD bOverridePlayingAnim : 1;   // 0x009C (0x0004) [0x0000000000000000]
                                      // [0x00000001]
    float PlayFrequency;              // 0x00A0 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[14692];

        return pClassPointer;
    };

    void eventNotify();
};

UClass* UAnimNotify_PlayFaceFXAnim::pClassPointer = NULL;

// Class Engine.BroadcastHandler
// 0x0008 (0x024C - 0x0244)
class ABroadcastHandler : public AInfo {
   public:
    int SentText;               // 0x0244 (0x0004) [0x0000000000000000]
    DWORD bMuteSpectators : 1;  // 0x0248 (0x0004) [0x0000000000000000]
                                // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[15314];

        return pClassPointer;
    };

    void eventAllowBroadcastLocalizedTeam();
    void eventAllowBroadcastLocalized();
    void BroadcastTeam();
    void Broadcast();
    void BroadcastLocalized();
    void BroadcastText();
    void AllowsBroadcast();
    void UpdateSentText();
};

UClass* ABroadcastHandler::pClassPointer = NULL;

// Class Engine.HttpFactory
// 0x0010 (0x0070 - 0x0060)
class UHttpFactory : public UObject {
   public:
    struct FString
        HttpRequestClassName;  // 0x0060 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[16219];

        return pClassPointer;
    };

    void CreateRequest();
};

UClass* UHttpFactory::pClassPointer = NULL;

// Class Engine.CloudSaveSystemKVSInterface
// 0x0000 (0x0060 - 0x0060)
class UCloudSaveSystemKVSInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[16458];

        return pClassPointer;
    };

    void WriteKeyValue();
    void ReadKeyValue();
};

UClass* UCloudSaveSystemKVSInterface::pClassPointer = NULL;

// Class Engine.CloudSaveSystemDataBlobStoreInterface
// 0x0000 (0x0060 - 0x0060)
class UCloudSaveSystemDataBlobStoreInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[16462];

        return pClassPointer;
    };

    void DeleteDataBlob();
    void DeleteDataBlobCallbackDelegate();
    void SetDataBlob();
    void SetDataBlobCallbackDelegate();
    void GetDataBlob();
    void GetDataBlobCallbackDelegate();
};

UClass* UCloudSaveSystemDataBlobStoreInterface::pClassPointer = NULL;

// Class Engine.CloudStorageBaseCloudSaveSystemKVS
// 0x0008 (0x0068 - 0x0060)
class UCloudStorageBaseCloudSaveSystemKVS : public UObject {
   public:
    class UCloudStorageBase*
        CloudStorage;  // 0x0060 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[16612];

        return pClassPointer;
    };

    void GenerateKeyNameForSaveSlot();
    void WriteKeyValue();
    void ReadKeyValue();
    void Init();
};

UClass* UCloudStorageBaseCloudSaveSystemKVS::pClassPointer = NULL;

// Class Engine.ColorScaleVolume
// 0x0010 (0x0290 - 0x0280)
class AColorScaleVolume : public AVolume {
   public:
    struct FVector ColorScale;  // 0x0280 (0x000C) [0x0000000000000000]
    float InterpTime;           // 0x028C (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[16648];

        return pClassPointer;
    };

    void eventUnTouch();
    void eventTouch();
};

UClass* AColorScaleVolume::pClassPointer = NULL;

// Class Engine.SeqAct_SetDamageInstigator
// 0x0008 (0x0158 - 0x0150)
class USeqAct_SetDamageInstigator : public USequenceAction {
   public:
    class AActor* DamageInstigator;  // 0x0150 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[18096];

        return pClassPointer;
    };
};

UClass* USeqAct_SetDamageInstigator::pClassPointer = NULL;

// Class Engine.VolumeTimer
// 0x0008 (0x024C - 0x0244)
class AVolumeTimer : public AInfo {
   public:
    class APhysicsVolume* V;  // 0x0244 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[18099];

        return pClassPointer;
    };

    void eventTimer();
    void eventPostBeginPlay();
};

UClass* AVolumeTimer::pClassPointer = NULL;

// Class Engine.TWSeqEvent_LightFlicker
// 0x0000 (0x0170 - 0x0170)
class UTWSeqEvent_LightFlicker : public USequenceEvent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[18183];

        return pClassPointer;
    };
};

UClass* UTWSeqEvent_LightFlicker::pClassPointer = NULL;

// Class Engine.DmgType_Crushed
// 0x0000 (0x0090 - 0x0090)
class UDmgType_Crushed : public UDamageType {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[18326];

        return pClassPointer;
    };
};

UClass* UDmgType_Crushed::pClassPointer = NULL;

// Class Engine.DmgType_Fell
// 0x0000 (0x0090 - 0x0090)
class UDmgType_Fell : public UDamageType {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[18328];

        return pClassPointer;
    };
};

UClass* UDmgType_Fell::pClassPointer = NULL;

// Class Engine.DmgType_Telefragged
// 0x0000 (0x0090 - 0x0090)
class UDmgType_Telefragged : public UDamageType {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[18331];

        return pClassPointer;
    };
};

UClass* UDmgType_Telefragged::pClassPointer = NULL;

// Class Engine.DynamicPhysicsVolume
// 0x0004 (0x02D4 - 0x02D0)
class ADynamicPhysicsVolume : public APhysicsVolume {
   public:
    DWORD bEnabled : 1;  // 0x02D0 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[18609];

        return pClassPointer;
    };

    void eventPostBeginPlay();
};

UClass* ADynamicPhysicsVolume::pClassPointer = NULL;

// Class Engine.DynamicSMActor_Spawnable
// 0x0000 (0x0294 - 0x0294)
class ADynamicSMActor_Spawnable : public ADynamicSMActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[18664];

        return pClassPointer;
    };
};

UClass* ADynamicSMActor_Spawnable::pClassPointer = NULL;

// Class Engine.DynamicTriggerVolume
// 0x0004 (0x0284 - 0x0280)
class ADynamicTriggerVolume : public ATriggerVolume {
   public:
    DWORD bEnabled : 1;  // 0x0280 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[18673];

        return pClassPointer;
    };

    void eventPostBeginPlay();
};

UClass* ADynamicTriggerVolume::pClassPointer = NULL;

// Class Engine.SeqAct_SetParticleSysParam
// 0x0018 (0x0168 - 0x0150)
class USeqAct_SetParticleSysParam : public USequenceAction {
   public:
    TArray<struct FParticleSysParam>
        InstanceParameters;     // 0x0150 (0x0010) [0x0000000000000000]
    DWORD bOverrideScalar : 1;  // 0x0160 (0x0004) [0x0000000000000000]
                                // [0x00000001]
    float ScalarValue;          // 0x0164 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[18979];

        return pClassPointer;
    };
};

UClass* USeqAct_SetParticleSysParam::pClassPointer = NULL;

// Class Engine.ExponentialHeightFog
// 0x000C (0x0250 - 0x0244)
class AExponentialHeightFog : public AInfo {
   public:
    class UExponentialHeightFogComponent*
        Component;       // 0x0244 (0x0008) [0x0000000000000000]
    DWORD bEnabled : 1;  // 0x024C (0x0004) [0x0000000000150000] [0x00000001] (
                         // CPF_Travel | CPF_GlobalConfig )

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[19485];

        return pClassPointer;
    };

    void OnToggle();
    void eventReplicatedEvent();
    void eventPostBeginPlay();
};

UClass* AExponentialHeightFog::pClassPointer = NULL;

// Class Engine.FailedConnect
// 0x0040 (0x00B4 - 0x0074)
class UFailedConnect : public ULocalMessage {
   public:
    struct FString FailMessage[0x4];  // 0x0074 (0x0040) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[19606];

        return pClassPointer;
    };

    void GetString();
    void GetFailSwitch();
};

UClass* UFailedConnect::pClassPointer = NULL;

// Class Engine.FracturedSMActorSpawnable
// 0x0000 (0x02D8 - 0x02D8)
class AFracturedSMActorSpawnable : public AFracturedStaticMeshActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[20932];

        return pClassPointer;
    };
};

UClass* AFracturedSMActorSpawnable::pClassPointer = NULL;

// Class Engine.FracturedStaticMeshActor_Spawnable
// 0x0000 (0x02D8 - 0x02D8)
class AFracturedStaticMeshActor_Spawnable : public AFracturedStaticMeshActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[20937];

        return pClassPointer;
    };
};

UClass* AFracturedStaticMeshActor_Spawnable::pClassPointer = NULL;

// Class Engine.SeqEvent_PlayerSpawned
// 0x0008 (0x0178 - 0x0170)
class USeqEvent_PlayerSpawned : public USequenceEvent {
   public:
    class UObject* SpawnPoint;  // 0x0170 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[21860];

        return pClassPointer;
    };
};

UClass* USeqEvent_PlayerSpawned::pClassPointer = NULL;

// Class Engine.HeightFog
// 0x000C (0x0250 - 0x0244)
class AHeightFog : public AInfo {
   public:
    class UHeightFogComponent*
        Component;       // 0x0244 (0x0008) [0x0000000000000000]
    DWORD bEnabled : 1;  // 0x024C (0x0004) [0x0000000000150000] [0x00000001] (
                         // CPF_Travel | CPF_GlobalConfig )

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[22990];

        return pClassPointer;
    };

    void OnToggle();
    void eventReplicatedEvent();
    void eventPostBeginPlay();
};

UClass* AHeightFog::pClassPointer = NULL;

// Class Engine.InterpActor_ForCinematic
// 0x0000 (0x02E0 - 0x02E0)
class AInterpActor_ForCinematic : public AInterpActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[23534];

        return pClassPointer;
    };
};

UClass* AInterpActor_ForCinematic::pClassPointer = NULL;

// Class Engine.MaterialInstanceTimeVaryingActor
// 0x0008 (0x024C - 0x0244)
class AMaterialInstanceTimeVaryingActor : public AActor {
   public:
    class UMaterialInstanceTimeVarying*
        MatInst;  // 0x0244 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[25304];

        return pClassPointer;
    };
};

UClass* AMaterialInstanceTimeVaryingActor::pClassPointer = NULL;

// Class Engine.SeqAct_GiveInventory
// 0x0014 (0x0164 - 0x0150)
class USeqAct_GiveInventory : public USequenceAction {
   public:
    TArray<class UClass*>
        InventoryList;         // 0x0150 (0x0010) [0x0000000000000000]
    DWORD bClearExisting : 1;  // 0x0160 (0x0004) [0x0000000000000000]
                               // [0x00000001]
    DWORD
        bForceReplace : 1;  // 0x0160 (0x0004) [0x0000000000000000] [0x00000002]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[25971];

        return pClassPointer;
    };
};

UClass* USeqAct_GiveInventory::pClassPointer = NULL;

// Class Engine.SeqAct_AssignController
// 0x0008 (0x0158 - 0x0150)
class USeqAct_AssignController : public USequenceAction {
   public:
    class UClass* ControllerClass;  // 0x0150 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[25974];

        return pClassPointer;
    };
};

UClass* USeqAct_AssignController::pClassPointer = NULL;

// Class Engine.NavMeshBoundsVolume
// 0x0000 (0x0280 - 0x0280)
class ANavMeshBoundsVolume : public AVolume {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[26457];

        return pClassPointer;
    };
};

UClass* ANavMeshBoundsVolume::pClassPointer = NULL;

// Class Engine.OnlineEventsInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineEventsInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[27394];

        return pClassPointer;
    };

    void UpdatePlaylistPopulation();
    void UploadGameplayEventsData();
    void UploadPlayerData();
};

UClass* UOnlineEventsInterface::pClassPointer = NULL;

// Class Engine.OnlineGameDownloadInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineGameDownloadInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[27411];

        return pClassPointer;
    };

    void ClearOnChunkCompleteDelegate();
    void AddOnChunkCompleteDelegate();
    void OnChunkComplete();
    void SetDownloadSpeed();
    void SetChunksHighPriority();
    void GetTodoList();
    void GetOverallProgress();
    void GetChunksProgress();
    void GetChunkProgress();
    void GetChunksETA();
    void GetChunkETA();
    void RefreshGame();
    void DoesGameNeedRefresh();
    void AreChunksComplete();
    void IsChunkComplete();
    void IsGameComplete();
};

UClass* UOnlineGameDownloadInterface::pClassPointer = NULL;

// Class Engine.OnlinePlaylistGameTypeProvider
// 0x002C (0x00C0 - 0x0094)
class UOnlinePlaylistGameTypeProvider : public UUIResourceDataProvider {
   public:
    struct FName PlaylistGameTypeName;  // 0x0094 (0x0008) [0x0000000000000000]
    struct FString DisplayName;         // 0x009C (0x0010) [0x0000000000000000]
    struct FString Description;         // 0x00AC (0x0010) [0x0000000000000000]
    int GameTypeId;                     // 0x00BC (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[29044];

        return pClassPointer;
    };
};

UClass* UOnlinePlaylistGameTypeProvider::pClassPointer = NULL;

// Class Engine.OnlineRecentPlayersList
// 0x0058 (0x00B8 - 0x0060)
class UOnlineRecentPlayersList : public UObject {
   public:
    TArray<struct FUniqueNetId>
        RecentPlayers;  // 0x0060 (0x0010) [0x0000000000000000]
    TArray<struct FRecentParty>
        RecentParties;              // 0x0070 (0x0010) [0x0000000000000000]
    struct FRecentParty LastParty;  // 0x0080 (0x0018) [0x0000000000000000]
    int MaxRecentPlayers;           // 0x0098 (0x0004) [0x0000000000000000]
    int MaxRecentParties;           // 0x009C (0x0004) [0x0000000000000000]
    int RecentPlayersAddIndex;      // 0x00A0 (0x0004) [0x0000000000000000]
    int RecentPartiesAddIndex;      // 0x00A4 (0x0004) [0x0000000000000000]
    TArray<struct FCurrentPlayerMet>
        CurrentPlayers;  // 0x00A8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[29090];

        return pClassPointer;
    };

    void GetCurrentPlayersListCount();
    void SetCurrentPlayersList();
    void DumpCurrentPlayers();
    void DumpPlayersList();
    void ShowCurrentPlayersList();
    void ShowLastPartyPlayerList();
    void ShowRecentPartiesPlayerList();
    void ShowRecentPlayerList();
    void SetLastParty();
    void GetTeamForCurrentPlayer();
    void GetSkillForCurrentPlayer();
    void GetPlayersFromCurrentPlayers();
    void GetPlayersFromRecentParties();
    void ClearRecentParties();
    void AddPartyToRecentParties();
    void ClearRecentPlayers();
    void AddPlayerToRecentPlayers();
};

UClass* UOnlineRecentPlayersList::pClassPointer = NULL;

// Class Engine.OnlineSuppliedUIInterface
// 0x0000 (0x0060 - 0x0060)
class UOnlineSuppliedUIInterface : public UInterface {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[29439];

        return pClassPointer;
    };

    void ShowMatchmakingUI();
    void ClearShowOnlineStatsUICompleteDelegate();
    void AddShowOnlineStatsUICompleteDelegate();
    void ShowOnlineStatsUI();
    void OnShowOnlineStatsUIComplete();
};

UClass* UOnlineSuppliedUIInterface::pClassPointer = NULL;

// Class Engine.ParticleModuleForceFieldCylindrical
// 0x0000 (0x0074 - 0x0074)
class UParticleModuleForceFieldCylindrical
    : public UParticleModuleForceFieldBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[30012];

        return pClassPointer;
    };
};

UClass* UParticleModuleForceFieldCylindrical::pClassPointer = NULL;

// Class Engine.ParticleModuleForceFieldGeneric
// 0x0000 (0x0074 - 0x0074)
class UParticleModuleForceFieldGeneric : public UParticleModuleForceFieldBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[30015];

        return pClassPointer;
    };
};

UClass* UParticleModuleForceFieldGeneric::pClassPointer = NULL;

// Class Engine.ParticleModuleForceFieldRadial
// 0x0000 (0x0074 - 0x0074)
class UParticleModuleForceFieldRadial : public UParticleModuleForceFieldBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[30018];

        return pClassPointer;
    };
};

UClass* UParticleModuleForceFieldRadial::pClassPointer = NULL;

// Class Engine.ParticleModuleForceFieldTornado
// 0x0000 (0x0074 - 0x0074)
class UParticleModuleForceFieldTornado : public UParticleModuleForceFieldBase {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[30021];

        return pClassPointer;
    };
};

UClass* UParticleModuleForceFieldTornado::pClassPointer = NULL;

// Class Engine.PathNode_Dynamic
// 0x0000 (0x037C - 0x037C)
class APathNode_Dynamic : public APathNode {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[30819];

        return pClassPointer;
    };

    void eventGetDebugAbbrev();
};

UClass* APathNode_Dynamic::pClassPointer = NULL;

// Class Engine.SeqEvent_AIReachedRouteActor
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_AIReachedRouteActor : public USequenceEvent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[30827];

        return pClassPointer;
    };
};

UClass* USeqEvent_AIReachedRouteActor::pClassPointer = NULL;

// Class Engine.SeqEvent_PickupStatusChange
// 0x0000 (0x0170 - 0x0170)
class USeqEvent_PickupStatusChange : public USequenceEvent {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[31375];

        return pClassPointer;
    };
};

UClass* USeqEvent_PickupStatusChange::pClassPointer = NULL;

// Class Engine.RadialBlurActor
// 0x0008 (0x024C - 0x0244)
class ARadialBlurActor : public AActor {
   public:
    class URadialBlurComponent*
        RadialBlur;  // 0x0244 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[32140];

        return pClassPointer;
    };
};

UClass* ARadialBlurActor::pClassPointer = NULL;

// Class Engine.SeqAct_ToggleConstraintDrive
// 0x0004 (0x0154 - 0x0150)
class USeqAct_ToggleConstraintDrive : public USequenceAction {
   public:
    DWORD bEnableAngularPositionDrive : 1;  // 0x0150 (0x0004)
                                            // [0x0000000000000000] [0x00000001]
    DWORD bEnableAngularVelocityDrive : 1;  // 0x0150 (0x0004)
                                            // [0x0000000000000000] [0x00000002]
    DWORD bEnableLinearPositionDrive : 1;   // 0x0150 (0x0004)
                                            // [0x0000000000000000] [0x00000004]
    DWORD bEnableLinearvelocityDrive : 1;   // 0x0150 (0x0004)
                                            // [0x0000000000000000] [0x00000008]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[32334];

        return pClassPointer;
    };
};

UClass* USeqAct_ToggleConstraintDrive::pClassPointer = NULL;

// Class Engine.RB_BSJointActor
// 0x0000 (0x0278 - 0x0278)
class ARB_BSJointActor : public ARB_ConstraintActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[32379];

        return pClassPointer;
    };
};

UClass* ARB_BSJointActor::pClassPointer = NULL;

// Class Engine.RB_ConstraintActorSpawnable
// 0x0000 (0x0278 - 0x0278)
class ARB_ConstraintActorSpawnable : public ARB_ConstraintActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[32384];

        return pClassPointer;
    };
};

UClass* ARB_ConstraintActorSpawnable::pClassPointer = NULL;

// Class Engine.RB_HingeActor
// 0x0000 (0x0278 - 0x0278)
class ARB_HingeActor : public ARB_ConstraintActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[32446];

        return pClassPointer;
    };
};

UClass* ARB_HingeActor::pClassPointer = NULL;

// Class Engine.RB_PrismaticActor
// 0x0000 (0x0278 - 0x0278)
class ARB_PrismaticActor : public ARB_ConstraintActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[32463];

        return pClassPointer;
    };
};

UClass* ARB_PrismaticActor::pClassPointer = NULL;

// Class Engine.RB_PulleyJointActor
// 0x0000 (0x0278 - 0x0278)
class ARB_PulleyJointActor : public ARB_ConstraintActor {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[32468];

        return pClassPointer;
    };
};

UClass* ARB_PulleyJointActor::pClassPointer = NULL;

// Class Engine.ReverbVolumeToggleable
// 0x0000 (0x02C4 - 0x02C4)
class AReverbVolumeToggleable : public AReverbVolume {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[32533];

        return pClassPointer;
    };

    void OnToggle();
};

UClass* AReverbVolumeToggleable::pClassPointer = NULL;

// Class Engine.SeqAct_AddRemoveFaceFXAnimSet
// 0x0010 (0x0160 - 0x0150)
class USeqAct_AddRemoveFaceFXAnimSet : public USequenceAction {
   public:
    TArray<class UFaceFXAnimSet*>
        FaceFXAnimSets;  // 0x0150 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[32746];

        return pClassPointer;
    };
};

UClass* USeqAct_AddRemoveFaceFXAnimSet::pClassPointer = NULL;

// Class Engine.SeqAct_AIAbortMoveToActor
// 0x0000 (0x0150 - 0x0150)
class USeqAct_AIAbortMoveToActor : public USequenceAction {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[32750];

        return pClassPointer;
    };
};

UClass* USeqAct_AIAbortMoveToActor::pClassPointer = NULL;

// Class Engine.SeqAct_MITV_Activate
// 0x0004 (0x0154 - 0x0150)
class USeqAct_MITV_Activate : public USequenceAction {
   public:
    float DurationOfMITV;  // 0x0150 (0x0004) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[32969];

        return pClassPointer;
    };

    void eventActivated();
    void eventGetObjClassVersion();
};

UClass* USeqAct_MITV_Activate::pClassPointer = NULL;

// Class Engine.SeqAct_SetMatInstTexParam
// 0x0018 (0x0168 - 0x0150)
class USeqAct_SetMatInstTexParam : public USequenceAction {
   public:
    class UMaterialInstanceConstant*
        MatInst;                 // 0x0150 (0x0008) [0x0000000000000000]
    class UTexture* NewTexture;  // 0x0158 (0x0008) [0x0000000000000000]
    struct FName ParamName;      // 0x0160 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[33107];

        return pClassPointer;
    };
};

UClass* USeqAct_SetMatInstTexParam::pClassPointer = NULL;

// Class Engine.SeqAct_SetMatInstVectorParam
// 0x0020 (0x0170 - 0x0150)
class USeqAct_SetMatInstVectorParam : public USequenceAction {
   public:
    class UMaterialInstanceConstant*
        MatInst;                      // 0x0150 (0x0008) [0x0000000000000000]
    struct FName ParamName;           // 0x0158 (0x0008) [0x0000000000000000]
    struct FLinearColor VectorValue;  // 0x0160 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[33112];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_SetMatInstVectorParam::pClassPointer = NULL;

// Class Engine.SeqAct_SetSkelControlTarget
// 0x0018 (0x0168 - 0x0150)
class USeqAct_SetSkelControlTarget : public USequenceAction {
   public:
    struct FName SkelControlName;  // 0x0150 (0x0008) [0x0000000000000000]
    TArray<class UObject*>
        TargetActors;  // 0x0158 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[33131];

        return pClassPointer;
    };
};

UClass* USeqAct_SetSkelControlTarget::pClassPointer = NULL;

// Class Engine.SeqAct_SetVector
// 0x000C (0x015C - 0x0150)
class USeqAct_SetVector : public USeqAct_SetSequenceVariable {
   public:
    struct FVector DefaultValue;  // 0x0150 (0x000C) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[33146];

        return pClassPointer;
    };

    void eventActivated();
};

UClass* USeqAct_SetVector::pClassPointer = NULL;

// Class Engine.SeqAct_ToggleAffectedByHitEffects
// 0x0000 (0x0150 - 0x0150)
class USeqAct_ToggleAffectedByHitEffects : public USequenceAction {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[33236];

        return pClassPointer;
    };
};

UClass* USeqAct_ToggleAffectedByHitEffects::pClassPointer = NULL;

// Class Engine.SeqAct_UpdatePhysBonesFromAnim
// 0x0000 (0x0150 - 0x0150)
class USeqAct_UpdatePhysBonesFromAnim : public USequenceAction {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[33261];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqAct_UpdatePhysBonesFromAnim::pClassPointer = NULL;

// Class Engine.SeqEvent_LOS
// 0x000C (0x017C - 0x0170)
class USeqEvent_LOS : public USequenceEvent {
   public:
    float ScreenCenterDistance;       // 0x0170 (0x0004) [0x0000000000000000]
    float TriggerDistance;            // 0x0174 (0x0004) [0x0000000000000000]
    DWORD bCheckForObstructions : 1;  // 0x0178 (0x0004) [0x0000000000000000]
                                      // [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[33367];

        return pClassPointer;
    };

    void eventGetObjClassVersion();
};

UClass* USeqEvent_LOS::pClassPointer = NULL;

// Class Engine.SeqVar_Byte
// 0x0000 (0x00D4 - 0x00D4)
class USeqVar_Byte : public USequenceVariable {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[33483];

        return pClassPointer;
    };
};

UClass* USeqVar_Byte::pClassPointer = NULL;

// Class Engine.SeqVar_Name
// 0x0000 (0x00D4 - 0x00D4)
class USeqVar_Name : public USequenceVariable {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[33499];

        return pClassPointer;
    };
};

UClass* USeqVar_Name::pClassPointer = NULL;

// Class Engine.SeqVar_Union
// 0x0000 (0x00D4 - 0x00D4)
class USeqVar_Union : public USequenceVariable {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[33529];

        return pClassPointer;
    };
};

UClass* USeqVar_Union::pClassPointer = NULL;

// Class Engine.SkeletalMeshActorMATSpawnable
// 0x0000 (0x02B4 - 0x02B4)
class ASkeletalMeshActorMATSpawnable : public ASkeletalMeshActorMAT {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[34165];

        return pClassPointer;
    };
};

UClass* ASkeletalMeshActorMATSpawnable::pClassPointer = NULL;

// Class Engine.SkeletalMeshActorMATWalkable
// 0x0000 (0x02B4 - 0x02B4)
class ASkeletalMeshActorMATWalkable : public ASkeletalMeshActorMAT {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[34170];

        return pClassPointer;
    };
};

UClass* ASkeletalMeshActorMATWalkable::pClassPointer = NULL;

// Class Engine.Trigger_Dynamic
// 0x0000 (0x0254 - 0x0254)
class ATrigger_Dynamic : public ATrigger {
   public:
   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[35468];

        return pClassPointer;
    };
};

UClass* ATrigger_Dynamic::pClassPointer = NULL;

// Class Engine.Trigger_LOS
// 0x0010 (0x0264 - 0x0254)
class ATrigger_LOS : public ATrigger {
   public:
    TArray<class APlayerController*>
        PCsWithLOS;  // 0x0254 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[35472];

        return pClassPointer;
    };

    void eventTick();
};

UClass* ATrigger_LOS::pClassPointer = NULL;

// Class Engine.TriggeredPath
// 0x000C (0x0388 - 0x037C)
class ATriggeredPath : public ANavigationPoint {
   public:
    DWORD bOpen : 1;  // 0x037C (0x0004) [0x0000000000000000] [0x00000001]
    class AActor* MyTrigger;  // 0x0380 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[35492];

        return pClassPointer;
    };

    void eventSuggestMovePreparation();
    void eventSpecialHandling();
    void OnToggle();
};

UClass* ATriggeredPath::pClassPointer = NULL;

// Class Engine.TriggerStreamingLevel
// 0x0010 (0x0264 - 0x0254)
class ATriggerStreamingLevel : public ATrigger {
   public:
    TArray<struct FLevelStreamingData>
        Levels;  // 0x0254 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[35506];

        return pClassPointer;
    };

    void eventTouch();
};

UClass* ATriggerStreamingLevel::pClassPointer = NULL;

// Class Engine.UICharacterSummary
// 0x0034 (0x00C8 - 0x0094)
class UUICharacterSummary : public UUIResourceDataProvider {
   public:
    struct FString ClassPathName;  // 0x0094 (0x0010) [0x0000000000000000]
    struct FString CharacterName;  // 0x00A4 (0x0010) [0x0000000000000000]
    struct FString CharacterBio;   // 0x00B4 (0x0010) [0x0000000000000000]
    DWORD bIsDisabled : 1;  // 0x00C4 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[35791];

        return pClassPointer;
    };
};

UClass* UUICharacterSummary::pClassPointer = NULL;

// Class Engine.UIGameInfoSummary
// 0x0064 (0x00F8 - 0x0094)
class UUIGameInfoSummary : public UUIResourceDataProvider {
   public:
    struct FString ClassName;    // 0x0094 (0x0010) [0x0000000000000000]
    struct FString GameAcronym;  // 0x00A4 (0x0010) [0x0000000000000000]
    struct FString MapPrefix;    // 0x00B4 (0x0010) [0x0000000000000000]
    DWORD bIsTeamGame : 1;  // 0x00C4 (0x0004) [0x0000000000000000] [0x00000001]
    DWORD bIsDisabled : 1;  // 0x00C4 (0x0004) [0x0000000000000000] [0x00000002]
    struct FString
        GameSettingsClassName;   // 0x00C8 (0x0010) [0x0000000000000000]
    struct FString GameName;     // 0x00D8 (0x0010) [0x0000000000000000]
    struct FString Description;  // 0x00E8 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[36424];

        return pClassPointer;
    };
};

UClass* UUIGameInfoSummary::pClassPointer = NULL;

// Class Engine.UIMapSummary
// 0x0040 (0x00D4 - 0x0094)
class UUIMapSummary : public UUIResourceDataProvider {
   public:
    struct FString MapName;             // 0x0094 (0x0010) [0x0000000000000000]
    struct FString ScreenshotPathName;  // 0x00A4 (0x0010) [0x0000000000000000]
    struct FString DisplayName;         // 0x00B4 (0x0010) [0x0000000000000000]
    struct FString Description;         // 0x00C4 (0x0010) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[36546];

        return pClassPointer;
    };
};

UClass* UUIMapSummary::pClassPointer = NULL;

// Class Engine.UIWeaponSummary
// 0x0034 (0x00C8 - 0x0094)
class UUIWeaponSummary : public UUIResourceDataProvider {
   public:
    struct FString ClassPathName;      // 0x0094 (0x0010) [0x0000000000000000]
    struct FString FriendlyName;       // 0x00A4 (0x0010) [0x0000000000000000]
    struct FString WeaponDescription;  // 0x00B4 (0x0010) [0x0000000000000000]
    DWORD bIsDisabled : 1;  // 0x00C4 (0x0004) [0x0000000000000000] [0x00000001]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[36568];

        return pClassPointer;
    };
};

UClass* UUIWeaponSummary::pClassPointer = NULL;

// Class Engine.UserCloudFileCloudSaveSystemDataBlobStore
// 0x0070 (0x00D0 - 0x0060)
class UUserCloudFileCloudSaveSystemDataBlobStore : public UObject {
   public:
    class UUserCloudFileInterface*
        UserCloudFile;                 // 0x0060 (0x0010) [0x0000000000000000]
    unsigned char UnknownData00[0x8];  // 0x0068 (0x0008) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        GetDataBlobCallback;           // 0x0070 (0x0010) [0x0000000000000000]
    unsigned char UnknownData01[0x4];  // 0x0074 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        SetDataBlobCallback;           // 0x0080 (0x0010) [0x0000000000000000]
    unsigned char UnknownData02[0x4];  // 0x0084 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        DeleteDataBlobCallback;        // 0x0090 (0x0010) [0x0000000000000000]
    unsigned char UnknownData03[0x4];  // 0x0094 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __GetDataBlobCallbackDelegate__Delegate;  // 0x00A0 (0x0010)
                                                  // [0x0000000000000000]
    unsigned char UnknownData04[0x4];  // 0x00A4 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __SetDataBlobCallbackDelegate__Delegate;  // 0x00B0 (0x0010)
                                                  // [0x0000000000000000]
    unsigned char UnknownData05[0x4];  // 0x00B4 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY
    struct FScriptDelegate
        __DeleteDataBlobCallbackDelegate__Delegate;  // 0x00C0 (0x0010)
                                                     // [0x0000000000000000]
    unsigned char UnknownData06[0x4];  // 0x00C4 (0x0004) FIX WRONG TYPE SIZE OF
                                       // PREVIUS PROPERTY

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[36574];

        return pClassPointer;
    };

    void OnDeleteUserFileComplete();
    void DeleteDataBlob();
    void OnWriteUserFileComplete();
    void SetDataBlob();
    void OnReadUserFileComplete();
    void GetDataBlob();
    void Init();
    void DeleteDataBlobCallbackDelegate();
    void SetDataBlobCallbackDelegate();
    void GetDataBlobCallbackDelegate();
};

UClass* UUserCloudFileCloudSaveSystemDataBlobStore::pClassPointer = NULL;

// Class Engine.WaterVolume
// 0x0020 (0x02F0 - 0x02D0)
class AWaterVolume : public APhysicsVolume {
   public:
    class USoundCue* EntrySound;  // 0x02D0 (0x0008) [0x0000000000000000]
    class UClass* EntryActor;     // 0x02D8 (0x0008) [0x0000000000000000]
    class USoundCue* ExitSound;   // 0x02E0 (0x0008) [0x0000000000000000]
    class UClass* ExitActor;      // 0x02E8 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[36709];

        return pClassPointer;
    };

    void PlayExitSplash();
    void eventUnTouch();
    void PlayEntrySplash();
    void eventTouch();
};

UClass* AWaterVolume::pClassPointer = NULL;

// Class Engine.WindDirectionalSource
// 0x0008 (0x024C - 0x0244)
class AWindDirectionalSource : public AInfo {
   public:
    class UWindDirectionalSourceComponent*
        Component;  // 0x0244 (0x0008) [0x0000000000000000]

   private:
    static UClass* pClassPointer;

   public:
    static UClass* StaticClass() {
        if (!pClassPointer)
            pClassPointer = (UClass*)UObject::GObjObjects()->Data[37040];

        return pClassPointer;
    };
};

UClass* AWindDirectionalSource::pClassPointer = NULL;

#ifdef _MSC_VER
#pragma pack(pop)
#endif